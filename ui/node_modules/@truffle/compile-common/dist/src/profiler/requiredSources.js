"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requiredSources = void 0;
const resolveAllSources_1 = require("./resolveAllSources");
const getImports_1 = require("./getImports");
function requiredSources({ allPaths, updatedPaths, resolve, shouldIncludePath, parseImports }) {
    return __awaiter(this, void 0, void 0, function* () {
        const allSources = {};
        const compilationTargets = [];
        // Solidity test files might have been injected. Include them in the known set.
        updatedPaths.forEach(_path => {
            if (!allPaths.includes(_path)) {
                allPaths.push(_path);
            }
        });
        const resolved = yield resolveAllSources_1.resolveAllSources({
            resolve,
            parseImports,
            shouldIncludePath,
            paths: allPaths
        });
        // Generate hash of all sources including external packages - passed to solc inputs.
        for (const file of Object.keys(resolved)) {
            if (shouldIncludePath(file)) {
                allSources[file] = resolved[file].body;
            }
        }
        // Exit w/out minimizing if we've been asked to compile everything, or nothing.
        if (listsEqual(updatedPaths, allPaths)) {
            return {
                allSources,
                compilationTargets: []
            };
        }
        else if (!updatedPaths.length) {
            return {
                allSources: {},
                compilationTargets: []
            };
        }
        // Seed compilationTargets with known updates
        for (const update of updatedPaths) {
            compilationTargets.push(update);
        }
        // While there are updated files in the queue, we take each one
        // and search the entire file corpus to find any sources that import it.
        // Those sources are added to list of compilation targets as well as
        // the update queue because their own ancestors need to be discovered.
        while (updatedPaths.length > 0) {
            const currentUpdate = updatedPaths.shift();
            const files = allPaths.slice();
            // While files: dequeue and inspect their imports
            while (files.length > 0) {
                const currentFile = files.shift();
                // Ignore targets already selected.
                if (compilationTargets.includes(currentFile)) {
                    continue;
                }
                const imports = shouldIncludePath(currentFile)
                    ? yield getImports_1.getImports({
                        source: resolved[currentFile],
                        parseImports,
                        shouldIncludePath
                    })
                    : [];
                // If file imports a compilation target, add it
                // to list of updates and compilation targets
                if (imports.includes(currentUpdate)) {
                    updatedPaths.push(currentFile);
                    compilationTargets.push(currentFile);
                }
            }
        }
        return {
            allSources,
            compilationTargets
        };
    });
}
exports.requiredSources = requiredSources;
function listsEqual(listA, listB) {
    const a = listA.sort();
    const b = listB.sort();
    return JSON.stringify(a) === JSON.stringify(b);
}
//# sourceMappingURL=requiredSources.js.map