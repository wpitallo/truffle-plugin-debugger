{"version":3,"sources":["webpack/universalModuleDefinition","webpack/bootstrap","external \"debug\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/helpers/index.js","external \"babel-runtime/helpers/extends\"","external \"@truffle/codec\"","external \"reselect-tree\"","external \"redux-saga/effects\"","external \"babel-runtime/core-js/object/entries\"","external \"redux\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/trace/selectors/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/evm/selectors/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/solidity/selectors/index.js","external \"babel-runtime/core-js/object/assign\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/trace/actions/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/trace/sagas/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/session/actions/index.js","external \"babel-runtime/core-js/object/values\"","external \"json-pointer\"","external \"bn.js\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/data/sagas/index.js","external \"babel-runtime/helpers/asyncToGenerator\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/controller/actions/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/data/selectors/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/stacktrace/selectors/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/session/selectors/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/evm/sagas/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/controller/selectors/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/ast/selectors/index.js","external \"lodash.flatten\"","external \"semver\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/data/actions/index.js","external \"babel-runtime/core-js/set\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/evm/actions/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/web3/sagas/index.js","external \"web3\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/controller/sagas/index.js","external \"babel-runtime/core-js/object/keys\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/solidity/sagas/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/solidity/actions/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/stacktrace/sagas/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/stacktrace/actions/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/debugger.js","external \"source-map-support/register\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/debugger.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/session/index.js","external \"babel-runtime/core-js/promise\"","external \"json-stable-stringify\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/store/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/store/production.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/store/common.js","external \"redux-saga\"","external \"@truffle/solidity-utils\"","external \"lodash.zipwith\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/web3/actions/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/web3/adapter.js","external \"util\"","external \"lodash.sum\"","/home/sniffnoy/truffle/truffle/packages/debugger/lib/session/sagas/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/ast/sagas/index.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/session/reducers.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/data/reducers.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/evm/reducers.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/solidity/reducers.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/trace/reducers.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/controller/reducers.js","/home/sniffnoy/truffle/truffle/packages/debugger/lib/stacktrace/reducers.js","external \"@truffle/compile-solidity/legacy/shims\""],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","isDeliberatelySkippedNodeType","isSkippedNodeType","node","includes","nodeType","undefined","typeDescriptions","Codec","Ast","Utils","typeClass","prefixName","prefix","fn","configurable","makePath","sourceId","pointer","popNWhere","array","numToRemove","predicate","newArray","slice","length","top","pop","keccak256","stableKeccak256","makeAssignment","idObj","ref","id","isCallMnemonic","op","isShortCallMnemonic","isDelegateCallMnemonicBroad","isDelegateCallMnemonicStrict","isStaticCallMnemonic","isCreateMnemonic","args","Conversion","toHexString","Evm","WORD_SIZE","obj","type","PAST_END_OF_TRACE","depth","error","gas","memory","stack","storage","gasCost","pc","trace","createSelectorTree","index","state","proc","loaded","createLeaf","steps","finished","finishedOrUnloaded","transaction","stepsRemaining","step","next","nextOfSameDepth","find","application","submoduleCount","ZERO_WORD","repeat","determineFullContext","address","binary","instances","search","contexts","contextId","isConstructor","Boolean","context","createStepSelectors","base","programCounter","isCall","isShortCall","isDelegateCallBroad","isDelegateCallStrict","isStaticCall","isCreate","isCreate2","isStore","isLoad","touchesStorage","stores","loads","path","startsWith","isRelative","isJump","valueStored","callAddress","toAddress","createBinary","offset","parseInt","join","substring","padEnd","callData","short","argOffset","callValue","calls","delegates","isStatic","BN","toBN","createValue","storageAffected","callContext","evm","info","byContext","binaries","Contexts","findDebuggerContext","globals","tx","block","status","initialCall","startingContext","current","callstack","map","param","createdAddress","create2Address","ZERO_ADDRESS","storageAddress","ADDRESS_SIZE","isInstantCallOrCreate","creates","contextChange","isContextChange","currentDepth","nextDepth","isNormalHalting","isHalting","isExceptionalHalting","returnStatus","remaining","finalStatus","returnValue","valueLoaded","codex","_","rawStorage","accounts","code","debug","contextRequiresPhantomStackframes","compiler","semver","satisfies","version","includePrerelease","createMultistepSelectors","stepSelector","instruction","modifierDepth","source","sources","file","findOverlappingRange","compilationId","functions","sourceRange","SolidityUtils","getSourceRange","pointerAndNode","range","findRange","start","ast","solidity","byCompilationId","bottomStackframeRequiresPhantomFrame","byId","sourceMap","humanReadableSourceMap","getHumanReadableSourceMap","functionDepthStack","nextFrameIsPhantom","functionDepth","callRequiresPhantomFrame","instructions","getProcessedInstructionsForBinary","instructionAtProgramCounter","isSourceRangeFinal","functionsByProgramCounter","getFunctionsByProgramCounter","isMultiline","lines","line","end","willJump","jumpDirection","jump","willCall","isInstant","willReturn","nextMapped","views","compilations","makeOverlapFunction","saveSteps","SAVE_STEPS","NEXT","tick","TICK","tock","TOCK","endTrace","END_OF_TRACE","reset","RESET","unloadTransaction","UNLOAD_TRANSACTION","backtick","BACKTICK","setSubmoduleCount","count","SET_SUBMODULE_COUNT","put","actions","addSubmoduleToCount","select","advance","take","signalTickSagaCompletion","processTrace","filter","unload","saga","waitingForSubmodules","takeEvery","provider","txHash","START","loadTransaction","LOAD_TRANSACTION","interrupt","INTERRUPT","ready","READY","wait","WAIT","ERROR","recordContracts","RECORD_CONTRACTS","saveTransaction","SAVE_TRANSACTION","saveReceipt","receipt","SAVE_RECEIPT","saveBlock","SAVE_BLOCK","setLightMode","SET_LIGHT_MODE","setFullMode","SET_FULL_MODE","startFullMode","START_FULL_MODE","addCompilations","ADD_COMPILATIONS","scope","nodeId","parentId","declare","yulScope","yulDeclare","scopePointer","defineType","decode","decodeReturnValue","userDefinedTypes","data","allocations","returnAllocation","decoder","decodeReturndata","result","done","response","request","requestCode","recordAllocations","contracts","contractAllocationInfo","referenceDeclarations","storageAllocations","Storage","Allocate","getStorageAllocations","memoryAllocations","Memory","getMemoryAllocations","abiAllocations","AbiData","getAbiAllocations","calldataAllocations","getCalldataAllocations","stateAllocations","getStateAllocations","allocate","web3","tickSaga","atLastInstructionForSourceRange","assignment","assignments","preambleAssignments","baseExpression","slot","position","nextPointer","scopes","inlined","currentAssignments","mappedPaths","inModifier","inFunctionOrModifier","aboutToModify","modifier","modifierBeingInvoked","currentIndex","modifierArgumentIndex","parameters","parametersLeft","adjustment","stackSize","assignParameters","nextModifier","assign","returnSuffixes","returnVariables","vars","parameterSuffixes","bareLetSuffixes","bareLetsInYulAreHit","outerIndex","declaration","body","statements","innerIndex","variables","unshift","suffixes","concat","suffix","sourceAndPointer","astRef","stackframe","location","from","to","allocation","members","Number","fullId","definition","varId","parentPointer","replace","parent","jsonpointer","variableSourceAndPointer","literalAssignments","isReference","referenceType","isMapping","keyDefinition","indexValue","indexDefinition","indexId","indexIdObj","fullIndexId","indexReference","isSimpleConstant","splicedDefinition","spliceLocation","referencedDeclaration","indexConstantDeclaration","constant","indexConstantDefinition","kind","arguments","operator","subExpression","decodeMappingKeyCore","cleanBool","decodeMappingKeySaga","indexExpression","fetchBasePath","hashPath","isDynamicArray","asBN","muln","storageSize","Import","definitionToType","words","mapPathAndAssign","typeIdentifier","expression","structType","memberAllocations","memberName","memberAllocation","member","clone","variablesAndMappingsSaga","mappingKeys","currentContext","internalFunctionsTable","Uint8Array","decodeVariable","NO_CODE","blockNumber","obtainBinaries","addInstance","toBytes","literal","Stack","Read","readStack","forModifier","reverseParameters","reverse","currentPosition","parameter","baseNode","ADVANCE","stepNext","STEP_NEXT","stepOver","STEP_OVER","stepInto","STEP_INTO","stepOut","STEP_OUT","continueUntilBreakpoint","breakpoints","CONTINUE","addBreakpoint","breakpoint","ADD_BREAKPOINT","removeBreakpoint","REMOVE_BREAKPOINT","removeAllBreakpoints","REMOVE_ALL_BREAKPOINTS","startStepping","START_STEPPING","doneStepping","DONE_STEPPING","identity","x","findAncestorOfType","types","modifierForInvocation","invocation","rawId","modifierName","baseName","rawNode","nodes","functionKind","debuggerContextToDecoderContext","contextHash","contractName","contractId","contractKind","abi","payable","computeSelectors","NOW_DEFINITION","src","typeString","MSG_DEFINITION","TX_DEFINITION","BLOCK_DEFINITION","final","newScope","linearizedBaseContractsFromBase","linearizedBaseContracts","variable","visibility","raw","byAstRef","entry","definitionToStoredType","deployedContext","constructorContext","immutableReferences","contractNode","compilationIdForType","byAddress","byType","bySlotAddress","number","toString","calldata","decodingKeys","decodingStarted","word","mapping","specials","sender","this","allAllocations","transformedAllocations","contract","function","nextInvocation","argument","modifierInvocation","invocationPointer","difference","rawIndex","match","identifiers","cur","msg","builtin","now","definitions","thisDefinition","identifier","builtins","refs","idHash","byBuiltin","constructorAllocations","functionAllocations","output","selector","returndata","invalid","generateReport","message","locations","frame","calledFromLocation","shift","push","names","functionName","report","nameInfo","strippedLocation","sourcePath","stacktrace","returnCounter","lastPosition","innerReturnPosition","innerReturnStatus","willJumpIn","willJumpOut","revertString","rawRevertMessage","revertDecodings","decodeRevert","revertStringInfo","asString","Buffer","asHex","positionWillChange","nextLocation","currentLocation","lastLocation","oldLocation","finalReport","session","affectedInstances","primarySource","readyOrError","waiting","lastLoadingError","isError","success","errored","lightMode","addContext","refreshInstances","begin","gasprice","saveGlobals","saveStatus","callstackAndCodexSaga","fail","currentCall","returnedBinary","returnedContext","returnCreate","returnCall","storedValue","store","loadedValue","load","anyNonSkippedInRange","sourceStart","sourceLength","sourceEnd","some","AST","isOldStyleAssembly","controller","executionContext","resolver","adjustedBreakpoint","lineLengths","split","lineStarts","isStepping","SCOPE","scopeAstRef","DECLARE","ASSIGN","parentType","MAP_PATH_AND_ASSIGN","DEFINE_TYPE","ALLOCATE","externalSolidity","ADD_CONTEXT","ADD_INSTANCE","REFRESH_INSTANCE","origin","SAVE_GLOBALS","SAVE_STATUS","CALL","CREATE","RETURN_CALL","RETURN_CREATE","FAIL","STORE","LOAD","inspectTransaction","inspect","action","RECEIVE_TRACE","ERROR_WEB3","RECEIVE_CALL","addresses","tasks","all","fork","receiveBinary","fetchBinary","init","padHexString","hexString","padStart","fetchTransactionInfo","adapter","apply","getTrace","e","receiveTrace","getTransaction","getReceipt","getBlock","solidityBlock","coinbase","miner","difficulty","gaslimit","gasLimit","timestamp","receiveCall","input","gasPrice","Web3","utils","isAddress","contractAddress","getDeployedCode","RECEIVE_BINARY","INIT_WEB3","Web3Adapter","INSPECT","FETCH_BINARY","STEP_SAGAS","startingDepth","startingLocation","breakpointHit","currentLine","currentSourceId","currentCompilationId","previousLine","previousSourceId","currentNode","race","exec","starting","upcoming","addSources","guard","externalCall","externalReturn","nextSource","clearPhantomGuard","functionDepthSaga","ADD_SOURCES","JUMP","EXTERNAL_CALL","EXTERNAL_RETURN","CLEAR_PHANTOM_GUARD","positionUpdated","executeReturn","nextParent","jumpIn","jumpOut","nextContext","nextAddress","updatePosition","stacktraceSaga","functionNode","JUMP_IN","JUMP_OUT","counter","EXECUTE_RETURN","UPDATE_POSITION","Debugger","default","forTx","options","files","Compilations","shimArtifacts","Session","forProject","createNestedSelector","astSelector","dataSelector","traceSelector","evmSelector","soliditySelector","stacktraceSelector","sessionSelector","controllerSelector","dataSagas","controllerSagas","sagas","constructor","moduleOptions","sagaMiddleware","reducer","rootSaga","_store","_sagaMiddleware","normalize","dispatch","_ready","accept","reject","unsubscribe","subscribe","view","readyAgainAfterLoading","sessionAction","hasStartedWaiting","compilation","unreliableSourceOrder","Error","primarySourceIndex","bytecode","deployedBytecode","deployedBinary","deployedSourceMap","primarySourceId","shimBytecode","findIndex","getContractNode","schemaAbiToAbi","normalizeContexts","getState","_runSaga","run","toPromise","stepperAction","resolve","hasStarted","decodeReady","decoded","connect","addExternalCompilations","configureStore","sagaArgs","initialState","composeEnhancers","compose","createStore","applyMiddleware","promisify","currentProvider","send","jsonrpc","method","params","Date","getTime","structLogs","eth","getTransactionReceipt","blockNumberOrHash","getCode","processTransaction","LOAD_SAGAS","recordContexts","recordSources","visitAll","listenerSaga","mainApps","otherApps","apps","app","forkListeners","err","recordInstance","fetchTx","walk","handleEnter","Array","isArray","child","entries","yulWalk","basePointer","findYulScopePointer","relativePointer","relativeParentPointer","handleYulEnter","_parentId","handleYulExit","handleYul","handleExit","combineReducers","reduceState","DEFAULT_SCOPES","DEFAULT_ALLOCATIONS","newState","GLOBAL_ASSIGNMENTS","special","DEFAULT_ASSIGNMENTS","DEFAULT_PATHS","reduce","acc","regularizeTypeIdentifier","hexSlotAddress","slotAddress","parentAddress","newSlot","DEFAULT_CONTEXTS","abiHasPayableFallback","DEFAULT_TX","DEFAULT_BLOCK","DEFAULT_CODEX","topCodex","updateFrameStorage","updateFrameCode","existingPage","safeSave","DEFAULT_SOURCES","delta","belowTop","Math","max","newFrame","ETERNAL_CALL"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,WAAY,GAAIH,GACG,iBAAZC,QACdA,QAAkB,SAAID,IAEtBD,EAAe,SAAIC,IARrB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,I,gBClFrDtC,EAAOD,QAAUwC,QAAQ,U,8FCITC,gC,EAaAC,kBAAT,SAA2BC,GAQhC,OACEF,EAA8BE,IARN,CACxB,+BACA,UACA,QACA,iBACA,gBAIkBC,SAASD,EAAKE,WAChCF,EAAKE,SAASD,SAAS,kBAEIE,IAA1BH,EAAKI,kBACgC,kBAApCC,EAAMC,IAAIC,MAAMC,UAAUR,I,EAIhBS,WAAT,SAAoBC,EAAQC,GAMjC,OALApC,OAAOC,eAAemC,EAAI,OAAQ,CAChC7B,MAAQ,GAAE4B,KAAUC,EAAGvC,OACvBwC,cAAc,IAGTD,G,EAGOE,SAAT,SAAkBC,EAAUC,GACjC,MAAQ,GAAED,KAAYC,K,EASRC,UAAT,SAAmBC,EAAOC,EAAaC,GAC5C,IAAIC,EAAWH,EAAMI,QAErB,KAAOH,EAAc,GAAKE,EAASE,OAAS,GAAG,CAC7C,IAAIC,EAAMH,EAASA,EAASE,OAAS,GACjCH,EAAUI,IACZL,IAEFE,EAASI,MAEX,OAAOJ,G,EAMOK,Y,EAWAC,kB,EAQAC,eAAT,SAAwBC,EAAOC,GACpC,IAAIC,EAAKJ,EAAgBE,GACzB,uBAAYA,EAAZ,CAAmBE,KAAID,S,EAOTE,eAAT,SAAwBC,GAE7B,MADc,CAAC,OAAQ,eAAgB,aAAc,YACxC/B,SAAS+B,I,EAMRC,oBAAT,SAA6BD,GAElC,MADmB,CAAC,eAAgB,cAClB/B,SAAS+B,I,EAMbE,4BAAT,SAAqCF,GAE1C,MADsB,CAAC,eAAgB,YAClB/B,SAAS+B,I,EAMhBG,6BAAT,SAAsCH,GAE3C,MADsB,CAAC,gBACF/B,SAAS+B,I,EAMhBI,qBAAT,SAA8BJ,GAEnC,MADsB,CAAC,cACF/B,SAAS+B,I,EAOhBK,iBAAT,SAA0BL,GAE/B,MADgB,CAAC,SAAU,WACZ/B,SAAS+B,IA7I1B,IAAY3B,E,wJAAZ,M,IACA,O,mDAGO,SAASP,EAA8BE,GAO5C,MANqB,CACnB,qBACA,sBACA,yBACA,YAEkBC,SAASD,EAAKE,UA2D7B,SAASuB,KAAaa,GAC3B,OAAOjC,EAAMkC,WAAWC,YACtBnC,EAAMoC,IAAIlC,MAAMkB,aAAaa,GAC7BjC,EAAMoC,IAAIlC,MAAMmC,WAQb,SAAShB,EAAgBiB,GAC9B,OAAOlB,EAAU,CAAEmB,KAAM,SAAU9D,OAAO,aAAU6D,O,cClFtDrF,EAAOD,QAAUwC,QAAQ,kC,cCAzBvC,EAAOD,QAAUwC,QAAQ,mB,cCAzBvC,EAAOD,QAAUwC,QAAQ,kB,cCAzBvC,EAAOD,QAAUwC,QAAQ,uB,cCAzBvC,EAAOD,QAAUwC,QAAQ,yC,cCAzBvC,EAAOD,QAAUwC,QAAQ,U,8ECAzB,WAEA,MAAMgD,EAAoB,CACxBC,OAAQ,EAERC,MAAO,GACPC,IAAK,EACLC,OAAQ,GACRC,MAAO,GACPC,QAAS,GACTC,QAAS,EACTpB,GAAI,OACJqB,IAAK,GAGP,IAAIC,GAAQ,IAAAC,oBAAmB,CAM7BC,MAAOC,GAASA,EAAMH,MAAMI,KAAKF,MAMjCG,QAAQ,IAAAC,YAAW,CAAC,UAAWC,GAAmB,OAAVA,GAMxCC,SAAUL,GAASA,EAAMH,MAAMI,KAAKI,SAOpCC,oBAAoB,IAAAH,YAClB,CAAC,YAAa,WACd,CAACE,EAAUH,IAAWG,IAAaH,GAQrCE,MAAOJ,GAASA,EAAMH,MAAMU,YAAYH,MAOxCI,gBAAgB,IAAAL,YACd,CAAC,UAAW,WACZ,CAACC,EAAOL,IAAUK,EAAMvC,OAASkC,GAUnCU,MAAM,IAAAN,YACJ,CAAC,UAAW,WACZ,CAACC,EAAOL,IACNK,EAASA,EAAMvC,OAAS,EAAIuC,EAAML,GAASX,EAAqB,MAUpEsB,MAAM,IAAAP,YACJ,CAAC,UAAW,WACZ,CAACC,EAAOL,IACNA,EAAQK,EAAMvC,OAAS,EAAIuC,EAAML,EAAQ,GAAKX,GASlDuB,iBAAiB,IAAAR,YAAW,CAAC,UAAW,WAAY,CAACC,EAAOL,KAC1D,IAAIV,EAAQe,EAAML,GAAOV,MACzB,OAAOe,EAAMxC,MAAMmC,EAAQ,GAAGa,KAAKH,GAAQA,EAAKpB,QAAUA,KAM5DwB,YAAa,CAIXC,eAAgBd,GAASA,EAAMH,MAAMgB,YAAYC,kB,UAItCjB,G,qHC9Gf,MAGA,O,IACA,O,IAEA,MAEYjD,E,wJAAZ,MACA,O,oDARc,aAAY,0BAA1B,MAkBMmE,EAAY,KAAKC,OAAOpE,EAAMoC,IAAIlC,MAAMmC,WAE9C,SAASgC,GACP,QAAEC,EAAF,OAAWC,GACXC,EACAC,EACAC,GAEA,IAAIC,EACAC,EAAgBC,QAAQN,GAC5B,GAAID,IAICQ,QAASH,EAAWJ,UAAWC,EAAUF,QACvC,KAAIM,EAMT,OAAO,KAHPD,EAAYF,EAAOF,GAMrB,GAAiBzE,MAAb6E,EAAwB,CAE1B,IAAIG,EAAUJ,EAASC,GACvB,uBACKG,EADL,CAEEP,WAIF,MAAO,CACLA,SACAK,iBASN,SAASG,EAAoBlB,EAAMT,EAAQ,MACzC,IAAI4B,EAAO,CAMT/B,OAAO,IAAAM,YAAW,CAACM,GAAOA,IACxB,IAAKA,EACH,OAAO,KAET,IAAI,QAAEd,EAAF,GAAWpB,EAAX,GAAeqB,GAAOa,EAC1B,MAAO,CAAEd,UAASpB,KAAIqB,QAMxBiC,gBAAgB,IAAA1B,YAAW,CAAC,WAAYM,GAASA,EAAOA,EAAKb,GAAK,MAOlEkC,QAAQ,IAAA3B,YAAW,CAAC,WAAYM,IAAQ,IAAAnC,gBAAemC,EAAKlC,KAO5DwD,aAAa,IAAA5B,YAAW,CAAC,WAAYM,IAAQ,IAAAjC,qBAAoBiC,EAAKlC,KAOtEyD,qBAAqB,IAAA7B,YAAW,CAAC,WAAYM,IAC3C,IAAAhC,6BAA4BgC,EAAKlC,KAQnC0D,sBAAsB,IAAA9B,YAAW,CAAC,WAAYM,IAC5C,IAAA/B,8BAA6B+B,EAAKlC,KAMpC2D,cAAc,IAAA/B,YAAW,CAAC,WAAYM,IACpC,IAAA9B,sBAAqB8B,EAAKlC,KAO5B4D,UAAU,IAAAhC,YAAW,CAAC,WAAYM,IAAQ,IAAA7B,kBAAiB6B,EAAKlC,KAKhE6D,WAAW,IAAAjC,YAAW,CAAC,WAAYM,GAAoB,YAAZA,EAAKlC,IAKhD8D,SAAS,IAAAlC,YAAW,CAAC,WAAYM,GAAoB,WAAZA,EAAKlC,IAK9C+D,QAAQ,IAAAnC,YAAW,CAAC,WAAYM,GAAoB,UAAZA,EAAKlC,IAO7CgE,gBAAgB,IAAApC,YACd,CAAC,YAAa,UACd,CAACqC,EAAQC,IAAUD,GAAUC,IAIjC,GAAIzC,EAAO,CACU0C,IACD,iBAATA,IACNA,EAAKC,WAAW,OAASD,EAAKC,WAAW,QAExCC,CAAW5C,KACbA,EAAS,MAAKA,IAGhB,aAAc4B,EAAM,CAIlBiB,QAAQ,IAAA1C,YACN,CAAC,UAAWH,GACZ,CAACS,GAAQhB,WACK,SAAZgB,EAAKlC,IACQ,UAAZkC,EAAKlC,IAAkBkB,EAAMA,EAAM5B,OAAS,KAAOkD,GAUxD+B,aAAa,IAAA3C,YAAW,CAAC,YAAaH,GAAQ,CAACqC,GAAW5C,WACnD4C,EAGE5C,EAAMA,EAAM5B,OAAS,GAFnB,MAUXkF,aAAa,IAAA5C,YACX,CAAC,WAAYH,GAEb,CAAC8B,GAAUrC,YACT,IAAKqC,EACH,OAAO,KAGT,IAAIZ,EAAUzB,EAAMA,EAAM5B,OAAS,GACnC,OAAOjB,EAAMoC,IAAIlC,MAAMkG,UAAU9B,KASrC+B,cAAc,IAAA9C,YACZ,CAAC,aAAcH,GAEf,CAACmC,GAAY1C,QAAOD,aAClB,IAAK2C,EACH,OAAO,KAKT,MAAMe,EAAiD,EAAxCC,SAAS1D,EAAMA,EAAM5B,OAAS,GAAI,IAC3CA,EAAiD,EAAxCsF,SAAS1D,EAAMA,EAAM5B,OAAS,GAAI,IAEjD,MACE,KACA2B,EACG4D,KAAK,IACLC,UAAUH,EAAQA,EAASrF,GAC3ByF,OAAOzF,EAAQ,QAUxB0F,UAAU,IAAApD,YACR,CAAC,WAAY,gBAAiBH,GAC9B,CAAC8B,EAAQ0B,GAAS/D,QAAOD,aACvB,IAAKsC,EACH,OAAO,KAMT,IAAI2B,EAAYD,EAAQ,EAAI,EAI5B,MAAMN,EAA6D,EAApDC,SAAS1D,EAAMA,EAAM5B,OAAS,EAAI4F,GAAY,IACvD5F,EAA6D,EAApDsF,SAAS1D,EAAMA,EAAM5B,OAAS,EAAI4F,GAAY,IAE7D,MACE,KACAjE,EACG4D,KAAK,IACLC,UAAUH,EAAQA,EAASrF,GAC3ByF,OAAOzF,EAAQ,QAUxB6F,WAAW,IAAAvD,YACT,CAAC,WAAY,yBAA0B,iBAAkBH,GACzD,CAAC2D,EAAOC,EAAWC,GAAYpE,YAC7B,IAAKkE,GAASC,EACZ,OAAO,KAGT,GAAIC,EACF,OAAO,IAAIC,UAAG,GAIhB,IAAIzI,EAAQoE,EAAMA,EAAM5B,OAAS,GACjC,OAAOjB,EAAMkC,WAAWiF,KAAK1I,KASjC2I,aAAa,IAAA7D,YAAW,CAAC,aAAcH,GAAQ,CAACmC,GAAY1C,YAC1D,IAAK0C,EACH,OAAO,KAIT,IAAI9G,EAAQoE,EAAMA,EAAM5B,OAAS,GACjC,OAAOjB,EAAMkC,WAAWiF,KAAK1I,KAS/B4I,iBAAiB,IAAA9D,YACf,CAAC,mBAAoBH,GAErB,CAACuC,GAAkB9C,WACZ8C,EAIE9C,EAAMA,EAAM5B,OAAS,GAHnB,MAYbqG,aAAa,IAAA/D,YACX,CACE,gBACA,iBACA,2BACA,wBACA,kBAEF,CAACe,EAASC,EAAQC,EAAWC,EAAQC,IACnCL,EAAqB,CAAEC,UAASC,UAAUC,EAAWC,EAAQC,MAKrE,OAAOM,EAGT,MAAMuC,GAAM,IAAArE,oBAAmB,CAI7BE,MAAOA,GAASA,EAAMmE,IAKtBC,KAAM,CAIJ9C,UAAU,IAAAnB,YAAW,CAAC,UAAWH,GAASA,EAAMoE,KAAK9C,SAAS+C,WAK9DC,SAAU,CAORjD,QAAQ,IAAAlB,YAAW,CAAC,kBAAmBmB,GAAYH,GACjDvE,EAAM2H,SAASzH,MAAM0H,oBAAoBlD,EAAUH,MAQzDZ,YAAa,CAIXkE,QAAS,CAIPC,IAAI,IAAAvE,YAAW,CAAC,UAAWH,GAASA,EAAMO,YAAYkE,QAAQC,IAI9DC,OAAO,IAAAxE,YAAW,CAAC,UAAWH,GAASA,EAAMO,YAAYkE,QAAQE,QAMnEC,QAAQ,IAAAzE,YAAW,CAAC,UAAWH,GAASA,EAAMO,YAAYqE,QAK1DC,aAAa,IAAA1E,YAAW,CAAC,UAAWH,GAASA,EAAMO,YAAYsE,aAK/DC,iBAAiB,IAAA3E,YACf,CACE,qBACA,2BACA,wBACA,kBAEF,CAACV,EAAO2B,EAAWC,EAAQC,IACzB7B,EAAM5B,OAAS,EACXoD,EAAqBxB,EAAM,GAAI2B,EAAWC,EAAQC,GAClD,OAOVyD,QAAS,CAIPC,UAAWhF,GAASA,EAAMmE,IAAIlE,KAAK+E,UAKnCzK,MAAM,IAAA4F,YACJ,CAAC,eAEDV,GAAUA,EAAM5B,OAAS4B,EAAMA,EAAM5B,OAAS,GAAK,IAMrD6D,SAAS,IAAAvB,YACP,CACE,SACA,oBACA,wBACA,kBAEFc,GAQFjB,OAAO,aACL,MACG,CAAC,QAAS,QAAS,MAAO,SAAU,QAAS,WAAWiF,IAAIC,IAASA,CACtE,CAACA,IAAQ,IAAA/E,YAAW,CAACN,UAAMY,MAAOA,GAAQA,EAAKyE,QAOnDzE,sBACKkB,EAAoB9B,UAAMY,KAAM,WADrC,CAWE0E,gBAAgB,IAAAhF,YACd,CACE,aACA,+BACA,cACA,oBAEF,CAACgC,EAAU1C,EAAO2C,EAAWgD,KAC3B,IAAKjD,EACH,OAAO,KAET,IAAIjB,EAAUtE,EAAMoC,IAAIlC,MAAMkG,UAAUvD,EAAMA,EAAM5B,OAAS,IAC7D,OAAIqD,IAAYtE,EAAMoC,IAAIlC,MAAMuI,cAAgBjD,EACvCgD,EAEFlE,IAIXkE,gBAAgB,IAAAjF,YACd,CAAC,cAAe,iBAAkB,UAAW,kBAC7C,CAACiC,EAAWjB,GAAUmE,kBAAkB7F,IACtC2C,EACIxF,EAAMoC,IAAIlC,MAAMkG,UACd,MACE,IAAAhF,WAAU,CACRmB,KAAM,QACN9D,MAGE,OACAiK,EAAe1H,MAAM,GACrB6B,EAAMA,EAAM5B,OAAS,IACrB,IAAAG,WAAU,CAAEmB,KAAM,QAAS9D,MAAO8F,IAAUvD,MAAM,KACnDA,MACD,EACE,GACGhB,EAAMoC,IAAIlC,MAAMmC,UACfrC,EAAMoC,IAAIlC,MAAMyI,gBAK5B,MAaRC,uBAAuB,IAAArF,YACrB,CAAC,WAAY,aAAc,qBAC3B,CAACwD,EAAO8B,EAASC,KAAmB/B,GAAS8B,KAAaC,GAO5DC,iBAAiB,IAAAxF,YACf,CAAC,uBAAwB,qBACzB,CAACyF,EAAcC,IAAcD,IAAiBC,GAMhDC,iBAAiB,IAAA3F,YACf,CAAC,cAAe,kBAChB,CAAC4F,EAAWnB,IAAWmB,GAAanB,GAWtCmB,WAAW,IAAA5F,YACT,CAAC,uBAAwB,oBAAqBN,UAAMW,gBACpD,CAACoF,EAAcC,EAAWrF,IACxBqF,EAAYD,GAAmC,IAAnBpF,GAMhCwF,sBAAsB,IAAA7F,YACpB,CAAC,cAAe,kBAChB,CAAC4F,EAAWnB,IAAWmB,IAAcnB,GASvCqB,cAAc,IAAA9F,YACZ,CACE,cACA,cACAN,UAAMW,eACN,uBAEF,CAACuF,GAAatG,SAASyG,EAAWC,IAC3BJ,EAIDG,GAAa,EACRC,EAEA1G,EAAMA,EAAM5B,OAAS,KAAOkD,EAN5B,MAsBbqF,aAAa,IAAAjG,YACX,CAAC,UAAW,yBAA0B,YAEtC,CAACM,EAAMuF,GAAwBvG,QAAOD,aACpC,GAAgB,WAAZiB,EAAKlC,IAA+B,WAAZkC,EAAKlC,GAC/B,MAAO,KAET,GAAIyH,GAAoC,WAAZvF,EAAKlC,GAC/B,MAAO,KAIT,MAAM2E,EAAiD,EAAxCC,SAAS1D,EAAMA,EAAM5B,OAAS,GAAI,IAC3CA,EAAiD,EAAxCsF,SAAS1D,EAAMA,EAAM5B,OAAS,GAAI,IAEjD,MACE,KACA2B,EACG4D,KAAK,IACLC,UAAUH,EAAQA,EAASrF,GAC3ByF,OAAOzF,EAAQ,QAYxBwI,aAAa,IAAAlG,YACX,CAAC,WAAY,eACb,CAACmC,GAAU7C,WACJ6C,EAGE7C,EAAMA,EAAM5B,OAAS,GAFnB,QAUfyI,MAAO,CAKLC,GAAG,IAAApG,YAAW,CAAC,UAAWH,GAASA,EAAMC,KAAKqG,OAS9C5G,SAAS,IAAAS,YACP,CAAC,MAAO,mBAAoB,WAC5B,CAACmG,EAAOE,GAAclB,oBACpBA,IAAmB1I,EAAMoC,IAAIlC,MAAMuI,aAC/BmB,EACAF,EAAMA,EAAMzI,OAAS,GAAG4I,SAASnB,GAAgB5F,SAMzD0B,WAAW,IAAAjB,YAAW,CAAC,OAAQmG,IAC7B,aACE,OACG,aAAeA,EAAMA,EAAMzI,OAAS,GAAG4I,UAAUxB,IAClD,EAAE/D,GAAWwF,OAAMhF,eAAnB,CACE,CAACR,GAAU,CAAEA,UAASC,OAAQuF,EAAMhF,kBAWhDhB,KAAM,CAMJV,OAAO,aACL,MACG,CAAC,QAAS,QAAS,MAAO,SAAU,QAAS,WAAWiF,IAAIC,IAASA,CACtE,CAACA,IAAQ,IAAA/E,YAAW,CAACN,UAAMa,MAAOD,GAAQA,EAAKyE,QAOnDzE,KAAMkB,EAAoB9B,UAAMa,KAAM,YAMxCC,gBAAiB,CAMfX,OAAO,aACL,MACG,CAAC,QAAS,QAAS,MAAO,SAAU,QAAS,WAAWiF,IAAIC,IAASA,CACtE,CAACA,IAAQ,IAAA/E,YAAW,CAACN,UAAMc,iBAAkBF,GAAQA,EAAKyE,W,UAMnDf,G,qHCjuBf,MAGA,O,IACA,O,IAEA,O,IAEA,M,IACA,M,mDARA,MAAMwC,GAAQ,aAAY,+BAU1B,SAASC,EAAkClF,GAEzC,OADAiF,EAAM,cAAejF,QAEEhF,IAArBgF,EAAQmF,UAERC,UAAOC,UAAUrF,EAAQmF,SAASG,QAAS,UAAW,CACpDC,mBAAmB,MAEpBvF,EAAQF,cAKb,SAAS0F,EAAyBC,GAChC,MAAO,CAILC,aAAa,IAAAjH,YACX,CAAC,uCAAwCgH,EAAatF,gBAMtD,CAACoD,EAAKrF,IAAOqF,EAAIrF,IAAO,IAM1ByH,eAAe,IAAAlH,YACb,CAAC,iBACDiH,GAAeA,EAAYC,eAM7BC,QAAQ,IAAAnH,YAGN,CAAC,mBAAoB,iBAErB,CAACoH,GAAWC,KAAMnJ,KAAUkJ,GAAUA,EAAQlJ,IAAY,IAM5DoJ,sBAAsB,IAAAtH,YACpB,CAAC,WAAY,+BACb,EAAGuH,gBAAerJ,MAAMsJ,KAAeA,EAAUD,IAAkB,IAAIrJ,IAMzEuJ,aAAa,IAAAzH,YAAW,CAAC,iBAAkB0H,UAAcC,gBAKzDC,gBAAgB,IAAA5H,YACd,CAAC,yBAA0B,iBAE3B,CAACsH,EAAsBO,IACrBP,EACII,UAAcI,UACZR,EACAO,EAAME,MACNF,EAAMnK,QAER,MAMRP,SAAS,IAAA6C,YACP,CAAC,oBAED4H,GAAmBA,EAAiBA,EAAezK,QAAU,MAM/Df,MAAM,IAAA4D,YACJ,CAAC,WAAY,oBAEb,EAAGgI,OAAOJ,IAAoBA,EAAiBA,EAAexL,KAAO4L,IAK3E,IAAIC,GAAW,IAAAtI,oBAAmB,CAIhCE,MAAOA,GAASA,EAAMoI,SAKtBhE,KAAM,CAKJmD,SAAS,IAAApH,YAAW,CAAC,UAAWH,GAASA,EAAMoE,KAAKmD,QAAQc,kBAM9D9H,YAAa,CAIX+H,sCAAsC,IAAAnI,YACpC,CAACgE,UAAI5D,YAAYuE,iBACjB8B,IAOJ7B,uBAMEwC,SAAS,IAAApH,YACP,CAAC,gBAAiBgE,UAAIY,QAAQrD,SAC9B,CAAC6F,EAAS7F,IACRA,OAC8BhF,IAA1BgF,EAAQgG,eACLH,EAAQ7F,EAAQgG,gBAAkB,CAAEa,KAAM,OAAQA,KACnD,GACF,MAMRC,WAAW,IAAArI,YACT,CAACgE,UAAIY,QAAQrD,SAEbA,GAAYA,EAAUA,EAAQ8G,UAAY,MAM5CC,wBAAwB,IAAAtI,YACtB,CAAC,eACDqI,GACEA,EAAYX,UAAca,0BAA0BF,GAAa,MAMrEG,mBAAoB3I,GAASA,EAAMoI,SAASnI,KAAK0I,mBAKjDC,mBAAoB5I,GAASA,EAAMoI,SAASnI,KAAK2I,mBAKjDC,eAAe,IAAA1I,YACb,CAAC,wBACDV,GAASA,EAAMA,EAAM5B,OAAS,IAMhCiL,0BAA0B,IAAA3I,YACxB,CAACgE,UAAIY,QAAQrD,SACbkF,GAMFmC,cAAc,IAAA5I,YACZ,CAAC,YAAagE,UAAIY,QAAQrD,QAAS,4BAEnC,CAAC6F,EAAS7F,EAAS8G,IACZ9G,EAIEmG,UAAcmB,mCAClBzB,GAAW,IAAItC,IAAI,EAAGqC,YAAaA,GACpC5F,EAAQP,OACRqH,GANO,IAcbS,6BAA6B,IAAA9I,YAC3B,CAAC,kBAED4I,IACE,aACE,MACGA,EAAa9D,IAAImC,IAAeA,CACjC,CAACA,EAAYxH,IAAKwH,QAKvBF,EAAyB/C,UAAIY,QAAQtE,MA9F1C,CAmGEyI,oBAAoB,IAAA/I,YAClB,CACE,gCACAgE,UAAIY,QAAQtE,KAAKoB,eACjBsC,UAAIzD,KAAKD,KAAKoB,gBAGhB,CAACoD,EAAKF,EAASrE,KACRuE,EAAIvE,KAITqE,EAAUE,EAAIF,GACdrE,EAAOuE,EAAIvE,GAGTqE,EAAQmD,OAASxH,EAAKwH,OACtBnD,EAAQlH,QAAU6C,EAAK7C,QACvBkH,EAAQyC,MAAQ9G,EAAK8G,OAQ3B2B,2BAA2B,IAAAhJ,YACzB,CACE,iBACA,YACA,8BACAgE,UAAIY,QAAQrD,SAEd,CAACqH,EAAcxB,EAASI,GAAaD,mBAInCG,UAAcuB,6BACZL,EACAxB,EAAQtC,IAAI,EAAGkD,SAAUA,GACzBR,EAAUD,GACVA,IAON2B,aAAa,IAAAlJ,YACX,CAAC,iBAED,EAAGmJ,WAAYA,EAAMpB,MAAMqB,MAAQD,EAAME,IAAID,MAM/CE,UAAU,IAAAtJ,YAAW,CAACgE,UAAIY,QAAQtE,KAAKoC,QAASA,GAAUA,GAK1D6G,eAAe,IAAAvJ,YAAW,CAAC,iBAAkB,CAAC/F,EAAI,KAAOA,EAAEuP,MAAQ,KAMnEC,UAAU,IAAAzJ,YACR,CACEgE,UAAIY,QAAQtE,KAAKqB,OACjBqC,UAAIY,QAAQtE,KAAK0B,SACjBgC,UAAIY,QAAQtE,KAAK+E,uBAEnB,CAAC1D,EAAQK,EAAU0H,KAAe/H,GAAUK,KAAc0H,GAQ5DC,YAAY,IAAA3J,YACV,CAACgE,UAAIY,QAAQtE,KAAKsF,WAClBA,GAAaA,GAUfgE,YAAY,IAAA5J,YACV,CAAC,gCAAiCN,UAAMO,MAAOP,UAAME,OACrD,CAACkF,EAAK7E,EAAOL,IACXK,EAAMxC,MAAMmC,EAAQ,GAAGa,KAAK,EAAGhB,QAASqF,EAAIrF,KAAyB,IAAlBqF,EAAIrF,GAAI4H,SASjE9G,KAAMwG,EAAyB/C,UAAIzD,KAAKD,MAKxCuJ,MAAO,CAKLvC,sBAAsB,IAAAtH,YAAW,CAAC,iBAAkB8J,IAClD,aACE,OACG,aAAeA,GAAchF,IAC9B,EAAEyC,GAAiBa,KAAMhB,OAAzB,CACE,CAACG,GAAgBH,EAAQtC,IAAI,EAAGkD,SAC9BN,UAAcqC,oBAAoB/B,Y,UASjCC,G,cClXfvO,EAAOD,QAAUwC,QAAQ,wC,gFCCT+N,UAAT,SAAmB/J,GACxB,MAAO,CACLjB,KAAMiL,EACNhK,U,EAKYM,KAAT,WACL,MAAO,CAAEvB,KAAMkL,I,EAIDC,KAAT,WACL,MAAO,CAAEnL,KAAMoL,I,EAIDC,KAAT,WACL,MAAO,CAAErL,KAAMsL,I,EAIDC,SAAT,WACL,MAAO,CAAEvL,KAAMwL,I,EAIDC,MAAT,WACL,MAAO,CAAEzL,KAAM0L,I,EAIDC,kBAAT,WACL,MAAO,CAAE3L,KAAM4L,I,EAIDC,SAAT,WACL,MAAO,CAAE7L,KAAM8L,I,EAIDC,kBAAT,SAA2BC,GAChC,MAAO,CAAEhM,KAAMiM,EAAqBD,UA7C/B,MAAMf,EAAaA,EAAbA,WAAa,mBAQnB,MAAMC,EAAOA,EAAPA,KAAO,aAKb,MAAME,EAAOA,EAAPA,KAAO,aAKb,MAAME,EAAOA,EAAPA,KAAO,aAKb,MAAME,EAAeA,EAAfA,aAAe,YAKrB,MAAME,EAAQA,EAARA,MAAQ,cAKd,MAAME,EAAqBA,EAArBA,mBAAqB,2BAK3B,MAAME,EAAWA,EAAXA,SAAW,iBAKjB,MAAMG,EAAsBA,EAAtBA,oBAAsB,6B,+FC/BlBF,kBAAV,UAA4BC,SAC3B,IAAAE,KAAIC,EAAQJ,kBAAkBC,K,EAGrBI,oBAAV,YACL,IAAIJ,QAAc,IAAAK,QAAO3L,UAAMgB,YAAYC,sBACrC,IAAAuK,KAAIC,EAAQJ,kBAAkBC,EAAQ,K,EAG7BM,QAAV,kBACC,IAAAJ,KAAIC,EAAQ5K,QAElBiG,EAAM,sBACA,IAAA+E,MAAK,CAACJ,EAAQb,KAAMa,EAAQX,eAClChE,EAAM,e,EAuCSgF,yBAAV,kBACC,IAAAN,KAAIC,EAAQN,a,EAGHY,aAAV,UAAuBxL,GAuB5B,aAtBM,IAAAiL,KAAIC,EAAQnB,UAAU/J,IAEZ,IACX,IAAI,EAAJ,QACDA,EACG6E,IACC,EAAG1G,KAAIkB,YACL,IAAAnB,gBAAeC,GAEX3B,EAAMoC,IAAIlC,MAAMkG,UAAUvD,EAAMA,EAAM5B,OAAS,SAG/CnB,GAGPmP,OACC3K,QACcxE,IAAZwE,GAAyBA,IAAYtE,EAAMoC,IAAIlC,MAAMuI,iB,EAQhDuF,MAAV,kBACC,IAAAS,KAAIC,EAAQV,U,EAGHkB,OAAV,kBACC,IAAAT,KAAIC,EAAQR,sB,EAGHiB,OAvGjB,I,IAAA,MAGA,OACA,OAEYnP,E,EAAZ,MAEY0O,E,EAAZ,O,IAEA,M,4MATA,MAAM3E,GAAQ,aAAY,wBA4B1B,SAAUjG,IACR,IAAIwF,QAAkB,IAAAsF,QAAO3L,UAAMW,gBACnCmG,EAAM,gBAAiBT,GACvB,IAAI9F,QAAc,IAAAoL,QAAO3L,UAAMO,OAC/BuG,EAAM,kBAAmBvG,EAAMvC,QAC/B,IAAImO,EAAuB,EAE3B,GAAI9F,EAAY,EAAG,CAQjB,IAPAS,EAAM,gBAENqF,QAA6B,IAAAR,QAAO3L,UAAMgB,YAAYC,sBAChD,IAAAuK,KAAIC,EAAQhB,QAClB3D,EAAM,YAGCqF,EAAuB,SACtB,IAAAN,MAAKJ,EAAQL,UACnBtE,EAAM,gBACNqF,IAGF9F,IAGEA,GACFS,EAAM,sBAEA,IAAA0E,KAAIC,EAAQd,QAClB7D,EAAM,cAENA,EAAM,8BACA,IAAA0E,KAAIC,EAAQZ,YAClB/D,EAAM,qBA0CH,SAAUoF,UACT,IAAAE,WAAUX,EAAQjB,KAAM3J,G,WAGjB,IAAA1D,YAAW,QAAS+O,I,gFC1GnB7D,MAAT,SAAegE,EAAUC,GAC9B,MAAO,CACLhN,KAAMiN,EACNF,WACAC,W,EAKYE,gBAAT,SAAyBF,GAC9B,MAAO,CACLhN,KAAMmN,EACNH,W,EAKYI,UAAT,WACL,MAAO,CAAEpN,KAAMqN,I,EAID1B,kBAAT,WACL,MAAO,CACL3L,KAAM4L,I,EAKM0B,MAAT,WACL,MAAO,CACLtN,KAAMuN,I,EAKMC,KAAT,WACL,MAAO,CACLxN,KAAMyN,I,EAKMtN,MAAT,SAAeA,GACpB,MAAO,CACLH,KAAM0N,EACNvN,U,EAKYwN,gBAAT,SAAyBxL,EAAUiG,GACxC,MAAO,CACLpI,KAAM4N,EACNzL,WACAiG,Y,EAKYyF,gBAAT,SAAyBzM,GAC9B,MAAO,CACLpB,KAAM8N,EACN1M,gB,EAKY2M,YAAT,SAAqBC,GAC1B,MAAO,CACLhO,KAAMiO,EACND,Y,EAKYE,UAAT,SAAmB1I,GACxB,MAAO,CACLxF,KAAMmO,EACN3I,U,EAKY4I,aAAT,WACL,MAAO,CAAEpO,KAAMqO,I,EAIDC,YAAT,WACL,MAAO,CAAEtO,KAAMuO,I,EAIDC,cAAT,WACL,MAAO,CAAExO,KAAMyO,I,EAIDC,gBAAT,SAAyBtG,EAASjG,GACvC,MAAO,CACLnC,KAAM2O,EACNvG,UACAjG,aAxGG,MAAM8K,EAAQA,EAARA,MAAQ,gBASd,MAAME,EAAmBA,EAAnBA,iBAAmB,2BAQzB,MAAME,EAAYA,EAAZA,UAAY,oBAKlB,MAAMzB,EAAqBA,EAArBA,mBAAqB,6BAO3B,MAAM2B,EAAQA,EAARA,MAAQ,gBAOd,MAAME,EAAOA,EAAPA,KAAO,eAOb,MAAMC,EAAQA,EAARA,MAAQ,gBAQd,MAAME,EAAmBA,EAAnBA,iBAAmB,2BASzB,MAAME,EAAmBA,EAAnBA,iBAAmB,2BAQzB,MAAMG,EAAeA,EAAfA,aAAe,uBAQrB,MAAME,EAAaA,EAAbA,WAAa,qBAQnB,MAAME,EAAiBA,EAAjBA,eAAiB,yBAKvB,MAAME,EAAgBA,EAAhBA,cAAgB,wBAKtB,MAAME,EAAkBA,EAAlBA,gBAAkB,0BAKxB,MAAME,EAAmBA,EAAnBA,iBAAmB,4B,cCnGhCjU,EAAOD,QAAUwC,QAAQ,wC,cCAzBvC,EAAOD,QAAUwC,QAAQ,iB,cCAzBvC,EAAOD,QAAUwC,QAAQ,U,8FC0BR2R,MAAV,UAAgBC,EAAQ1Q,EAAS2Q,EAAU5Q,EAAUqK,SACpD,IAAA2D,KAAIC,EAAQyC,MAAMC,EAAQ1Q,EAAS2Q,EAAU5Q,EAAUqK,K,EAG9CwG,QAAV,UAAkB3R,EAAMmL,SACvB,IAAA2D,KAAIC,EAAQ4C,QAAQ3R,EAAK5B,KAAM4B,EAAK8B,GAAI9B,EAAKwR,MAAOrG,K,EAG3CyG,SAAV,UAAmB7Q,EAASD,EAAUqK,EAAeuG,SACpD,IAAA5C,KACJC,EAAQyC,WAAMrR,EAAWY,EAAS2Q,EAAU5Q,EAAUqK,K,EAIzC0G,WAAV,UACL7R,EACAe,EACA+Q,EACAhR,EACAqK,SAEM,IAAA2D,KACJC,EAAQ4C,QACN3R,EAAK5B,MACL,IAAAyC,UAASC,EAAUC,IACnB,IAAAF,UAASC,EAAUgR,GACnB3G,K,EAKW4G,WAAV,UAAqB/R,EAAMmL,SAC1B,IAAA2D,KAAIC,EAAQgD,WAAW/R,EAAMmL,K,EAQpB6G,S,EAuDAC,kBAAV,YACL,MAAMC,QAAyB,IAAAjD,QAAOkD,UAAK1E,MAAMyE,kBAC3CzO,QAAc,IAAAwL,QAAOkD,UAAKhO,KAAKV,OAC/B2O,QAAoB,IAAAnD,QAAOkD,UAAKtK,KAAKuK,aACrCrN,QAAiB,IAAAkK,QAAOkD,UAAK1E,MAAM1I,UACnCsD,QAAe,IAAA4G,QAAOkD,UAAK3J,QAAQkB,cACnC2I,QAAyB,IAAApD,QAAOkD,UAAK3J,QAAQ6J,kBAE7CC,EAAUjS,EAAMkS,iBACpB,CACEL,mBACAzO,QACA2O,cACArN,YAEFsN,EACAhK,GAGF+B,EAAM,sBACN,IAAIoI,EAASF,EAAQnO,OACrB,MAAQqO,EAAOC,MAAM,CACnBrI,EAAM,oBACN,IACIsI,EADAC,EAAUH,EAAO1T,MAErB,OAAQ6T,EAAQ/P,MAEd,IAAK,OACH8P,QAAkBE,EAAYD,EAAQhO,SACtC,MACF,QACEyF,EAAM,8BAEVA,EAAM,oBACNoI,EAASF,EAAQnO,KAAKuO,GAIxB,OADAtI,EAAM,iBACCoI,EAAO1T,O,EAqvBCuP,MAAV,kBACC,IAAAS,KAAIC,EAAQV,U,EAGHwE,kBAAV,YACL,MAAMC,QAAkB,IAAA7D,QAAOkD,UAAK1E,MAAMsF,wBAC1C3I,EAAM,eAAgB0I,GACtB,MAAME,QAA8B,IAAA/D,QAAOkD,UAAK1E,MAAMuF,uBAChDd,QAAyB,IAAAjD,QAAOkD,UAAK1E,MAAMyE,kBACjD9H,EAAM,2BAA4B4I,GAClC,MAAMC,EAAqB5S,EAAM6S,QAAQC,SAASC,sBAChDlB,GAEF9H,EAAM,wBAAyB6I,GAC/B,MAAMI,EAAoBhT,EAAMiT,OAAOH,SAASI,qBAC9CrB,GAEIsB,EAAiBnT,EAAMoT,QAAQN,SAASO,kBAC5CxB,GAEIyB,EAAsBtT,EAAMoT,QAAQN,SAASS,uBACjDd,EACAE,EACAd,EACAsB,GAEIK,EAAmBxT,EAAM6S,QAAQC,SAASW,oBAC9ChB,EACAE,EACAd,EACAe,SAEI,IAAAnE,KACJC,EAAQgF,SACNd,EACAI,EACAG,EACAG,EACAE,K,EA2HWrE,OArjCjB,I,IAAA,MAGA,OAEA,OAOA,QACYT,E,EAAZ,OACYzL,E,EAAZ,OACYsE,E,EAAZ,OACYoM,E,EAAZ,O,IAEA,O,IAEA,O,IACA,OAEY3T,E,EAAZ,M,IACA,O,4MAvBA,MAAM+J,GAAQ,aAAY,uBA4D1B,SAAU6J,UAgIV,YAQE,WAAY,IAAAhF,QAAOkD,UAAK1E,MAAMyG,kCAC5B,OAGF,IAOIhR,EAPAlD,QAAa,IAAAiP,QAAOkD,UAAK3J,QAAQxI,MAErC,IAAKA,EACH,OAKF,OAAQA,EAAKE,UACX,IAAK,cACL,IAAK,eACHgD,QAAc,IAAA+L,QAAOkD,UAAK3E,WAAW/J,MAAMP,OAM3C,MACF,IAAK,kBACHA,QAAc,IAAA+L,QAAOkD,UAAK/N,gBAAgBX,MAAMP,OAIhD,MACF,QACEA,QAAc,IAAA+L,QAAOkD,UAAKhO,KAAKV,MAAMP,OAazC,IAAKA,EAEH,OAGF,IAoBIiR,EACFC,EACAC,EACAC,EACAC,EACApO,EACAqO,EA1BEjT,EAAM2B,EAAM5B,OAAS,EAGrBP,QAAgB,IAAAkO,QAAOkD,UAAK3J,QAAQzH,SACpC0T,QAAoB,IAAAxF,QAAOkD,UAAKhO,KAAKpD,SACrC2T,QAAe,IAAAzF,QAAOkD,UAAK3J,QAAQkM,OAAOC,SAC1CvC,QAAoB,IAAAnD,QAAOkD,UAAK3J,QAAQ4J,YAAY3O,OACpDwP,QAA2B,IAAAhE,QAAOkD,UAAKtK,KAAKuK,YAAYjP,SACxD+O,QAAyB,IAAAjD,QAAOkD,UAAK1E,MAAMyE,kBAC3C0C,QAA2B,IAAA3F,QAAOkD,UAAKzO,KAAK0Q,aAC5CS,QAAoB,IAAA5F,QAAOkD,UAAKzO,KAAKmR,aACrCxL,QAAqB,IAAA4F,QAAOkD,UAAK3J,QAAQ8D,eACzCxB,QAAsB,IAAAmE,QAAOkD,UAAK3J,QAAQsC,eAC1CgK,QAAmB,IAAA7F,QAAOkD,UAAK3J,QAAQsM,YACvCC,QAA6B,IAAA9F,QAAOkD,UAAK3J,QAAQuM,sBACjDpQ,QAAgB,IAAAsK,QAAOkD,UAAK3J,QAAQ7D,SACpCwG,QAAsB,IAAA8D,QAAOkD,UAAK3J,QAAQ2C,eAC1CrK,QAAiB,IAAAmO,QAAOkD,UAAK3J,QAAQ1H,UACrCwJ,QAAiB,IAAA2E,QAAOkD,UAAK3J,QAAQ8B,UAczC,SAAU,IAAA2E,QAAOkD,UAAK3J,QAAQwM,eAAgB,CAC5C,IAAIC,QAAiB,IAAAhG,QAAOkD,UAAK3J,QAAQ0M,sBAErCC,QAAqB,IAAAlG,QAAOkD,UAAK3J,QAAQ4M,uBAC7ChL,EAAM,kBAAmB+K,GACzB,IAAIE,EAAaJ,EAASI,WAAWA,WAGjCC,EAAiBD,EAAWhU,MAAM8T,EAAe,GACjDI,GAAa,aAAID,EAAe5M,IAAIrI,EAAMC,IAAIC,MAAMiV,YACxDpL,EAAM,gBAAiBmL,GACvBlB,EAAsBoB,EACpBtK,EACAkK,EACA9T,EAAMgU,EACNlM,EACAyB,EACsB,uBAAtBmK,EAAS/U,eAGXmU,EAAsB,GAGxB,OAAQrU,EAAKE,UACX,IAAK,qBACL,IAAK,qBAUH,IAAIwV,QAAqB,IAAAzG,QAAOkD,UAAKhO,KAAK+Q,sBAC1C,GAAIQ,GAAgBA,EAAa5T,KAAO9B,EAAK8B,GAC3C,MAGF,IAAIuT,EAAarV,EAAKqV,WAAWA,WAMjCjB,EAAcqB,EACZtK,EACAkK,EACA9T,EACA8H,EACAyB,EACAgK,GAGF1K,EAAM,4BACNA,EAAM,iBAAkBgK,SAElB,IAAAtF,KAAIC,EAAQ4G,OAAOvB,IACzB,MAEF,IAAK,wBACH,GAAoB,OAAhBK,IAAyBA,EAAYrO,WAAcrF,EAAF,UAMnD,MAQF,MAAM6U,GAAkB5V,EAAK6V,iBAAmB,IAAInN,IAClD,CAACsB,EAAGxG,EAAOsS,IAAU,qBAAmBA,EAAKxU,OAAS,EAAIkC,IAEtDuS,GAAqB/V,EAAKqV,YAAc,IAAI3M,IAChD,CAACsB,EAAGxG,IAAW,eAAcA,GAK/B,IAAIwS,EAAkB,GACtB,WAAY,IAAA/G,QAAOkD,UAAK3J,QAAQyN,sBAAuB,CACrD,IAAIC,EAAa,EACjB,IAAK,MAAMC,KAAenW,EAAKoW,KAAKC,WAAY,CAC9C,GAC2B,2BAAzBF,EAAYjW,UACS,MAArBiW,EAAYrX,MAGZ,MAEF,IACE,IAAIwX,EAAa,EACjBA,EAAaH,EAAYI,UAAUjV,OACnCgV,IAIAN,EAAgBQ,QACb,oBAAmBN,eAAwBI,KAGhDJ,KAKJ,MAAMO,EAAWT,EAAgBU,OAC/Bd,EACAG,GAEF3L,EAAM,eAAgBqM,GACtBrC,EAAc,GACdI,EAAWjT,EACX,IAAK,MAAMoV,KAAUF,EAAU,CAE7B,MAAMG,GAAmB,IAAA/V,UAASC,EAAUC,EAAU4V,GACtDxC,GAAa,IAAAxS,gBACXmT,EACI,CACE3J,gBACA0L,OAAQD,EACRE,WAAYzN,EACZyB,iBAEF,CACEK,gBACA0L,OAAQD,EACRE,WAAYzN,GAElB,CACE0N,SAAU,QACVC,KAAMxC,EACNyC,GAAIzC,IAGRJ,EAAYD,EAAWrS,IAAMqS,EAC7BK,UAEI,IAAA1F,KAAIC,EAAQ4G,OAAOvB,IACzB,MAEF,IAAK,qBACH,IAAI8C,EAAa9E,EAAYpS,EAAK8B,IAElCsI,EAAM,4BACNA,EAAM,iBAAkBgI,GACxBhI,EAAM,gBAAiB8M,GACvB9C,EAAc,GACd,IAAK,IAAItS,KAAMoV,EAAWC,QAAS,CACjCrV,EAAKsV,OAAOtV,GACZ,IAAIF,EAAQ,CAAEuJ,gBAAe0L,OAAQ/U,EAAI6C,WACrC0S,GAAS,IAAA3V,iBAAgBE,GAE7BuS,mBACKvS,EADL,CAEEE,GAAIuV,EACJxV,sBACO+S,EAAmB5I,KAAKqL,IAAW,IAAIxV,KAAO,GAChDqV,EAAWC,QAAQrV,GAAIf,WAG9BqT,EAAYiD,GAAUlD,EAExB/J,EAAM,iBAAkBgK,SAGlB,IAAAtF,KAAIC,EAAQ4G,OAAOvB,IACzB,MAEF,IAAK,mBAQH,GAHApU,EAAO0U,EAAOA,EAAO1U,EAAK8B,IAAI4P,UAAU4F,WAGlB,wBAAlBtX,EAAKE,SACP,MAIJ,IAAK,sBACH,IAAIqX,EAAQvX,EAAK8B,GAIjB,GAHAsI,EAAM,6BACNA,EAAM,2BAA4Bf,EAAckO,IAE3CxC,EAAsB,CAGzB3K,EAAM,gCACN,MAIF+J,GAAa,IAAAxS,gBACXmT,EACI,CACE3J,gBACA0L,OAAQU,EACRT,WAAYzN,EACZyB,iBAEF,CAAEK,gBAAe0L,OAAQU,EAAOT,WAAYzN,GAChD,CACE0N,SAAU,QACVC,KAAMzV,EAAMlB,EAAMC,IAAIC,MAAMiV,UAAUxV,GAAQ,EAC9CiX,GAAI1V,IAGR6S,EAAc,CAAE,CAACD,EAAWrS,IAAKqS,GAEjC/J,EAAM,kBAAmBgK,SACnB,IAAAtF,KAAIC,EAAQ4G,OAAOvB,IACzB,MAEF,IAAK,kBACH,GAAoB,OAAhBK,GAAwBA,EAAYrO,WAAWrF,GAEjD,MAGJ,IAAK,aACL,IAAK,gBAEH,IAAIyW,EAAgBzW,EAAQ0W,QAAQ,WAAY,IAC5Cta,QAAa,IAAA8R,QAAOkD,UAAK3J,QAAQrL,MACjCua,EAASC,UAAYjZ,IAAIvB,EAAMqa,GACnC,GACEzW,IAAeyW,EAAF,UACO,2BAApBE,EAAOxX,SAEP,MAEFF,EAAO0X,EACP3W,EAAUyW,EAEZ,IAAK,yBACH,MAAMZ,GAAmB,IAAA/V,UAASC,EAAUC,GAC5CqJ,EAAM,uBAAwBwM,GAC9BxC,EAAc,GAEdI,EAAWjT,EACX,IAAK,IAAIiC,EAAQxD,EAAKuW,UAAUjV,OAAS,EAAGkC,GAAS,EAAGA,IAAS,CAE/D,MAAMoU,EAA4B,GAAEhB,eAA8BpT,IAClE2Q,GAAa,IAAAxS,gBACXmT,EACI,CACE3J,gBACA0L,OAAQe,EACRd,WAAYzN,EACZyB,iBAEF,CACEK,gBACA0L,OAAQe,EACRd,WAAYzN,GAElB,CACE0N,SAAU,QACVC,KAAMxC,EACNyC,GAAIzC,IAGRJ,EAAYD,EAAWrS,IAAMqS,EAC7BK,UAII,IAAA1F,KAAIC,EAAQ4G,OAAOvB,IACzB,MAEF,IAAK,cAgCH,GA1BAhK,EAAM,qBAKNgK,mBACKC,EACAwD,EACD1M,EACAnL,EACAkD,EACAmG,EACAyB,EACAgK,IAKJR,EAAiBtU,EAAKsU,eAS0B,UAA9CjU,EAAMC,IAAIC,MAAMC,UAAU8T,IACqB,UAA9CjU,EAAMC,IAAIC,MAAMC,UAAU8T,KACxBjU,EAAMC,IAAIC,MAAMuX,YAAY9X,GACyB,YAAlDK,EAAMC,IAAIC,MAAMwX,cAAczD,IAC7BjU,EAAMC,IAAIC,MAAMyX,UAAUhY,IACjC,CACAoK,EAAM,+BACNA,EAAM,eAAgB/J,EAAMC,IAAIC,MAAMC,UAAU8T,IAChDlK,EACE,mBACA/J,EAAMC,IAAIC,MAAMwX,cAAczD,IAEhClK,EAAM,uBAAwB/J,EAAMC,IAAIC,MAAMuX,YAAY9X,UACpD,IAAA8O,KAAIC,EAAQ4G,OAAOvB,IACzB,MAGF,IAAI6D,EAAgB5X,EAAMC,IAAIC,MAAM0X,cAAc3D,EAAgBI,GAK9DwD,QA4KV,UAA+BC,EAAiBF,GAG9C,IAAIC,QAIN,UAA+BC,EAAiBF,GAC9C,IAAIvD,QAAe,IAAAzF,QAAOkD,UAAK3J,QAAQkM,OAAOC,SAC1CxJ,QAAsB,IAAA8D,QAAOkD,UAAK3J,QAAQ2C,eAC1CyJ,QAA2B,IAAA3F,QAAOkD,UAAKzO,KAAK0Q,aAC5C/K,QAAqB,IAAA4F,QAAOkD,UAAK3J,QAAQ8D,eACzCxB,QAAsB,IAAAmE,QAAOkD,UAAK3J,QAAQsC,eAC1CgK,QAAmB,IAAA7F,QAAOkD,UAAK3J,QAAQsM,YAI3C,OAAa,CACX,IAAIsD,EAAUD,EAAgBrW,GAE1BuW,EAAavD,EACb,CACE3J,gBACA0L,OAAQuB,EACRtB,WAAYzN,EACZyB,iBAEF,CAAEK,gBAAe0L,OAAQuB,EAAStB,WAAYzN,GAC9CiP,GAAc,IAAA5W,iBAAgB2W,GAElC,MAAME,GAAkB3D,EAAmB5I,KAAKsM,IAAgB,IAAIzW,IAEpE,GAAIxB,EAAMC,IAAIC,MAAMiY,iBAAiBL,GAUnC,OADA/N,EAAM,wCACQ4H,EACZiG,EACA,CACElB,SAAU,aACVO,WAAYa,GAEdhN,GAEG,GAAIoN,EAAgB,CAEzB,IAAIE,EAgBJ,OAVEA,EADEpY,EAAMC,IAAIC,MAAMuX,YAAYK,GACV9X,EAAMC,IAAIC,MAAMmY,eAClCT,EACA5X,EAAMC,IAAIC,MAAMwX,cAAcI,IAKZF,EAEtB7N,EAAM,yBACQ4H,EAAOyG,EAAmBF,EAAgBpN,GACnD,GACLgN,EAAgBQ,uBAChBjE,EAAOyD,EAAgBQ,uBACvB,CAKAvO,EAAM,2BAA4B+N,EAAgBQ,uBAClD,IAAIC,EACFlE,EAAOyD,EAAgBQ,uBAAuBrB,WAEhD,GADAlN,EAAM,8BAA+BwO,GACjCA,EAAyBC,SAAU,CACrC,IAAIC,EAA0BF,EAAyB9Z,MAEvD,OAAIuB,EAAMC,IAAIC,MAAMiY,iBAAiBM,IACnC1O,EAAM,yCACQ4H,EACZiG,EACA,CACElB,SAAU,aACVO,WAAYsB,EAAyB9Z,OAEvCqM,IAGK,KAGT,OAAO,KAYN,GAA6B,mBAAzBgN,EAAgBY,KACvBZ,EAAkBA,EAAgBa,UAAU,OAIzC,IAC0B,mBAA7Bb,EAAgBjY,UACa,MAA7BiY,EAAgBc,SAUhB,OAAO,KARPd,EAAkBA,EAAgBe,gBApHdC,CAAqBhB,EAAiBF,GAC9D,OAAOC,EAAa7X,EAAMkC,WAAW6W,UAAUlB,GAAcA,EAhLjCmB,CACtBrZ,EAAKsZ,gBACLrB,GAYF,GATA7N,EAAM,iBAAkB8N,GACxB9N,EAAM,mBAAoB6N,GAQR,MAAdC,GAAsBA,EAAWpZ,MAAO,CAC1CqH,EAAOoT,EACLpO,EACAmJ,EACAO,EACAD,EACAvL,EACAyB,EACAgK,GAGF,IAAIP,EAAO,CAAEpO,QAIb,OAAQ9F,EAAMC,IAAIC,MAAMC,UAAU8T,IAChC,IAAK,QACHC,EAAKiF,SAAWnZ,EAAMC,IAAIC,MAAMkZ,eAAenF,GAC/CC,EAAK5N,OAASuR,EAAWpZ,MAAM4a,KAAKC,KAClCtZ,EAAM6S,QAAQC,SAASyG,YACrBvZ,EAAMC,IAAIuZ,OAAOC,iBACf9Z,EACAmL,EACAb,GAEF4H,EACAe,GACA8G,OAEJ,MACF,IAAK,UACHxF,EAAKnV,IAAM8Y,EACX3D,EAAK5N,OAAS,IAAIY,UAAG,GACrB,MACF,QACE6C,EAAM,8BAEVA,EAAM,UAAWmK,SAGX,IAAAzF,KACJC,EAAQiL,iBACNrV,EACA4P,EACAH,EACA/T,EAAMC,IAAIC,MAAM0Z,eAAeja,GAC/BK,EAAMC,IAAIC,MAAM0Z,eAAe3F,UAKnClK,EAAM,0CACA,IAAA0E,KAAIC,EAAQ4G,OAAOvB,IAG3B,MAEF,IAAK,eA0BH,GApBAA,mBACKC,EACAwD,EACD1M,EACAnL,EACAkD,EACAmG,EACAyB,EACAgK,IAIJ1K,EAAM,sBAGNkK,EAAiBtU,EAAKka,WAM0B,WAA9C7Z,EAAMC,IAAIC,MAAMC,UAAU8T,KACzBjU,EAAMC,IAAIC,MAAMuX,YAAY9X,GACyB,YAAlDK,EAAMC,IAAIC,MAAMwX,cAAczD,IAC7BjU,EAAMC,IAAIC,MAAMyX,UAAUhY,IAC/B,CACAoK,EAAM,sCACA,IAAA0E,KAAIC,EAAQ4G,OAAOvB,IACzB,MAIFjO,EAAOoT,EACLpO,EACAmJ,EACAO,EACAD,EACAvL,EACAyB,EACAgK,GAGFP,EAAO,CAAEpO,QAET,IAAIgU,EAAa9Z,EAAMC,IAAIuZ,OAAOC,iBAChCxF,EACAnJ,EACAb,GAEE8P,GAAoBnH,EAAmBkH,EAAWrY,IAAIqV,QAEtDkD,GAAa3F,EAAO1U,EAAK2Y,uBAAuBrB,WAAWlZ,KAC3Dkc,GAAmBF,GAAkB/V,KACvCkW,GAAUA,EAAOnc,OAASic,IAG5B9F,EAAK5N,OAAS2T,GAAiBvZ,QAAQ0K,MAAMuL,KAAKzC,KAAK5N,OAAO6T,QAE9DpQ,EAAM,UAAWmK,SACX,IAAAzF,KACJC,EAAQiL,iBACNrV,EACA4P,EACAH,EACA/T,EAAMC,IAAIC,MAAM0Z,eAAeja,GAC/BK,EAAMC,IAAIC,MAAM0Z,eAAe3F,KAGnC,MAEF,QACE,QAAgBnU,IAAZH,EAAK8B,IAA6C3B,MAAzBH,EAAKI,iBAChC,MAGFgK,EAAM,+BAAgCpK,EAAKI,kBAC3CgK,EAAM,gBACNA,EAAM,6BAA8Bf,EAAcrJ,EAAK8B,IAEvDsS,mBACKC,EACAwD,EACD1M,EACAnL,EACAkD,EACAmG,EACAyB,EACAgK,UAGE,IAAAhG,KAAIC,EAAQ4G,OAAOvB,KA3sBtBqG,SACAnX,EAAM8L,2BAGR,SAAU4C,EAAOsF,EAAYzV,EAAKsJ,GACvC,MAAM+G,QAAyB,IAAAjD,QAAOkD,UAAK1E,MAAMyE,kBAC3CzO,QAAc,IAAAwL,QAAOkD,UAAK3J,QAAQ/E,OAClCiX,QAAoB,IAAAzL,QAAOkD,UAAK1E,MAAMiN,aACtCtI,QAAoB,IAAAnD,QAAOkD,UAAKtK,KAAKuK,aACrCrN,QAAiB,IAAAkK,QAAOkD,UAAK1E,MAAM1I,UACnC4V,QAAuB,IAAA1L,QAAOkD,UAAK3J,QAAQrD,SAC3CyV,QAA+B,IAAA3L,QACnCkD,UAAK3J,QAAQoE,2BAGTpI,EAAY,IAAIqW,WAAWxa,EAAMoC,IAAIlC,MAAMmC,WAE3C4P,EAAUjS,EAAMya,eACpBxD,EACAzV,EACA,CACEqQ,mBACAzO,QACAiX,cACAtI,cACArN,WACA4V,iBACAC,0BAEFzP,GAGFf,EAAM,sBACN,IAAIoI,EAASF,EAAQnO,OACrB,MAAQqO,EAAOC,MAAM,CACnBrI,EAAM,oBACN,IACIsI,EADAC,EAAUH,EAAO1T,MAErB,OAAQ6T,EAAQ/P,MACd,IAAK,UAGH8P,EAAWlO,EACX,MACF,IAAK,OACHkO,QAAkBE,EAAYD,EAAQhO,SACtC,MACF,QACEyF,EAAM,8BAEVA,EAAM,oBACNoI,EAASF,EAAQnO,KAAKuO,GAKxB,OAFAtI,EAAM,iBACNA,EAAM,oBAAqBoI,EAAO1T,OAC3B0T,EAAO1T,MA+ChB,SAAU8T,EAAYjO,GACpB,MAAMoW,EAAU,IAAIF,WACdG,QAAoB,IAAA/L,QAAOkD,UAAK1E,MAAMuN,aACtCnW,QAAkB,IAAAoK,QAAOkD,UAAK1E,MAAM5I,WAE1C,GAAIF,KAAWE,EACb,OAAOA,EAAUF,GACZ,GAAIA,IAAYtE,EAAMoC,IAAIlC,MAAMuI,aAKrC,OAAOiS,EACF,CAGL3Q,EAAM,mBACN,IAAIxF,SAAiBoP,EAAKiH,eAAe,CAACtW,GAAUqW,IAAc,GAGlE,OAFA5Q,EAAM,yBACCxC,EAAIsT,YAAYvW,EAASC,GACzBvE,EAAMkC,WAAW4Y,QAAQvW,IAswBpC,SAASiT,EACP1M,EACAnL,EACAkD,EACAmG,EACAyB,EACAgK,GAEA,IAEIsG,EAFA7Z,EAAM2B,EAAM5B,OAAS,EAGzB,IACE8Z,EAAU/a,EAAMgb,MAAMC,KAAKC,UACzB,CACExE,SAAU,QACVC,KAAMzV,EAAMlB,EAAMC,IAAIC,MAAMiV,UAAUxV,GAAQ,EAC9CiX,GAAI1V,GAEN,CACE2B,QACAC,QAAS,KAGb,MAAOJ,GACPqY,OAAUjb,EAIZ,IAAIgU,GAAa,IAAAxS,gBACfmT,EACI,CACE3J,gBACA0L,OAAQ7W,EAAK8B,GACbgV,WAAYzN,EACZyB,iBAEF,CAAEK,gBAAe0L,OAAQ7W,EAAK8B,GAAIgV,WAAYzN,GAClD,CAAE0N,SAAU,eAAgBqE,YAG9B,MAAO,CAAE,CAACjH,EAAWrS,IAAKqS,GAI5B,SAASsB,EACPtK,EACAkK,EACA9T,EACA+K,EACAxB,EAAgB,EAChB0Q,GAAc,GAEd,IAAIC,EAAoBpG,EAAWhU,QAAQqa,UAE3CtR,EAAM,uBAAwBiL,GAE9B,IAAIsG,EAAkBpa,EAClB6S,EAAc,GAElB,IAAK,IAAIwH,KAAaH,EAAmB,CACvC,IAAI1B,EAAQ1Z,EAAMC,IAAIC,MAAMiV,UAAUoG,GAClC7a,EAAU,CACZgW,SAAU,QACVC,KAAM2E,EAAkB5B,EAAQ,EAChC9C,GAAI0E,GAEFxH,GAAa,IAAAxS,gBACf6Z,EACI,CACErQ,gBACA0L,OAAQ+E,EAAU9Z,GAClBgV,WAAYxK,EACZxB,iBAEF,CAAEK,gBAAe0L,OAAQ+E,EAAU9Z,GAAIgV,WAAYxK,GACvDvL,GAEFqT,EAAYD,EAAWrS,IAAMqS,EAC7BwH,GAAmB5B,EAErB,OAAO3F,EAGT,SAASmF,EACPpO,EACA0Q,EACAhH,EACAD,EACAvL,EACAyB,EACAgK,GAEA,IAAIuC,GAAS,IAAA3V,iBACXoT,EACI,CACE3J,gBACA0L,OAAQgF,EAAS/Z,GACjBgV,WAAYzN,EACZyB,iBAEF,CACEK,gBACA0L,OAAQgF,EAAS/Z,GACjBgV,WAAYzN,IAYpB,OATAe,EAAM,YAAayR,EAAS/Z,IAC5BsI,EAAM,iBAAkBf,GACxBe,EAAM,aAAciN,GACpBjN,EAAM,yBAA0BwK,GAMzB,CAAEjO,OAHItG,EAAMkC,WAAWiF,KAC5BoN,EAAmB5I,KAAKqL,GAAQxV,IAAIuZ,UAKjC,SAAU5L,UACT,IAAAE,WAAU1B,OAAMiG,G,WAGT,IAAAxT,YAAW,OAAQ+O,I,cCzjClClS,EAAOD,QAAUwC,QAAQ,2C,gFCCTqP,QAAT,SAAiBN,GACtB,MAAO,CAAEhM,KAAMkZ,EAASlN,U,EAIVmN,SAAT,WACL,MAAO,CAAEnZ,KAAMoZ,I,EAIDC,SAAT,WACL,MAAO,CAAErZ,KAAMsZ,I,EAIDC,SAAT,WACL,MAAO,CAAEvZ,KAAMwZ,I,EAIDC,QAAT,WACL,MAAO,CAAEzZ,KAAM0Z,I,EAIDjO,MAAT,WACL,MAAO,CAAEzL,KAAM0L,I,EAID0B,UAAT,WACL,MAAO,CAAEpN,KAAMqN,I,EAIDsM,wBAAT,SAAiCC,GAEtC,MAAO,CACL5Z,KAAM6Z,EACND,gB,EAKYE,cAAT,SAAuBC,GAC5B,MAAO,CACL/Z,KAAMga,EACND,e,EAKYE,iBAAT,SAA0BF,GAC/B,MAAO,CACL/Z,KAAMka,EACNH,e,EAKYI,qBAAT,WACL,MAAO,CACLna,KAAMoa,I,EAKMC,cAAT,WACL,MAAO,CACLra,KAAMsa,I,EAKMC,aAAT,WACL,MAAO,CACLva,KAAMwa,IA7EH,MAAMtB,EAAUA,EAAVA,QAAU,qBAKhB,MAAME,EAAYA,EAAZA,UAAY,uBAKlB,MAAME,EAAYA,EAAZA,UAAY,uBAKlB,MAAME,EAAYA,EAAZA,UAAY,uBAKlB,MAAME,EAAWA,EAAXA,SAAW,sBAKjB,MAAMhO,EAAQA,EAARA,MAAQ,mBAKd,MAAM2B,EAAYA,EAAZA,UAAY,uBAKlB,MAAMwM,EAAWA,EAAXA,SAAW,sBASjB,MAAMG,EAAiBA,EAAjBA,eAAiB,4BAQvB,MAAME,EAAoBA,EAApBA,kBAAoB,+BAQ1B,MAAME,EAAyBA,EAAzBA,uBAAyB,oCAO/B,MAAME,EAAiBA,EAAjBA,eAAiB,4BAOvB,MAAME,EAAgBA,EAAhBA,cAAgB,4B,4MC1E7B,MAGA,O,IACA,O,IACA,O,IACA,OAEA,O,IAEA,M,IACA,M,IACA,OAEY/c,E,wJAAZ,M,mDAbA,MAAM+J,GAAQ,aAAY,2BAkBpBiT,EAAWC,GAAKA,EAEtB,SAASC,EAAmBvd,EAAMwd,EAAO9I,EAAQ3T,EAAU,KAAM5D,EAAO,MAMtE,KAAO6C,IAASwd,EAAMvd,SAASD,EAAKE,WAClC,QAAgBC,IAAZH,EAAK8B,GACP9B,EAAO0U,EAAOA,EAAO1U,EAAK8B,IAAI4P,UAAU4F,eACnC,CACL,GAAgB,OAAZvW,GAA6B,OAAT5D,EACtB,OAAO,KAET4D,EAAUA,EAAQ0W,QAAQ,WAAY,IACtCzX,EAAO2X,UAAYjZ,IAAIvB,EAAM4D,GAGjC,OAAOf,EAKT,SAASyd,EAAsBC,EAAYhJ,GACzC,IAAIiJ,EAIJ,OAAQD,EAAWxd,UACjB,IAAK,qBACHyd,EAAQD,EAAWE,aAAajF,sBAChC,MACF,IAAK,uBACHgF,EAAQD,EAAWG,SAASlF,sBAC5B,MACF,QACEvO,EAAM,uBAEV,IAAI0T,EAAUpJ,EAAOiJ,GAAOrG,WAC5B,OAAQwG,EAAQ5d,UACd,IAAK,qBACH,OAAO4d,EACT,IAAK,qBACH,OAAOA,EAAQC,MAAM1Z,KACnBrE,GACoB,uBAAlBA,EAAKE,UACkC,gBAAvCG,EAAMC,IAAIC,MAAMyd,aAAahe,IAEnC,QAEE,QAKN,SAASie,EAAgC9Y,GACvC,IACEA,QAAS+Y,EADP,aAEFC,EAFE,OAGFvZ,EAHE,WAIFwZ,EAJE,aAKFC,EALE,cAMFpZ,EANE,IAOFqZ,EAPE,QAQFC,EARE,SASFjU,EATE,cAUFa,GACEhG,EACJ,MAAO,CACLA,QAAS+Y,EACTC,eACAvZ,SACAwZ,aACAC,eACApZ,gBACAqZ,IAAKje,EAAMoT,QAAQlT,MAAMie,iBAAiBF,GAC1CC,UACAjU,WACAa,iBAOG,MAAMsT,EAAiBA,EAAjBA,eAAiB,CAC5B3c,IAAK,EACL4c,IAAK,SACLtgB,KAAM,MACN8B,SAAU,sBACVE,iBAAkB,CAChB6Z,eAAgB,YAChB0E,WAAY,YAIHC,EAAiBA,EAAjBA,eAAiB,CAC5B9c,IAAK,EACL4c,IAAK,SACLtgB,KAAM,MACN8B,SAAU,sBACVE,iBAAkB,CAChB6Z,eAAgB,kBAChB0E,WAAY,QAIHE,EAAgBA,EAAhBA,cAAgB,CAC3B/c,IAAK,EACL4c,IAAK,SACLtgB,KAAM,KACN8B,SAAU,sBACVE,iBAAkB,CAChB6Z,eAAgB,sBAChB0E,WAAY,OAIHG,EAAmBA,EAAnBA,iBAAmB,CAC9Bhd,IAAK,EACL4c,IAAK,SACLtgB,KAAM,QACN8B,SAAU,sBACVE,iBAAkB,CAChB6Z,eAAgB,gBAChB0E,WAAY,UAqBhB,MAAMxM,GAAO,IAAA5O,oBAAmB,CAC9BE,MAAOA,GAASA,EAAM0O,KAKtB1E,MAAO,CAILyG,iCAAiC,IAAAtQ,YAC/B,CAACiI,UAASrD,QAAQmE,oBAClBoS,GAASA,GAMXrK,OAAQ,CAMN1K,GAAG,IAAApG,YAAW,CAAC,QAAS,iBAAkB,CAAC8Q,EAAQC,KACjD,aACE,OACG,aAAeD,GAAQhM,IAAI,EAAEyC,EAAe4S,MAAjB,CAC5B,CAAC5S,IAAgB,aACf,OACG,aAAe4S,GAAOrV,IAAI,EAAE5G,EAAI0P,MACjC,IAAI8F,EAAa3C,EAAQxJ,GAAerJ,GAAIwV,WAC5C,GAA4B,uBAAxBA,EAAWpX,SACb,MAAO,CAAE,CAAC4B,GAAK0P,GAKjBpH,EAAM,iBAAkBtI,GACxB,IAAIkd,GAAWA,EAAXA,cAAgBxN,GAIhByN,EAAkC3H,EAAW4H,wBAC9C7d,QACAqa,UAmCH,OAlCAuD,EAAgCzd,MAGhCwd,EAASzI,UAAY,GAClBG,UAEIuI,EAAgCvW,IACjC0V,GACE1J,EAAOvJ,GAAeiT,GAAY7H,WAAa,KAKpDjH,OACC6P,GAEoB,YADlBxK,EAAQxJ,GAAegU,EAAStI,QAAQS,WACrC8H,YAKN1I,OAAOhC,EAAOvJ,GAAerJ,GAAIyU,WAAa,IAC9CjH,OAAO6P,IAGN/U,EAAM,cAAe+U,GACrB,IAAI7H,EACF3C,EAAQxJ,GAAegU,EAAStI,QAAQS,WAC1C,OACGA,EAAWuB,UACZxY,EAAMC,IAAIC,MAAMiY,iBAAiBlB,EAAWxY,SAI3C,CAAE,CAACgD,GAAKkd,WAczBK,KAAK,IAAAzb,YAAW,CAAC,gBAAiB8Q,IAChC,aACE,OACG,aAAeA,EAAO5I,iBAAiBpD,IACxC,EAAEyC,GAAiBmU,SAAUvB,OAA7B,CACE,CAAC5S,IAAD,gBAAsB4S,QAS9BpJ,QAAS,CAMP3K,GAAG,IAAApG,YAAW,CAAC,OAAQ,SAAU,CAAC8Q,EAAQC,KACxC,aACE,OACG,aAAeA,GAASjM,IAAI,EAAEyC,EAAe4S,MAAjB,CAC7B,CAAC5S,IAAgB,aACf,OACG,aAAe4S,GAAOrV,IAAI,EAAE5G,EAAI+F,MAAN,CAC3B,CAAC/F,IAAD,gBACK+F,EADL,CAEE0O,UAAW7B,EAAOvJ,GAAerJ,GAAIyU,qBAYjD8I,KAAK,IAAAzb,YACH,CAAC,SAAUiI,UAAShE,KAAKmD,SAEzB,CAAC0J,EAAQ1J,KACP,aACE,OACG,aAAe0J,GAAQhM,IAAI,EAAEyC,EAAe4S,MAAjB,CAC5B,CAAC5S,IAAgB,aACf,OACG,aAAe4S,GAAOrV,IAAI,EAAE5G,EAAIyd,MAAN,CAC3B,CAACzd,IAAD,gBACKyd,EADL,CAGEjI,WAAYK,UAAYjZ,IACtBsM,EAAQG,GAAea,KAAKuT,EAAMze,UAAU8K,IAC5C2T,EAAMxe,sBAgB1BmR,kBAAkB,IAAAtO,YAChB,CAAC,0BAA2B,WAAYiI,UAAShE,KAAKmD,SACtD,CAACgI,EAAuB0B,EAAQ1J,KACvB,aACL,OACG,cACD,aAAegI,GAAuBtK,IACpC,EAAEyC,EAAe4S,MACf,aAAcA,GACXrV,IAAI1I,GACHK,EAAMC,IAAIuZ,OAAO2F,uBACfxf,EACAmL,EACAH,EAAQG,GAAea,KACrB0I,EAAOvJ,GAAenL,EAAK8B,IAAIhB,UAC/BwJ,SACF0I,EAAsB7H,KAGzBzC,IAAI9F,IAAQA,CAAG,CAACA,EAAKd,IAAKc,SAUzCmQ,wBAAwB,IAAAnP,YACtB,CACE,yBACA,wBACAiI,UAAShE,KAAKmD,QACdpD,UAAIC,KAAK9C,UAEX,CAACmN,EAAkBwC,EAAQ1J,EAASjG,KAClC,aAAcmN,GACX5C,OACC,EAAGnE,gBAAerJ,QAEhB,uBADA4S,EAAOvJ,GAAerJ,GAAIwV,WAAWpX,UAGxCwI,IAAI,EAAGyC,gBAAerJ,SACrBsI,EAAM,SAAUtI,GAChBsI,EAAM,oBAAqBe,GAC3B,IAAIsU,GAAkB,aAAc1a,GAAUV,KAC5Cc,IACGA,EAAQF,eACTE,EAAQgG,gBAAkBA,GAC1BhG,EAAQiZ,aAAetc,GAEvB4d,GAAqB,aAAc3a,GAAUV,KAC/Cc,GACEA,EAAQF,eACRE,EAAQgG,gBAAkBA,GAC1BhG,EAAQiZ,aAAetc,GAEvB6d,EAAsBF,EACtBA,EAAgBE,yBAChBxf,EACJ,MAAO,CACLyf,aAAclL,EAAOvJ,GAAerJ,GAAIwV,WACxCnM,gBACAwU,sBAEArV,SACEU,EAAQG,GAAea,KAAK0I,EAAOvJ,GAAerJ,GAAIhB,UACnDwJ,SAELgU,KAAMmB,GAAmB,IAAInB,IAC7BmB,kBACAC,yBASV1M,uBAAuB,IAAApP,YACrB,CAAC,mBAAoB,0BACrB,CAAC8Q,EAAQxC,KACP,aACE,OACG,aAAewC,GAAQhM,IAAI,EAAEyC,EAAe4S,MAAjB,CAC5B,CAAC5S,IAAgB,aACf,MACG+G,EAAiBxJ,IAClB,EAAGyC,cAAe0U,EAAsB/d,QACtC+d,IAAyB1U,EACrB,CAAE,CAACrJ,GAAKic,EAAMjc,GAAIwV,YAClB,UAUlBoD,aAAa,IAAA9W,YACX,CAAC,oBAAqB,oBACtB,CAACiR,EAAalQ,IACZ,GACG+R,WACI,cACA7B,EAAYiL,UAAUnb,IAAY,CAAEob,OAAQ,KAAMA,QACnDrX,IAAI,EAAGsX,oBAAoB,aAAcA,KAE5C1Q,OAAOiF,QAAqBpU,IAAboU,EAAKnV,MAO3B4b,aAAa,IAAApX,YAAW,CAACgE,UAAI5D,YAAYkE,QAAQE,OAAQA,GACvDA,EAAM6X,OAAOC,YAQfrb,WAAW,IAAAjB,YAAW,CAACgE,UAAIY,QAAQuB,MAAMlF,WAAYA,IACnD,aACE,OACG,aAAeA,GAAW6D,IAAI,EAAE/D,GAAWC,cAAb,CAC/B,CAACD,GAAUtE,EAAMkC,WAAW4Y,QAAQvW,QAc1CG,UAAU,IAAAnB,YAAW,CAACgE,UAAIC,KAAK9C,UAAWA,IACxC,aACE,OACG,aAAcA,GACduK,OAAOnK,IAAYA,EAAQF,eAC3ByD,IAAIvD,IAAWA,CACd,CAACA,EAAQiZ,YAAaH,EAAgC9Y,SAShE0C,KAAM,CAIJ6M,QAAQ,IAAA9Q,YAAW,CAAC,UAAWH,GAASA,EAAMoE,KAAK6M,QAKnDtC,YAAa,CAIXjP,SAAS,IAAAS,YAAW,CAAC,UAAWH,GAASA,EAAMoE,KAAKuK,YAAYjP,SAKhEM,OAAO,IAAAG,YAAW,CAAC,UAAWH,GAASA,EAAMoE,KAAKuK,YAAY3O,OAK9DR,QAAQ,IAAAW,YAAW,CAAC,UAAWH,GAASA,EAAMoE,KAAKuK,YAAYnP,QAK/Dqb,KAAK,IAAA1a,YAAW,CAAC,UAAWH,GAASA,EAAMoE,KAAKuK,YAAYkM,KAK5D6B,UAAU,IAAAvc,YAAW,CAAC,UAAWH,GAASA,EAAMoE,KAAKuK,YAAY+N,WAMnEjO,kBAAkB,IAAAtO,YAChB,CAAC,UACDH,GAASA,EAAMoE,KAAKqK,mBAOxBxO,KAAM,CAIJ0Q,aAAa,IAAAxQ,YACX,CAAC,UACDH,GAASA,EAAMC,KAAK0Q,aAQtBS,aAAa,IAAAjR,YAAW,CAAC,UAAWH,GAASA,EAAMC,KAAKmR,aAOxDuL,cAAc,IAAAxc,YACZ,CAAC,iBACDiR,GAAeA,EAAYwL,kBAO/B7X,QAAS,CAIP/E,MAAO,CAILP,OAAO,IAAAU,YACL,CAACgE,UAAIY,QAAQ/E,MAAMP,OAEnB6W,IAAUA,GAAS,IAAIrR,IAAI4X,GAAQjgB,EAAMkC,WAAW4Y,QAAQmF,KAM9Drd,QAAQ,IAAAW,YACN,CAACgE,UAAIY,QAAQ/E,MAAMR,QAEnB8W,GAAS1Z,EAAMkC,WAAW4Y,QAAQpB,EAAMlT,KAAK,MAM/CsD,MAAM,IAAAvG,YAAW,CAACgE,UAAIY,QAAQrD,SAAU,EAAGP,YACzCvE,EAAMkC,WAAW4Y,QAAQvW,IAM3Bub,UAAU,IAAAvc,YACR,CAACgE,UAAIY,QAAQxK,MAEb,EAAGmU,UAAW9R,EAAMkC,WAAW4Y,QAAQhJ,IAMzChP,SAAS,IAAAS,YACP,CAACgE,UAAIY,QAAQuB,MAAM5G,SAEnBod,IACE,aACE,OACG,aAAeA,GAAS7X,IAAI,EAAE/D,EAAS2b,MAAX,CAC7B,CAAE,KAAI3b,GAAYtE,EAAMkC,WAAW4Y,QAAQmF,QAWnDE,UAAU,IAAA5c,YACR,CAAC,mBAAoBgE,UAAIY,QAAQxK,KAAM4J,UAAI5D,YAAYkE,SACvD,CAACvD,GAAW8b,SAAQ3hB,UAAWqJ,KAAIC,YAAnC,cACEsY,KAAMrgB,EAAMkC,WAAW4Y,QAAQxW,GAE/B8b,OAAQpgB,EAAMkC,WAAW4Y,QAAQsF,GAEjC3hB,MAAOuB,EAAMkC,WAAW4Y,QAAQrc,KAG7B,aACD,OACG,aAAeqJ,GAAIO,IAAI,EAAEyW,EAAUrgB,MAAZ,CACxB,CAACqgB,GAAW9e,EAAMkC,WAAW4Y,QAAQrc,QAItC,aACD,OACG,aAAesJ,GAAOM,IAAI,EAAEyW,EAAUrgB,MAAZ,CAC3B,CAACqgB,GAAW9e,EAAMkC,WAAW4Y,QAAQrc,UAU/CqM,eAAe,IAAAvH,YACb,CAACgE,UAAIY,QAAQrD,SACb,EAAGgG,mBAAoBA,GAMzBrK,UAAU,IAAA8C,YAAW,CAACiI,UAASrD,QAAQuC,QAAS,EAAGjJ,QAASA,GAK5D3E,MAAM,IAAAyG,YAAW,CAACiI,UAASrD,QAAQuC,QAAS,EAAGa,SAAUA,GAKzD8I,OAAQ,CAON1K,GAAG,IAAApG,YACD,CAAC,gBAAiB,oBAClB,CAAC8Q,EAAQvJ,IAAkBuJ,EAAOvJ,IASpCwJ,SAAS,IAAA/Q,YACP,CAAC,wBAAyB,oBAC1B,CAAC8Q,EAAQvJ,IAAkBuJ,EAAOvJ,KAOtC6H,uBAAuB,IAAApP,YACrB,CAAC,+BAAgC,mBACjC,CAAC8Q,EAAQvJ,IAAkBuJ,EAAOvJ,IAMpCiH,YAAa,CAUX3O,OAAO,IAAAG,YACL,CACE,0BACA,0BACA,mBACAgE,UAAIY,QAAQrD,SAEd,CACEwb,EACAzO,EACA/G,GACElG,oBAEF,MAAMmN,EAAcjH,EAChBwV,EAAexV,GACf,GAEJ,IAAIyV,GAAyB,aAC3B,OACG,aAAexO,GAAa1J,IAAI,EAAE5G,EAAIoV,MAAN,CACjC,CAACpV,GAAK,CACJqV,QAASD,EAAWC,QAAQzO,IAAI6R,IAAUA,EAAVA,cAAgBA,SAMtD,GAAItV,EAEF,IAAK,MAAMnD,KAAM8e,EAAwB,CACvC,MAAM1J,EAAa0J,EAAuB9e,GAG1C,IAAI6J,EAAQ,EAAItL,EAAMoC,IAAIlC,MAAMmC,UAChC,IAAK,MAAM6X,KAAUrD,EAAWC,QAGA,SAA5BoD,EAAOxZ,QAAQgW,UACa,YAA5BwD,EAAOxZ,QAAQgW,WAGfwD,EAAOxZ,QAAU,CACfgW,SAAU,SACVpL,QACArK,OAAQjB,EAAMoC,IAAIlC,MAAMmC,WAE1BiJ,GAAStL,EAAMoC,IAAIlC,MAAMmC,WAOjC,OAAO,aACL,OACG,aAAeke,GAAwBlY,IACxC,EAAE5G,EAAIoV,MAAN,CACE,CAACpV,GAAK,CACJqV,SAAS,aACP,MACGD,EAAWC,QAAQzO,IAAI4R,IAAoBA,CAC5C,CAACA,EAAiBhD,WAAWxV,IAAKwY,cAcpDhQ,UAAU,IAAA1G,YAAW,CAACgE,UAAIY,QAAQrD,SAAU,EAAGmF,cAAeA,GAK9D2L,qBAAqB,IAAArS,YACnB,CAAC,cACD0G,QACenK,IAAbmK,GACAC,UAAOC,UAAUF,EAASG,QAAS,UAAW,CAC5CC,mBAAmB,KAOzB1K,MAAM,IAAA4D,YAAW,CAACiI,UAASrD,QAAQxI,MAAOqd,GAK1Ctc,SAAS,IAAA6C,YAAW,CAACiI,UAASrD,QAAQzH,SAAUsc,GAMhD7L,OAAO,IAAA5N,YAAW,CAAC,UAAWyZ,GAO9BwD,UAAU,IAAAjd,YACR,CAAC,SAAU,mBAAoB,YAAa,UAC5C,CAAC5D,EAAM0U,EAAQ3T,EAAS5D,IAGfogB,EAAmBvd,EAFZ,CAAC,qBAAsB,cAEE0U,EAAQ3T,EAAS5D,IAQ5D2jB,UAAU,IAAAld,YACR,CAAC,SAAU,mBAAoB,YAAa,UAC5C,CAAC5D,EAAM0U,EAAQ3T,EAAS5D,IAQfogB,EAAmBvd,EAPZ,CACZ,qBACA,qBACA,qBACA,cAGqC0U,EAAQ3T,EAAS5D,IAO5D2X,YAAY,IAAAlR,YACV,CAAC,cACD5D,GAAQA,GAA0B,uBAAlBA,EAAKE,UAMvB6U,sBAAsB,IAAAnR,YACpB,CAAC,cACD5D,GACEA,IACmB,uBAAlBA,EAAKE,UACc,uBAAlBF,EAAKE,WAOXoM,eAAe,IAAA1I,YAAW,CAACiI,UAASrD,QAAQ8D,eAAgB+Q,GAM5DvS,eAAe,IAAAlH,YAAW,CAACiI,UAASrD,QAAQsC,eAAgBuS,GAQ5D1Y,SAAS,IAAAf,YAAW,CAACgE,UAAIY,QAAQxK,MAAOA,GAAQA,EAAK+K,gBAKrD6D,2BAA2B,IAAAhJ,YACzB,CAACiI,UAASrD,QAAQoE,2BAClBxB,GAAaA,GAMfjG,SAAS,IAAAvB,YAAW,CAACgE,UAAIY,QAAQrD,SAAU8Y,GAe3CjJ,eAAe,IAAApR,YACb,CACE,SACA,uBACA,0BACA,aACA,2BACAgE,UAAIY,QAAQtE,KAAKkF,iBAEnB,CAACpJ,EAAM0d,EAAYla,EAAOW,EAAM4c,EAAgB3X,KAM9C,GACEA,IACCpJ,QACWG,IAAZH,EAAK8B,KACJqC,QACWhE,IAAZgE,EAAKrC,KACJ4b,QACiBvd,IAAlBud,EAAW5b,KACVif,QACqB5gB,IAAtB4gB,EAAejf,GAEf,OAAO,EAMT,GAA4B,eAAxB4b,EAAWxd,SACb,OAAO,EAIT,GACoB,uBAAlBiE,EAAKjE,UACa,uBAAlBiE,EAAKjE,SAEL,OAAO,EAIT,GAC8B,eAA5B6gB,EAAe7gB,UACf6gB,EAAejf,KAAO4b,EAAW5b,GAEjC,OAAO,EAKT,QAAc3B,IAAVqD,EACF,OAAO,EAET,IAAIwd,EAAWtD,EAAW1E,UAAUxV,GACpC,KAAyB,mBAAlBwd,EAASjI,MAA2B,CACzC,GAAI/Y,EAAK8B,KAAOkf,EAASlf,GACvB,OAAO,EAETkf,EAAWA,EAAShI,UAAU,GAEhC,OAAOhZ,EAAK8B,KAAOkf,EAASlf,KAOhCmf,oBAAoB,IAAArd,YAClB,CAAC,SAAU,oBACX,CAAC5D,EAAM0U,IAOE6I,EAAmBvd,EANZ,CACZ,qBACA,uBACA,cAGqC0U,IAS3CU,uBAAuB,IAAAxR,YACrB,CAAC,WAAY,SAAU,wBACvB,CAAC8Q,EAAQ1U,EAAM0d,KACb,IAAKA,GAAsC,eAAxBA,EAAWxd,SAC5B,OAGF,IAAIa,EAAU2T,EAAO1U,EAAK8B,IAAIf,QAC1BmgB,EAAoBxM,EAAOgJ,EAAW5b,IAAIf,QAG1CogB,EAAapgB,EAAQM,MAAM6f,EAAkB5f,QACjD8I,EAAM,gBAAiB+W,GACvB,IAAIC,EAAWD,EAAWE,MAAM,uBAGhC,OADAjX,EAAM,cAAegX,GACJ,OAAbA,EAGGxa,SAASwa,EAAS,SAHzB,IAYJlM,sBAAsB,IAAAtR,YACpB,CAAC,uBAAwB,oBACzB,CAAC8Z,EAAYhJ,KACX,GAAKgJ,GAAsC,eAAxBA,EAAWxd,SAI9B,OAAOud,EAAsBC,EAAYhJ,KAO7C4M,YAAa,CAOXtX,GAAG,IAAApG,YACD,CACE,0BACA,gBACA,mBACA,qBAGF,CAAC8Q,EAAQlD,EAAOzQ,EAASD,KACvB,IAAIyV,EAAY,GAChB,QAAcpW,IAAVqR,EAAqB,CACvB,IAAI+P,OACWphB,IAAbqR,EAAM1P,GAAmB0P,EAAM1P,IAAK,IAAAjB,UAASC,EAAUC,GAEzD,KAAe,OAARwgB,GAAgB7M,EAAO6M,KAC5BhL,GAAY,aACVA,MACI7B,EAAO6M,GAAKhL,WAAa,IAC1BjH,OAAO6P,GAA8B,KAAlBA,EAAS/gB,MAC5BkR,OAAO6P,GAAwChf,MAA5BoW,EAAU4I,EAAS/gB,OACtCsK,IAAIyW,IAAYA,CACf,CAACA,EAAS/gB,MAAO,CAAEyY,OAAQsI,EAAStI,YAQF,0BAApCnC,EAAO6M,GAAKjK,WAAWpX,WAMzBqhB,OAD2BphB,IAAzBuU,EAAO6M,GAAK7P,SACRgD,EAAO6M,GAAK7P,SAMZ6P,EAAI9J,QAAQ,mBAAoB,IAa5C,OACEjG,IACCA,EAAMtR,SAASkG,WAAW,QACN,mBAAnBoL,EAAMtR,UAGDqW,GAGT,gBAAYA,EAjBG,CACbiL,IAAK,CAAEC,QAAS,OAChBtZ,GAAI,CAAEsZ,QAAS,MACfrZ,MAAO,CAAEqZ,QAAS,SAClBf,KAAM,CAAEe,QAAS,QACjBC,IAAK,CAAED,QAAS,WAmBtBE,YAAa,CAIX3X,GAAG,IAAApG,YACD,CAAC,0BAA2B,OAAQ,UAEpC,CAAC8Q,EAAQ4M,EAAaM,KACpB,IAAIrL,GAAY,aACd,OACG,aAAe+K,GAAa5Y,IAAI,EAAEmZ,EAAY1C,MAC/C,QAAwBhf,IAApBgf,EAAStI,OAAsB,CACjC,IAAI,WAAES,GAAe5C,EAAOyK,EAAStI,QACrC,MAAO,CAAE,CAACgL,GAAavK,GAIvB,MAAO,MAITwK,EAAW,CACbN,IAAK5C,EACLzW,GAAI0W,EACJzW,MAAO0W,EACP4C,IAAKjD,GAMP,OAHImD,IACFE,EAASpB,KAAOkB,IAElB,gBAAYrL,EAAcuL,KAS9BpB,MAAM,IAAA9c,YACJ,CAAC,qBACDgc,IACEA,UAA0C,uBAA1BA,EAAa1f,UApgCZie,EAsgCXyB,EAAaxhB,KAtgCYggB,EAugCzBwB,EAAa9d,GAvgCwBuc,EAwgCrCuB,EAAavB,aAngCtB,CACLvc,IAAK,EACL4c,IAAK,SACLtgB,KAAM,OACN8B,SAAU,sBACVE,iBAAkB,CAChB6Z,eAAgB,eAVAkE,EAAa1G,QAAQ,MAAO,KAAKhT,OAAO,IAUP,KAAO2Z,EACxDO,WAAYN,EAAe,IAAMF,KA8/BvB,KA1gChB,IAA6BA,EAAcC,EAAYC,KAmhCjD0D,MAAM,IAAAne,YACJ,CACE,oBACA,MACA,yBACA,yBACA,yBACA,sBACA,oBAGF,CACEwQ,EACAkN,EACAnW,EACA9B,EACAyB,EACAgK,EACAnQ,KAEA,aACE,OACG,aAAe2c,GAAa5Y,IAC7B,EAAEmZ,GAAchL,SAAQ4K,eACtB,IAAI3f,EAKJ,GAJAsI,EAAM,aAAcyM,GACpBzM,EAAM,cAAeqX,QAGNthB,IAAX0W,EAAsB,CAKxB/U,KAFGsS,EAAYtI,gBAAgBX,IAAkB,IAC5CmU,UAAY,IACYzI,IAAW,IAAIxS,KAC1C2d,GAAU5N,EAAYpI,KAAKgW,GAAQrd,UAAYA,GAEjDyF,EAAM,sBAAuBtI,QAGlB3B,IAAP2B,IAGAA,EADEgT,GACG,IAAApT,iBAAgB,CACnBmV,SACA1L,gBACA2L,WAAYzN,EACZyB,mBAGG,IAAApJ,iBAAgB,CACnBmV,SACA1L,gBACA2L,WAAYzN,KAIlBe,EAAM,qBAAsBtI,QAK5BsI,EAAM,cAAeqX,GACrB3f,EAAKsS,EAAY6N,UAAUR,GAAS,GAItCrX,EAAM,SAAUtI,GAEhB,IAAI,IAAED,GAAQuS,EAAYpI,KAAKlK,IAAO,GACtC,GAAKD,EAIL,MAAO,CACL,CAACggB,GAAahgB,QAW5B6H,cAAc,IAAA9F,YACZ,CAACgE,UAAIY,QAAQtE,KAAKwF,cAClBrB,GAAsB,OAAXA,OAAkBlI,EAAYkI,GAM3CgK,kBAAkB,IAAAzO,YAChB,CAACgE,UAAIY,QAAQxK,KAAM,mBAAoB,8BACvC,EACImU,KAAMgO,IACNhb,UAASF,kBACTid,yBAAwBC,0BAE1B,GAAIld,EAAe,CAEjB,IAAIiS,EAAagL,EAAuB/c,GACxC,OAAK+R,EAGEA,EAAWkL,OAFT,KAGJ,CAEL,IAAIC,EAAWlC,EAAS9e,MAAM,EAAG,IACjC+I,EAAM,eAAgBiY,GACtBjY,EAAM,iBAAkB+X,EAAoBhd,IAC5C,IAAI+R,GAAciL,EAAoBhd,IAAY,IAAIkd,GACtD,OAAKnL,EAGEA,EAAWkL,OAFT,SAWjBje,KAAM,CAMJV,MAAO,CAILP,OAAO,IAAAU,YACL,CAACgE,UAAIzD,KAAKV,MAAMP,OAEhB6W,IAAUA,GAAS,IAAIrR,IAAI4X,GAAQjgB,EAAMkC,WAAW4Y,QAAQmF,KAS9DgC,YAAY,IAAA1e,YAAW,CAACgE,UAAIY,QAAQtE,KAAK2F,aAAcsI,GACrD9R,EAAMkC,WAAW4Y,QAAQhJ,KAW7BnS,MAAM,IAAA4D,YAAW,CAACiI,UAAS1H,KAAKnE,MAAOqd,GAKvCtc,SAAS,IAAA6C,YAAW,CAACiI,UAAS1H,KAAKpD,SAAUsc,GAO7C4D,oBAAoB,IAAArd,YAClB,CAAC,SAAU,0BAA2BgE,UAAIY,QAAQtE,KAAKkF,iBACvD,CAACpJ,EAAM0U,EAAQ6N,KAIb,GAAIA,EACF,OAQF,OAAOhF,EAAmBvd,EANZ,CACZ,qBACA,uBACA,cAGqC0U,KAO3CQ,sBAAsB,IAAAtR,YACpB,CACE,uBACA,0BACAgE,UAAIY,QAAQtE,KAAKkF,iBAEnB,CAACsU,EAAYhJ,EAAQ6N,KACnB,IAAIA,GAAY7E,GAAsC,eAAxBA,EAAWxd,SAIzC,OAAOud,EAAsBC,EAAYhJ,MAS/ClH,WAAY,CAQV/J,MAAO,CAILP,OAAO,IAAAU,YACL,CAACiI,UAASrD,QAAQgF,YAElBtJ,KACIA,GAAQ,IAAIhB,OAAS,IAAIwF,IAAI4X,GAAQjgB,EAAMkC,WAAW4Y,QAAQmF,OAQxElc,gBAAiB,CAOfX,MAAO,CAILP,OAAO,IAAAU,YACL,CAACN,UAAMc,iBAEPF,GACEA,GACKA,EAAKhB,OAAS,IAAIwF,IAAI4X,GAAQjgB,EAAMkC,WAAW4Y,QAAQmF,IACxD,U,UAMCnO,G,gGC76Cf,MAGA,O,IAEA,M,IACA,O,IAEA,O,IACA,OACA,OACY9R,E,wJAAZ,M,mDAVA,MAAM+J,GAAQ,aAAY,iCAYpBiT,EAAYC,GAAMA,EAExB,SAASkF,EAAe/Z,EAAWsO,EAAU1O,EAAQoa,GAEnD,IAAIC,EAAYja,EAAUC,IAAKia,GAAUA,EAAMC,oBAE/CF,EAAUG,QACVH,EAAUI,KAAK/L,GACf3M,EAAM,gBAAiBsY,GACvB,MAAMK,EAAQta,EAAUC,IAAI,EAAGsa,eAAc7E,eAAcxZ,cAA/B,CAC1Bqe,eACA7E,eACAxZ,aAEFyF,EAAM,YAAa2Y,GACnB,IAAIE,GAAS,aAAQP,EAAWK,EAAO,CAAChM,EAAUmM,KAAX,gBAClCA,EADkC,CAErCnM,cAUF,OANe,OAAX1O,IACF4a,EAAOA,EAAO3hB,OAAS,GAAG+G,OAASA,QAErBlI,IAAZsiB,IACFQ,EAAO,GAAGR,QAAUA,GAEfQ,EAGT,SAAStY,EAAyBC,GAChC,MAAO,CAILmM,SAAU,CAIRhM,QAAQ,IAAAnH,YAAW,CAACgH,EAAaG,QAASsS,GAI1ChS,aAAa,IAAAzH,YAAW,CAACgH,EAAaS,aAAcgS,GAIpDrd,MAAM,IAAA4D,YAAW,CAACgH,EAAa5K,MAAOqd,GAItCtc,SAAS,IAAA6C,YAAW,CAACgH,EAAa7J,SAAUsc,IAM9C8F,kBAAkB,IAAAvf,YAChB,CAAC,oBAAqB,0BACtB,EAAG9B,KAAIqJ,gBAAeiY,cAAc/X,KAApC,CACEN,OAAQ,CAAEjJ,KAAIqJ,gBAAeiY,cAC7B/X,iBAWJuU,cAAc,IAAAhc,YACZ,CAAC,oBAAqB,sBACtB,EAAGgI,OAAO7K,IACRA,EACI4W,UAAYjZ,IACVkN,EACA7K,EAAQ0W,QAAQ,gBAAiB,KAEnC7L,IAKZ,IAAIyX,GAAa,IAAA9f,oBAAmB,CAIlCE,MAAQA,GAAUA,EAAM4f,WAKxB7a,uBAIEC,WAAW,IAAA7E,YAAW,CAAC,UAAYH,GAAUA,EAAMC,KAAK+E,WAKxD6a,eAAe,IAAA1f,YAAW,CAAC,UAAYH,GAAUA,EAAMC,KAAK4f,eAK5DC,cAAc,IAAA3f,YAAW,CAAC,UAAYH,GAAUA,EAAMC,KAAK6f,cAK3DC,qBAAqB,IAAA5f,YACnB,CAAC,UACAH,GAAUA,EAAMC,KAAK8f,qBAMxBC,mBAAmB,IAAA7f,YACjB,CAAC,UACAH,GAAUA,EAAMC,KAAK+f,oBAGrB9Y,EAAyBkB,UAASrD,SAhCvC,CAqCEkb,YAAY,IAAA9f,YACV,CAACiI,UAASrD,QAAQ0E,SAAUrB,UAASrD,QAAQ2E,eAC7C,CAACD,EAAUC,IAAkBD,GAA8B,MAAlBC,GAM3CwW,aAAa,IAAA/f,YACX,CAACiI,UAASrD,QAAQ0E,SAAUrB,UAASrD,QAAQ2E,eAC7C,CAACD,EAAUC,IAAkBD,GAA8B,MAAlBC,GAO3CE,UAAU,IAAAzJ,YAAW,CAACiI,UAASrD,QAAQ6E,UAAWgQ,GAKlDlY,SAAS,IAAAvB,YAAW,CAACgE,UAAIY,QAAQrD,SAAUkY,GAK3C1V,aAAa,IAAA/D,YAAW,CAACgE,UAAIY,QAAQtE,KAAKyD,aAAc0V,GAKxD9P,YAAY,IAAA3J,YAAW,CAACiI,UAASrD,QAAQ+E,YAAa8P,GAKtD3T,cAAc,IAAA9F,YAAW,CAACgE,UAAIY,QAAQtE,KAAKwF,cAAe2T,GAO1D1Y,SAAS,IAAAf,YAAW,CAACgE,UAAIY,QAAQxK,MAAQA,GAASA,EAAK+K,gBAWvDvC,aAAa,IAAA5C,YACX,CACEgE,UAAIY,QAAQtE,KAAKqB,OACjBqC,UAAIY,QAAQtE,KAAK0B,SACjBgC,UAAIY,QAAQtE,KAAKsC,YACjBoB,UAAIY,QAAQtE,KAAK0E,gBAEnB,CAACrD,EAAQK,EAAUY,EAAaoC,IAC1BrD,EACKiB,EACEZ,EACLgD,IAAmBvI,EAAMoC,IAAIlC,MAAMuI,aAC9BF,OAEP,EAGK,MAWbgb,cAAc,IAAAhgB,YACZ,CAACgE,UAAIY,QAAQtE,KAAK2F,aACjBga,IACC,IAAIC,EAAkBzjB,EAAM0jB,aAC1B1jB,EAAMkC,WAAW4Y,QAAQ0I,IAE3B,GAC6B,IAA3BC,EAAgBxiB,QACY,WAA5BwiB,EAAgB,GAAG/K,KACnB,CACA,IAAIiL,EAAmBF,EAAgB,GAAG9K,UAAU,GAAGla,MAAMA,MAC7D,OAAQklB,EAAiBjL,MACvB,IAAK,QACH,OAAOiL,EAAiBC,SAC1B,IAAK,YAGH,OAAOC,OAAOlN,KACZgN,EAAiBG,MAAM9iB,MAAM,GAC7B,OACA6e,eAWZkE,oBAAoB,IAAAxgB,YAClB,CAAC,iBAAkB,oBAAqB,kBACxC,CAACygB,EAAcC,EAAiBC,KAC9B,IAAIC,OAC4BrkB,IAA9BmkB,EAAgBvZ,OAAOjJ,GACnBwiB,EACAC,EACN,OACErf,QAAQsf,IACRtf,QAAQmf,EAAatZ,cACM5K,IAA3BkkB,EAAatZ,OAAOjJ,KACnBuiB,EAAatZ,OAAOI,gBACnBqZ,EAAYzZ,OAAOI,eACnBkZ,EAAatZ,OAAOjJ,KAAO0iB,EAAYzZ,OAAOjJ,IAC9CuiB,EAAahZ,YAAYM,QAAU6Y,EAAYnZ,YAAYM,OAC3D0Y,EAAahZ,YAAY/J,SAAWkjB,EAAYnZ,YAAY/J,UAUpEmjB,aAAa,IAAA7gB,YACX,CACE,cACA,wBACA,sBACA,kBAEF4e,GAUFS,QAAQ,IAAArf,YACN,CACE,cACA,kBACA,iBACA,6BAEF,CAAC6E,EAAW6a,EAAeC,EAAce,IACvC9B,GACE,IAAAxhB,WACEyH,EACA6a,EACCX,GAAyB,aAAfA,EAAM/f,MAEnB0hB,GAAmBf,EACnB,UACApjB,MAQRgE,sBACKwG,EAAyBkB,UAAS1H,S,UAI1Bkf,G,2GCzUf,MAGA,O,IAEA,M,IACA,M,IACA,O,mDANA,MAAMjZ,GAAQ,aAAY,8BAQpBsa,GAAU,IAAAnhB,oBAAmB,CAIjCE,MAAOA,GAASA,EAAMihB,QAKtB7c,KAAM,CAIJ8c,mBAAmB,IAAA/gB,YACjB,CAACgE,UAAIY,QAAQuB,MAAMlF,UAAW+C,UAAIC,KAAK9C,SAAU8G,UAAShE,KAAKmD,SAE/D,CAACnG,EAAWE,EAAUiG,KACpB,aACE,OACG,aAAenG,GAAW6D,IAC3B,EAAE/D,GAAWQ,QAASH,EAAWJ,cAC/BwF,EAAM,eAAgBvF,GACtBuF,EAAM,cAAerF,GACrB,IAAII,EAAUJ,EAASC,GACvB,IAAKG,EACH,MAAO,CAAE,CAACR,GAAU,CAAEC,WAExB,IAAI,aAAEuZ,EAAF,cAAgBhT,EAAhB,cAA+ByZ,GAAkBzf,EAWrD,OATAiF,EAAM,oBAAqBwa,GAC3Bxa,EAAM,oBAAqBe,GAC3Bf,EAAM,cAAeY,GAOd,CACL,CAACrG,GAAU,CACTwZ,eACApT,YAPgB5K,IAAlBykB,EACI5Z,EAAQG,GAAea,KAAK4Y,QAC5BzkB,EAMFyE,gBAYhBZ,YAAa,CAKXgG,GAAG,IAAApG,YAAW,CAAC,UAAWH,GAASA,EAAMO,aAMzC4M,SAAS,IAAAhN,YAAW,CAAC,UAAWH,GAASA,EAAMmN,SAM/CxI,OAAO,IAAAxE,YAAW,CAAC,UAAWH,GAASA,EAAM2E,QAM/CC,OAAQ,CAINwc,cAAc,IAAAjhB,YAAW,CAAC,UAAWH,GAASA,EAAMyM,OAKpDA,OAAO,IAAAtM,YACL,CAAC,iBAAkB,aACnB,CAACihB,EAAc9hB,IAAU8hB,IAAiB9hB,GAM5C+hB,SAAS,IAAAlhB,YAAW,CAAC,UAAWH,IAAUA,EAAMyM,OAKhDnN,OAAO,IAAAa,YAAW,CAAC,UAAWH,GAASA,EAAMshB,kBAK7CC,SAAS,IAAAphB,YAAW,CAAC,WAAYb,GAAmB,OAAVA,GAK1CkiB,SAAS,IAAArhB,YAAW,CAAC,WAAYb,GAAmB,OAAVA,GAK1CmiB,SAAS,IAAAthB,YACP,CAAC,iBAAkB,aACnB,CAACihB,EAAc9hB,IAAU8hB,GAAgB9hB,GAM3CY,QAAQ,IAAAC,YAAW,CAACN,UAAMK,QAASA,GAAUA,GAK7CwhB,WAAW,IAAAvhB,YAAW,CAAC,UAAWH,GAASA,EAAM0hB,c,UAItCT,G,wGC1HEU,WAAV,UAAqBjgB,GAE1B,MAAM+Y,EACJ/Y,EAAQA,UAAW,IAAA1D,WAAU,CAAEmB,KAAM,SAAU9D,MAAOqG,EAAQP,SAOhE,OAHAwF,EAAM,aAAcjF,SACd,IAAA2J,KAAIC,EAAQqW,YAAR,gBAAwBjgB,EAAxB,CAAiCA,QAAS+Y,MAE7CA,G,EASQhD,YAAV,UAAsBvW,EAASC,GACpC,MACMO,SADe,IAAA8J,QAAOrH,UAAIC,KAAKE,SAASjD,SACvBF,GAKvB,aAFM,IAAAkK,KAAIC,EAAQmM,YAAYvW,EAASQ,EAASP,IAEzCO,G,EAMQkgB,iBAAV,YACL,MAAMxgB,QAAkB,IAAAoK,QAAOrH,UAAIY,QAAQuB,MAAMlF,WACjD,IAAK,IAAKF,GAAS,OAAEC,MAAa,aAAeC,GAAY,CAC3D,MACMM,SADe,IAAA8J,QAAOrH,UAAIC,KAAKE,SAASjD,SACvBF,SACjB,IAAAkK,KAAIC,EAAQmM,YAAYvW,EAASQ,EAASP,M,EAInC0gB,MAAV,WAAgB,QACrB3gB,EADqB,OAErBC,EAFqB,KAGrBuN,EAHqB,eAIrBpJ,EAJqB,OAKrBV,EALqB,OAMrBoY,EANqB,MAOrB3hB,EAPqB,SAQrBymB,EARqB,MASrBnd,UAEM,IAAA0G,KAAIC,EAAQyW,YAAY/E,EAAQ8E,EAAUnd,UAC1C,IAAA0G,KAAIC,EAAQ0W,WAAWpd,IAC7B+B,EAAM,kBAAmB,IAAA6E,QAAOrH,UAAIY,QAAQuB,QACxCpF,QACI,IAAAmK,KAAIC,EAAQ/Q,KAAK2G,EAASwN,EAAMpJ,EAAgB0X,EAAQ3hB,UAExD,IAAAgQ,KAAIC,EAAQ5P,OAAOyF,EAAQmE,EAAgB0X,EAAQ3hB,K,EAiB5C4mB,wB,EA4EArX,MAAV,YACL,IAAI/F,QAAoB,IAAA2G,QAAOrH,UAAI5D,YAAYsE,mBACzC,IAAAwG,KAAIC,EAAQV,eACZ,IAAAS,KAAIxG,I,EAGKiH,OAAV,kBACC,IAAAT,KAAIC,EAAQR,sB,EAGHiB,OAnLjB,I,IAAA,MAGA,OACA,OAEA,QACYT,E,EAAZ,O,IAEA,MAEYzL,E,EAAZ,O,4MAVA,MAAM8G,GAAQ,aAAY,sBA+E1B,SAAU6J,IACR7J,EAAM,kBAECsb,UACApiB,EAAM8L,2BASR,SAAUsW,IACf,SAAU,IAAAzW,QAAOrH,UAAIY,QAAQtE,KAAKuF,sBAGhCW,EAAM,2BAEA,IAAA0E,KAAIC,EAAQ4W,aACb,SAAU,IAAA1W,QAAOrH,UAAIY,QAAQtE,KAAK+E,6BAOlC,SAAU,IAAAgG,QAAOrH,UAAIY,QAAQtE,KAAKqB,QAAS,CAChD6E,EAAM,YAEN,IAAIzF,QAAgB,IAAAsK,QAAOrH,UAAIY,QAAQtE,KAAKsC,aACxC2L,QAAa,IAAAlD,QAAOrH,UAAIY,QAAQtE,KAAK8C,UAIzC,GAFAoD,EAAM,qBAAsBzF,SAElB,IAAAsK,QAAOrH,UAAIY,QAAQtE,KAAKwB,sBAAuB,CAEvD,IAAI,eAAEqD,EAAF,OAAkB0X,EAAlB,MAA0B3hB,SAAgB,IAAAmQ,QAAOrH,UAAIY,QAAQxK,YAC3D,IAAA8Q,KAAIC,EAAQ/Q,KAAK2G,EAASwN,EAAMpJ,EAAgB0X,EAAQ3hB,QACzD,CAEL,IAAI8mB,QAAoB,IAAA3W,QAAOrH,UAAIY,QAAQxK,MACvC+K,SAAwB,IAAAkG,QAAOrH,UAAIY,QAAQtE,KAAKuB,sBAChDmgB,EAAY7c,eACZpE,EACA8b,EAASmF,EAAY7c,eACrBjK,QAAc,IAAAmQ,QAAOrH,UAAIY,QAAQtE,KAAKiD,iBACpC,IAAA2H,KAAIC,EAAQ/Q,KAAK2G,EAASwN,EAAMpJ,EAAgB0X,EAAQ3hB,UAE3D,SAAU,IAAAmQ,QAAOrH,UAAIY,QAAQtE,KAAK0B,UAAW,CAClDwE,EAAM,cACN,IAAIxF,QAAe,IAAAqK,QAAOrH,UAAIY,QAAQtE,KAAKwC,cACvCkC,QAAuB,IAAAqG,QAAOrH,UAAIY,QAAQtE,KAAK0E,gBAC/C9J,QAAc,IAAAmQ,QAAOrH,UAAIY,QAAQtE,KAAKuD,aACtCgZ,SAAgB,IAAAxR,QAAOrH,UAAIY,QAAQxK,OAAO+K,qBAGxC,IAAA+F,KAAIC,EAAQ5P,OAAOyF,EAAQgE,EAAgB6X,EAAQ3hB,SAEpD,SAAU,IAAAmQ,QAAOrH,UAAIY,QAAQtE,KAAKqF,iBAAkB,CACzDa,EAAM,cAEN,IAAI,OAAExF,EAAF,eAAUmE,SAAyB,IAAAkG,QAAOrH,UAAIY,QAAQxK,MAE1D,GAAI4G,EAAQ,CAGV,IAAIihB,QAAuB,IAAA5W,QAAOrH,UAAIY,QAAQtE,KAAK2F,aAE/Cic,SADe,IAAA7W,QAAOrH,UAAIC,KAAKE,SAASjD,SACf+gB,SACvB,IAAA/W,KACJC,EAAQgX,aAAahd,EAAgB8c,EAAgBC,eAGjD,IAAAhX,KAAIC,EAAQiX,mBAEf,SAAU,IAAA/W,QAAOrH,UAAIY,QAAQtE,KAAK4B,SAAU,CACjD,IAAIiD,SAAwB,IAAAkG,QAAOrH,UAAIY,QAAQxK,OAAO+K,eAClDwL,QAAa,IAAAtF,QAAOrH,UAAIY,QAAQtE,KAAKwD,iBACrCue,QAAoB,IAAAhX,QAAOrH,UAAIY,QAAQtE,KAAKqC,mBAC1C,IAAAuI,KAAIC,EAAQmX,MAAMnd,EAAgBwL,EAAM0R,SACzC,SAAU,IAAAhX,QAAOrH,UAAIY,QAAQtE,KAAK6B,QAAS,CAChD,IAAIgD,SAAwB,IAAAkG,QAAOrH,UAAIY,QAAQxK,OAAO+K,eAClDwL,QAAa,IAAAtF,QAAOrH,UAAIY,QAAQtE,KAAKwD,iBACrCye,QAAoB,IAAAlX,QAAOrH,UAAIY,QAAQtE,KAAK4F,mBAC1C,IAAAgF,KAAIC,EAAQqX,KAAKrd,EAAgBwL,EAAM4R,KAc1C,SAAU3W,UACT,IAAAE,WAAU1B,OAAMiG,G,WAGT,IAAAxT,YAAW,MAAO+O,I,gGCvLjC,MAGA,OACA,O,IAEA,M,IACA,O,IACA,M,mDAPA,MAAMpF,GAAQ,aAAY,iCAYpBiT,EAAWC,GAAKA,EAEtB,SAAS+I,EACPnb,EACAlL,EACAsmB,EACAC,GAEA,IAAIC,EAAYF,EAAcC,EAC9B,OAAOrb,EAAqBob,EAAaC,GAAcE,KACrD,EAAGhb,QAAOzL,UAad,SAA4BA,GAC1B,MAAyB,mBAAlBA,EAAKE,WAAkCF,EAAK0mB,IAb/CC,CAAmB3mB,IAClBsmB,GAAe7a,EAAM,IACpBA,EAAM,GAAK+a,KACV,IAAAzmB,mBAAkBC,IAgB3B,MAAM4mB,GAAa,IAAArjB,oBAAmB,CAIpCE,MAAOA,GAASA,EAAMmjB,WAItBpe,QAAS,CAIP8D,eAAe,IAAA1I,YAAW,CAACiI,UAASrD,QAAQ8D,eAAgB+Q,GAK5DwJ,kBAAkB,IAAAjjB,YAAW,CAACgE,UAAIY,QAAQxK,MAAOqf,GAKjDnQ,UAAU,IAAAtJ,YAAW,CAACgE,UAAIY,QAAQtE,KAAKoC,QAAS+W,GAKhDtG,SAAU,CAIR1L,aAAa,IAAAzH,YACX,CAACiI,UAASrD,QAAQ6C,YAAa,yBAC/B,CAACI,EAAO9H,IAAYA,EAAS8H,EAAQ,MAMvCV,QAAQ,IAAAnH,YACN,CAACiI,UAASrD,QAAQuC,OAAQ,yBAC1B,CAACA,EAAQpH,IAAYA,EAASoH,EAAS,MAMzC/K,MAAM,IAAA4D,YACJ,CAACiI,UAASrD,QAAQxI,KAAM,yBACxB,CAACA,EAAM2D,IAAYA,EAAS3D,EAAO,MAMrC8M,aAAa,IAAAlJ,YACX,CAACiI,UAASrD,QAAQsE,YAAa,yBAC/B,CAACuS,EAAK1b,MAAYA,GAAS0b,IAO/B/b,MAAO,CAILQ,UAAU,IAAAF,YAAW,CAACN,UAAMQ,UAAWuZ,GAKvC1Z,QAAQ,IAAAC,YAAW,CAACN,UAAMK,QAAS0Z,KAOvCb,YAAa,CAIXxS,GAAG,IAAApG,YAAW,CAAC,UAAWH,GAASA,EAAM+Y,aAUzCsK,UAAU,IAAAljB,YACR,CAACiI,UAAShE,KAAKmD,QAASa,UAAS4B,MAAMvC,sBACvC,CAACF,EAASI,IAAcuR,IACtB,IAAIoK,EACJ,QAAwB5mB,IAApBwc,EAAW3c,KAAoB,CACjC,IAAIgN,EAAO2P,EAAW3P,KACtB5C,EAAM,iBAAkBuS,GACxBvS,EAAM,cAAeY,GACrB,IAAI,OAAED,EAAF,IAAUa,GAAQZ,EAAQ2R,EAAWxR,eAAea,KACtD2Q,EAAW7b,UAEToK,EACFE,EAAUuR,EAAWxR,eAAewR,EAAW7b,UAC7CkmB,EAAcjc,EAAOkc,MAAM,MAAMve,IAAIsE,GAAQA,EAAK1L,QAGlD4lB,EAAa,CAAC,GAClB,IAAK,IAAI5lB,KAAU0lB,EACjBE,EAAWpE,KAAKoE,EAAWA,EAAW5lB,OAAS,GAAKA,EAAS,GAO/D,IAJA8I,EACE,WACAW,EAAO1J,MAAM6lB,EAAWla,GAAOka,EAAWla,GAAQga,EAAYha,KAG9DA,EAAOga,EAAY1lB,SAClB+kB,EACCnb,EACAU,EACAsb,EAAWla,GACXga,EAAYha,KAGd5C,EAAM,gBACN4C,IAGA+Z,EADE/Z,GAAQga,EAAY1lB,OACD,MAErBylB,gBAA0BpK,EAA1B,CAAsC3P,cAGxC5C,EAAM,yBACN2c,EAAqBpK,EAEvB,OAAOoK,KASbjjB,UAAU,IAAAF,YAAW,CAAC,2BAA4BE,GAAYA,GAK9DqjB,YAAY,IAAAvjB,YAAW,CAAC,WAAYH,GAASA,EAAM0jB,c,UAGtCP,G,8ECxMf,I,IAAA,MAGA,O,IAEA,O,oDAJc,aAAY,0BAA1B,MASMhb,GAAM,IAAArI,oBAAmB,CAI7BkK,MAAO,CAILzC,SAAS,IAAApH,YAAW,CAACiI,UAAShE,KAAKmD,SAAUA,GAAWA,M,UAI7CY,G,cCtBftO,EAAOD,QAAUwC,QAAQ,mB,cCAzBvC,EAAOD,QAAUwC,QAAQ,W,gFCCT2R,MAAT,SAAe1P,EAAIf,EAAS2Q,EAAU5Q,EAAUqK,GACrD,MAAO,CACLvI,KAAMwkB,EACNtlB,KACAf,UACA2Q,WACA5Q,WACAqK,kB,EAKYwG,QAAT,SAAiBvT,EAAMyY,EAAQwQ,EAAalc,GACjD,MAAO,CACLvI,KAAM0kB,EACNlpB,OACAyY,SACAwQ,cACAlc,kB,EAKYwK,OAAT,SAAgBvB,GACrB,MAAO,CACLxR,KAAM2kB,EACNnT,gB,EAKY4F,iBAAT,SACLrV,EACA4P,EACAH,EACA6F,EACAuN,GAEA,MAAO,CACL5kB,KAAM6kB,EACN9iB,UACA4P,OACAH,cACA6F,iBACAuN,e,EAKYnZ,MAAT,WACL,MAAO,CAAEzL,KAAM0L,I,EAIDyD,WAAT,SAAoB/R,EAAMmL,GAC/B,MAAO,CACLvI,KAAM8kB,EACN1nB,OACAmL,kB,EAKY4I,SAAT,SAAkB5Q,EAASF,EAAQqb,EAAK6B,EAAU1c,GACvD,MAAO,CACLb,KAAM+kB,EACNxkB,UACAF,SACAqb,MACA6B,WACA1c,UAvEG,MAAM2jB,EAAQA,EAARA,MAAQ,aAYd,MAAME,EAAUA,EAAVA,QAAU,wBAWhB,MAAMC,EAASA,EAATA,OAAS,cAQf,MAAME,EAAsBA,EAAtBA,oBAAsB,2BAkB5B,MAAMnZ,EAAQA,EAARA,MAAQ,aAKd,MAAMoZ,EAAcA,EAAdA,YAAc,mBASpB,MAAMC,EAAWA,EAAXA,SAAW,iB,cC/DxBrqB,EAAOD,QAAUwC,QAAQ,8B,gFCCTulB,WAAT,UAAoB,QACzBjgB,EADyB,aAEzBgZ,EAFyB,OAGzBvZ,EAHyB,UAIzBqH,EAJyB,cAKzB2Y,EALyB,oBAMzBjF,EANyB,SAOzBrV,EAPyB,cAQzBa,EARyB,IASzBmT,EATyB,WAUzBF,EAVyB,aAWzBC,EAXyB,cAYzBpZ,EAZyB,iBAazB2iB,IAEA,MAAO,CACLhlB,KAAMilB,EACN1iB,UACAgZ,eACAvZ,SACAqH,YACA2Y,gBACAjF,sBACArV,WACAa,gBACAmT,MACAF,aACAC,eACApZ,gBACA2iB,qB,EAKY1M,YAAT,SAAqBvW,EAASQ,EAASP,GAC5C,MAAO,CACLhC,KAAMklB,EACNnjB,UACAQ,UACAP,W,EAKYygB,iBAAT,SAA0B1gB,EAASQ,GACxC,MAAO,CACLvC,KAAMmlB,EACNpjB,UACAQ,Y,EAKYqgB,YAAT,SAAqBwC,EAAQzC,EAAUnd,GAC5C,MAAO,CACLxF,KAAMqlB,EACND,SACAzC,WACAnd,U,EAKYqd,WAAT,SAAoBpd,GACzB,MAAO,CACLzF,KAAMslB,EACN7f,W,EAKYrK,KAAT,SAAc2G,EAASwN,EAAMpJ,EAAgB0X,EAAQ3hB,GAC1D,MAAO,CACL8D,KAAMulB,EACNxjB,UACAwN,OACApJ,iBACA0X,SACA3hB,U,EAKYK,OAAT,SAAgByF,EAAQmE,EAAgB0X,EAAQ3hB,GACrD,MAAO,CACL8D,KAAMwlB,EACNxjB,SACAmE,iBACA0X,SACA3hB,U,EAKYknB,WAAT,WACL,MAAO,CACLpjB,KAAMylB,I,EAKMtC,aAAT,SAAsBphB,EAASwF,EAAMhF,GAC1C,MAAO,CACLvC,KAAM0lB,EACN3jB,UACAwF,OACAhF,Y,EAKYwgB,KAAT,WACL,MAAO,CACL/iB,KAAM2lB,I,EAKMrC,MAAT,SAAevhB,EAAS4P,EAAMzV,GACnC,MAAO,CACL8D,KAAM4lB,EACN7jB,UACA4P,OACAzV,U,EAKYsnB,KAAT,SAAczhB,EAAS4P,EAAMzV,GAClC,MAAO,CACL8D,KAAM6lB,EACN9jB,UACA4P,OACAzV,U,EAKYuP,MAAT,SAAetF,GACpB,MAAO,CACLnG,KAAM0L,EACNvF,mB,EAKYwF,kBAAT,WACL,MAAO,CACL3L,KAAM4L,IArJH,MAAMqZ,EAAcA,EAAdA,YAAc,kBAkCpB,MAAMC,EAAeA,EAAfA,aAAe,mBAUrB,MAAMC,EAAmBA,EAAnBA,iBAAmB,uBASzB,MAAME,EAAeA,EAAfA,aAAe,mBAUrB,MAAMC,EAAcA,EAAdA,YAAc,kBAQpB,MAAMC,EAAOA,EAAPA,KAAO,WAYb,MAAMC,EAASA,EAATA,OAAS,aAWf,MAAMC,EAAcA,EAAdA,YAAc,kBAOpB,MAAMC,EAAgBA,EAAhBA,cAAgB,oBAUtB,MAAMC,EAAOA,EAAPA,KAAO,WAOb,MAAMC,EAAQA,EAARA,MAAQ,YAUd,MAAMC,EAAOA,EAAPA,KAAO,WAUb,MAAMna,EAAQA,EAARA,MAAQ,YAQd,MAAME,EAAqBA,EAArBA,mBAAqB,0B,8FC9BjBka,mBAAV,UAA6B9Y,SAC5B,IAAAd,KAAIC,EAAQ4Z,QAAQ/Y,IAE1B,IAAIgZ,QAAe,IAAAzZ,MAAK,CAACJ,EAAQ8Z,cAAe9Z,EAAQ+Z,aAGxD,IAAIxlB,EACJ,GAHA8G,EAAM,YAAawe,GAGfA,EAAOhmB,MAAQmM,EAAQ8Z,cAIzB,MAAO,CAAE9lB,MAAO6lB,EAAO7lB,OAHvBO,EAAQslB,EAAOtlB,MACf8G,EAAM,kBAKR,IAAI,QACFzF,EADE,OAEFC,EAFE,KAGFuN,EAHE,eAIFpJ,EAJE,OAKFV,EALE,OAMFoY,EANE,MAOF3hB,EAPE,SAQFymB,EARE,MASFnd,SACQ,IAAA+G,MAAKJ,EAAQga,cAGvB,OAFA3e,EAAM,iBAEC,CACL9G,QACAqB,UACAC,SACAuN,OACApJ,iBACAV,SACAoY,SACA3hB,QACAymB,WACAnd,U,EAKa6S,eAAV,UAAyB+N,EAAW5gB,GACzC,IAAI6gB,QAAc,IAAAC,KAAIF,EAAUtgB,IAAI/D,IAAW,IAAAwkB,MAAKC,EAAezkB,KAEnEyF,EAAM,6BACA,IAAA8e,KAAIF,EAAUtgB,IAAI/D,IAAW,IAAAmK,KAAIC,EAAQsa,YAAY1kB,EAASyD,MAEpE,IAAIL,EAAW,GAKf,OAJAA,QAAiB,IAAAlB,MAAKoiB,GAEtB7e,EAAM,cAAerC,GAEdA,G,EAYQuhB,KAAV,UAAe3Z,SACd,IAAAb,KAAIC,EAAQua,KAAK3Z,K,EAGRH,OAzLjB,I,IAAA,MAGA,OASA,OAEYT,E,EAAZ,OACY2V,E,EAAZ,O,IAEA,O,IACA,OACYrkB,E,EAAZ,M,IAEA,O,4MApBA,MAAM+J,GAAQ,aAAY,uBAmC1B,SAASmf,EAAaC,GACpB,OAAOA,EAAUpjB,WAAW,MACxBojB,EAAUnoB,MAAM,GAAGooB,SAAS,EAAIppB,EAAMoC,IAAIlC,MAAMmC,UAAW,KAC3D8mB,EAGN,SAAUE,EAAqBC,GAAS,OAAE/Z,IAExC,IAAItM,EADJ8G,EAAM,0BAEN,IACE9G,QAAc,IAAAsmB,OAAMD,EAASA,EAAQE,SAAU,CAACja,IAChD,MAAOka,GAGP,OAFA1f,EAAM,4BACA,IAAA0E,KAAIC,EAAQhM,MAAM+mB,KAI1B1f,EAAM,aACN9G,EAA0BA,EA7BboF,IAAIxE,IAAQA,EAARA,cACZA,EADY,CAEfhB,MAAOgB,EAAKhB,MAAMwF,IAAI6gB,GACtBtmB,OAAQiB,EAAKjB,OAAOyF,IAAI6gB,YA2BpB,IAAAza,KAAIC,EAAQgb,aAAazmB,IAE/B,IAAI6E,QAAW,IAAAyhB,OAAMD,EAASA,EAAQK,eAAgB,CAACpa,IACvDxF,EAAM,QAASjC,GACf,IAAIyI,QAAgB,IAAAgZ,OAAMD,EAASA,EAAQM,WAAY,CAACra,IACxDxF,EAAM,aAAcwG,GACpB,IAAIxI,QAAc,IAAAwhB,OAAMD,EAASA,EAAQO,SAAU,CAAC/hB,EAAG6S,cACvD5Q,EAAM,WAAYhC,SAEZ,IAAA0G,KAAI4V,EAAQjU,gBAAgBtI,UAC5B,IAAA2G,KAAI4V,EAAQ/T,YAAYC,UACxB,IAAA9B,KAAI4V,EAAQ5T,UAAU1I,IAG5B,IAAI+hB,EAAgB,CAClBC,SAAUhiB,EAAMiiB,MAChBC,WAAY,IAAI/iB,UAAGa,EAAMkiB,YACzBC,SAAU,IAAIhjB,UAAGa,EAAMoiB,UACvBvK,OAAQ,IAAI1Y,UAAGa,EAAM6X,QACrBwK,UAAW,IAAIljB,UAAGa,EAAMqiB,YAG1B,GAAa,MAATtiB,EAAG8O,SACC,IAAAnI,KACJC,EAAQ2b,YAAY,CAClB/lB,QAASwD,EAAG8O,GACZ9E,KAAMhK,EAAGwiB,MACT5hB,eAAgBZ,EAAG8O,GACnB5O,OAAQuI,EAAQvI,OAChBoY,OAAQtY,EAAG6O,KACXlY,MAAO,IAAIyI,UAAGY,EAAGrJ,OACjBymB,SAAU,IAAIhe,UAAGY,EAAGyiB,UACpBxiB,MAAO+hB,SAGN,CACL,IAAIphB,EAAiB8hB,UAAKC,MAAMC,UAAUna,EAAQoa,iBAC9Cpa,EAAQoa,gBACR3qB,EAAMoC,IAAIlC,MAAMuI,mBACd,IAAAgG,KACJC,EAAQ2b,YAAY,CAClB9lB,OAAQuD,EAAGwiB,MACX5hB,iBACAV,OAAQuI,EAAQvI,OAChBoY,OAAQtY,EAAG6O,KACXlY,MAAO,IAAIyI,UAAGY,EAAGrJ,OACjBymB,SAAU,IAAIhe,UAAGY,EAAGyiB,UACpBxiB,MAAO+hB,MAMf,SAAUd,EAAYM,GAAS,QAAEhlB,EAAF,MAAWyD,IACxCgC,EAAM,yBAA0BzF,GAChC,IAAIC,QAAe,IAAAglB,OAAMD,EAASA,EAAQsB,gBAAiB,CAACtmB,EAASyD,IAErEgC,EAAM,yBAA0BzF,SAC1B,IAAAmK,KAAIC,EAAQqa,cAAczkB,EAASC,IA2D3C,SAAUwkB,EAAczkB,GACtB,IAAI,OAAEC,SAAiB,IAAAuK,MACrByZ,GAAUA,EAAOhmB,MAAQmM,EAAQmc,gBAAkBtC,EAAOjkB,SAAWA,GAIvE,OAFAyF,EAAM,oBAAqBzF,GAEpBC,EAOF,SAAU4K,IAEf,IAAI,SAAEG,SAAmB,IAAAR,MAAKJ,EAAQoc,WAClCxB,EAAU,IAAIyB,UAAYzb,SAExB,IAAAD,WAAUX,EAAQsc,QAAS3B,EAAsBC,SACjD,IAAAja,WAAUX,EAAQuc,aAAcjC,EAAaM,G,WAGtC,IAAAlpB,YAAW,OAAQ+O,I,cClMlClS,EAAOD,QAAUwC,QAAQ,S,+FC0BR2P,O,EAuPAnB,MAAV,kBACE8D,EAAK9D,cACLzG,EAAIyG,cACJxC,EAASwC,cACT/K,EAAM+K,cACNgV,EAAWhV,SAtRpB,I,IAAA,MAGA,OAEA,OAEY/K,E,EAAZ,OACY6O,E,EAAZ,OACYvK,E,EAAZ,OACYiE,E,EAAZ,OACYwX,E,EAAZ,OAEYtU,E,EAAZ,O,IAEA,O,4MAdA,MAAM3E,GAAQ,aAAY,6BAgBpBmhB,EAAa,CACjB,CAACxc,EAAQ+M,SAAU5M,EACnB,CAACH,EAAQiN,WAAYD,EACrB,CAAChN,EAAQmN,WAAYD,EACrB,CAAClN,EAAQqN,WAyFX,YACE,MAAMoP,QAAsB,IAAAvc,QAAO2X,UAAWpe,QAAQ8D,eAChDmf,QAAyB,IAAAxc,QAAO2X,UAAWpe,QAAQuO,UAGzD,IAAI1N,EACAib,EACAxgB,EAJJsG,EAAM,oBAAqBohB,GAC3BphB,EAAM,6BAA8BqhB,GAAoB,IAAIpgB,aAK5D,SACS0Q,IAEP1S,QAAqB,IAAA4F,QAAO2X,UAAWpe,QAAQ8D,eAC/CgY,QAAwB,IAAArV,QAAO2X,UAAWpe,QAAQuO,UAClDjT,QAAiB,IAAAmL,QAAO2X,UAAWpe,QAAQlF,MAAMQ,UACjDsG,EAAM,mBAAoBf,GAC1Be,EAAM,4BAA6Bka,GAAmB,IAAIjZ,aAC1DjB,EAAM,eAAgBtG,UAGrBA,GAEDuF,GAAgBmiB,GAEhBlH,EAAgBvZ,OAAOI,gBACrBsgB,EAAiB1gB,OAAOI,eAC1BmZ,EAAgBvZ,OAAOjJ,KAAO2pB,EAAiB1gB,OAAOjJ,IAEtDwiB,EAAgBjZ,YAAY0B,MAAMpB,MAAMqB,OACtCye,EAAiBpgB,YAAY0B,MAAMpB,MAAMqB,OArH7C,CAAC+B,EAAQuN,UA+HX,YACE,SAAU,IAAArN,QAAO2X,UAAWpe,QAAQuO,SAASjK,aAE3C,kBADOmP,KAIT,MAAMuP,QAAsB,IAAAvc,QAAO2X,UAAWpe,QAAQ8D,eACtD,IAAIjD,EACAvF,EAEJ,SACSiY,IAEP1S,QAAqB,IAAA4F,QAAO2X,UAAWpe,QAAQ8D,eAC/CxI,QAAiB,IAAAmL,QAAO2X,UAAWpe,QAAQlF,MAAMQ,iBACzCA,GAAYuF,GAAgBmiB,IA7ItC,CAACzc,EAAQ0N,UAyLX,UAAkCmM,GAIhC,IAAIpM,OACSrc,IAAXyoB,QAA+CzoB,IAAvByoB,EAAOpM,YAC3BoM,EAAOpM,kBACD,IAAAvN,QAAO2X,UAAWpK,aAE1BkP,GAAgB,EAEhBpH,QAAwB,IAAArV,QAAO2X,UAAWpe,QAAQuO,UAClD4U,EAAcrH,EAAgBjZ,YAAY0B,MAAMpB,MAAMqB,KACtD4e,EAAkBtH,EAAgBvZ,OAAOjJ,GACzC+pB,EAAuBvH,EAAgBvZ,OAAOI,cAElD,EAAG,OACM4Q,IAKP,IAAI+P,EAAeH,EACfI,EAAmBH,EAKvB,GAHAtH,QAAwB,IAAArV,QAAO2X,UAAWpe,QAAQuO,UAClD3M,EAAM,sBAAuBka,SACR,IAAArV,QAAO2X,UAAWpe,QAAQlF,MAAMQ,UAEnD,MAIF,GADA8nB,EAAkBtH,EAAgBvZ,OAAOjJ,QACjB3B,IAApByrB,EACF,SAEFC,EAAuBvH,EAAgBvZ,OAAOI,cAC9C,IAAI6gB,EAAc1H,EAAgBtkB,KAAK8B,GACvC6pB,EAAcrH,EAAgBjZ,YAAY0B,MAAMpB,MAAMqB,KAEtD0e,EACElP,EAAYlN,OAAO,EAAGxO,WAAUqK,gBAAe6B,OAAMhN,eACtCG,IAATH,EAEAmL,IAAkB0gB,GAClB/qB,IAAa8qB,GACb5rB,IAASgsB,EAMX7gB,IAAkB0gB,GAClB/qB,IAAa8qB,GACb5e,IAAS2e,IACRC,IAAoBG,GAAoBJ,IAAgBG,IAE1DxqB,OAAS,SACNoqB,KAhPL,SAAUlc,IACf,OAAa,CACXpF,EAAM,8BACN,IAAIwe,QAAe,IAAAzZ,OAAK,aAAYoc,IACpC,WAAY,IAAAtc,QAAO2X,UAAWpe,QAAQlF,MAAMK,SAC1C,SAEFyG,EAAM,sBACN,IAAIoF,EAAO+b,EAAW3C,EAAOhmB,YAEvB,IAAAkM,KAAIC,EAAQkO,uBACZ,IAAAgP,MAAK,CACTC,MAAM,IAAAluB,MAAKwR,EAAMoZ,GACjB5Y,WAAW,IAAAb,MAAKJ,EAAQkB,mBAEpB,IAAAnB,KAAIC,EAAQoO,iBAUtB,SAAUjO,EAAQ0Z,GAChB,IAAIha,OACSzO,IAAXyoB,QAAyCzoB,IAAjByoB,EAAOha,MAAsBga,EAAOha,MAAQ,EAEtE,IACE,IAAI/Q,EAAI,EACRA,EAAI+Q,WAAiB,IAAAK,QAAO2X,UAAWpe,QAAQlF,MAAMQ,WACrDjG,UAEOyF,EAAM4L,UAWjB,SAAU6M,IACR,MAAMoQ,QAAiB,IAAAld,QAAO2X,UAAWpe,QAAQuO,UAEjD,IAAIqV,EAAUtoB,EAEd,SAESoL,IAGPkd,QAAiB,IAAAnd,QAAO2X,UAAWpe,QAAQuO,UAE3CjT,QAAiB,IAAAmL,QAAO2X,UAAWpe,QAAQlF,MAAMQ,iBAIhDA,KACCsoB,IACCA,EAASpsB,OACV,IAAAF,+BAA8BssB,EAASpsB,OACtCosB,EAAS/gB,YAAYM,QAAUwgB,EAAS9gB,YAAYM,OACnDygB,EAAS/gB,YAAY/J,SAAW6qB,EAAS9gB,YAAY/J,QACrD8qB,EAASrhB,OAAOjJ,KAAOqqB,EAASphB,OAAOjJ,IACvCsqB,EAASrhB,OAAOI,gBAAkBghB,EAASphB,OAAOI,gBA+E1D,SAAU8Q,IACR,MAAMuP,QAAsB,IAAAvc,QAAO2X,UAAWpe,QAAQ8D,eAChDmf,QAAyB,IAAAxc,QAAO2X,UAAWpe,QAAQuO,UACzD,IAAI1N,EACAib,EACAxgB,EAEJ,SACSiY,IAEP1S,QAAqB,IAAA4F,QAAO2X,UAAWpe,QAAQ8D,eAC/CgY,QAAwB,IAAArV,QAAO2X,UAAWpe,QAAQuO,UAClDjT,QAAiB,IAAAmL,QAAO2X,UAAWpe,QAAQlF,MAAMQ,iBAKhDA,GAEDuF,GAAgBmiB,IAIfniB,EAAemiB,GACblH,EAAgBvZ,OAAOjJ,KAAO2pB,EAAiB1gB,OAAOjJ,IACrDwiB,EAAgBvZ,OAAOI,gBACrBsgB,EAAiB1gB,OAAOI,eAC1BmZ,EAAgBjZ,YAAY0B,MAAMpB,MAAMqB,OACtCye,EAAiBpgB,YAAY0B,MAAMpB,MAAMqB,O,WA5JpC,IAAAvM,YAAW,aAAc+O,I,cC7CxClS,EAAOD,QAAUwC,QAAQ,sC,gFCYRwsB,WAAV,UAAqB3e,SACpB,IAAAoB,KAAIC,EAAQsd,WAAW3e,K,EAqCdW,MAAV,YACL,IAAIie,QAAc,IAAArd,QAChBpD,UAAS7H,YAAY+H,4CAEjB,IAAA+C,KAAIC,EAAQV,MAAMie,K,EAGT/c,OAAV,kBACC,IAAAT,KAAIC,EAAQR,sB,EAGH+W,MAAV,YACL,IAAIgH,QAAc,IAAArd,QAChBpD,UAAS7H,YAAY+H,4CAEjB,IAAA+C,KAAIC,EAAQwd,aAAaD,K,EAGhB9c,OApEjB,I,IAAA,MAGA,OACA,OAEYT,E,EAAZ,OACA,QACYzL,E,EAAZ,O,IAEA,O,4MATA,MAAM8G,GAAQ,aAAY,2BAe1B,SAAU6J,IACR7J,EAAM,kBAOR,YACE,SAAU,IAAA6E,QAAOpD,UAASrD,QAAQ+E,kBAG1B,IAAAuB,KAAIC,EAAQyd,uBACb,SAAU,IAAAvd,QAAOpD,UAASrD,QAAQ0E,UAAW,CAClD,IAAIC,QAAsB,IAAA8B,QAAOpD,UAASrD,QAAQ2E,eAClD/C,EAAM,kBACN,IAAIkiB,QAAc,IAAArd,QAAOpD,UAASrD,QAAQ6D,oBACtCogB,QAAmB,IAAAxd,QAAOpD,UAAS1H,KAAK4G,QACtB,MAAlBoC,GAAyBmf,QAA2BnsB,IAAlBssB,EAAW3qB,SAIzC,IAAAgN,KAAIC,EAAQ2d,2BAEZ,IAAA5d,KAAIC,EAAQ3B,KAAKD,SAEpB,SAAU,IAAA8B,QAAOpD,UAASrD,QAAQ6E,UAAW,CAElDjD,EAAM,4BACN,IAAIkiB,QAAc,IAAArd,QAAOpD,UAASrD,QAAQ+D,gCACpC,IAAAuC,KAAIC,EAAQwd,aAAaD,KA3B1BK,GACPviB,EAAM,wBAAyB,IAAA6E,QAAOpD,UAASrD,QAAQqC,oBAChDvH,EAAM8L,2BA+CR,SAAUI,UACT,IAAAE,WAAU1B,OAAMiG,G,WAGT,IAAAxT,YAAW,WAAY+O,I,gFCvEtB6c,WAAT,SAAoB3e,GACzB,MAAO,CACL9K,KAAMgqB,EACNlf,iB,EAKYN,KAAT,SAAcD,GACnB,MAAO,CACLvK,KAAMiqB,EACN1f,kB,EAKYof,aAAT,SAAsBD,GAC3B,MAAO,CAAE1pB,KAAMkqB,EAAeR,U,EAIhBE,eAAT,WACL,MAAO,CAAE5pB,KAAMmqB,I,EAIDL,kBAAT,WACL,MAAO,CAAE9pB,KAAMoqB,I,EAID3e,MAAT,SAAeie,GACpB,MAAO,CAAE1pB,KAAM0L,EAAOge,U,EAIR/d,kBAAT,WACL,MAAO,CAAE3L,KAAM4L,IAtCV,MAAMoe,EAAcA,EAAdA,YAAc,uBAQpB,MAAMC,EAAOA,EAAPA,KAAO,gBAQb,MAAMC,EAAgBA,EAAhBA,cAAgB,yBAKtB,MAAMC,EAAkBA,EAAlBA,gBAAkB,2BAKxB,MAAMC,EAAsBA,EAAtBA,oBAAsB,+BAK5B,MAAM1e,EAAQA,EAARA,MAAQ,iBAKd,MAAME,EAAqBA,EAArBA,mBAAqB,+B,gFC2CjBH,MAAV,kBACC,IAAAS,KAAIC,EAAQV,U,EAGHkB,OAAV,kBACC,IAAAT,KAAIC,EAAQR,sB,EAGH+W,MAAV,YACL,MAAMngB,QAAgB,IAAA8J,QAAOoU,UAAW7a,QAAQrD,SAC1CR,QAAgB,IAAAsK,QAAOoU,UAAW7a,QAAQ7D,eAC1C,IAAAmK,KAAIC,EAAQwd,aAAa,KAAMpnB,EAASR,K,EAG/B6K,OA7FjB,I,IAAA,MAGA,OACA,OAEYT,E,EAAZ,OACA,QACYzL,E,EAAZ,O,IAEA,O,4MATA,MAAM8G,GAAQ,aAAY,6BAW1B,SAAU6J,UAUV,YACE,MAAMqQ,QAAwB,IAAArV,QAAOoU,UAAW7a,QAAQ2a,kBAClDoB,QAAqB,IAAAtV,QAAOoU,UAAW7a,QAAQ+a,cAC/CD,QAAsB,IAAArU,QAAOoU,UAAW7a,QAAQ8a,eACtD,IAAI2J,GAAkB,EAGtB,SAAU,IAAAhe,QAAOoU,UAAW7a,QAAQ+E,YAAa,CAC/C,MAAMlF,QAAe,IAAA4G,QAAOoU,UAAW7a,QAAQkB,cAC/CU,EAAM,oBACA,IAAA0E,KAAIC,EAAQyd,eAAejI,EAAclc,EAAQic,IACvD2I,GAAkB,OAKlB3J,EAAgB,UACT,IAAArU,QAAOoU,UAAW7a,QAAQ4b,uBAEjCha,EAAM,cACNA,EAAM,qBAAsB,IAAA6E,QAAOoU,UAAWlf,KAAK4S,WACnD3M,EAAM,aAAcma,SACd,IAAAzV,KAAIC,EAAQme,cAAc5J,EAAegB,IAC/C2I,GAAkB,GAMpB,SAAU,IAAAhe,QAAOoU,UAAW7a,QAAQkb,YAAa,CAC/C,MAAMW,QAAqB,IAAApV,QAAOoU,UAAWlf,KAAK4S,UAC5CoW,QAAmB,IAAAle,QAAOoU,UAAWlf,KAAKyb,oBAC1C,IAAA9Q,KAAIC,EAAQqe,OAAO9I,EAAiBD,EAAarkB,KAAMmtB,IAC7DF,GAAkB,OACb,SAAU,IAAAhe,QAAOoU,UAAW7a,QAAQmb,mBACnC,IAAA7U,KAAIC,EAAQse,QAAQ/I,IAC1B2I,GAAkB,OACb,SAAU,IAAAhe,QAAOoU,UAAW7a,QAAQ6E,UAAW,CASpD,MAAMigB,QAAoB,IAAAre,QAAOoU,UAAW7a,QAAQb,aAC9C4lB,QAAoB,IAAAte,QAAOoU,UAAW7a,QAAQhC,mBAC9C,IAAAsI,KAAIC,EAAQwd,aAAajI,EAAiBgJ,EAAaC,IAC7DN,GAAkB,EAGfA,UACG,IAAAne,KAAIC,EAAQye,eAAelJ,KA9D5BmJ,SACAnqB,EAAM8L,2BA+ER,SAAUI,UACT,IAAAE,WAAU1B,OAAMiG,G,WAGT,IAAAxT,YAAW,aAAc+O,I,gFChGxB4d,OAAT,SAAgBrW,EAAU2W,EAAc9N,GAC7C,MAAO,CACLhd,KAAM+qB,EACN5W,WACA2W,eACA9N,iB,EAKYyN,QAAT,SAAiBtW,GACtB,MAAO,CACLnU,KAAMgrB,EACN7W,a,EAKYwV,aAAT,SAAsBxV,EAAU5R,EAASR,GAC9C,MAAO,CACL/B,KAAMkqB,EACN/V,WACA5R,UACAR,Y,EAKY6nB,eAAT,SAAwBxV,EAAM3O,EAAQ0O,GAC3C,MAAO,CACLnU,KAAMmqB,EACN/V,OACA3O,SACA0O,a,EAKYmW,cAAT,SAAuBW,EAAS9W,GACrC,MAAO,CACLnU,KAAMkrB,EACND,UACA9W,a,EAKYyW,eAAT,SAAwBzW,GAC7B,MAAO,CACLnU,KAAMmrB,EACNhX,a,EAKY1I,MAAT,WACL,MAAO,CACLzL,KAAM0L,I,EAKMC,kBAAT,WACL,MAAO,CACL3L,KAAM4L,IAjEH,MAAMmf,EAAUA,EAAVA,QAAU,qBAUhB,MAAMC,EAAWA,EAAXA,SAAW,sBAQjB,MAAMd,EAAgBA,EAAhBA,cAAgB,2BAUtB,MAAMC,EAAkBA,EAAlBA,gBAAkB,6BAUxB,MAAMe,EAAiBA,EAAjBA,eAAiB,4BASvB,MAAMC,EAAkBA,EAAlBA,gBAAkB,6BAQxB,MAAMzf,EAAQA,EAARA,MAAQ,mBAOd,MAAME,EAAqBA,EAArBA,mBAAqB,iC,gBC9DlC,EAAQ,IACR,IAAIwf,EAAW,EAAQ,IAAkBC,QAEzC3wB,EAAOD,QAAU2wB,G,cCHjB1wB,EAAOD,QAAUwC,QAAQ,gC,iGCAzB,M,IAGA,OAEA,O,IAEA,O,IACA,O,IACA,M,IACA,M,IACA,O,IACA,O,IACA,O,IACA,OAEA,O,mDAfA,MAAMuK,GAAQ,aAAY,YAiBpB4jB,EAAW,CAQfE,OAAA,iBAAO,UAAete,EAAQue,EAAU,IACtC,IAAI,UAAErb,EAAF,MAAasb,EAAb,SAAoBze,EAApB,aAA8BjC,EAA9B,UAA4CyX,GAAcgJ,EACzDzgB,IACHA,EAAe2gB,eAAa9tB,MAAM+tB,cAAcxb,EAAWsb,IAE7D,IAAI1J,EAAU,IAAI6J,UAAQ7gB,EAAciC,EAAU,CAAEwV,aAAavV,GAEjE,UACQ8U,EAAQxU,QACd9F,EAAM,iBACN,MAAO0f,GACP1f,EAAM,4BACNsa,EAAQnV,SAGV,OAAOmV,KAfT,6CAwBA8J,YAAA,iBAAY,UAAeL,EAAU,IACnC,IAAI,UAAErb,EAAF,MAAasb,EAAb,SAAoBze,EAApB,aAA8BjC,EAA9B,UAA4CyX,GAAcgJ,EACzDzgB,IACHA,EAAe2gB,eAAa9tB,MAAM+tB,cAAcxb,EAAWsb,IAE7D,IAAI1J,EAAU,IAAI6J,UAAQ7gB,EAAciC,EAAU,CAAEwV,cAIpD,aAFMT,EAAQxU,QAEPwU,KATT,4CA0BA,gBACE,OAAO,IAAA+J,sBAAqB,CAC1B7iB,IAAK8iB,UACLvc,KAAMwc,UACNrrB,MAAOsrB,UACPhnB,IAAKinB,UACLhjB,SAAUijB,UACVzL,WAAY0L,UACZrK,QAASsK,UACTpI,WAAYqI,cAnChBT,IAAA,EAxBA,E,UAgEaR,G,2IC1Ff,MAGY3tB,E,EAAZ,MACA,O,IAEA,OAEYumB,E,EAAZ,OACY7X,E,EAAZ,O,IACA,O,IACA,O,IACA,OACYmgB,E,EAAZ,OACYC,E,EAAZ,OACYC,E,EAAZ,O,IACA,OAEA,O,IAEA,O,IACA,M,IACA,M,IACA,O,IAGA,OAEA,Q,4MA3BA,MAAMhlB,GAAQ,aAAY,oBAgCX,MAAMmkB,EAOnBc,YAAY3hB,EAAciC,EAAU2f,EAAe1f,GAIjD,IAAI,MAAEsW,EAAF,eAASqJ,IAAmB,aAAeC,UAASC,UAAU,CAChEH,IAEF5O,KAAKgP,OAASxJ,EACdxF,KAAKiP,gBAAkBJ,EAEvB,IAAI,SAAExqB,EAAF,QAAYiG,GAAYujB,EAAQqB,UAAUliB,GAG9CgT,KAAKgP,OAAOG,SAAS9gB,EAAQwB,gBAAgBxL,EAAUiG,IAGvD0V,KAAKoP,OAAS,IAAI,EAAJ,QAAY,CAACC,EAAQC,KACjC,MAAMC,EAAcvP,KAAKgP,OAAOQ,UAAU,KACpCxP,KAAKyP,KAAKzL,UAAQrc,OAAO6H,QAC3B9F,EAAM,UACN6lB,IACAF,KACSrP,KAAKyP,KAAKzL,UAAQrc,OAAO6c,WAClC9a,EAAM,UACN6lB,IACAD,EAAOtP,KAAKyP,KAAKzL,UAAQrc,OAAOtF,aAMtC2d,KAAKgP,OAAOG,SAAS9gB,EAAQpD,MAAMgE,EAAUC,IAGzCM,QAAQ,kDACN,EAAK4f,SADC,GAIRM,uBAAuBC,GAAe,4CAC1C,OAAO,IAAI,EAAJ,SAAY,SAACN,EAAQC,GAC1B,IAAIM,GAAoB,EACxBlmB,EAAM,2BACN,MAAM6lB,EAAc,EAAKP,OAAOQ,WAAU,WACxC9lB,EAAM,YACFkmB,EACE,EAAKH,KAAKzL,UAAQrc,OAAO6H,QAC3B9F,EAAM,YACN6lB,IACAF,GAAO,IACE,EAAKI,KAAKzL,UAAQrc,OAAO6c,WAClC+K,IACA7lB,EAAM,UACN4lB,EAAO,EAAKG,KAAKzL,UAAQrc,OAAOtF,SAG9B,EAAKotB,KAAKzL,UAAQrc,OAAOyc,WAC3B1a,EAAM,mBACNkmB,GAAoB,MAK1B,EAAKT,SAASQ,QAxB0B,GAwC5C,iBAAiB3iB,GACf,IAAI3I,EAAW,GACXiG,EAAU,GAEd,IAAK,IAAIulB,KAAe7iB,EAAc,CACpC,GAAI6iB,EAAYC,sBACd,MAAM,IAAIC,MACP,sBAAqBF,EAAYzuB,mCAGtC,IAAIwI,EAAWimB,EAAYjmB,SAC3BU,EAAQulB,EAAYzuB,IAAM,GAC1B,IAAK,IAAI0B,KAAS+sB,EAAYvlB,QAAS,CAGrC,IAAID,EAASwlB,EAAYvlB,QAAQxH,GAC5BuH,IAGLC,EAAQulB,EAAYzuB,IAAI0B,IAAxB,gBACKuH,EADL,CAEET,SAAUS,EAAOT,UAAYA,EAC7Ba,cAAeolB,EAAYzuB,GAC3BA,GAAI0B,KAIR,IAAK,IAAIqd,KAAY0P,EAAYzd,UAAW,CAC1C,IAoBI4d,GApBA,aACFvS,EACAwS,SAAU/rB,EAFR,UAGFqH,EACA2kB,iBAAkBC,EAJhB,kBAKFC,EALE,oBAMFnR,EANE,IAOFrB,EAPE,SAQFhU,EARE,gBASFymB,GACElQ,EAGkB,iBAAXjc,IACTA,GAAS,IAAAosB,cAAapsB,IAEM,iBAAnBisB,IACTA,GAAiB,IAAAG,cAAaH,SAIR1wB,IAApB4wB,IAEFL,EAAqBH,EAAYvlB,QAAQimB,UACvClmB,GAAUA,GAAUA,EAAOjJ,KAAOivB,IAQtC,IAAInR,EAAevf,EAAMguB,aAAa9tB,MAAM2wB,gBAC1CrQ,EACA0P,GAGEnS,EAAawB,EAAeA,EAAa9d,QAAK3B,EAC9Cke,EAAeuB,EAAeA,EAAavB,kBAAele,EAC9Dme,EAAMje,EAAMoT,QAAQlT,MAAM4wB,eAAe7S,GAEzClU,EAAM,kBAAmB+T,GACzB/T,EAAM,eAAgB6B,GACtB7B,EAAM,cAAeE,GACrBF,EAAM,SAAUkU,GAEZ1Z,GAAoB,MAAVA,GACZG,EAAS+d,KAAK,CACZ3E,eACAvZ,SACAqH,YACA2Y,cAAe8L,EACfpS,MACAhU,WACAa,cAAeolB,EAAYzuB,GAC3Bsc,aACAC,eACAuJ,iBAAkB2I,EAAY3I,iBAC9B3iB,eAAe,IAIf4rB,GAAoC,MAAlBA,GACpB9rB,EAAS+d,KAAK,CACZ3E,eACAvZ,OAAQisB,EACR5kB,UAAW6kB,EACXlM,cAAe8L,EACf/Q,sBACArB,MACAhU,WACAa,cAAeolB,EAAYzuB,GAC3Bsc,aACAC,eACAuJ,iBAAkB2I,EAAY3I,iBAC9B3iB,eAAe,KA4BvB,OArBAF,GAAW,aACT,MACGA,EAAS2D,IAAIvD,IACd,MAAM+Y,GAAc,IAAAzc,WAAU,CAC5BmB,KAAM,SACN9D,MAAOqG,EAAQP,SAIjB,MAAO,CACL,CAACsZ,IAAD,gBACK/Y,EADL,CAEEA,QAAS+Y,QAOjBnZ,EAAW1E,EAAM2H,SAASzH,MAAM6wB,kBAAkBrsB,GAE3C,CAAEA,WAAUiG,WAGrB,YACE,OAAO0V,KAAKgP,OAAO2B,WAGrBlB,KAAK9N,GACH,OAAOA,EAAS3B,KAAKjd,OAGjBosB,SAASjH,GAAQ,4CAGrB,OAFA,EAAK8G,OAAOG,SAASjH,IAEd,IAHc,GAYjB0I,SAAS9hB,KAASlN,GAAM,4CAC5B,aAAa,EAAKqtB,gBAAgB4B,IAAI/hB,KAASlN,GAAMkvB,cADzB,GAIxBxhB,YAAY,kDACV,EAAK6f,SAAS9gB,EAAQiB,mBACtB,EAAK6f,SAASjJ,EAAW5W,eAFf,GAKZmN,aAAasU,GAAe,4CAChC,OAAO,IAAI,EAAJ,SAAY,SAAAC,GACjB,IAAIC,GAAa,EACjB,MAAM1B,EAAc,EAAKP,OAAOQ,WAAU,WACxC,MAAM/I,EAAa,EAAKgJ,KAAKlB,UAAmB9H,YAEhD,GAAIA,IAAewK,EAGjB,OAFAA,GAAa,OACbvnB,EAAM,qBAIH+c,GAAcwK,IACjBvnB,EAAM,mBACN6lB,IACAyB,GAAQ,OAGZ,EAAK7B,SAAS4B,QAlBgB,GAuB5BrL,KAAKxW,GAAQ,4CACjB,GAAI,EAAKugB,KAAKzL,UAAQrc,OAAO1E,QAC3B,OAAO,EAET,IACE,aAAa,EAAKysB,uBAAuBrhB,EAAQe,gBAAgBF,IACjE,MAAOka,GAEP,OADA,EAAKwH,SAASlC,EAAM7f,QACbua,KARQ,GAabva,SAAS,4CACb,QAAK,EAAK4gB,KAAKzL,UAAQrc,OAAO1E,UAG9ByG,EAAM,mBACA,EAAKknB,SAASlC,EAAM7f,SACnB,KANM,GAUTL,QAAQN,GAAO,4CACnB,aAAa,EAAKuO,aAAayJ,EAAW1X,QAAQN,MAD/B,GAIfmN,WAAW,4CACf,aAAa,EAAKoB,aAAayJ,EAAW7K,cAD3B,GAIXE,WAAW,4CACf,aAAa,EAAKkB,aAAayJ,EAAW3K,cAD3B,GAIXE,WAAW,4CACf,aAAa,EAAKgB,aAAayJ,EAAWzK,cAD3B,GAIXE,UAAU,4CACd,aAAa,EAAKc,aAAayJ,EAAWvK,aAD5B,GAIVhO,QAAQ,4CAEZ,GADa,EAAK8hB,KAAKzL,UAAQrc,OAAO1E,QAItC,aAAa,EAAK2tB,SAASnC,EAAgB9gB,SAL/B,GAWRkO,wBAAwBC,GAAa,4CACzC,aAAa,EAAKW,aAChByJ,EAAWrK,wBAAwBC,MAFI,GAMrCE,cAAcC,GAAY,4CAC9B,aAAa,EAAKkT,SAASjJ,EAAWlK,cAAcC,MADtB,GAI1BE,iBAAiBF,GAAY,4CACjC,aAAa,EAAKkT,SAASjJ,EAAW/J,iBAAiBF,MADtB,GAI7BI,uBAAuB,4CAC3B,aAAa,EAAK8S,SAASjJ,EAAW7J,0BADX,GAKvB6U,cAAc,iCAClB,OAAO,IADW,GAIdzS,SAAS/gB,GAAM,4CACnB,MAAMujB,EAAc,EAAKwO,KAAKhe,UAAK3J,QAAQ8Y,YAAYK,aACjDI,EAAO,EAAKoO,KAAKhe,UAAK3J,QAAQ8Y,YAAYS,MAC1C5W,EAAgB,EAAKglB,KAAKhe,UAAK3J,QAAQ2C,eAE7C,aAAa,EAAKmmB,SAChBpC,EAAUld,OACV2P,EAAYvjB,GACZ2jB,EAAK3jB,GACL+M,KATiB,GAafoL,YAAY,4CAChB,IAAK,EAAK4Z,KAAKzL,UAAQrc,OAAO1E,QAC5B,MAAO,GAET,IAAIge,EAAc,EAAKwO,KAAKhe,UAAK3J,QAAQ8Y,YAAYK,aACjDI,EAAO,EAAKoO,KAAKhe,UAAK3J,QAAQ8Y,YAAYS,MAC1C5W,EAAgB,EAAKglB,KAAKhe,UAAK3J,QAAQ2C,eACvC0mB,EAAU,GACd,IAAK,IAAKhQ,EAAYhgB,KAAQ,aAAekgB,GACvCF,KAAcF,IAChBkQ,EAAQhQ,SAAoB,EAAKyP,SAC/BpC,EAAUld,OACV2P,EAAYE,GACZhgB,EACAsJ,IAIN,OAAO0mB,IAlBS,GAqBZhoB,cAAc,4CAClB,OACG,EAAKsmB,KAAKzL,UAAQrc,OAAO1E,SACzB,EAAKwsB,KAAKvoB,UAAIY,QAAQtE,KAAKsF,iBAIjB,EAAK8nB,SAASpC,EAAUjd,mBAF5B,OALS,GAUpBxJ,YACE,OAAKiY,KAAKyP,KAAKzL,UAAQrc,OAAO1E,QAGvB+c,KAAKyP,KAAK9M,UAAW7a,QAAQya,QAF3B,KAKXI,aACE,OAAK3C,KAAKyP,KAAKzL,UAAQrc,OAAO1E,QAGvB+c,KAAKyP,KAAK9M,UAAW7a,QAAQic,aAF3B,KAKXqN,UACE,OAAOpR,KAGHqR,wBAAwBrkB,GAAc,4CAC1C,IAAI,SAAE3I,EAAF,QAAYiG,GAAYujB,EAAQqB,UAAUliB,GAC9C,aAAa,EAAKmiB,SAAS9gB,EAAQuC,gBAAgBtG,EAASjG,MAFlB,GAKtCqM,gBAAgB,4CACpB,aAAa,EAAKye,SAAS9gB,EAAQqC,mBADf,GAItB,gBACE,OAAO,IAAAqd,sBAAqB,CAC1B7iB,cACAuG,eACA7O,gBACAsE,cACAiE,mBACAwX,qBACAqB,kBACAkC,WAAYqI,a,UA5aGV,G,cCjCrBjxB,EAAOD,QAAUwC,QAAQ,kC,cCAzBvC,EAAOD,QAAUwC,QAAQ,0B,6BCCvBvC,EAAOD,QAAUwC,EAAQ,K,8ECD3B,I,EAAA,Q,8CACemyB,W,wFCKA,SACbxC,EACAhgB,EACAyiB,EACAC,EACAC,GAEA,MAAM5C,GAAiB,eAElB4C,IACHA,EAAmBC,WAGrB,IAAIlM,GAAQ,IAAAmM,aACV7C,EACA0C,EAEAC,GAAiB,IAAAG,iBAAgB/C,KAKnC,OAFAA,EAAegC,IAAI/hB,KAASyiB,GAErB,CAAE/L,QAAOqJ,mBA5BlB,I,IAAA,MAGA,O,IACA,O,oDAHc,aAAY,0B,cCD1BjyB,EAAOD,QAAUwC,QAAQ,e,cCAzBvC,EAAOD,QAAUwC,QAAQ,4B,cCAzBvC,EAAOD,QAAUwC,QAAQ,mB,gFCCTypB,KAAT,SAAc3Z,GACnB,MAAO,CACL/M,KAAMuoB,EACNxb,a,EAKYgZ,QAAT,SAAiB/Y,GACtB,MAAO,CACLhN,KAAMyoB,EACNzb,W,EAKYyZ,YAAT,SAAqB1kB,EAASyD,GACnC,MAAO,CACLxF,KAAM0oB,EACN3mB,UACAyD,U,EAKYghB,cAAT,SAAuBzkB,EAASC,GACrC,MAAO,CACLhC,KAAMsoB,EACNvmB,UACAC,W,EAKYmlB,aAAT,SAAsBzmB,GAC3B,MAAO,CACLV,KAAMimB,EACNvlB,U,EAKYonB,YAAT,UAAqB,QAC1B/lB,EAD0B,OAE1BC,EAF0B,KAG1BuN,EAH0B,eAI1BpJ,EAJ0B,OAK1BV,EAL0B,OAM1BoY,EAN0B,MAO1B3hB,EAP0B,SAQ1BymB,EAR0B,MAS1Bnd,IAEA,MAAO,CACLxF,KAAMmmB,EACNpkB,UACAC,SACAuN,OACApJ,iBACAV,SACAoY,SACA3hB,QACAymB,WACAnd,U,EAKYrF,MAAT,SAAeA,GACpB,MAAO,CACLH,KAAMkmB,EACN/lB,UAxEG,MAAMooB,EAAYA,EAAZA,UAAY,YAQlB,MAAME,EAAUA,EAAVA,QAAU,sBAQhB,MAAMC,EAAeA,EAAfA,aAAe,eASrB,MAAMJ,EAAiBA,EAAjBA,eAAiB,iBASvB,MAAMrC,EAAgBA,EAAhBA,cAAgB,gBAQtB,MAAME,EAAeA,EAAfA,aAAe,eA0BrB,MAAMD,EAAaA,EAAbA,WAAa,c,iGCpE1B,M,IAGA,OACA,Q,mDAHA,MAAM1e,GAAQ,aAAY,yB,UAKX,MACbilB,YAAY1f,GACV+Q,KAAK1M,KAAO,IAAI6W,UAAKlb,GAGjBka,SAASja,GAAQ,4CACrB,IAAI4C,QAAe,IAAA+f,WAAU,EAAKve,KAAKwe,gBAAgBC,KAApC,CAGjB,CACEC,QAAS,MACTC,OAAQ,yBACRC,OAAQ,CAAChjB,EAAQ,IACjB9N,IAAI,IAAI+wB,MAAOC,YAGnB,GAAItgB,EAAOzP,MACT,MAAM,IAAI0tB,MAAMje,EAAOzP,MAAM0f,SAE7B,OAAOjQ,EAAOA,OAAOugB,aAdF,GAkBjB/I,eAAepa,GAAQ,4CAC3B,aAAa,EAAKoE,KAAKgf,IAAIhJ,eAAepa,KADf,GAIvBqa,WAAWra,GAAQ,4CACvB,aAAa,EAAKoE,KAAKgf,IAAIC,sBAAsBrjB,KAD1B,GAInBsa,SAASgJ,GAAmB,4CAChC,aAAa,EAAKlf,KAAKgf,IAAI9I,SAASgJ,KADJ,GAU5BjI,gBAAgBtmB,EAASyD,GAAO,4CACpCgC,EAAM,+BAAgCzF,GACtC,IAAIwF,QAAa,EAAK6J,KAAKgf,IAAIG,QAAQxuB,EAASyD,GAChD,MAAgB,QAAT+B,EAAiB,KAAOA,IAHK,M,cC/CxC7M,EAAOD,QAAUwC,QAAQ,S,cCAzBvC,EAAOD,QAAUwC,QAAQ,e,0GC0CR2P,O,EAmFA4jB,qB,EAwFA7jB,OAAV,YACLnF,EAAM,mBACC+H,EAAK9D,cACLxC,EAAS0D,eACT3H,EAAI2H,eACJjM,EAAMiM,eACN8T,EAAW9T,eACZ,IAAAT,KAAIC,EAAQR,sBA5NpB,I,IAAA,MAGA,OAEA,OAEY3C,E,EAAZ,OACYgb,E,EAAZ,OACY/a,E,EAAZ,OACYwX,E,EAAZ,OACYzb,E,EAAZ,OACYtE,E,EAAZ,OACY6O,E,EAAZ,OACY6B,E,EAAZ,OAEYjF,E,EAAZ,O,IAEA,O,4MAjBA,MAAM3E,GAAQ,aAAY,0BAmBpBipB,EAAa,CACjB,CAACtkB,EAAQgB,kBA4MX,WAAe,OAAEH,UACRwjB,EAAmBxjB,IA1M1B,CAACb,EAAQwC,kBAmEX,WAA0B,QAAEvG,EAAF,SAAWjG,IACnCqF,EAAM,qCACCkpB,EAAevuB,GAEtBqF,EAAM,oCACCmpB,EAAcvoB,GAErBZ,EAAM,8BACCxC,EAAIyd,oBA1EX,CAACtW,EAAQsC,iBA6EX,YAGE,GAFAjH,EAAM,cAAesa,mBACC,IAAAzV,QAAOyV,UAAQrc,OAAO8c,YAG1C,OAEF/a,EAAM,kCACA,IAAA+e,MAAKhX,EAAK3C,MAEhBpF,EAAM,uBAECwB,EAAI4nB,WAGXppB,EAAM,iCACC+H,EAAKU,0BAELvP,EAAM0L,4BAEP,IAAAF,KAAIC,EAAQmC,iBA9FpB,SAAUuiB,IACR,OAAa,CACX,IAAI7K,QAAe,IAAAzZ,OAAK,aAAYkkB,IAChC7jB,EAAO6jB,EAAWzK,EAAOhmB,YAEvB,IAAAkM,KAAIC,EAAQqB,cACZ,IAAA6b,MAAK,CACTC,MAAM,IAAAluB,MAAKwR,EAAMoZ,GACjB5Y,WAAW,IAAAb,MAAKJ,EAAQkB,mBAEpB,IAAAnB,KAAIC,EAAQmB,UAIf,SAAUV,EAAK8f,GACpBllB,EAAM,4BA8FR,UAAwBklB,SAChB,IAAAnG,MAAKsK,GAEX,IAAIC,EAAW,CAAC9rB,EAAKiE,EAAUwX,GAC1BiM,EAAcnK,WACjBuO,EAAS5Q,KAAK3Q,GAEhB,IAAIwhB,EAAY,CAACrwB,EAAOsjB,EAAY5S,GACpC,MAAMzP,EAAiBmvB,EAASpyB,OAC1BsyB,EAAOF,EAAShd,OAAOid,GAE7B,aADOrwB,EAAMqL,kBAAkBpK,SAClB,IAAA2kB,KAAI0K,EAAKlrB,IAAImrB,IAAO,IAAA1K,MAAK0K,EAAIrkB,QAxGnCskB,CAAcxE,GAGrBllB,EAAM,oCACN,IAAI,SAAErF,EAAF,QAAYiG,SAAkB,IAAAmE,MAAKJ,EAAQyB,kBAE/CpG,EAAM,qCACCkpB,EAAevuB,GAEtBqF,EAAM,oCACCmpB,EAAcvoB,GAErBZ,EAAM,qBAEN,IAAI,OAAEwF,EAAF,SAAUD,SAAmB,IAAAR,MAAKJ,EAAQc,OAC9CzF,EAAM,YAEDklB,EAAcnK,WAUjB/a,EAAM,4BACA,IAAA0E,KAAIC,EAAQiC,kBAVlB5G,EAAM,uBAECwB,EAAI4nB,WAGXppB,EAAM,iCACC+H,EAAKU,qBAQdzI,EAAM,8BACC4J,EAAKsV,KAAK3Z,QAIFxP,IAAXyP,UACKwjB,EAAmBxjB,IAG5BxF,EAAM,kBAuHR,kBACQ,IAAA0E,KAAIC,EAAQmB,SAtHXA,GAsCF,SAAUkjB,EAAmBxjB,GAElCxF,EAAM,6BACN,IAAI2pB,QAuBN,UAAkBnkB,GAChB,IAAI4C,QAAgBwB,EAAK0U,mBAAmB9Y,GAG5C,GAFAxF,EAAM,YAAaoI,GAEfA,EAAOzP,MACT,OAAOyP,EAAOzP,MAIhBqH,EAAM,kCACN,IAAI4e,QAAmB1lB,EAAM+L,aAAamD,EAAOlP,OAE7CkP,EAAO7N,UAAYqkB,EAAU/oB,SAASuS,EAAO7N,UAC/CqkB,EAAUlG,KAAKtQ,EAAO7N,SAItB6N,EAAO5N,QACP4N,EAAOnK,SACN2gB,EAAU/oB,SAASuS,EAAOzJ,iBAE3BigB,EAAUlG,KAAKtQ,EAAOzJ,gBAGxB,IAAIiS,EAAcxI,EAAOpK,MAAM6X,OAAOC,WACtC9V,EAAM,sBACN,IAAIrC,QAAkBiM,EAAKiH,eAAe+N,EAAWhO,GAErD5Q,EAAM,6BACA,IAAA8e,KACJF,EAAUtgB,IAAI,CAAC/D,EAAS9G,KAAM,IAAAG,MAAKg2B,EAAgBrvB,EAASoD,EAASlK,MAGvEuM,EAAM,8BACCxC,EAAI0d,MAAM9S,SACV3G,EAASyZ,cACTjC,EAAWiC,QA3DD2O,CAAQrkB,GACrBmkB,IACF3pB,EAAM,WAAY2pB,SA8EtB,UAAgBA,SACR,IAAAjlB,KAAIC,EAAQhM,MAAMgxB,IA9EfhxB,CAAMgxB,IA2DjB,SAAUT,EAAevuB,GACvB,IAAK,IAAII,KAAW,aAAcJ,SACzB6C,EAAIwd,WAAWjgB,GAI1B,SAAUouB,EAAcvoB,SACfa,EAASwgB,WAAWrhB,GAG7B,SAAUgpB,EAAervB,EAASC,SACzBgD,EAAIsT,YAAYvW,EAASC,G,WAlEnB,IAAAnE,YAAW,UAAW+O,I,yGCtEpBgkB,SAAV,YACL,IAAI9lB,QAAqB,IAAAuB,QAAOrD,UAAI6B,MAAMzC,SAEtCA,GAAU,cACZ,aAAc0C,GAAchF,IAAI,EAAGsD,UAAWA,IAC9CsD,OAAOgO,GAAKA,SAER,IAAA4L,KACJle,EACGsE,OAAO,EAAG1D,SAAUA,GACpBlD,IAAI,EAAGkD,MAAK9J,KAAIqJ,oBAAoB,IAAAnN,MAAKk2B,EAAM/oB,EAAerJ,EAAI8J,KAGvExB,EAAM,kBA9ER,I,IAAA,MAGA,OAEY+H,E,wJAAZ,O,IAEA,O,IAEA,O,IACA,O,mDATA,MAAM/H,GAAQ,aAAY,sBAW1B,SAAU8pB,EAAK/oB,EAAerK,EAAUd,EAAMe,EAAU,GAAI2Q,EAAW,MAKrE,GAJAtH,EAAM,mBAAoBtJ,EAAUC,EAASf,SAoB/C,UAAsBmL,EAAerK,EAAUd,EAAMe,EAAS2Q,GAG5D,GAFAtH,EAAM,iBAAkBtJ,EAAUC,KAE5Bf,aAAgBzB,QACpB,YAGc4B,IAAZH,EAAK8B,KACPsI,EAAM,wBAAyBrJ,EAASf,EAAK8B,UACtCqQ,EAAKX,MAAMxR,EAAK8B,GAAIf,EAAS2Q,EAAU5Q,EAAUqK,IAG1D,OAAQnL,EAAKE,UACX,IAAK,sBACHkK,EAAM,2BAA4BrJ,EAASf,SACpCmS,EAAKR,QAAQ3R,EAAMmL,GAC1B,MACF,IAAK,qBACL,IAAK,mBACL,IAAK,iBACHf,EAAM,uBAAwBrJ,EAASf,SAChCmS,EAAKJ,WAAW/R,EAAMmL,IAvC1BgpB,CAAYhpB,EAAerK,EAAUd,EAAMe,EAAS2Q,GAEvD0iB,MAAMC,QAAQr0B,GAChB,IAAK,IAAKnC,EAAGy2B,KAAUt0B,EAAKu0B,gBACnBL,EAAK/oB,EAAerK,EAAUwzB,EAAQ,GAAEvzB,KAAWlD,IAAK6T,QAE5D,GAAI1R,GAA0B,aAAlBA,EAAKE,eA4D1B,UAAoBiL,EAAerK,EAAUd,EAAMe,EAAS2Q,SAY5D,SAAU8iB,EACRrpB,EACArK,EACAd,EACAe,EACAsE,EACAovB,EACA/iB,GAYA,SAiDF,UACEvG,EACArK,EACAd,EACAe,EACAsE,EACAovB,EACA/iB,GAIA,GAFAtH,EAAM,iBAAkBtJ,EAAUC,IAE7Bf,EACH,YAGeG,IAAbH,EAAK0e,MACPtU,EAAM,kBACC+H,EAAKP,SAAS7Q,EAASD,EAAUqK,EAAeuG,IAGzD,GAAsB,iBAAlB1R,EAAKE,SAA6B,CACpC,IAAI4R,EAWR,SAAS4iB,EAAoB10B,EAAMe,EAASsE,EAAMovB,GAGhDrqB,EAAM,cAAerJ,GACrBqJ,EAAM,kBAAmBqqB,GACzB,IAAIE,EAAkB5zB,EAAQM,MAAMozB,EAAYnzB,QAChD8I,EAAM,sBAAuBuqB,GAC7B,IAAIC,EAAwBD,EAAgBld,QAAQ,WAAY,IAC5DD,EAAgBid,EAAcG,EAClCxqB,EAAM,oBAAqBoN,GAC3B,IAAIE,EAASC,UAAYjZ,IAAI2G,EAAMuvB,GAInC,MAAsB,aAAlB50B,EAAKE,SACiB,eAApBwX,EAAOxX,UACLa,IAAeyW,EAAF,OAGRA,EAKFzW,EAEkB,0BAAlBf,EAAKE,SACPa,EAEA2zB,EAAoBhd,EAAQF,EAAenS,EAAMovB,GAxCrCC,CAAoB10B,EAAMe,EAASsE,EAAMovB,SACrDtiB,EAAKN,WACV7R,EACAe,EACA+Q,EACAhR,EACAqK,IAtFG0pB,CACL1pB,EACArK,EACAd,EACAe,EACAsE,EACAovB,EACA/iB,GAGE0iB,MAAMC,QAAQr0B,GAChB,IAAK,IAAKnC,EAAGy2B,KAAUt0B,EAAKu0B,gBACnBC,EACLrpB,EACArK,EACAwzB,EACC,GAAEvzB,KAAWlD,IACdwH,EACAovB,QAGC,GAAIz0B,aAAgBzB,OACzB,IAAK,IAAKa,EAAKk1B,KAAU,aAAet0B,SAC/Bw0B,EACLrpB,EACArK,EACAwzB,EACC,GAAEvzB,KAAW3B,IACdiG,EACAovB,SAgBR,UACEtpB,EACArK,EACAd,EACAe,EACAsE,EACAovB,EACAK,GAEA1qB,EAAM,gBAAiBtJ,EAAUC,GApB1Bg0B,CACL5pB,EACArK,EACAd,EACAe,GA1DKyzB,CACLrpB,EACArK,EACAd,EACAe,EACAf,EACAe,EACA2Q,GAlEOsjB,CAAU7pB,EAAerK,EAAUd,EAAMe,EAAS2Q,QACpD,GAAI1R,aAAgBzB,OACzB,IAAK,IAAKa,EAAKk1B,KAAU,aAAet0B,SAC/Bk0B,EAAK/oB,EAAerK,EAAUwzB,EAAQ,GAAEvzB,KAAW3B,IAAOY,EAAK8B,UAiC5E,UAAqBqJ,EAAerK,EAAUd,EAAMe,GAClDqJ,EAAM,gBAAiBtJ,EAAUC,GA9B1Bk0B,CAAW9pB,EAAerK,EAAUd,EAAMe,K,8EC9BnD,I,IAAA,MAGA,O,IAEA,O,IACA,O,IACA,O,IACA,O,IACA,O,IACA,OAEYgO,E,wJAAZ,O,mDAXA,MAAM3E,GAAQ,aAAY,6BAqF1B,MAAMsa,GAAU,IAAAwQ,iBAAgB,CAC9BhlB,MAzEF,SAAezM,GAAQ,EAAOmlB,GAC5B,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQoB,MAEX,OADA/F,EAAM,aACC,EAET,KAAK2E,EAAQsB,KACX,OAAO,EAET,QACE,OAAO5M,IAgEXshB,iBA5DF,SAA0BthB,EAAQ,KAAMmlB,GACtC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQuB,MAEX,OADAlG,EAAM,YAAawe,EAAO7lB,OACnB6lB,EAAO7lB,MAEhB,KAAKgM,EAAQsB,KACX,OAAO,KAET,QACE,OAAO5M,IAmDXO,YA/CF,SAAqBP,EAAQ,GAAImlB,GAC/B,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQ2B,iBACX,OAAOkY,EAAO5kB,YAChB,KAAK+K,EAAQP,mBACX,MAAO,GACT,QACE,OAAO/K,IAyCXmN,QArCF,SAAiBnN,EAAQ,GAAImlB,GAC3B,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQ8B,aACX,OAAO+X,EAAOhY,QAChB,KAAK7B,EAAQP,mBACX,MAAO,GACT,QACE,OAAO/K,IA+BX2E,MA3BF,SAAe3E,EAAQ,GAAImlB,GACzB,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQgC,WACX,OAAO6X,EAAOxgB,MAChB,KAAK2G,EAAQP,mBACX,MAAO,GACT,QACE,OAAO/K,IAqBX0hB,UAjBF,SAAmB1hB,GAAQ,EAAOmlB,GAChC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQkC,eACX,OAAO,EACT,KAAKlC,EAAQoC,cACX,OAAO,EACT,QACE,OAAO1N,MAaP0xB,GAAc,IAAAD,iBAAgB,CAClCxQ,UACAvS,eACAvK,cACAiE,mBACAwX,qBACA/f,gBACAsjB,uB,UAGauO,G,iICzGf,MAGA,OAEYpmB,E,EAAZ,OAEY1O,E,EAAZ,MACA,O,4MAPA,MAAM+J,GAAQ,aAAY,0BASpBgrB,EAAiB,CACrBtpB,gBAAiB,IA2GnB,MAAMupB,EAAsB,CAC1BlyB,QAAS,GACTF,OAAQ,GACRqb,IAAK,GACL7a,MAAO,IAiBT,MAAMoE,GAAO,IAAAqtB,iBAAgB,CAC3BxgB,OA9HF,SAAgBjR,EAAQ2xB,EAAgBxM,GACtC,IAAIpX,EACA8jB,EACA/e,EAEJ,OAAQqS,EAAOhmB,MACb,KAAKmM,EAAQqY,MAAO,CAClB,MAAM,cAAEjc,EAAF,GAAiBrJ,EAAjB,SAAqBhB,EAArB,SAA+B4Q,EAA/B,QAAyC3Q,GAAY6nB,EACrD/R,OAAgB1W,IAAP2B,EAAmBA,GAAK,IAAAjB,UAASC,EAAUC,GAmC1D,OA7BAu0B,EAAW,CACTxpB,iCACKrI,EAAMqI,gBADX,CAEE,CAACX,IAAD,gBACK1H,EAAMqI,gBAAgBX,OAO/BmqB,EAASxpB,gBAAgBX,IAAzB,gBACKmqB,EAASxpB,gBAAgBX,GAD9B,CAEEmU,0BACKgW,EAASxpB,gBAAgBX,GAAemU,YAI/C9N,EAAQ8jB,EAASxpB,gBAAgBX,GAAemU,SAASzI,GAEzDye,EAASxpB,gBAAgBX,GAAemU,SAASzI,IAAjD,gBACKrF,EADL,CAEE1P,KACAhB,WACA4Q,WACA3Q,UACAoK,kBAGKmqB,EAGT,KAAKvmB,EAAQuY,QAAS,CACpB,IAAI,cAAEnc,EAAF,KAAiB/M,EAAjB,OAAuByY,EAAvB,YAA+BwQ,GAAgBuB,EAMnD,OAHApX,EAAQ/N,EAAMqI,gBAAgBX,GAAemU,SAAS+H,IAAgB,GACtE9Q,EAAY/E,EAAM+E,WAAa,GAExB,CACLzK,iCACKrI,EAAMqI,gBADX,CAEE,CAACX,IAAD,gBACK1H,EAAMqI,gBAAgBX,GAD3B,CAEEmU,0BACK7b,EAAMqI,gBAAgBX,GAAemU,SAD1C,CAGE,CAAC+H,IAAD,gBACK7V,EADL,CAGE+E,UAAW,IACNA,EAEH,CACEnY,OACAyY,SACA1L,2BAUhB,QACE,OAAO1H,IA8CXyO,iBAnCF,SAA0BzO,EAAQ,GAAImlB,GACpC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQ2Y,YACX,MAAO,IACFjkB,EACH,CAAE3B,GAAI8mB,EAAO5oB,KAAK8B,GAAIqJ,cAAeyd,EAAOzd,gBAEhD,QACE,OAAO1H,IA4BX2O,YAjBF,SAAqB3O,EAAQ4xB,EAAqBzM,GAChD,OAAIA,EAAOhmB,OAASmM,EAAQ4Y,SACnB,CACLxkB,QAASylB,EAAOzlB,QAChBF,OAAQ2lB,EAAO3lB,OACfqb,IAAKsK,EAAOtK,IACZ6B,SAAUyI,EAAOzI,SACjB1c,MAAOmlB,EAAOnlB,OAGTA,KAUL8xB,EAAqB,CACzB,CAAC,CAAE9T,QAAS,OAAS,CAAE1K,SAAU,UAAWye,QAAS,QACrD,CAAC,CAAE/T,QAAS,MAAQ,CAAE1K,SAAU,UAAWye,QAAS,OACpD,CAAC,CAAE/T,QAAS,SAAW,CAAE1K,SAAU,UAAWye,QAAS,UACvD,CAAC,CAAE/T,QAAS,QAAU,CAAE1K,SAAU,UAAWye,QAAS,SACtD,CAAC,CAAE/T,QAAS,OAAS,CAAE1K,SAAU,UAAWye,QAAS,eACrD9sB,IAAI,EAAE9G,EAAOC,MAAS,IAAAF,gBAAeC,EAAOC,IAExC4zB,EAAsB,CAC1BzpB,MAAM,aACJ,MACGupB,EAAmB7sB,IAAIyL,IAAcA,CAAG,CAACA,EAAWrS,IAAKqS,MAE9DrI,gBAAiB,GACjBmW,WAAW,aACT,MACGsT,EAAmB7sB,IAAIyL,IAAcA,CACtC,CAACA,EAAWsN,SAAU,CAACtN,EAAWrS,SAgDxC,MAAM4zB,EAAgB,CACpB5V,UAAW,IAsHb,MAAMpc,GAAO,IAAAwxB,iBAAgB,CAC3B9gB,YAnKF,SAAqB3Q,EAAQgyB,EAAqB7M,GAChD,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQwY,OACb,KAAKxY,EAAQ0Y,oBAGX,OAFArd,EAAM,iBAAkBwe,EAAOhmB,MAC/BwH,EAAM,wBAAyBwe,EAAOxU,cAC/B,aAAcwU,EAAOxU,aAAauhB,OAAO,CAACC,EAAKzhB,KACpD,IAAI,GAAErS,EAAF,OAAM+U,EAAN,cAAc1L,GAAkBgJ,EAGpC,uBACKyhB,EADL,CAEE5pB,sBACK4pB,EAAI5pB,KADT,CAEE,CAAClK,GAAKqS,IAERrI,iCACK8pB,EAAI9pB,gBADT,CAEE,CAACX,IAAD,gBACKyqB,EAAI9pB,gBAAgBX,GADzB,CAEEmU,2BACMsW,EAAI9pB,gBAAgBX,IAAkB,IAAImU,SADhD,CAEE,CAACzI,GAAS,IACL,IAAI,EAAJ,QAAQ,MACH+e,EAAI9pB,gBAAgBX,IAAkB,IAAImU,UAC9C,IAAIzI,IAAW,GACjB/U,cAOX2B,GAEL,KAAKsL,EAAQT,MACX,OAAOmnB,EAET,QACE,OAAOhyB,IA6HXoR,YAjHF,SAAqBpR,EAAQiyB,EAAe9M,GAC1C,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQ0Y,oBACX,IAAI,QAAE9iB,EAAF,KAAW4P,EAAX,eAAiB0F,EAAjB,WAAiCuN,GAAeoB,EAmBpDxe,EAAM,oBAAqB6P,GAC3BA,EAAiB5Z,EAAMC,IAAIC,MAAMs1B,yBAAyB5b,GAC1DuN,EAAannB,EAAMC,IAAIC,MAAMs1B,yBAAyBrO,GAEtDpd,EAAM,UAAWmK,GACjB,IAAIuhB,EAAiBz1B,EAAMkC,WAAWC,YACpCnC,EAAM6S,QAAQ3S,MAAMw1B,YAAYxhB,GAChClU,EAAMoC,IAAIlC,MAAMmC,WAEdszB,EAAgBzhB,EAAKpO,KACrB9F,EAAMkC,WAAWC,YACfnC,EAAM6S,QAAQ3S,MAAMw1B,YAAYxhB,EAAKpO,MACrC9F,EAAMoC,IAAIlC,MAAMmC,gBAElBvC,EAIAm1B,GAAWA,EAAXA,cACC7xB,EADD,CAEFqc,2BACKrc,EAAMqc,UADX,CAEE,CAACnb,GAAU,CACTob,yBACMtc,EAAMqc,UAAUnb,IAAY,CAAEob,OAAQ,KAAMA,aA2BxD,GApBAuV,EAASxV,UAAUnb,GAASob,QAA5B,gBACKuV,EAASxV,UAAUnb,GAASob,OADjC,CAEE,CAAC9F,GAAiB,CAChB+F,gCAEIsV,EAASxV,UAAUnb,GAASob,OAAO9F,IAAmB,CACpD+F,cAAe,KAEjBA,uBAYQ7f,IANdm1B,EAASxV,UAAUnb,GAASob,OAAO9F,GAAgB+F,cACjD8V,GAKuB,CACzB,IAAIG,EACJ7rB,EAAM,mBAAoB4rB,GAUxBC,OARkB91B,IAAlB61B,GACAV,EAASxV,UAAUnb,GAASob,OAAOyH,IACnC8N,EAASxV,UAAUnb,GAASob,OAAOyH,GAAYxH,cAC7CgW,IAKFC,gBACK1hB,EADL,CAEEpO,KACEmvB,EAASxV,UAAUnb,GAASob,OAAOyH,GAAYxH,cAC7CgW,KAIIzhB,EAEZ+gB,EAASxV,UAAUnb,GAASob,OAAO9F,GAAgB+F,cACjD8V,GACEG,EAIN,OAAOX,EAET,KAAKvmB,EAAQT,MACX,OAAOonB,EAET,QACE,OAAOjyB,MASP+rB,GAAU,IAAA0F,iBAAgB,CAC9BrtB,OACAnE,S,UAGa8rB,G,gGCnVf,MAGA,OAEYzgB,E,EAAZ,OACY1O,E,EAAZ,M,IAEA,O,4MAPA,MAAM+J,GAAQ,aAAY,yBASpB8rB,EAAmB,CACvBpuB,UAAW,IA0Db,MAAMD,GAAO,IAAAqtB,iBAAgB,CAC3BnwB,SAxDF,SAAkBtB,EAAQyyB,EAAkBtN,GAC1C,OAAQA,EAAOhmB,MAIb,KAAKmM,EAAQ8Y,YACX,MAAM,QACJ1iB,EADI,aAEJgZ,EAFI,OAGJvZ,EAHI,UAIJqH,EAJI,cAKJ2Y,EALI,oBAMJjF,EANI,SAOJrV,EAPI,cAQJa,EARI,IASJmT,EATI,WAUJF,EAVI,aAWJC,EAXI,cAYJpZ,EAZI,iBAaJ2iB,GACEgB,EAGJ,OAFAxe,EAAM,YAAawe,IAEnB,gBACKnlB,EADL,CAEEqE,2BACKrE,EAAMqE,UADX,CAEE,CAAC3C,GAAU,CACTA,UACAgZ,eACAhZ,UACAP,SACAqH,YACA2Y,gBACAjF,sBACArV,WACAa,gBACAmT,MACAF,aACAC,eACApZ,gBACA2iB,mBACArJ,QAASle,EAAMoT,QAAQlT,MAAM41B,sBAAsB7X,QAQ3D,QACE,OAAO7a,MAQP2yB,EAAa,CACjB7Q,SAAU,IAAIhe,UAAG,GACjBygB,OAAQ3nB,EAAMoC,IAAIlC,MAAMuI,cAe1B,MAAMutB,EAAgB,CACpBjM,SAAU/pB,EAAMoC,IAAIlC,MAAMuI,aAC1BwhB,WAAY,IAAI/iB,UAAG,GACnBgjB,SAAU,IAAIhjB,UAAG,GACjB0Y,OAAQ,IAAI1Y,UAAG,GACfkjB,UAAW,IAAIljB,UAAG,IAcpB,MAAMW,GAAU,IAAAgtB,iBAAgB,CAC9B/sB,GAhCF,SAAY1E,EAAQ2yB,EAAYxN,GAC9B,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQkZ,aACX,IAAI,SAAE1C,EAAF,OAAYyC,GAAWY,EAC3B,MAAO,CAAErD,WAAUyC,UACrB,KAAKjZ,EAAQP,mBACX,OAAO4nB,EACT,QACE,OAAO3yB,IAyBX2E,MAbF,SAAe3E,EAAQ4yB,EAAezN,GACpC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQkZ,aACX,OAAOW,EAAOxgB,MAChB,KAAK2G,EAAQP,mBACX,OAAO6nB,EACT,QACE,OAAO5yB,MAuCb,MAAMO,GAAc,IAAAkxB,iBAAgB,CAClChtB,UACAG,OAhCF,SAAgB5E,EAAQ,KAAMmlB,GAC5B,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQmZ,YACX,OAAOU,EAAOvgB,OAChB,KAAK0G,EAAQP,mBACX,OAAO,KACT,QACE,OAAO/K,IA0BX6E,YAtBF,SAAqB7E,EAAQ,KAAMmlB,GACjC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQoZ,KACb,KAAKpZ,EAAQqZ,OAGX,OAAc,OAAV3kB,EACKA,EAGAmlB,EAEX,KAAK7Z,EAAQP,mBACX,OAAO,KACT,QACE,OAAO/K,MAyCb,MAAM6yB,EAAgB,CACpB,CACEpsB,SAAU,KAgMd,MAAMxG,GAAO,IAAAwxB,iBAAgB,CAC3BzsB,UAlOF,SAAmBhF,EAAQ,GAAImlB,GAC7B,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQoZ,KAAM,CACjB,MAAM,QAAExjB,EAAF,KAAWwN,EAAX,eAAiBpJ,EAAjB,OAAiC0X,EAAjC,MAAyC3hB,GAAU8pB,EACzD,OAAOnlB,EAAMiT,OAAO,CAAC,CAAE/R,UAASwN,OAAMpJ,iBAAgB0X,SAAQ3hB,WAGhE,KAAKiQ,EAAQqZ,OAAQ,CACnB,MAAM,OAAExjB,EAAF,eAAUmE,EAAV,OAA0B0X,EAA1B,MAAkC3hB,GAAU8pB,EAClD,OAAOnlB,EAAMiT,OACX,CAAC,CAAE9R,SAAQuN,KAAM,KAAMpJ,iBAAgB0X,SAAQ3hB,WAKnD,KAAKiQ,EAAQsZ,YACb,KAAKtZ,EAAQuZ,cACb,KAAKvZ,EAAQwZ,KAGX,OAAO9kB,EAAMnC,OAAS,EAAImC,EAAMpC,MAAM,GAAI,GAAKoC,EAEjD,KAAKsL,EAAQT,MACb,KAAKS,EAAQP,mBACX,MAAO,GAET,QACE,OAAO/K,IAwMXsG,MA7LF,SAAetG,EAAQ6yB,EAAe1N,GACpC,IAAI0M,EAAUiB,EAEd,MAAMC,EAAqB,CAAC7T,EAAOhe,EAAS4P,EAAMzV,KAAvB,gBACtB6jB,EADsB,CAEzBzY,0BACKyY,EAAMzY,SADX,CAEE,CAACvF,IAAD,cACEwF,KAAM,KACNhF,QAAS,MACNwd,EAAMzY,SAASvF,GAHpB,CAIExB,0BACMwf,EAAMzY,SAASvF,IAAY,IAAIxB,QADrC,CAEE,CAACoR,GAAOzV,UAOV23B,EAAkB,CAAC9T,EAAOhe,EAASwF,EAAMhF,KAC7C,IAAIuxB,EAAe/T,EAAMzY,SAASvF,IAAY,CAAExB,QAAS,IACzD,uBACKwf,EADL,CAEEzY,0BACKyY,EAAMzY,SADX,CAEE,CAACvF,IAAD,gBACK+xB,EADL,CAEEvsB,KAAMA,EACNhF,QAASA,SAUXwxB,EAAW11B,GACfA,EAAMK,OAAS,EACXL,EAAMI,MAAM,GAAI,GAAGqV,OAAO,CAACzV,EAAMA,EAAMK,OAAS,KAChDL,EAEN,OAAQ2nB,EAAOhmB,MACb,KAAKmM,EAAQoZ,KAMX,OALA/d,EAAM,eACNA,EAAM,YAAa3G,GAIZ,IAAIA,EAAOA,EAAMA,EAAMnC,OAAS,IAEzC,KAAKyN,EAAQqZ,OAUX,OATAhe,EAAM,iBAMNkrB,EAAW,IAAI7xB,EAAOA,EAAMA,EAAMnC,OAAS,IAC3Ci1B,EAAWjB,EAASA,EAASh0B,OAAS,QAGSnB,IAA7Co2B,EAASrsB,SAAS0e,EAAO7f,iBACzB6f,EAAO7f,iBAAmB1I,EAAMoC,IAAIlC,MAAMuI,aAGnCwsB,GAGTA,EAASA,EAASh0B,OAAS,IAA3B,gBACKi1B,EADL,CAEErsB,0BACKqsB,EAASrsB,SADd,CAEE,CAAC0e,EAAO7f,gBAAiB,CACvB5F,QAAS,GACTgH,KAAM,KACNhF,QAAS,UAKRmwB,GAET,KAAKvmB,EAAQyZ,MAAO,CAClBpe,EAAM,gBAGN,MAAM,QAAEzF,EAAF,KAAW4P,EAAX,MAAiBzV,GAAU8pB,EACjC,OAAIjkB,IAAYtE,EAAMoC,IAAIlC,MAAMuI,aAEvBrF,GAET6xB,EAAW7xB,EAAMpC,QACjBk1B,EAAWjB,EAASA,EAASh0B,OAAS,GACtCg0B,EAASA,EAASh0B,OAAS,GAAKk1B,EAC9BD,EACA5xB,EACA4P,EACAzV,GAEKw2B,GAGT,KAAKvmB,EAAQ0Z,KAAM,CACjBre,EAAM,eAIN,MAAM,QAAEzF,EAAF,KAAW4P,EAAX,MAAiBzV,GAAU8pB,EACjC,OAAIjkB,IAAYtE,EAAMoC,IAAIlC,MAAMuI,aAEvBrF,GAET8yB,EAAW9yB,EAAMA,EAAMnC,OAAS,QACiBnB,IAA7Co2B,EAASrsB,SAASvF,GAASxB,QAAQoR,GAK9B9Q,EAMAA,EAAMiF,IAAIia,GACf6T,EAAmB7T,EAAOhe,EAAS4P,EAAMzV,KAK/C,KAAKiQ,EAAQsZ,YAKX,OAJAje,EAAM,oBAICusB,EAASlzB,GAElB,KAAKsL,EAAQuZ,cAAe,CAC1Ble,EAAM,sBAGN,MAAM,QAAEzF,EAAF,KAAWwF,EAAX,QAAiBhF,GAAYyjB,EAWnC,OAVA0M,EAAW7xB,EAAMpC,QAGjBi0B,EAASA,EAASh0B,OAAS,GAAKm1B,EAC9BnB,EAASA,EAASh0B,OAAS,GAC3BqD,EACAwF,EACAhF,GAEFiF,EAAM,eAAgBkrB,GACfqB,EAASrB,GAGlB,KAAKvmB,EAAQwZ,KAIX,OAHAne,EAAM,gBA3HMnJ,EA8HGwC,GA9HanC,OAAS,EAAIL,EAAMI,MAAM,GAAI,GAAKJ,EAgIhE,KAAK8N,EAAQT,MAEX,OADAlE,EAAM,gBACC,CAAC3G,EAAM,IAEhB,KAAKsL,EAAQP,mBAEX,OADApE,EAAM,iBACCksB,EAET,KAAKvnB,EAAQ+Y,aAAc,CAGzB1d,EAAM,mBACN,MAAM,QAAEzF,EAAF,OAAWC,EAAX,QAAmBO,GAAYyjB,EACrC,OAAOnlB,EAAMiF,IAAIia,GACf8T,EAAgB9T,EAAOhe,EAASC,EAAQO,IAI5C,QACE,OAAO1B,EAnJKxC,SA4JZuuB,GAAU,IAAA0F,iBAAgB,CAC9BrtB,OACA7D,cACAN,S,UAGa8rB,G,iHClYf,OAEYzgB,E,wJAAZ,O,mDAEA,MAAM6nB,EAAkB,CACtB9qB,gBAAiB,IAgCnB,MAAMjE,GAAO,IAAAqtB,iBAAgB,CAC3BlqB,QA9BF,SAAiBvH,EAAQmzB,EAAiBhO,GACxC,OAAQA,EAAOhmB,MAIb,KAAKmM,EAAQ6d,YAGX,MAAO,CACL9gB,iCACKrI,EAAMqI,iBACN,aACD,OACG,aAAe8c,EAAOlb,cAAchF,IAAI,EAAE5G,EAAIyuB,MAAN,CACzC,CAACzuB,GAAK,CACJkK,KAAMukB,SASlB,QACE,OAAO9sB,MAkEb,MAAMC,GAAO,IAAAwxB,iBAAgB,CAC3B9oB,mBA3DF,SAA4B3I,EAAQ,GAAImlB,GACtC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQ8d,KACX,IAAIyI,EAAW7xB,EAAMpC,QACrB,MAAMw1B,EA6CG,OADEzpB,EA5CWwb,EAAOzb,eA8CxB,EACW,MAATC,GACD,EAED,EAjDL,IAAI7L,EAAM+zB,EAASA,EAASh0B,OAAS,GACjCw1B,EAAWxB,EAASh0B,OAAS,EAAIg0B,EAASA,EAASh0B,OAAS,IAAM,EAEtE,OADAg0B,EAASA,EAASh0B,OAAS,GAAKy1B,KAAKC,IAAIz1B,EAAMs1B,EAAOC,EAAW,GAC1DxB,EAET,KAAKvmB,EAAQT,MACX,MAAO,CAAC,GAEV,KAAKS,EAAQP,mBACX,MAAO,GAET,KAAKO,EAAQ+d,cACX,OAAqB,IAAjBrpB,EAAMnC,OACD,CAAC,GAEH,IAAImC,EAAOA,EAAMA,EAAMnC,OAAS,GAAK,GAE9C,KAAKyN,EAAQge,gBAEX,OAAOtpB,EAAMnC,OAAS,EAAImC,EAAMpC,MAAM,GAAI,GAAKoC,EAEjD,QACE,OAAOA,EAqBb,IAAiB2J,GAYff,mBA7BF,SAA4B5I,EAAQ,KAAMmlB,GACxC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQie,oBAEb,KAAKje,EAAQge,gBACX,OAAO,EACT,KAAKhe,EAAQ+d,cAEb,KAAK/d,EAAQT,MACX,OAAOsa,EAAO0D,MAChB,KAAKvd,EAAQP,mBACX,OAAO,KACT,QACE,OAAO/K,MAmBP+rB,GAAU,IAAA0F,iBAAgB,CAC9BrtB,OACAnE,S,UAGa8rB,G,8EC7Gf,I,EAAA,O,oCAGA,OAEYzgB,E,wJAAZ,OAJA,MAAM3E,GAAQ,aAAY,2BAuD1B,MAAMpG,GAAc,IAAAkxB,iBAAgB,CAClCrxB,MAtBF,SAAeJ,EAAQ,KAAMmlB,GAC3B,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQlB,WACX,OAAO+a,EAAO/kB,MAChB,KAAKkL,EAAQP,mBAEX,OADApE,EAAM,aACC,KACT,QACE,OAAO3G,MAiBPC,GAAO,IAAAwxB,iBAAgB,CAC3B1xB,MAtDF,SAAeC,EAAQ,EAAGmlB,GACxB,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQb,KACX,OAAOzK,EAAQ,EAEjB,KAAKsL,EAAQT,MACb,KAAKS,EAAQP,mBACX,OAAO,EAET,QACE,OAAO/K,IA6CXK,SAzCF,SAAkBL,GAAQ,EAAOmlB,GAC/B,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQX,aACX,OAAO,EAET,KAAKW,EAAQT,MACb,KAAKS,EAAQP,mBACX,OAAO,EAET,QACE,OAAO/K,MAkCPa,GAAc,IAAA4wB,iBAAgB,CAClC3wB,eAnBF,SAAwBd,EAAQ,EAAGmlB,GACjC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQF,oBACX,OAAO+Z,EAAOha,MAChB,QACE,OAAOnL,MAiBP+rB,GAAU,IAAA0F,iBAAgB,CAC9BlxB,cACAN,OACAY,gB,UAGakrB,G,8EC3Ef,I,EAAA,O,oCAGA,OAEYzgB,E,wJAAZ,OAJA,MAAM3E,GAAQ,aAAY,gCA0D1B,MAAMolB,GAAU,IAAA0F,iBAAgB,CAC9B1Y,YArDF,SAAqB/Y,EAAQ,GAAImlB,GAC/B,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQ6N,eAEX,OACEnZ,EAAM6L,OACJqN,GACEA,EAAWxR,gBAAkByd,EAAOjM,WAAWxR,eAC/CwR,EAAW7b,WAAa8nB,EAAOjM,WAAW7b,UAC1C6b,EAAW3P,OAAS4b,EAAOjM,WAAW3P,MACtC2P,EAAW3c,OAAS4oB,EAAOjM,WAAW3c,MACxCsB,OAAS,EAGJmC,EAGAA,EAAMiT,OAAO,CAACkS,EAAOjM,aAIhC,KAAK5N,EAAQ+N,kBACX,OAAOrZ,EAAM6L,OACXqN,GACEA,EAAWxR,gBAAkByd,EAAOjM,WAAWxR,eAC/CwR,EAAW7b,WAAa8nB,EAAOjM,WAAW7b,UAC1C6b,EAAW3P,OAAS4b,EAAOjM,WAAW3P,MACtC2P,EAAW3c,OAAS4oB,EAAOjM,WAAW3c,MAI5C,KAAK+O,EAAQiO,uBACX,MAAO,GAET,QACE,OAAOvZ,IAmBX0jB,WAfF,SAAoB1jB,GAAQ,EAAOmlB,GACjC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQmO,eAEX,OADA9S,EAAM,0BACC,EACT,KAAK2E,EAAQqO,cAEX,OADAhT,EAAM,yBACC,EACT,QACE,OAAO3G,M,UASE+rB,G,8EChEf,I,EAAA,O,oCAGA,OACA,OAEYzgB,E,wJAAZ,QALc,aAAY,gCAkI1B,MAAMrL,GAAO,IAAAwxB,iBAAgB,CAC3BzsB,UA5HF,SAAmBhF,EAAQ,GAAImlB,GAC7B,IAAIqO,EACJ,OAAQrO,EAAOhmB,MACb,KAAKmM,EAAQ4e,QACX,IAAI,SAAE5W,EAAF,aAAY2W,EAAZ,aAA0B9N,GAAiBgJ,EAoB/C,OAnBAqO,EAAW,CACTr0B,KAAM,WACNggB,mBAAoB7L,EACpBpS,QAASlB,EAAMA,EAAMnC,OAAS,GAAGqD,QACjCqe,cACE0K,GAC2B,uBAA1BA,EAAaxtB,UACc,0BAA1BwtB,EAAaxtB,cAEXC,EADAutB,EAAatvB,KAEnB+f,aACEyB,GAA0C,uBAA1BA,EAAa1f,SACzB0f,EAAaxhB,UACb+B,GAMD,IAAIsD,EAAOwzB,GACpB,KAAKloB,EAAQ6e,SACX,IAAIrsB,EAAMkC,EAAMA,EAAMnC,OAAS,GAC/B,OAAIC,GAAoB,aAAbA,EAAIqB,KACNa,EAAMpC,MAAM,GAAI,GAEhBoC,EAEX,KAAKsL,EAAQ+d,cAQX,OAPAmK,EAAW,CACTr0B,KAAM,WACN+B,QAASikB,EAAOjkB,QAChBie,mBAAoBgG,EAAO7R,SAC3BiM,kBAAc7iB,EACdge,aAAcyK,EAAOzjB,QAAQgZ,cAExB,IAAI1a,EAAOwzB,GACpB,KAAKloB,EAAQ+e,eACX,OAAO,IAAA9sB,WACLyC,EACAmlB,EAAOiF,QACNlL,GAAyB,aAAfA,EAAM/f,MAErB,KAAKmM,EAAQT,MACX,MAAO,CAAC7K,EAAM,IAChB,KAAKsL,EAAQP,mBACX,MAAO,GACT,QAGE,OAAO/K,IAuEX6f,cAnEF,SAAuB7f,EAAQ,EAAGmlB,GAChC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQge,gBACX,OAAOtpB,EAAQ,EACjB,KAAKsL,EAAQ+e,eACb,KAAK/e,EAAQT,MACb,KAAKS,EAAQP,mBACX,OAAO,EACT,QACE,OAAO/K,IA2DX8f,aAvDF,SAAsB9f,EAAQ,KAAMmlB,GAClC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQ4e,QACb,KAAK5e,EAAQ6e,SACb,KAAK7e,EAAQmoB,aACb,KAAKnoB,EAAQge,gBACb,KAAKhe,EAAQgf,gBACb,KAAKhf,EAAQ+e,eACX,MAAM,SAAE/W,GAAa6R,EACrB,YAA2BzoB,IAAvB4W,EAAShM,OAAOjJ,GAEX2B,EAEFsT,EACT,KAAKhI,EAAQT,MACb,KAAKS,EAAQP,mBACX,OAAO,KACT,QACE,OAAO/K,IAsCX+f,oBAlCF,SAA6B/f,EAAQ,KAAMmlB,GACzC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQge,gBAGX,OAAOtpB,GAASmlB,EAAO5R,KACzB,KAAKjI,EAAQ+e,eACb,KAAK/e,EAAQT,MACb,KAAKS,EAAQP,mBACX,OAAO,KACT,QACE,OAAO/K,IAwBXggB,kBApBF,SAA2BhgB,EAAQ,KAAMmlB,GACvC,OAAQA,EAAOhmB,MACb,KAAKmM,EAAQge,gBAGX,OAAiB,OAAVtpB,EAAiBmlB,EAAOvgB,OAAS5E,EAC1C,KAAKsL,EAAQ+e,eACb,KAAK/e,EAAQT,MACb,KAAKS,EAAQP,mBACX,OAAO,KACT,QACE,OAAO/K,MAYP+rB,GAAU,IAAA0F,iBAAgB,CAC9BxxB,S,UAGa8rB,G,cC/IflyB,EAAOD,QAAUwC,QAAQ","file":"debugger.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Debugger\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Debugger\"] = factory();\n\telse\n\t\troot[\"Debugger\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 40);\n","module.exports = require(\"debug\");","import * as Codec from \"@truffle/codec\";\nimport stringify from \"json-stable-stringify\";\n\n/** AST node types that are skipped by stepNext() to filter out some noise */\nexport function isDeliberatelySkippedNodeType(node) {\n  const skippedTypes = [\n    \"ContractDefinition\",\n    \"VariableDeclaration\",\n    \"YulVariableDeclaration\",\n    \"YulBlock\"\n  ];\n  return skippedTypes.includes(node.nodeType);\n}\n\n//HACK\n//these aren't the only types of skipped nodes, but determining all skipped\n//nodes would be too difficult\nexport function isSkippedNodeType(node) {\n  const otherSkippedTypes = [\n    \"VariableDeclarationStatement\",\n    \"Mapping\",\n    \"Block\",\n    \"InlineAssembly\", //definitely do *not* add to deliberately skipped!\n    \"YulTypedName\"\n  ];\n  return (\n    isDeliberatelySkippedNodeType(node) ||\n    otherSkippedTypes.includes(node.nodeType) ||\n    node.nodeType.includes(\"TypeName\") || //HACK\n    //skip string literals too -- we'll handle that manually\n    (node.typeDescriptions !== undefined && //seems this sometimes happens?\n      Codec.Ast.Utils.typeClass(node) === \"stringliteral\")\n  );\n}\n\nexport function prefixName(prefix, fn) {\n  Object.defineProperty(fn, \"name\", {\n    value: `${prefix}.${fn.name}`,\n    configurable: true\n  });\n\n  return fn;\n}\n\nexport function makePath(sourceId, pointer) {\n  return `${sourceId}:${pointer}`;\n}\n\n/**\n * returns a new array which is a copy of array but with\n * elements popped from the top until numToRemove elements\n * satisfying the predicate have been removed (or until the\n * array is empty)\n */\nexport function popNWhere(array, numToRemove, predicate) {\n  let newArray = array.slice();\n  //I'm going to write this the C way, hope you don't mind :P\n  while (numToRemove > 0 && newArray.length > 0) {\n    let top = newArray[newArray.length - 1];\n    if (predicate(top)) {\n      numToRemove--;\n    }\n    newArray.pop();\n  }\n  return newArray;\n}\n\n/**\n * @return 0x-prefix string of keccak256 hash\n */\nexport function keccak256(...args) {\n  return Codec.Conversion.toHexString(\n    Codec.Evm.Utils.keccak256(...args),\n    Codec.Evm.Utils.WORD_SIZE\n  );\n}\n\n/**\n * Given an object, return a stable hash by first running it through a stable\n * stringify operation before hashing\n */\nexport function stableKeccak256(obj) {\n  return keccak256({ type: \"string\", value: stringify(obj) });\n}\n\n/*\n * used by data; takes an id object and a ref (pointer) and returns a full\n * corresponding assignment object\n */\nexport function makeAssignment(idObj, ref) {\n  let id = stableKeccak256(idObj);\n  return { ...idObj, id, ref };\n}\n\n/*\n * Given a mmemonic, determine whether it's the mnemonic of a calling\n * instruction (does NOT include creation instructions)\n */\nexport function isCallMnemonic(op) {\n  const calls = [\"CALL\", \"DELEGATECALL\", \"STATICCALL\", \"CALLCODE\"];\n  return calls.includes(op);\n}\n\n/*\n * returns true for mnemonics for calls that take only 6 args instead of 7\n */\nexport function isShortCallMnemonic(op) {\n  const shortCalls = [\"DELEGATECALL\", \"STATICCALL\"];\n  return shortCalls.includes(op);\n}\n\n/*\n * returns true for mnemonics for calls that delegate storage\n */\nexport function isDelegateCallMnemonicBroad(op) {\n  const delegateCalls = [\"DELEGATECALL\", \"CALLCODE\"];\n  return delegateCalls.includes(op);\n}\n\n/*\n * returns true for mnemonics for calls that delegate everything\n */\nexport function isDelegateCallMnemonicStrict(op) {\n  const delegateCalls = [\"DELEGATECALL\"];\n  return delegateCalls.includes(op);\n}\n\n/*\n * returns true for mnemonics for static calls\n */\nexport function isStaticCallMnemonic(op) {\n  const delegateCalls = [\"STATICCALL\"];\n  return delegateCalls.includes(op);\n}\n\n/*\n * Given a mmemonic, determine whether it's the mnemonic of a creation\n * instruction\n */\nexport function isCreateMnemonic(op) {\n  const creates = [\"CREATE\", \"CREATE2\"];\n  return creates.includes(op);\n}\n","module.exports = require(\"babel-runtime/helpers/extends\");","module.exports = require(\"@truffle/codec\");","module.exports = require(\"reselect-tree\");","module.exports = require(\"redux-saga/effects\");","module.exports = require(\"babel-runtime/core-js/object/entries\");","module.exports = require(\"redux\");","import { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nconst PAST_END_OF_TRACE = {\n  depth: -1, //this is the part that matters!\n  //the rest of this is just to look like a trace step\n  error: \"\",\n  gas: 0,\n  memory: [],\n  stack: [],\n  storage: {},\n  gasCost: 0,\n  op: \"STOP\",\n  pc: -1 //this is not at all valid but that's fine\n};\n\nlet trace = createSelectorTree({\n  /**\n   * trace.index\n   *\n   * current step index\n   */\n  index: state => state.trace.proc.index,\n\n  /*\n   * trace.loaded\n   * is a trace loaded?\n   */\n  loaded: createLeaf([\"/steps\"], steps => steps !== null),\n\n  /**\n   * trace.finished\n   * is the trace finished?\n   */\n  finished: state => state.trace.proc.finished,\n\n  /**\n   * trace.finishedOrUnloaded\n   *\n   * is the trace finished, including if it's unloaded?\n   */\n  finishedOrUnloaded: createLeaf(\n    [\"/finished\", \"/loaded\"],\n    (finished, loaded) => finished || !loaded\n  ),\n\n  /**\n   * trace.steps\n   *\n   * all trace steps\n   */\n  steps: state => state.trace.transaction.steps,\n\n  /**\n   * trace.stepsRemaining\n   *\n   * number of steps remaining in trace\n   */\n  stepsRemaining: createLeaf(\n    [\"./steps\", \"./index\"],\n    (steps, index) => steps.length - index\n  ),\n\n  /**\n   * trace.step\n   *\n   * current trace step\n   * HACK: if no steps,\n   * we will return a spoofed \"past end\" step\n   */\n  step: createLeaf(\n    [\"./steps\", \"./index\"],\n    (steps, index) =>\n      steps ? (steps.length > 0 ? steps[index] : PAST_END_OF_TRACE) : null //null if no tx loaded\n  ),\n\n  /**\n   * trace.next\n   *\n   * next trace step\n   * HACK: if at the end,\n   * we will return a spoofed \"past end\" step\n   */\n  next: createLeaf(\n    [\"./steps\", \"./index\"],\n    (steps, index) =>\n      index < steps.length - 1 ? steps[index + 1] : PAST_END_OF_TRACE\n  ),\n\n  /*\n   * trace.nextOfSameDepth\n   * next trace step that's at the same depth as this one\n   * NOTE: if there is none, will return undefined\n   * (should not be used in such cases)\n   */\n  nextOfSameDepth: createLeaf([\"./steps\", \"./index\"], (steps, index) => {\n    let depth = steps[index].depth;\n    return steps.slice(index + 1).find(step => step.depth === depth);\n  }),\n\n  /**\n   * trace.application\n   */\n  application: {\n    /**\n     * trace.application.submoduleCount\n     */\n    submoduleCount: state => state.trace.application.submoduleCount\n  }\n});\n\nexport default trace;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:evm:selectors\"); // eslint-disable-line no-unused-vars\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport BN from \"bn.js\";\n\nimport trace from \"lib/trace/selectors\";\n\nimport * as Codec from \"@truffle/codec\";\nimport {\n  keccak256,\n  isCallMnemonic,\n  isCreateMnemonic,\n  isShortCallMnemonic,\n  isDelegateCallMnemonicBroad,\n  isDelegateCallMnemonicStrict,\n  isStaticCallMnemonic\n} from \"lib/helpers\";\n\nconst ZERO_WORD = \"00\".repeat(Codec.Evm.Utils.WORD_SIZE);\n\nfunction determineFullContext(\n  { address, binary },\n  instances,\n  search,\n  contexts\n) {\n  let contextId;\n  let isConstructor = Boolean(binary);\n  if (address) {\n    //if we're in a call to a deployed contract, we must have recorded\n    //the context in the codex, so we don't need to do any further\n    //searching\n    ({ context: contextId, binary } = instances[address]);\n  } else if (isConstructor) {\n    //otherwise, if we're in a constructor, we'll need to actually do a\n    //search\n    contextId = search(binary);\n  } else {\n    //exceptional case: no transaction is loaded\n    return null;\n  }\n\n  if (contextId != undefined) {\n    //if we found the context, use it\n    let context = contexts[contextId];\n    return {\n      ...context,\n      binary\n    };\n  } else {\n    //otherwise we'll construct something default\n    return {\n      binary,\n      isConstructor\n    };\n  }\n}\n\n/**\n * create EVM-level selectors for a given trace step selector\n * may specify additional selectors to include\n */\nfunction createStepSelectors(step, state = null) {\n  let base = {\n    /**\n     * .trace\n     *\n     * trace step info related to operation\n     */\n    trace: createLeaf([step], step => {\n      if (!step) {\n        return null;\n      }\n      let { gasCost, op, pc } = step;\n      return { gasCost, op, pc };\n    }),\n\n    /**\n     * .programCounter\n     */\n    programCounter: createLeaf([\"./trace\"], step => (step ? step.pc : null)),\n\n    /**\n     * .isCall\n     *\n     * whether the opcode will switch to another calling context\n     */\n    isCall: createLeaf([\"./trace\"], step => isCallMnemonic(step.op)),\n\n    /**\n     * .isShortCall\n     *\n     * for calls that only take 6 arguments instead of 7\n     */\n    isShortCall: createLeaf([\"./trace\"], step => isShortCallMnemonic(step.op)),\n\n    /**\n     * .isDelegateCallBroad\n     *\n     * for calls that delegate storage\n     */\n    isDelegateCallBroad: createLeaf([\"./trace\"], step =>\n      isDelegateCallMnemonicBroad(step.op)\n    ),\n\n    /**\n     * .isDelegateCallStrict\n     *\n     * for calls that additionally delegate sender and value\n     */\n    isDelegateCallStrict: createLeaf([\"./trace\"], step =>\n      isDelegateCallMnemonicStrict(step.op)\n    ),\n\n    /**\n     * .isStaticCall\n     */\n    isStaticCall: createLeaf([\"./trace\"], step =>\n      isStaticCallMnemonic(step.op)\n    ),\n\n    /**\n     * .isCreate\n     * (includes CREATE2)\n     */\n    isCreate: createLeaf([\"./trace\"], step => isCreateMnemonic(step.op)),\n\n    /**\n     * .isCreate2\n     */\n    isCreate2: createLeaf([\"./trace\"], step => step.op === \"CREATE2\"),\n\n    /*\n     * .isStore\n     */\n    isStore: createLeaf([\"./trace\"], step => step.op === \"SSTORE\"),\n\n    /*\n     * .isLoad\n     */\n    isLoad: createLeaf([\"./trace\"], step => step.op === \"SLOAD\"),\n\n    /*\n     * .touchesStorage\n     *\n     * whether the instruction involves storage\n     */\n    touchesStorage: createLeaf(\n      [\"./isStore\", \"isLoad\"],\n      (stores, loads) => stores || loads\n    )\n  };\n\n  if (state) {\n    const isRelative = path =>\n      typeof path === \"string\" &&\n      (path.startsWith(\"./\") || path.startsWith(\"../\"));\n\n    if (isRelative(state)) {\n      state = `../${state}`;\n    }\n\n    Object.assign(base, {\n      /**\n       * .isJump\n       */\n      isJump: createLeaf(\n        [\"./trace\", state],\n        (step, { stack }) =>\n          step.op === \"JUMP\" ||\n          (step.op === \"JUMPI\" && stack[stack.length - 2] !== ZERO_WORD)\n      ),\n\n      /**\n       * .valueStored\n       * the storage written, as determined by looking at the stack\n       * rather than at storage (since valueLoaded is now being done\n       * this way, may as well do valueStored this way as well and\n       * completely remove our dependence on the storage field!)\n       */\n      valueStored: createLeaf([\"./isStore\", state], (isStore, { stack }) => {\n        if (!isStore) {\n          return null;\n        }\n        return stack[stack.length - 2];\n      }),\n\n      /**\n       * .callAddress\n       *\n       * address transferred to by call operation\n       */\n      callAddress: createLeaf(\n        [\"./isCall\", state],\n\n        (isCall, { stack }) => {\n          if (!isCall) {\n            return null;\n          }\n\n          let address = stack[stack.length - 2];\n          return Codec.Evm.Utils.toAddress(address);\n        }\n      ),\n\n      /**\n       * .createBinary\n       *\n       * binary code to execute via create operation\n       */\n      createBinary: createLeaf(\n        [\"./isCreate\", state],\n\n        (isCreate, { stack, memory }) => {\n          if (!isCreate) {\n            return null;\n          }\n\n          // Get the code that's going to be created from memory.\n          // Note we multiply by 2 because these offsets are in bytes.\n          const offset = parseInt(stack[stack.length - 2], 16) * 2;\n          const length = parseInt(stack[stack.length - 3], 16) * 2;\n\n          return (\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\")\n          );\n        }\n      ),\n\n      /**\n       * .callData\n       *\n       * data passed to EVM call\n       */\n      callData: createLeaf(\n        [\"./isCall\", \"./isShortCall\", state],\n        (isCall, short, { stack, memory }) => {\n          if (!isCall) {\n            return null;\n          }\n\n          //if it's 6-argument call, the data start and offset will be one spot\n          //higher in the stack than they would be for a 7-argument call, so\n          //let's introduce an offset to handle this\n          let argOffset = short ? 1 : 0;\n\n          // Get the data from memory.\n          // Note we multiply by 2 because these offsets are in bytes.\n          const offset = parseInt(stack[stack.length - 4 + argOffset], 16) * 2;\n          const length = parseInt(stack[stack.length - 5 + argOffset], 16) * 2;\n\n          return (\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\")\n          );\n        }\n      ),\n\n      /**\n       * .callValue\n       *\n       * value for the call (not create); returns null for DELEGATECALL\n       */\n      callValue: createLeaf(\n        [\"./isCall\", \"./isDelegateCallStrict\", \"./isStaticCall\", state],\n        (calls, delegates, isStatic, { stack }) => {\n          if (!calls || delegates) {\n            return null;\n          }\n\n          if (isStatic) {\n            return new BN(0);\n          }\n\n          //otherwise, for CALL and CALLCODE, it's the 3rd argument\n          let value = stack[stack.length - 3];\n          return Codec.Conversion.toBN(value);\n        }\n      ),\n\n      /**\n       * .createValue\n       *\n       * value for the create\n       */\n      createValue: createLeaf([\"./isCreate\", state], (isCreate, { stack }) => {\n        if (!isCreate) {\n          return null;\n        }\n\n        //creates have the value as the first argument\n        let value = stack[stack.length - 1];\n        return Codec.Conversion.toBN(value);\n      }),\n\n      /**\n       * .storageAffected\n       *\n       * storage slot being stored to or loaded from\n       * we do NOT prepend \"0x\"\n       */\n      storageAffected: createLeaf(\n        [\"./touchesStorage\", state],\n\n        (touchesStorage, { stack }) => {\n          if (!touchesStorage) {\n            return null;\n          }\n\n          return stack[stack.length - 1];\n        }\n      ),\n\n      /**\n       * .callContext\n       *\n       * context of what this step is calling/creating (if applicable)\n       */\n      callContext: createLeaf(\n        [\n          \"./callAddress\",\n          \"./createBinary\",\n          \"/current/codex/instances\",\n          \"/info/binaries/search\",\n          \"/info/contexts\"\n        ],\n        (address, binary, instances, search, contexts) =>\n          determineFullContext({ address, binary }, instances, search, contexts)\n      )\n    });\n  }\n\n  return base;\n}\n\nconst evm = createSelectorTree({\n  /**\n   * evm.state\n   */\n  state: state => state.evm,\n\n  /**\n   * evm.info\n   */\n  info: {\n    /**\n     * evm.info.contexts\n     */\n    contexts: createLeaf([\"/state\"], state => state.info.contexts.byContext),\n\n    /**\n     * evm.info.binaries\n     */\n    binaries: {\n      /**\n       * evm.info.binaries.search\n       *\n       * returns function (binary) => context (returns the *ID* of the context)\n       * (returns null on no match)\n       */\n      search: createLeaf([\"/info/contexts\"], contexts => binary =>\n        Codec.Contexts.Utils.findDebuggerContext(contexts, binary)\n      )\n    }\n  },\n\n  /**\n   * evm.transaction\n   */\n  transaction: {\n    /*\n     * evm.transaction.globals\n     */\n    globals: {\n      /*\n       * evm.transaction.globals.tx\n       */\n      tx: createLeaf([\"/state\"], state => state.transaction.globals.tx),\n      /*\n       * evm.transaction.globals.block\n       */\n      block: createLeaf([\"/state\"], state => state.transaction.globals.block)\n    },\n\n    /*\n     * evm.transaction.status\n     */\n    status: createLeaf([\"/state\"], state => state.transaction.status),\n\n    /*\n     * evm.transaction.initialCall\n     */\n    initialCall: createLeaf([\"/state\"], state => state.transaction.initialCall),\n\n    /*\n     * evm.transaction.startingContext\n     */\n    startingContext: createLeaf(\n      [\n        \"/current/callstack\", //we're just getting bottom stackframe, so this is in fact tx-level\n        \"/current/codex/instances\", //this should also be fine?\n        \"/info/binaries/search\",\n        \"/info/contexts\"\n      ],\n      (stack, instances, search, contexts) =>\n        stack.length > 0\n          ? determineFullContext(stack[0], instances, search, contexts)\n          : null\n    )\n  },\n\n  /**\n   * evm.current\n   */\n  current: {\n    /**\n     * evm.current.callstack\n     */\n    callstack: state => state.evm.proc.callstack,\n\n    /**\n     * evm.current.call\n     */\n    call: createLeaf(\n      [\"./callstack\"],\n\n      stack => (stack.length ? stack[stack.length - 1] : {})\n    ),\n\n    /**\n     * evm.current.context\n     */\n    context: createLeaf(\n      [\n        \"./call\",\n        \"./codex/instances\",\n        \"/info/binaries/search\",\n        \"/info/contexts\"\n      ],\n      determineFullContext\n    ),\n\n    /**\n     * evm.current.state\n     *\n     * evm state info: as of last operation, before op defined in step\n     */\n    state: Object.assign(\n      {},\n      ...[\"depth\", \"error\", \"gas\", \"memory\", \"stack\", \"storage\"].map(param => ({\n        [param]: createLeaf([trace.step], step => step[param])\n      }))\n    ),\n\n    /**\n     * evm.current.step\n     */\n    step: {\n      ...createStepSelectors(trace.step, \"./state\"),\n\n      //the following step selectors only exist for current, not next or any\n      //other step\n\n      /*\n       * evm.current.step.createdAddress\n       *\n       * address created by the current create step\n       */\n      createdAddress: createLeaf(\n        [\n          \"./isCreate\",\n          \"/nextOfSameDepth/state/stack\",\n          \"./isCreate2\",\n          \"./create2Address\"\n        ],\n        (isCreate, stack, isCreate2, create2Address) => {\n          if (!isCreate) {\n            return null;\n          }\n          let address = Codec.Evm.Utils.toAddress(stack[stack.length - 1]);\n          if (address === Codec.Evm.Utils.ZERO_ADDRESS && isCreate2) {\n            return create2Address;\n          }\n          return address;\n        }\n      ),\n\n      create2Address: createLeaf(\n        [\"./isCreate2\", \"./createBinary\", \"../call\", \"../state/stack\"],\n        (isCreate2, binary, { storageAddress }, stack) =>\n          isCreate2\n            ? Codec.Evm.Utils.toAddress(\n                \"0x\" +\n                  keccak256({\n                    type: \"bytes\",\n                    value:\n                      //slice 2's are for cutting off initial \"0x\" where we've prepended this\n                      //0xff, then address, then salt, then code hash\n                      \"0xff\" +\n                      storageAddress.slice(2) +\n                      stack[stack.length - 4] +\n                      keccak256({ type: \"bytes\", value: binary }).slice(2)\n                  }).slice(\n                    2 +\n                      2 *\n                        (Codec.Evm.Utils.WORD_SIZE -\n                          Codec.Evm.Utils.ADDRESS_SIZE)\n                  )\n                //slice off initial 0x and initial 12 bytes (note we've re-prepended the\n                //0x at the beginning)\n              )\n            : null\n      ),\n\n      /**\n       * evm.current.step.isInstantCallOrReturn\n       *\n       * are we doing a call or create for which there are no trace steps?\n       * This can happen if:\n       * 1. we call a precompile\n       * 2. we call an externally-owned account (or other account w/no code)\n       * 3. we do a call or create but the call stack is exhausted\n       * 4. we attempt to transfer more ether than we have\n       */\n      isInstantCallOrCreate: createLeaf(\n        [\"./isCall\", \"./isCreate\", \"./isContextChange\"],\n        (calls, creates, contextChange) => (calls || creates) && !contextChange\n      ),\n\n      /**\n       * evm.current.step.isContextChange\n       * groups together calls, creates, halts, and exceptional halts\n       */\n      isContextChange: createLeaf(\n        [\"/current/state/depth\", \"/next/state/depth\"],\n        (currentDepth, nextDepth) => currentDepth !== nextDepth\n      ),\n\n      /**\n       * .isNormalHalting\n       */\n      isNormalHalting: createLeaf(\n        [\"./isHalting\", \"./returnStatus\"],\n        (isHalting, status) => isHalting && status\n      ),\n\n      /**\n       * .isHalting\n       *\n       * whether the instruction halts or returns from a calling context\n       * HACK: the check for stepsRemainining === 0 is a hack to cover\n       * the special case when there are no trace steps; normally this\n       * is unnecessary because the spoofed step past the end covers it\n       */\n      isHalting: createLeaf(\n        [\"/current/state/depth\", \"/next/state/depth\", trace.stepsRemaining],\n        (currentDepth, nextDepth, stepsRemaining) =>\n          nextDepth < currentDepth || stepsRemaining === 0\n      ),\n\n      /**\n       * evm.current.step.isExceptionalHalting\n       */\n      isExceptionalHalting: createLeaf(\n        [\"./isHalting\", \"./returnStatus\"],\n        (isHalting, status) => isHalting && !status\n      ),\n\n      /**\n       * evm.current.step.returnStatus\n       * checks the return status of the *current* halting instruction\n       * returns null if not halting\n       * (returns a boolean -- true for success, false for failure)\n       */\n      returnStatus: createLeaf(\n        [\n          \"./isHalting\",\n          \"/next/state\",\n          trace.stepsRemaining,\n          \"/transaction/status\"\n        ],\n        (isHalting, { stack }, remaining, finalStatus) => {\n          if (!isHalting) {\n            return null; //not clear this'll do much good since this may get\n            //read as false, but, oh well, may as well\n          }\n          if (remaining <= 1) {\n            return finalStatus;\n          } else {\n            return stack[stack.length - 1] !== ZERO_WORD;\n          }\n        }\n      ),\n\n      /**\n       * evm.current.step.returnValue\n       *\n       * for a [successful] RETURN or REVERT instruction, the value returned;\n       * we DO prepend \"0x\"\n       * for everything else, including unsuccessful RETURN, just returns \"0x\"\n       * (which is what the return value would be if the instruction were to\n       * fail) (or succeed in the case of STOP or SELFDESTRUCT)\n       * NOTE: technically this will be wrong if a REVERT fails, but that case\n       * is hard to detect and it barely matters\n       */\n      returnValue: createLeaf(\n        [\"./trace\", \"./isExceptionalHalting\", \"../state\"],\n\n        (step, isExceptionalHalting, { stack, memory }) => {\n          if (step.op !== \"RETURN\" && step.op !== \"REVERT\") {\n            return \"0x\";\n          }\n          if (isExceptionalHalting && step.op !== \"REVERT\") {\n            return \"0x\";\n          }\n          // Get the data from memory.\n          // Note we multiply by 2 because these offsets are in bytes.\n          const offset = parseInt(stack[stack.length - 1], 16) * 2;\n          const length = parseInt(stack[stack.length - 2], 16) * 2;\n\n          return (\n            \"0x\" +\n            memory\n              .join(\"\")\n              .substring(offset, offset + length)\n              .padEnd(length, \"00\")\n          );\n        }\n      ),\n\n      /**\n       * evm.current.step.valueLoaded\n       * the storage loaded on an SLOAD. determined by examining\n       * the next stack, rather than storage (we're avoiding\n       * relying on storage to support old versions of Geth and Besu)\n       * we do not include an initial \"0x\"\n       */\n      valueLoaded: createLeaf(\n        [\"./isLoad\", \"/next/state\"],\n        (isLoad, { stack }) => {\n          if (!isLoad) {\n            return null;\n          }\n          return stack[stack.length - 1];\n        }\n      )\n    },\n\n    /**\n     * evm.current.codex (namespace)\n     */\n    codex: {\n      /**\n       * evm.current.codex (selector)\n       * the whole codex! not that that's very much at the moment\n       */\n      _: createLeaf([\"/state\"], state => state.proc.codex),\n\n      /**\n       * evm.current.codex.storage\n       * the current storage, as fetched from the codex... unless we're in a\n       * failed creation call, then we just fall back on the state (which will\n       * work, since nothing else can interfere with the storage of a failed\n       * creation call!)\n       */\n      storage: createLeaf(\n        [\"./_\", \"../state/storage\", \"../call\"],\n        (codex, rawStorage, { storageAddress }) =>\n          storageAddress === Codec.Evm.Utils.ZERO_ADDRESS\n            ? rawStorage //HACK -- if zero address ignore the codex\n            : codex[codex.length - 1].accounts[storageAddress].storage\n      ),\n\n      /*\n       * evm.current.codex.instances\n       */\n      instances: createLeaf([\"./_\"], codex =>\n        Object.assign(\n          {},\n          ...Object.entries(codex[codex.length - 1].accounts).map(\n            ([address, { code, context }]) => ({\n              [address]: { address, binary: code, context }\n            })\n          )\n        )\n      )\n    }\n  },\n\n  /**\n   * evm.next\n   */\n  next: {\n    /**\n     * evm.next.state\n     *\n     * evm state as a result of next step operation\n     */\n    state: Object.assign(\n      {},\n      ...[\"depth\", \"error\", \"gas\", \"memory\", \"stack\", \"storage\"].map(param => ({\n        [param]: createLeaf([trace.next], step => step[param])\n      }))\n    ),\n\n    /*\n     * evm.next.step\n     */\n    step: createStepSelectors(trace.next, \"./state\")\n  },\n\n  /**\n   * evm.nextOfSameDepth\n   */\n  nextOfSameDepth: {\n    /**\n     * evm.nextOfSameDepth.state\n     *\n     * evm state at the next step of same depth\n     */\n    state: Object.assign(\n      {},\n      ...[\"depth\", \"error\", \"gas\", \"memory\", \"stack\", \"storage\"].map(param => ({\n        [param]: createLeaf([trace.nextOfSameDepth], step => step[param])\n      }))\n    )\n  }\n});\n\nexport default evm;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:solidity:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport SolidityUtils from \"@truffle/solidity-utils\";\n\nimport semver from \"semver\";\n\nimport evm from \"lib/evm/selectors\";\nimport trace from \"lib/trace/selectors\";\n\nfunction contextRequiresPhantomStackframes(context) {\n  debug(\"context: %O\", context);\n  return (\n    context.compiler !== undefined && //(do NOT just put context.compiler here,\n    //we need this to be a boolean, not undefined, because it gets put in the state)\n    semver.satisfies(context.compiler.version, \">=0.5.1\", {\n      includePrerelease: true\n    }) &&\n    !context.isConstructor //constructors should not get a phantom stackframe!\n  );\n}\n\n//function to create selectors that need both a current and next version\nfunction createMultistepSelectors(stepSelector) {\n  return {\n    /**\n     * .instruction\n     */\n    instruction: createLeaf(\n      [\"/current/instructionAtProgramCounter\", stepSelector.programCounter],\n      //HACK: we use solidity.current.instructionAtProgramCounter\n      //even if we're looking at solidity.next.\n      //This is harmless... so long as the current instruction isn't a context\n      //change.  So, don't use solidity.next when it is.\n\n      (map, pc) => map[pc] || {}\n    ),\n\n    /**\n     * .modifierDepth\n     */\n    modifierDepth: createLeaf(\n      [\"./instruction\"],\n      instruction => instruction.modifierDepth\n    ),\n\n    /**\n     * .source\n     */\n    source: createLeaf(\n      //HACK: same hack as with instruction (we use current sources).\n      //but I don't need to give the same warning twice.\n      [\"/current/sources\", \"./instruction\"],\n\n      (sources, { file: id }) => (sources ? sources[id] || {} : {})\n    ),\n\n    /**\n     * HACK... you get the idea\n     */\n    findOverlappingRange: createLeaf(\n      [\"./source\", \"/views/findOverlappingRange\"],\n      ({ compilationId, id }, functions) => (functions[compilationId] || {})[id]\n    ),\n\n    /**\n     * .sourceRange\n     */\n    sourceRange: createLeaf([\"./instruction\"], SolidityUtils.getSourceRange),\n\n    /**\n     * .pointerAndNode\n     */\n    pointerAndNode: createLeaf(\n      [\"./findOverlappingRange\", \"./sourceRange\"],\n\n      (findOverlappingRange, range) =>\n        findOverlappingRange\n          ? SolidityUtils.findRange(\n              findOverlappingRange,\n              range.start,\n              range.length\n            )\n          : null\n    ),\n\n    /**\n     * .pointer\n     */\n    pointer: createLeaf(\n      [\"./pointerAndNode\"],\n\n      pointerAndNode => (pointerAndNode ? pointerAndNode.pointer : null)\n    ),\n\n    /**\n     * .node\n     */\n    node: createLeaf(\n      [\"./source\", \"./pointerAndNode\"],\n\n      ({ ast }, pointerAndNode) => (pointerAndNode ? pointerAndNode.node : ast)\n    )\n  };\n}\n\nlet solidity = createSelectorTree({\n  /**\n   * solidity.state\n   */\n  state: state => state.solidity,\n\n  /**\n   * solidity.info\n   */\n  info: {\n    /**\n     * solidity.info.sources\n     * NOTE: grouped by compilation!\n     */\n    sources: createLeaf([\"/state\"], state => state.info.sources.byCompilationId)\n  },\n\n  /**\n   * solidity.transaction\n   */\n  transaction: {\n    /**\n     * solidity.transaction.bottomStackframeRequiresPhantomFrame\n     */\n    bottomStackframeRequiresPhantomFrame: createLeaf(\n      [evm.transaction.startingContext],\n      contextRequiresPhantomStackframes\n    )\n  },\n\n  /**\n   * solidity.current\n   */\n  current: {\n    /**\n     * solidity.current.sources\n     * This takes the place of the old solidity.info.sources,\n     * returning only the sources for the current compilation.\n     */\n    sources: createLeaf(\n      [\"/info/sources\", evm.current.context],\n      (sources, context) =>\n        context\n          ? context.compilationId !== undefined\n            ? (sources[context.compilationId] || { byId: null }).byId\n            : [] //unknown context, return no sources\n          : null //no tx loaded, return null\n    ),\n\n    /**\n     * solidity.current.sourceMap\n     */\n    sourceMap: createLeaf(\n      [evm.current.context],\n\n      context => (context ? context.sourceMap : null) //null when no tx loaded\n    ),\n\n    /**\n     * solidity.current.humanReadableSourceMap\n     */\n    humanReadableSourceMap: createLeaf(\n      [\"./sourceMap\"],\n      sourceMap =>\n        sourceMap ? SolidityUtils.getHumanReadableSourceMap(sourceMap) : null\n    ),\n\n    /**\n     * solidity.current.functionDepthStack\n     */\n    functionDepthStack: state => state.solidity.proc.functionDepthStack,\n\n    /**\n     * solidity.current.nextFrameIsPhantom\n     */\n    nextFrameIsPhantom: state => state.solidity.proc.nextFrameIsPhantom,\n\n    /**\n     * solidity.current.functionDepth\n     */\n    functionDepth: createLeaf(\n      [\"./functionDepthStack\"],\n      stack => stack[stack.length - 1]\n    ),\n\n    /**\n     * solidity.current.callRequiresPhantomFrame\n     */\n    callRequiresPhantomFrame: createLeaf(\n      [evm.current.context],\n      contextRequiresPhantomStackframes\n    ),\n\n    /**\n     * solidity.current.instructions\n     */\n    instructions: createLeaf(\n      [\"./sources\", evm.current.context, \"./humanReadableSourceMap\"],\n\n      (sources, context, sourceMap) => {\n        if (!context) {\n          return [];\n        }\n\n        return SolidityUtils.getProcessedInstructionsForBinary(\n          (sources || []).map(({ source }) => source),\n          context.binary,\n          sourceMap\n        );\n      }\n    ),\n\n    /**\n     * solidity.current.instructionAtProgramCounter\n     */\n    instructionAtProgramCounter: createLeaf(\n      [\"./instructions\"],\n\n      instructions =>\n        Object.assign(\n          {},\n          ...instructions.map(instruction => ({\n            [instruction.pc]: instruction\n          }))\n        )\n    ),\n\n    ...createMultistepSelectors(evm.current.step),\n\n    /**\n     * solidity.current.isSourceRangeFinal\n     */\n    isSourceRangeFinal: createLeaf(\n      [\n        \"./instructionAtProgramCounter\",\n        evm.current.step.programCounter,\n        evm.next.step.programCounter\n      ],\n\n      (map, current, next) => {\n        if (!map[next]) {\n          return true;\n        }\n\n        current = map[current];\n        next = map[next];\n\n        return (\n          current.start != next.start ||\n          current.length != next.length ||\n          current.file != next.file\n        );\n      }\n    ),\n\n    /*\n     * solidity.current.functionsByProgramCounter\n     */\n    functionsByProgramCounter: createLeaf(\n      [\n        \"./instructions\",\n        \"./sources\",\n        \"/views/findOverlappingRange\",\n        evm.current.context\n      ],\n      (instructions, sources, functions, { compilationId }) =>\n        //note: we can skip an explicit null check on sources here because\n        //if sources is null then instructions = [] so the problematic map\n        //never occurs\n        SolidityUtils.getFunctionsByProgramCounter(\n          instructions,\n          sources.map(({ ast }) => ast),\n          functions[compilationId],\n          compilationId\n        )\n    ),\n\n    /**\n     * solidity.current.isMultiline\n     */\n    isMultiline: createLeaf(\n      [\"./sourceRange\"],\n\n      ({ lines }) => lines.start.line != lines.end.line\n    ),\n\n    /**\n     * solidity.current.willJump\n     */\n    willJump: createLeaf([evm.current.step.isJump], isJump => isJump),\n\n    /**\n     * solidity.current.jumpDirection\n     */\n    jumpDirection: createLeaf([\"./instruction\"], (i = {}) => i.jump || \"-\"),\n\n    /**\n     * solidity.current.willCall\n     * note: includes creations, does *not* include instareturns\n     */\n    willCall: createLeaf(\n      [\n        evm.current.step.isCall,\n        evm.current.step.isCreate,\n        evm.current.step.isInstantCallOrCreate\n      ],\n      (isCall, isCreate, isInstant) => (isCall || isCreate) && !isInstant\n    ),\n\n    /**\n     * solidity.current.willReturn\n     *\n     * covers both normal returns & failures\n     */\n    willReturn: createLeaf(\n      [evm.current.step.isHalting],\n      isHalting => isHalting\n    ),\n\n    /**\n     * solidity.current.nextMapped\n     * returns the next trace step after this one which is sourcemapped\n     * HACK: this assumes we're not about to change context! don't use this if\n     * we are!\n     * ALSO, this may return undefined, so be prepared for that\n     */\n    nextMapped: createLeaf(\n      [\"./instructionAtProgramCounter\", trace.steps, trace.index],\n      (map, steps, index) =>\n        steps.slice(index + 1).find(({ pc }) => map[pc] && map[pc].file !== -1)\n    )\n  },\n\n  /**\n   * solidity.next\n   * HACK WARNING: do not use these selectors when the current instruction is a\n   * context change! (evm call or evm return)\n   */\n  next: createMultistepSelectors(evm.next.step),\n\n  /**\n   * solidity.views\n   */\n  views: {\n    /**\n     * solidity.views.findOverlappingRange\n     * grouped by compilation\n     */\n    findOverlappingRange: createLeaf([\"/info/sources\"], compilations =>\n      Object.assign(\n        {},\n        ...Object.entries(compilations).map(\n          ([compilationId, { byId: sources }]) => ({\n            [compilationId]: sources.map(({ ast }) =>\n              SolidityUtils.makeOverlapFunction(ast)\n            )\n          })\n        )\n      )\n    )\n  }\n});\n\nexport default solidity;\n","module.exports = require(\"babel-runtime/core-js/object/assign\");","export const SAVE_STEPS = \"TRACE_SAVE_STEPS\";\nexport function saveSteps(steps) {\n  return {\n    type: SAVE_STEPS,\n    steps\n  };\n}\n\nexport const NEXT = \"TRACE_NEXT\";\nexport function next() {\n  return { type: NEXT };\n}\n\nexport const TICK = \"TRACE_TICK\";\nexport function tick() {\n  return { type: TICK };\n}\n\nexport const TOCK = \"TRACE_TOCK\";\nexport function tock() {\n  return { type: TOCK };\n}\n\nexport const END_OF_TRACE = \"TRACE_EOT\";\nexport function endTrace() {\n  return { type: END_OF_TRACE };\n}\n\nexport const RESET = \"TRACE_RESET\";\nexport function reset() {\n  return { type: RESET };\n}\n\nexport const UNLOAD_TRANSACTION = \"TRACE_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return { type: UNLOAD_TRANSACTION };\n}\n\nexport const BACKTICK = \"TRACE_BACKTICK\";\nexport function backtick() {\n  return { type: BACKTICK };\n}\n\nexport const SET_SUBMODULE_COUNT = \"TRACE_SET_SUBMODULE_COUNT\";\nexport function setSubmoduleCount(count) {\n  return { type: SET_SUBMODULE_COUNT, count };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:trace:sagas\");\n\nimport { take, takeEvery, put, select } from \"redux-saga/effects\";\nimport { prefixName, isCallMnemonic } from \"lib/helpers\";\n\nimport * as Codec from \"@truffle/codec\";\n\nimport * as actions from \"../actions\";\n\nimport trace from \"../selectors\";\n\nexport function* setSubmoduleCount(count) {\n  yield put(actions.setSubmoduleCount(count));\n}\n\nexport function* addSubmoduleToCount() {\n  let count = yield select(trace.application.submoduleCount);\n  yield put(actions.setSubmoduleCount(count + 1));\n}\n\nexport function* advance() {\n  yield put(actions.next());\n\n  debug(\"TOCK to take\");\n  yield take([actions.TOCK, actions.END_OF_TRACE]);\n  debug(\"TOCK taken\");\n}\n\nfunction* next() {\n  let remaining = yield select(trace.stepsRemaining);\n  debug(\"remaining: %o\", remaining);\n  let steps = yield select(trace.steps);\n  debug(\"total steps: %o\", steps.length);\n  let waitingForSubmodules = 0;\n\n  if (remaining > 0) {\n    debug(\"putting TICK\");\n    // updates state for current step\n    waitingForSubmodules = yield select(trace.application.submoduleCount);\n    yield put(actions.tick());\n    debug(\"put TICK\");\n\n    //wait for all backticks before continuing\n    while (waitingForSubmodules > 0) {\n      yield take(actions.BACKTICK);\n      debug(\"got BACKTICK\");\n      waitingForSubmodules--;\n    }\n\n    remaining--; // local update, just for convenience\n  }\n\n  if (remaining) {\n    debug(\"putting TOCK\");\n    // updates step to next step in trace\n    yield put(actions.tock());\n    debug(\"put TOCK\");\n  } else {\n    debug(\"putting END_OF_TRACE\");\n    yield put(actions.endTrace());\n    debug(\"put END_OF_TRACE\");\n  }\n}\n\nexport function* signalTickSagaCompletion() {\n  yield put(actions.backtick());\n}\n\nexport function* processTrace(steps) {\n  yield put(actions.saveSteps(steps));\n\n  let addresses = [\n    ...new Set(\n      steps\n        .map(\n          ({ op, stack }) =>\n            isCallMnemonic(op)\n              ? //if it's a call, just fetch the address off the stack\n                Codec.Evm.Utils.toAddress(stack[stack.length - 2])\n              : //if it's not a call, just return undefined (we've gone back to\n                //skipping creates)\n                undefined\n        )\n        //filter out zero addresses from failed creates (as well as undefineds)\n        .filter(\n          address =>\n            address !== undefined && address !== Codec.Evm.Utils.ZERO_ADDRESS\n        )\n    )\n  ];\n\n  return addresses;\n}\n\nexport function* reset() {\n  yield put(actions.reset());\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* saga() {\n  yield takeEvery(actions.NEXT, next);\n}\n\nexport default prefixName(\"trace\", saga);\n","export const START = \"SESSION_START\";\nexport function start(provider, txHash) {\n  return {\n    type: START,\n    provider,\n    txHash //OPTIONAL\n  };\n}\n\nexport const LOAD_TRANSACTION = \"SESSION_LOAD_TRANSACTION\";\nexport function loadTransaction(txHash) {\n  return {\n    type: LOAD_TRANSACTION,\n    txHash\n  };\n}\n\nexport const INTERRUPT = \"SESSION_INTERRUPT\";\nexport function interrupt() {\n  return { type: INTERRUPT };\n}\n\nexport const UNLOAD_TRANSACTION = \"SESSION_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION\n  };\n}\n\nexport const READY = \"SESSION_READY\";\nexport function ready() {\n  return {\n    type: READY\n  };\n}\n\nexport const WAIT = \"SESSION_WAIT\";\nexport function wait() {\n  return {\n    type: WAIT\n  };\n}\n\nexport const ERROR = \"SESSION_ERROR\";\nexport function error(error) {\n  return {\n    type: ERROR,\n    error\n  };\n}\n\nexport const RECORD_CONTRACTS = \"SESSION_RECORD_CONTRACTS\";\nexport function recordContracts(contexts, sources) {\n  return {\n    type: RECORD_CONTRACTS,\n    contexts,\n    sources\n  };\n}\n\nexport const SAVE_TRANSACTION = \"SESSION_SAVE_TRANSACTION\";\nexport function saveTransaction(transaction) {\n  return {\n    type: SAVE_TRANSACTION,\n    transaction\n  };\n}\n\nexport const SAVE_RECEIPT = \"SESSION_SAVE_RECEIPT\";\nexport function saveReceipt(receipt) {\n  return {\n    type: SAVE_RECEIPT,\n    receipt\n  };\n}\n\nexport const SAVE_BLOCK = \"SESSION_SAVE_BLOCK\";\nexport function saveBlock(block) {\n  return {\n    type: SAVE_BLOCK,\n    block\n  };\n}\n\nexport const SET_LIGHT_MODE = \"SESSION_SET_LIGHT_MODE\";\nexport function setLightMode() {\n  return { type: SET_LIGHT_MODE };\n}\n\nexport const SET_FULL_MODE = \"SESSION_SET_FULL_MODE\";\nexport function setFullMode() {\n  return { type: SET_FULL_MODE };\n}\n\nexport const START_FULL_MODE = \"SESSION_START_FULL_MODE\";\nexport function startFullMode() {\n  return { type: START_FULL_MODE };\n}\n\nexport const ADD_COMPILATIONS = \"SESSION_ADD_COMPILATIONS\";\nexport function addCompilations(sources, contexts) {\n  return {\n    type: ADD_COMPILATIONS,\n    sources,\n    contexts\n  };\n}\n","module.exports = require(\"babel-runtime/core-js/object/values\");","module.exports = require(\"json-pointer\");","module.exports = require(\"bn.js\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:data:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\n\nimport {\n  prefixName,\n  stableKeccak256,\n  makeAssignment,\n  makePath\n} from \"lib/helpers\";\n\nimport { TICK } from \"lib/trace/actions\";\nimport * as actions from \"../actions\";\nimport * as trace from \"lib/trace/sagas\";\nimport * as evm from \"lib/evm/sagas\";\nimport * as web3 from \"lib/web3/sagas\";\n\nimport data from \"../selectors\";\n\nimport sum from \"lodash.sum\";\nimport jsonpointer from \"json-pointer\";\n\nimport * as Codec from \"@truffle/codec\";\nimport BN from \"bn.js\";\n\nexport function* scope(nodeId, pointer, parentId, sourceId, compilationId) {\n  yield put(actions.scope(nodeId, pointer, parentId, sourceId, compilationId));\n}\n\nexport function* declare(node, compilationId) {\n  yield put(actions.declare(node.name, node.id, node.scope, compilationId));\n}\n\nexport function* yulScope(pointer, sourceId, compilationId, parentId) {\n  yield put(\n    actions.scope(undefined, pointer, parentId, sourceId, compilationId)\n  );\n}\n\nexport function* yulDeclare(\n  node,\n  pointer,\n  scopePointer,\n  sourceId,\n  compilationId\n) {\n  yield put(\n    actions.declare(\n      node.name,\n      makePath(sourceId, pointer),\n      makePath(sourceId, scopePointer),\n      compilationId\n    )\n  );\n}\n\nexport function* defineType(node, compilationId) {\n  yield put(actions.defineType(node, compilationId));\n}\n\nfunction* tickSaga() {\n  yield* variablesAndMappingsSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\nexport function* decode(definition, ref, compilationId) {\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  const state = yield select(data.current.state);\n  const mappingKeys = yield select(data.views.mappingKeys);\n  const allocations = yield select(data.info.allocations);\n  const contexts = yield select(data.views.contexts);\n  const currentContext = yield select(data.current.context);\n  const internalFunctionsTable = yield select(\n    data.current.functionsByProgramCounter\n  );\n\n  const ZERO_WORD = new Uint8Array(Codec.Evm.Utils.WORD_SIZE); //automatically filled with zeroes\n\n  const decoder = Codec.decodeVariable(\n    definition,\n    ref,\n    {\n      userDefinedTypes,\n      state,\n      mappingKeys,\n      allocations,\n      contexts,\n      currentContext,\n      internalFunctionsTable\n    },\n    compilationId\n  );\n\n  debug(\"beginning decoding\");\n  let result = decoder.next();\n  while (!result.done) {\n    debug(\"request received\");\n    let request = result.value;\n    let response;\n    switch (request.type) {\n      case \"storage\":\n        //the debugger supplies all storage it knows at the beginning.\n        //any storage it does not know is presumed to be zero.\n        response = ZERO_WORD;\n        break;\n      case \"code\":\n        response = yield* requestCode(request.address);\n        break;\n      default:\n        debug(\"unrecognized request type!\");\n    }\n    debug(\"sending response\");\n    result = decoder.next(response);\n  }\n  //at this point, result.value holds the final value\n  debug(\"done decoding\");\n  debug(\"decoded value: %O\", result.value);\n  return result.value;\n}\n\nexport function* decodeReturnValue() {\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  const state = yield select(data.next.state); //next state has the return data\n  const allocations = yield select(data.info.allocations);\n  const contexts = yield select(data.views.contexts);\n  const status = yield select(data.current.returnStatus); //may be undefined\n  const returnAllocation = yield select(data.current.returnAllocation); //may be null\n\n  const decoder = Codec.decodeReturndata(\n    {\n      userDefinedTypes,\n      state,\n      allocations,\n      contexts\n    },\n    returnAllocation,\n    status\n  );\n\n  debug(\"beginning decoding\");\n  let result = decoder.next();\n  while (!result.done) {\n    debug(\"request received\");\n    let request = result.value;\n    let response;\n    switch (request.type) {\n      //skip storage case, it won't happen here\n      case \"code\":\n        response = yield* requestCode(request.address);\n        break;\n      default:\n        debug(\"unrecognized request type!\");\n    }\n    debug(\"sending response\");\n    result = decoder.next(response);\n  }\n  //at this point, result.value holds the final value\n  debug(\"done decoding\");\n  return result.value;\n}\n\n//NOTE: calling this *can* add a new instance, which will not\n//go away on a reset!  Yes, this is a little weird, but we\n//decided this is OK for now\nfunction* requestCode(address) {\n  const NO_CODE = new Uint8Array(); //empty array\n  const blockNumber = yield select(data.views.blockNumber);\n  const instances = yield select(data.views.instances);\n\n  if (address in instances) {\n    return instances[address];\n  } else if (address === Codec.Evm.Utils.ZERO_ADDRESS) {\n    //HACK: to avoid displaying the zero address to the user as an\n    //affected address just because they decoded a contract or external\n    //function variable that hadn't been initialized yet, we give the\n    //zero address's codelessness its own private cache :P\n    return NO_CODE;\n  } else {\n    //I don't want to write a new web3 saga, so let's just use\n    //obtainBinaries with a one-element array\n    debug(\"fetching binary\");\n    let binary = (yield* web3.obtainBinaries([address], blockNumber))[0];\n    debug(\"adding instance\");\n    yield* evm.addInstance(address, binary);\n    return Codec.Conversion.toBytes(binary);\n  }\n}\n\nfunction* variablesAndMappingsSaga() {\n  // stack is only ready for interpretation after the last step of each\n  // source range\n  //\n  // the data module always looks at the result of a particular opcode\n  // (i.e., the following trace step's stack/memory/storage), so this\n  // asserts that the _current_ operation is the final one before\n  // proceeding\n  if (!(yield select(data.views.atLastInstructionForSourceRange))) {\n    return;\n  }\n\n  let node = yield select(data.current.node);\n\n  if (!node) {\n    return;\n  }\n\n  //set up stack; see default case for what normally goes on\n  let stack;\n  switch (node.nodeType) {\n    case \"IndexAccess\":\n    case \"MemberAccess\":\n      stack = yield select(data.nextMapped.state.stack);\n      //HACK: unfortunately, in some cases, data.next.state.stack gets the wrong\n      //results due to unmapped instructions intervening.  So, we get the stack at\n      //the next *mapped* stack instead.  This is something of a hack and won't\n      //work if we're about to change context, but it should work in the cases that\n      //need it.\n      break;\n    case \"YulFunctionCall\":\n      stack = yield select(data.nextOfSameDepth.state.stack);\n      //if the step we're on is a CALL (or similar), as can happen with Yul,\n      //we don't want to look at the stack on the *next* step, but rather\n      //the step when it returns; hence this\n      break;\n    default:\n      stack = yield select(data.next.state.stack); //note the use of next!\n      //in this saga we are interested in the *results* of the current instruction\n      //note that the decoder is still based on data.current.state; that's fine\n      //though.  There's already a delay between when we record things off the\n      //stack and when we decode them, after all.  Basically, nothing serious\n      //should happen after an index node but before the index access node that\n      //would cause storage, memory, or calldata to change, meaning that even if\n      //the literal we recorded was a pointer, it will still be valid at the time\n      //we use it.  (The other literals we make use of, for the base expressions,\n      //are not decoded, so no potential mismatch there would be relevant anyway.)\n      break;\n  }\n\n  if (!stack) {\n    //note: should only happen in YulFunctionCall case\n    return;\n  }\n\n  let top = stack.length - 1;\n\n  //set up other variables\n  let pointer = yield select(data.current.pointer);\n  let nextPointer = yield select(data.next.pointer);\n  let scopes = yield select(data.current.scopes.inlined);\n  let allocations = yield select(data.current.allocations.state);\n  let storageAllocations = yield select(data.info.allocations.storage);\n  let userDefinedTypes = yield select(data.views.userDefinedTypes);\n  let currentAssignments = yield select(data.proc.assignments);\n  let mappedPaths = yield select(data.proc.mappedPaths);\n  let currentDepth = yield select(data.current.functionDepth);\n  let modifierDepth = yield select(data.current.modifierDepth);\n  let inModifier = yield select(data.current.inModifier);\n  let inFunctionOrModifier = yield select(data.current.inFunctionOrModifier);\n  let address = yield select(data.current.address); //storage address, not code address\n  let compilationId = yield select(data.current.compilationId);\n  let sourceId = yield select(data.current.sourceId);\n  let compiler = yield select(data.current.compiler);\n\n  let assignment,\n    assignments,\n    preambleAssignments,\n    baseExpression,\n    slot,\n    path,\n    position;\n\n  //HACK: modifier preamble\n  //modifier definitions are typically skipped (this includes constructor\n  //definitions when called as a base constructor); as such I've added this\n  //\"modifier preamble\" to catch them\n  if (yield select(data.current.aboutToModify)) {\n    let modifier = yield select(data.current.modifierBeingInvoked);\n    //may be either a modifier or base constructor\n    let currentIndex = yield select(data.current.modifierArgumentIndex);\n    debug(\"currentIndex %d\", currentIndex);\n    let parameters = modifier.parameters.parameters;\n    //now: look at the parameters *after* the current index.  we'll need to\n    //adjust for those.\n    let parametersLeft = parameters.slice(currentIndex + 1);\n    let adjustment = sum(parametersLeft.map(Codec.Ast.Utils.stackSize));\n    debug(\"adjustment %d\", adjustment);\n    preambleAssignments = assignParameters(\n      compilationId,\n      parameters,\n      top + adjustment,\n      currentDepth,\n      modifierDepth,\n      modifier.nodeType === \"ModifierDefinition\"\n    );\n  } else {\n    preambleAssignments = {};\n  }\n\n  switch (node.nodeType) {\n    case \"FunctionDefinition\":\n    case \"ModifierDefinition\":\n      //NOTE: this will *not* catch most modifier definitions!\n      //the rest hopefully will be caught by the modifier preamble\n      //(in fact they won't all be, but...)\n\n      //HACK: filter out some garbage\n      //this filters out the case where we're really in an invocation of a\n      //modifier or base constructor, but have temporarily hit the definition\n      //node for some reason.  However this obviously can have a false positive\n      //in the case where a function has the same modifier twice.\n      let nextModifier = yield select(data.next.modifierBeingInvoked);\n      if (nextModifier && nextModifier.id === node.id) {\n        break;\n      }\n\n      let parameters = node.parameters.parameters;\n      //note that we do *not* include return parameters, since those are\n      //handled by the VariableDeclaration case (no, I don't know why it\n      //works out that way)\n\n      //we can skip preambleAssignments here, that isn't used in this case\n      assignments = assignParameters(\n        compilationId,\n        parameters,\n        top,\n        currentDepth,\n        modifierDepth,\n        inModifier\n      );\n\n      debug(\"Function definition case\");\n      debug(\"assignments %O\", assignments);\n\n      yield put(actions.assign(assignments));\n      break;\n\n    case \"YulFunctionDefinition\":\n      if (nextPointer === null || !nextPointer.startsWith(`${pointer}/body/`)) {\n        //in this case, we're seeing the function\n        //as it's being defined, rather than as it's\n        //being called\n        //notice the final slash; when you enter a function, you go *strictly inside*\n        //its body (if you hit the body node itself you are seeing the definition)\n        break;\n      }\n      //yul parameters are a bit weird.\n      //whereas solidity parameters go bottom to top,\n      //first inputs then outputs (and we skip handling the outputs),\n      //yul parameters have the inputs go top to bottom,\n      //and the outputs go bottom to top (again with the outputs on top)\n      //note we need to handle both inputs and outputs here\n      const returnSuffixes = (node.returnVariables || []).map(\n        (_, index, vars) => `/returnVariables/${vars.length - 1 - index}`\n      );\n      const parameterSuffixes = (node.parameters || []).map(\n        (_, index) => `/parameters/${index}`\n      );\n      //HACK: prior to 0.6.8, we *also* need to account for any bare lets (ones\n      //w/no value given) at the beginning of the function body because these\n      //will throw off our count otherwise\n      let bareLetSuffixes = []; //when hack is not invoked, we just leave this empty\n      if (!(yield select(data.current.bareLetsInYulAreHit))) {\n        let outerIndex = 0;\n        for (const declaration of node.body.statements) {\n          if (\n            declaration.nodeType !== \"YulVariableDeclaration\" ||\n            declaration.value != null\n          ) {\n            //deliberate != for future Solidity versions\n            break;\n          }\n          for (\n            let innerIndex = 0;\n            innerIndex < declaration.variables.length;\n            innerIndex++\n          ) {\n            //we want to process from top to bottom, so we'll put the earlier\n            //variables last\n            bareLetSuffixes.unshift(\n              `/body/statements/${outerIndex}/variables/${innerIndex}`\n            );\n          }\n          outerIndex++;\n        }\n      }\n      //both outputs and inputs in the appropriate order (top to bottom)\n      //(well, and those lets...)\n      const suffixes = bareLetSuffixes.concat(\n        returnSuffixes,\n        parameterSuffixes\n      );\n      debug(\"suffixes: %O\", suffixes);\n      assignments = {};\n      position = top; //because that's how we'll process things\n      for (const suffix of suffixes) {\n        //we only care about the pointer, not the variable\n        const sourceAndPointer = makePath(sourceId, pointer + suffix);\n        assignment = makeAssignment(\n          inModifier\n            ? {\n                compilationId,\n                astRef: sourceAndPointer,\n                stackframe: currentDepth,\n                modifierDepth\n              }\n            : {\n                compilationId,\n                astRef: sourceAndPointer,\n                stackframe: currentDepth\n              },\n          {\n            location: \"stack\",\n            from: position, //all Yul variables are size 1\n            to: position\n          }\n        );\n        assignments[assignment.id] = assignment;\n        position--;\n      }\n      yield put(actions.assign(assignments));\n      break;\n\n    case \"ContractDefinition\":\n      let allocation = allocations[node.id];\n\n      debug(\"Contract definition case\");\n      debug(\"allocations %O\", allocations);\n      debug(\"allocation %O\", allocation);\n      assignments = {};\n      for (let id in allocation.members) {\n        id = Number(id); //not sure why we're getting them as strings, but...\n        let idObj = { compilationId, astRef: id, address };\n        let fullId = stableKeccak256(idObj);\n        //we don't use makeAssignment here as we had to compute the ID anyway\n        assignment = {\n          ...idObj,\n          id: fullId,\n          ref: {\n            ...((currentAssignments.byId[fullId] || {}).ref || {}),\n            ...allocation.members[id].pointer\n          }\n        };\n        assignments[fullId] = assignment;\n      }\n      debug(\"assignments %O\", assignments);\n\n      //this case doesn't need preambleAssignments either\n      yield put(actions.assign(assignments));\n      break;\n\n    case \"FunctionTypeName\":\n      //HACK\n      //for some reasons, for declarations of local variables of function type,\n      //we land on the FunctionTypeName instead of the VariableDeclaration,\n      //so we replace the node with its parent (the VariableDeclaration)\n      node = scopes[scopes[node.id].parentId].definition;\n      //let's do a quick check that it *is* a VariableDeclaration before\n      //continuing\n      if (node.nodeType !== \"VariableDeclaration\") {\n        break;\n      }\n    //otherwise, deliberately fall through to the VariableDeclaration case\n    //NOTE: DELIBERATE FALL-THROUGH\n    case \"VariableDeclaration\":\n      let varId = node.id;\n      debug(\"Variable declaration case\");\n      debug(\"currentDepth %d varId %d\", currentDepth, varId);\n\n      if (!inFunctionOrModifier) {\n        //if we're not in a function or modifier, then this is a contract\n        //variable, not a local variable, and should not be included\n        debug(\"already a contract variable!\");\n        break;\n      }\n\n      //otherwise, go ahead and make the assignment\n      assignment = makeAssignment(\n        inModifier\n          ? {\n              compilationId,\n              astRef: varId,\n              stackframe: currentDepth,\n              modifierDepth\n            }\n          : { compilationId, astRef: varId, stackframe: currentDepth },\n        {\n          location: \"stack\",\n          from: top - Codec.Ast.Utils.stackSize(node) + 1,\n          to: top\n        }\n      );\n      assignments = { [assignment.id]: assignment };\n      //this case doesn't need preambleAssignments either\n      debug(\"assignments: %O\", assignments);\n      yield put(actions.assign(assignments));\n      break;\n\n    case \"YulFunctionCall\":\n      if (nextPointer !== null && nextPointer.startsWith(pointer)) {\n        //if we're moving inside the function call itself, ignore it\n        break;\n      }\n    //NOTE: DELIBERATE FALL-THROUGH\n    case \"YulLiteral\":\n    case \"YulIdentifier\":\n      //yul variable declaration, maybe\n      let parentPointer = pointer.replace(/\\/[^/]*$/, \"\"); //chop off end\n      let root = yield select(data.current.root);\n      let parent = jsonpointer.get(root, parentPointer);\n      if (\n        pointer !== `${parentPointer}/value` ||\n        parent.nodeType !== \"YulVariableDeclaration\"\n      ) {\n        break;\n      }\n      node = parent;\n      pointer = parentPointer;\n    //NOTE: DELIBERATE FALL-THROUGH\n    case \"YulVariableDeclaration\":\n      const sourceAndPointer = makePath(sourceId, pointer);\n      debug(\"sourceAndPointer: %s\", sourceAndPointer);\n      assignments = {};\n      //variables go on from bottom to top, so process from top to bottom\n      position = top; //NOTE: remember that which stack we use depends on our node type!\n      for (let index = node.variables.length - 1; index >= 0; index--) {\n        //we only care about the pointer, not the variable\n        const variableSourceAndPointer = `${sourceAndPointer}/variables/${index}`;\n        assignment = makeAssignment(\n          inModifier\n            ? {\n                compilationId,\n                astRef: variableSourceAndPointer,\n                stackframe: currentDepth,\n                modifierDepth\n              }\n            : {\n                compilationId,\n                astRef: variableSourceAndPointer,\n                stackframe: currentDepth\n              },\n          {\n            location: \"stack\",\n            from: position, //all Yul variables are size 1\n            to: position\n          }\n        );\n        assignments[assignment.id] = assignment;\n        position--;\n      }\n\n      //this case doesn't need preambleAssignments, obviously!\n      yield put(actions.assign(assignments));\n      break;\n\n    case \"IndexAccess\":\n      // to track `mapping` types known indices\n      // (and also *some* known indices for arrays)\n\n      //HACK: we use the alternate stack in this case\n\n      debug(\"Index access case\");\n\n      //we're going to start by doing the same thing as in the default case\n      //(see below) -- getting things ready for an assignment.  Then we're\n      //going to forget this for a bit while we handle the rest...\n      assignments = {\n        ...preambleAssignments,\n        ...literalAssignments(\n          compilationId,\n          node,\n          stack,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        )\n      };\n\n      //we'll need this\n      baseExpression = node.baseExpression;\n\n      //but first, a diversion -- is this something that could not *possibly*\n      //lead to a mapping?  i.e., either a bytes, or an array of non-reference\n      //types, or a non-storage array?\n      //if so, we'll just do the assign and quit out early\n      //(note: we write it this way because mappings aren't caught by\n      //isReference)\n      if (\n        Codec.Ast.Utils.typeClass(baseExpression) === \"bytes\" ||\n        (Codec.Ast.Utils.typeClass(baseExpression) === \"array\" &&\n          (Codec.Ast.Utils.isReference(node)\n            ? Codec.Ast.Utils.referenceType(baseExpression) !== \"storage\"\n            : !Codec.Ast.Utils.isMapping(node)))\n      ) {\n        debug(\"Index case bailed out early\");\n        debug(\"typeClass %s\", Codec.Ast.Utils.typeClass(baseExpression));\n        debug(\n          \"referenceType %s\",\n          Codec.Ast.Utils.referenceType(baseExpression)\n        );\n        debug(\"isReference(node) %o\", Codec.Ast.Utils.isReference(node));\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      let keyDefinition = Codec.Ast.Utils.keyDefinition(baseExpression, scopes);\n      //if we're dealing with an array, this will just spoof up a uint\n      //definition :)\n\n      //now... the decoding! (this is messy)\n      let indexValue = yield* decodeMappingKeySaga(\n        node.indexExpression,\n        keyDefinition\n      );\n\n      debug(\"index value %O\", indexValue);\n      debug(\"keyDefinition %o\", keyDefinition);\n\n      //whew! But we're not done yet -- we need to turn this decoded key into\n      //an actual path (assuming we *did* decode it; we check both for null\n      //and for the result being a Value and not an Error)\n      //OK, not an actual path -- we're just going to use a simple offset for\n      //the path.  But that's OK, because the mappedPaths reducer will turn\n      //it into an actual path.\n      if (indexValue != null && indexValue.value) {\n        path = fetchBasePath(\n          compilationId,\n          baseExpression,\n          mappedPaths,\n          currentAssignments,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        );\n\n        let slot = { path };\n\n        //we need to do things differently depending on whether we're dealing\n        //with an array or mapping\n        switch (Codec.Ast.Utils.typeClass(baseExpression)) {\n          case \"array\":\n            slot.hashPath = Codec.Ast.Utils.isDynamicArray(baseExpression);\n            slot.offset = indexValue.value.asBN.muln(\n              Codec.Storage.Allocate.storageSize(\n                Codec.Ast.Import.definitionToType(\n                  node,\n                  compilationId,\n                  compiler\n                ),\n                userDefinedTypes,\n                storageAllocations\n              ).words\n            );\n            break;\n          case \"mapping\":\n            slot.key = indexValue;\n            slot.offset = new BN(0);\n            break;\n          default:\n            debug(\"unrecognized index access!\");\n        }\n        debug(\"slot %O\", slot);\n\n        //now, map it! (and do the assign as well)\n        yield put(\n          actions.mapPathAndAssign(\n            address,\n            slot,\n            assignments,\n            Codec.Ast.Utils.typeIdentifier(node),\n            Codec.Ast.Utils.typeIdentifier(baseExpression)\n          )\n        );\n      } else {\n        //if we failed to decode, just do the assign from above\n        debug(\"failed to decode, just assigning\");\n        yield put(actions.assign(assignments));\n      }\n\n      break;\n\n    case \"MemberAccess\":\n      //HACK: we use the alternate stack in this case\n\n      //we're going to start by doing the same thing as in the default case\n      //(see below) -- getting things ready for an assignment.  Then we're\n      //going to forget this for a bit while we handle the rest...\n      assignments = {\n        ...preambleAssignments,\n        ...literalAssignments(\n          compilationId,\n          node,\n          stack,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        )\n      };\n\n      debug(\"Member access case\");\n\n      //MemberAccess uses expression, not baseExpression\n      baseExpression = node.expression;\n\n      //if this isn't a storage struct, or the element isn't of reference type,\n      //we'll just do the assignment and quit out (again, note that mappings\n      //aren't caught by isReference)\n      if (\n        Codec.Ast.Utils.typeClass(baseExpression) !== \"struct\" ||\n        (Codec.Ast.Utils.isReference(node)\n          ? Codec.Ast.Utils.referenceType(baseExpression) !== \"storage\"\n          : !Codec.Ast.Utils.isMapping(node))\n      ) {\n        debug(\"Member case bailed out early\");\n        yield put(actions.assign(assignments));\n        break;\n      }\n\n      //but if it is a storage struct, we have to map the path as well\n      path = fetchBasePath(\n        compilationId,\n        baseExpression,\n        mappedPaths,\n        currentAssignments,\n        currentDepth,\n        modifierDepth,\n        inModifier\n      );\n\n      slot = { path };\n\n      let structType = Codec.Ast.Import.definitionToType(\n        baseExpression,\n        compilationId,\n        compiler\n      );\n      let memberAllocations = storageAllocations[structType.id].members;\n      //members of a given struct have unique names so it's safe to look up the member by name\n      let memberName = scopes[node.referencedDeclaration].definition.name;\n      let memberAllocation = memberAllocations.find(\n        member => member.name === memberName\n      );\n\n      slot.offset = memberAllocation.pointer.range.from.slot.offset.clone();\n\n      debug(\"slot %o\", slot);\n      yield put(\n        actions.mapPathAndAssign(\n          address,\n          slot,\n          assignments,\n          Codec.Ast.Utils.typeIdentifier(node),\n          Codec.Ast.Utils.typeIdentifier(baseExpression)\n        )\n      );\n      break;\n\n    default:\n      if (node.id === undefined || node.typeDescriptions == undefined) {\n        break;\n      }\n\n      debug(\"decoding expression value %O\", node.typeDescriptions);\n      debug(\"default case\");\n      debug(\"currentDepth %d node.id %d\", currentDepth, node.id);\n\n      assignments = {\n        ...preambleAssignments,\n        ...literalAssignments(\n          compilationId,\n          node,\n          stack,\n          currentDepth,\n          modifierDepth,\n          inModifier\n        )\n      };\n      yield put(actions.assign(assignments));\n      break;\n  }\n}\n\nfunction* decodeMappingKeySaga(indexDefinition, keyDefinition) {\n  //something of a HACK -- cleans any out-of-range booleans\n  //resulting from the main mapping key decoding loop\n  let indexValue = yield* decodeMappingKeyCore(indexDefinition, keyDefinition);\n  return indexValue ? Codec.Conversion.cleanBool(indexValue) : indexValue;\n}\n\nfunction* decodeMappingKeyCore(indexDefinition, keyDefinition) {\n  let scopes = yield select(data.current.scopes.inlined);\n  let compilationId = yield select(data.current.compilationId);\n  let currentAssignments = yield select(data.proc.assignments);\n  let currentDepth = yield select(data.current.functionDepth);\n  let modifierDepth = yield select(data.current.modifierDepth);\n  let inModifier = yield select(data.current.inModifier);\n\n  //why the loop? see the end of the block it heads for an explanatory\n  //comment\n  while (true) {\n    let indexId = indexDefinition.id;\n    //indices need to be identified by stackframe\n    let indexIdObj = inModifier\n      ? {\n          compilationId,\n          astRef: indexId,\n          stackframe: currentDepth,\n          modifierDepth\n        }\n      : { compilationId, astRef: indexId, stackframe: currentDepth };\n    let fullIndexId = stableKeccak256(indexIdObj);\n\n    const indexReference = (currentAssignments.byId[fullIndexId] || {}).ref;\n\n    if (Codec.Ast.Utils.isSimpleConstant(indexDefinition)) {\n      //while the main case is the next one, where we look for a prior\n      //assignment, we need this case (and need it first) for two reasons:\n      //1. some constant expressions (specifically, string and hex literals)\n      //aren't sourcemapped to and so won't have a prior assignment\n      //2. if the key type is bytesN but the expression is constant, the\n      //value will go on the stack *left*-padded instead of right-padded,\n      //so looking for a prior assignment will read the wrong value.\n      //so instead it's preferable to use the constant directly.\n      debug(\"about to decode simple literal\");\n      return yield* decode(\n        keyDefinition,\n        {\n          location: \"definition\",\n          definition: indexDefinition\n        },\n        compilationId\n      );\n    } else if (indexReference) {\n      //if a prior assignment is found\n      let splicedDefinition;\n      //in general, we want to decode using the key definition, not the index\n      //definition. however, the key definition may have the wrong location\n      //on it.  so, when applicable, we splice the index definition location\n      //onto the key definition location.\n      if (Codec.Ast.Utils.isReference(indexDefinition)) {\n        splicedDefinition = Codec.Ast.Utils.spliceLocation(\n          keyDefinition,\n          Codec.Ast.Utils.referenceType(indexDefinition)\n        );\n        //we could put code here to add on the \"_ptr\" ending when absent,\n        //but we presently ignore that ending, so we'll skip that\n      } else {\n        splicedDefinition = keyDefinition;\n      }\n      debug(\"about to decode\");\n      return yield* decode(splicedDefinition, indexReference, compilationId);\n    } else if (\n      indexDefinition.referencedDeclaration &&\n      scopes[indexDefinition.referencedDeclaration]\n    ) {\n      //there's one more reason we might have failed to decode it: it might be a\n      //constant state variable.  Unfortunately, we don't know how to decode all\n      //those at the moment, but we can handle the ones we do know how to decode.\n      //In the future hopefully we will decode all of them\n      debug(\"referencedDeclaration %d\", indexDefinition.referencedDeclaration);\n      let indexConstantDeclaration =\n        scopes[indexDefinition.referencedDeclaration].definition;\n      debug(\"indexConstantDeclaration %O\", indexConstantDeclaration);\n      if (indexConstantDeclaration.constant) {\n        let indexConstantDefinition = indexConstantDeclaration.value;\n        //next line filters out constants we don't know how to handle\n        if (Codec.Ast.Utils.isSimpleConstant(indexConstantDefinition)) {\n          debug(\"about to decode simple constant\");\n          return yield* decode(\n            keyDefinition,\n            {\n              location: \"definition\",\n              definition: indexConstantDeclaration.value\n            },\n            compilationId\n          );\n        } else {\n          return null; //can't decode; see below for more explanation\n        }\n      } else {\n        return null; //can't decode; see below for more explanation\n      }\n    }\n    //there's still one more reason we might have failed to decode it:\n    //certain (silent) type conversions aren't sourcemapped either.\n    //(thankfully, any type conversion that actually *does* something seems\n    //to be sourcemapped.)  So if we've failed to decode it, we try again\n    //with the argument of the type conversion, if it is one; we leave\n    //indexValue undefined so the loop will continue\n    //(note that this case is last for a reason; if this were earlier, it\n    //would catch *non*-silent type conversions, which we want to just read\n    //off the stack)\n    else if (indexDefinition.kind === \"typeConversion\") {\n      indexDefinition = indexDefinition.arguments[0];\n    }\n    //...also prior to 0.5.0, unary + was legal, which needs to be accounted\n    //for for the same reason\n    else if (\n      indexDefinition.nodeType === \"UnaryOperation\" &&\n      indexDefinition.operator === \"+\"\n    ) {\n      indexDefinition = indexDefinition.subExpression;\n    }\n    //otherwise, we've just totally failed to decode it, so we mark\n    //indexValue as null (as distinct from undefined) to indicate this.  In\n    //the future, we should be able to decode all mapping keys, but we're\n    //not quite there yet, sorry (because we can't yet handle all constant\n    //state variables)\n    else {\n      return null;\n    }\n    //now, as mentioned, retry in the typeConversion case\n    //(or unary + case)\n  }\n}\n\nexport function* reset() {\n  yield put(actions.reset());\n}\n\nexport function* recordAllocations() {\n  const contracts = yield select(data.views.contractAllocationInfo);\n  debug(\"contracts %O\", contracts);\n  const referenceDeclarations = yield select(data.views.referenceDeclarations);\n  const userDefinedTypes = yield select(data.views.userDefinedTypes);\n  debug(\"referenceDeclarations %O\", referenceDeclarations);\n  const storageAllocations = Codec.Storage.Allocate.getStorageAllocations(\n    userDefinedTypes\n  );\n  debug(\"storageAllocations %O\", storageAllocations);\n  const memoryAllocations = Codec.Memory.Allocate.getMemoryAllocations(\n    userDefinedTypes\n  );\n  const abiAllocations = Codec.AbiData.Allocate.getAbiAllocations(\n    userDefinedTypes\n  );\n  const calldataAllocations = Codec.AbiData.Allocate.getCalldataAllocations(\n    contracts,\n    referenceDeclarations,\n    userDefinedTypes,\n    abiAllocations\n  );\n  const stateAllocations = Codec.Storage.Allocate.getStateAllocations(\n    contracts,\n    referenceDeclarations,\n    userDefinedTypes,\n    storageAllocations\n  );\n  yield put(\n    actions.allocate(\n      storageAllocations,\n      memoryAllocations,\n      abiAllocations,\n      calldataAllocations,\n      stateAllocations\n    )\n  );\n}\n\nfunction literalAssignments(\n  compilationId,\n  node,\n  stack,\n  currentDepth,\n  modifierDepth,\n  inModifier\n) {\n  let top = stack.length - 1;\n\n  let literal;\n  try {\n    literal = Codec.Stack.Read.readStack(\n      {\n        location: \"stack\",\n        from: top - Codec.Ast.Utils.stackSize(node) + 1,\n        to: top\n      },\n      {\n        stack,\n        storage: {} //irrelevant, but let's respect the type signature :)\n      }\n    );\n  } catch (error) {\n    literal = undefined; //not sure if this is right, but this is what would\n    //happen before, so I figure it's safe?\n  }\n\n  let assignment = makeAssignment(\n    inModifier\n      ? {\n          compilationId,\n          astRef: node.id,\n          stackframe: currentDepth,\n          modifierDepth\n        }\n      : { compilationId, astRef: node.id, stackframe: currentDepth },\n    { location: \"stackliteral\", literal }\n  );\n\n  return { [assignment.id]: assignment };\n}\n\n//takes a parameter list as given in the AST\nfunction assignParameters(\n  compilationId,\n  parameters,\n  top,\n  functionDepth,\n  modifierDepth = 0,\n  forModifier = false\n) {\n  let reverseParameters = parameters.slice().reverse();\n  //reverse is in-place, so we use slice() to clone first\n  debug(\"reverseParameters %o\", parameters);\n\n  let currentPosition = top;\n  let assignments = {};\n\n  for (let parameter of reverseParameters) {\n    let words = Codec.Ast.Utils.stackSize(parameter);\n    let pointer = {\n      location: \"stack\",\n      from: currentPosition - words + 1,\n      to: currentPosition\n    };\n    let assignment = makeAssignment(\n      forModifier\n        ? {\n            compilationId,\n            astRef: parameter.id,\n            stackframe: functionDepth,\n            modifierDepth\n          }\n        : { compilationId, astRef: parameter.id, stackframe: functionDepth },\n      pointer\n    );\n    assignments[assignment.id] = assignment;\n    currentPosition -= words;\n  }\n  return assignments;\n}\n\nfunction fetchBasePath(\n  compilationId,\n  baseNode,\n  mappedPaths,\n  currentAssignments,\n  currentDepth,\n  modifierDepth,\n  inModifier\n) {\n  let fullId = stableKeccak256(\n    inModifier\n      ? {\n          compilationId,\n          astRef: baseNode.id,\n          stackframe: currentDepth,\n          modifierDepth\n        }\n      : {\n          compilationId,\n          astRef: baseNode.id,\n          stackframe: currentDepth\n        }\n  );\n  debug(\"astId: %d\", baseNode.id);\n  debug(\"stackframe: %d\", currentDepth);\n  debug(\"fullId: %s\", fullId);\n  debug(\"currentAssignments: %O\", currentAssignments);\n  //base expression is an expression, and so has a literal assigned to\n  //it\n  let offset = Codec.Conversion.toBN(\n    currentAssignments.byId[fullId].ref.literal\n  );\n  return { offset };\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"data\", saga);\n","module.exports = require(\"babel-runtime/helpers/asyncToGenerator\");","export const ADVANCE = \"CONTROLLER_ADVANCE\";\nexport function advance(count) {\n  return { type: ADVANCE, count };\n}\n\nexport const STEP_NEXT = \"CONTROLLER_STEP_NEXT\";\nexport function stepNext() {\n  return { type: STEP_NEXT };\n}\n\nexport const STEP_OVER = \"CONTROLLER_STEP_OVER\";\nexport function stepOver() {\n  return { type: STEP_OVER };\n}\n\nexport const STEP_INTO = \"CONTROLLER_STEP_INTO\";\nexport function stepInto() {\n  return { type: STEP_INTO };\n}\n\nexport const STEP_OUT = \"CONTROLLER_STEP_OUT\";\nexport function stepOut() {\n  return { type: STEP_OUT };\n}\n\nexport const RESET = \"CONTROLLER_RESET\";\nexport function reset() {\n  return { type: RESET };\n}\n\nexport const INTERRUPT = \"CONTROLLER_INTERRUPT\";\nexport function interrupt() {\n  return { type: INTERRUPT };\n}\n\nexport const CONTINUE = \"CONTROLLER_CONTINUE\";\nexport function continueUntilBreakpoint(breakpoints) {\n  //\"continue\" is not a legal name\n  return {\n    type: CONTINUE,\n    breakpoints\n  };\n}\n\nexport const ADD_BREAKPOINT = \"CONTROLLER_ADD_BREAKPOINT\";\nexport function addBreakpoint(breakpoint) {\n  return {\n    type: ADD_BREAKPOINT,\n    breakpoint\n  };\n}\n\nexport const REMOVE_BREAKPOINT = \"CONTROLLER_REMOVE_BREAKPOINT\";\nexport function removeBreakpoint(breakpoint) {\n  return {\n    type: REMOVE_BREAKPOINT,\n    breakpoint\n  };\n}\n\nexport const REMOVE_ALL_BREAKPOINTS = \"CONTROLLER_REMOVE_ALL_BREAKPOINTS\";\nexport function removeAllBreakpoints() {\n  return {\n    type: REMOVE_ALL_BREAKPOINTS\n  };\n}\n\nexport const START_STEPPING = \"CONTROLLER_START_STEPPING\";\nexport function startStepping() {\n  return {\n    type: START_STEPPING\n  };\n}\n\nexport const DONE_STEPPING = \"CONTROLLER_DONE_STEPPING\";\nexport function doneStepping() {\n  return {\n    type: DONE_STEPPING\n  };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:data:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport jsonpointer from \"json-pointer\";\nimport flatten from \"lodash.flatten\";\nimport semver from \"semver\";\n\nimport { stableKeccak256, makePath } from \"lib/helpers\";\n\nimport trace from \"lib/trace/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport solidity from \"lib/solidity/selectors\";\n\nimport * as Codec from \"@truffle/codec\";\n\n/**\n * @private\n */\nconst identity = x => x;\n\nfunction findAncestorOfType(node, types, scopes, pointer = null, root = null) {\n  //note: you may want to include \"SourceUnit\" as a fallback type when using\n  //this function for convenience.\n  //you only need to pass pointer and root if you want this function to work\n  //from Yul.  Otherwise you can omit those and you'll get null if you happen\n  //to be in Yul.\n  while (node && !types.includes(node.nodeType)) {\n    if (node.id !== undefined) {\n      node = scopes[scopes[node.id].parentId].definition;\n    } else {\n      if (pointer === null || root === null) {\n        return null;\n      }\n      pointer = pointer.replace(/\\/[^/]*$/, \"\"); //chop off end\n      node = jsonpointer.get(root, pointer);\n    }\n  }\n  return node;\n}\n\n//given a modifier invocation (or inheritance specifier) node,\n//get the node for the actual modifier (or constructor)\nfunction modifierForInvocation(invocation, scopes) {\n  let rawId; //raw referencedDeclaration ID extracted from the AST.\n  //if it's a modifier this is what we want, but if it's base\n  //constructor, we'll get the contract instead, and need to find its\n  //constructor.\n  switch (invocation.nodeType) {\n    case \"ModifierInvocation\":\n      rawId = invocation.modifierName.referencedDeclaration;\n      break;\n    case \"InheritanceSpecifier\":\n      rawId = invocation.baseName.referencedDeclaration;\n      break;\n    default:\n      debug(\"bad invocation node\");\n  }\n  let rawNode = scopes[rawId].definition;\n  switch (rawNode.nodeType) {\n    case \"ModifierDefinition\":\n      return rawNode;\n    case \"ContractDefinition\":\n      return rawNode.nodes.find(\n        node =>\n          node.nodeType === \"FunctionDefinition\" &&\n          Codec.Ast.Utils.functionKind(node) === \"constructor\"\n      );\n    default:\n      //we should never hit this case\n      return undefined;\n  }\n}\n\n//see data.views.contexts for an explanation\nfunction debuggerContextToDecoderContext(context) {\n  let {\n    context: contextHash,\n    contractName,\n    binary,\n    contractId,\n    contractKind,\n    isConstructor,\n    abi,\n    payable,\n    compiler,\n    compilationId\n  } = context;\n  return {\n    context: contextHash,\n    contractName,\n    binary,\n    contractId,\n    contractKind,\n    isConstructor,\n    abi: Codec.AbiData.Utils.computeSelectors(abi),\n    payable,\n    compiler,\n    compilationId\n  };\n}\n\n//spoofed definitions we'll need\n//we'll give them id -1 to indicate that they're spoofed\n\nexport const NOW_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"now\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_uint256\",\n    typeString: \"uint256\"\n  }\n};\n\nexport const MSG_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"msg\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_magic_message\",\n    typeString: \"msg\"\n  }\n};\n\nexport const TX_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"tx\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_magic_transaction\",\n    typeString: \"tx\"\n  }\n};\n\nexport const BLOCK_DEFINITION = {\n  id: -1,\n  src: \"0:0:-1\",\n  name: \"block\",\n  nodeType: \"VariableDeclaration\",\n  typeDescriptions: {\n    typeIdentifier: \"t_magic_block\",\n    typeString: \"block\"\n  }\n};\n\nfunction spoofThisDefinition(contractName, contractId, contractKind) {\n  let formattedName = contractName.replace(/\\$/g, \"$$\".repeat(3));\n  //note that string.replace treats $'s specially in the replacement string;\n  //we want 3 $'s for each $ in the input, so we need to put *6* $'s in the\n  //replacement string\n  return {\n    id: -1,\n    src: \"0:0:-1\",\n    name: \"this\",\n    nodeType: \"VariableDeclaration\",\n    typeDescriptions: {\n      typeIdentifier: \"t_contract$_\" + formattedName + \"_$\" + contractId,\n      typeString: contractKind + \" \" + contractName\n    }\n  };\n}\n\nconst data = createSelectorTree({\n  state: state => state.data,\n\n  /**\n   * data.views\n   */\n  views: {\n    /*\n     * data.views.atLastInstructionForSourceRange\n     */\n    atLastInstructionForSourceRange: createLeaf(\n      [solidity.current.isSourceRangeFinal],\n      final => final\n    ),\n\n    /**\n     * data.views.scopes (namespace)\n     */\n    scopes: {\n      /**\n       * data.view.scopes (selector)\n       * the raw version is below; this version accounts for inheritance\n       * NOTE: grouped by compilation\n       */\n      _: createLeaf([\"./raw\", \"./inlined/raw\"], (scopes, inlined) =>\n        Object.assign(\n          {},\n          ...Object.entries(scopes).map(([compilationId, nodes]) => ({\n            [compilationId]: Object.assign(\n              {},\n              ...Object.entries(nodes).map(([id, scope]) => {\n                let definition = inlined[compilationId][id].definition;\n                if (definition.nodeType !== \"ContractDefinition\") {\n                  return { [id]: scope };\n                }\n                //if we've reached this point, we should be dealing with a\n                //contract, and specifically a contract -- not an interface or\n                //library (those don't get \"variables\" entries in their scopes)\n                debug(\"contract id %d\", id);\n                let newScope = { ...scope };\n                //note that Solidity gives us the linearization in order from most\n                //derived to most base, but we want most base to most derived;\n                //annoyingly, reverse() is in-place, so we clone with slice() first\n                let linearizedBaseContractsFromBase = definition.linearizedBaseContracts\n                  .slice()\n                  .reverse();\n                linearizedBaseContractsFromBase.pop(); //remove the last element, i.e.,\n                //the contract itself, because we want to treat that one specially\n                //now, we put it all together\n                newScope.variables = []\n                  .concat(\n                    //concatenate the variables lists from the base classes\n                    ...linearizedBaseContractsFromBase.map(\n                      contractId =>\n                        scopes[compilationId][contractId].variables || []\n                      //we need the || [] because contracts with no state variables\n                      //have variables undefined rather than empty like you'd expect\n                    )\n                  )\n                  .filter(\n                    variable =>\n                      inlined[compilationId][variable.astRef].definition\n                        .visibility !== \"private\"\n                    //filter out private variables from the base classes\n                  )\n                  //add in the variables for the contract itself -- note that here\n                  //private variables are not filtered out!\n                  .concat(scopes[compilationId][id].variables || [])\n                  .filter(variable => {\n                    //HACK: let's filter out those constants we don't know\n                    //how to read.  they'll just clutter things up.\n                    debug(\"variable %O\", variable);\n                    let definition =\n                      inlined[compilationId][variable.astRef].definition;\n                    return (\n                      !definition.constant ||\n                      Codec.Ast.Utils.isSimpleConstant(definition.value)\n                    );\n                  });\n\n                return { [id]: newScope };\n              })\n            )\n          }))\n        )\n      ),\n\n      /*\n       * data.views.scopes.raw\n       * NOTE: grouped by compilation\n       *\n       * the raw scopes data, just with intermediate\n       * layers cut out\n       */\n      raw: createLeaf([\"/info/scopes\"], scopes =>\n        Object.assign(\n          {},\n          ...Object.entries(scopes.byCompilationId).map(\n            ([compilationId, { byAstRef: nodes }]) => ({\n              [compilationId]: { ...nodes }\n            })\n          )\n        )\n      ),\n\n      /**\n       * data.views.scopes.inlined (namespace)\n       */\n      inlined: {\n        /**\n         * data.views.scopes.inlined (selector)\n         * see data.views.scopes for how this differs from the raw version\n         * NOTE: grouped by compilation\n         */\n        _: createLeaf([\"../_\", \"./raw\"], (scopes, inlined) =>\n          Object.assign(\n            {},\n            ...Object.entries(inlined).map(([compilationId, nodes]) => ({\n              [compilationId]: Object.assign(\n                {},\n                ...Object.entries(nodes).map(([id, info]) => ({\n                  [id]: {\n                    ...info,\n                    variables: scopes[compilationId][id].variables\n                  }\n                }))\n              )\n            }))\n          )\n        ),\n\n        /**\n         * data.views.scopes.inlined.raw\n         * NOTE: grouped by compilation\n         */\n        raw: createLeaf(\n          [\"../raw\", solidity.info.sources],\n\n          (scopes, sources) =>\n            Object.assign(\n              {},\n              ...Object.entries(scopes).map(([compilationId, nodes]) => ({\n                [compilationId]: Object.assign(\n                  {},\n                  ...Object.entries(nodes).map(([id, entry]) => ({\n                    [id]: {\n                      ...entry,\n\n                      definition: jsonpointer.get(\n                        sources[compilationId].byId[entry.sourceId].ast,\n                        entry.pointer\n                      )\n                    }\n                  }))\n                )\n              }))\n            )\n        )\n      }\n    },\n\n    /*\n     * data.views.userDefinedTypes\n     * user-defined types for passing to the decoder\n     * NOTE: *not* grouped by compilation\n     */\n    userDefinedTypes: createLeaf(\n      [\"./referenceDeclarations\", \"./scopes\", solidity.info.sources],\n      (referenceDeclarations, scopes, sources) => {\n        return Object.assign(\n          {},\n          ...flatten(\n            Object.entries(referenceDeclarations).map(\n              ([compilationId, nodes]) =>\n                Object.values(nodes)\n                  .map(node =>\n                    Codec.Ast.Import.definitionToStoredType(\n                      node,\n                      compilationId,\n                      sources[compilationId].byId[\n                        scopes[compilationId][node.id].sourceId\n                      ].compiler,\n                      referenceDeclarations[compilationId]\n                    )\n                  )\n                  .map(type => ({ [type.id]: type }))\n            )\n          )\n        );\n      }\n    ),\n\n    /*\n     * data.views.contractAllocationInfo\n     */\n    contractAllocationInfo: createLeaf(\n      [\n        \"/info/userDefinedTypes\",\n        \"/views/scopes/inlined\",\n        solidity.info.sources,\n        evm.info.contexts\n      ],\n      (userDefinedTypes, scopes, sources, contexts) =>\n        Object.values(userDefinedTypes)\n          .filter(\n            ({ compilationId, id }) =>\n              scopes[compilationId][id].definition.nodeType ===\n              \"ContractDefinition\"\n          )\n          .map(({ compilationId, id }) => {\n            debug(\"id: %O\", id);\n            debug(\"compilationId: %O\", compilationId);\n            let deployedContext = Object.values(contexts).find(\n              context =>\n                !context.isConstructor &&\n                context.compilationId === compilationId &&\n                context.contractId === id\n            );\n            let constructorContext = Object.values(contexts).find(\n              context =>\n                context.isConstructor &&\n                context.compilationId === compilationId &&\n                context.contractId === id\n            );\n            let immutableReferences = deployedContext\n              ? deployedContext.immutableReferences\n              : undefined;\n            return {\n              contractNode: scopes[compilationId][id].definition,\n              compilationId,\n              immutableReferences,\n              //we don't just use deployedContext to get compiler because it might not exist!\n              compiler:\n                sources[compilationId].byId[scopes[compilationId][id].sourceId]\n                  .compiler,\n              //the following three are only needed for decoding return values\n              abi: (deployedContext || {}).abi,\n              deployedContext,\n              constructorContext\n            };\n          })\n    ),\n\n    /*\n     * data.views.referenceDeclarations\n     * NOTE: grouped by compilation\n     */\n    referenceDeclarations: createLeaf(\n      [\"./scopes/inlined\", \"/info/userDefinedTypes\"],\n      (scopes, userDefinedTypes) =>\n        Object.assign(\n          {},\n          ...Object.entries(scopes).map(([compilationId, nodes]) => ({\n            [compilationId]: Object.assign(\n              {},\n              ...userDefinedTypes.map(\n                ({ compilationId: compilationIdForType, id }) =>\n                  compilationIdForType === compilationId\n                    ? { [id]: nodes[id].definition }\n                    : {}\n              )\n            )\n          }))\n        )\n    ),\n\n    /**\n     * data.views.mappingKeys\n     */\n    mappingKeys: createLeaf(\n      [\"/proc/mappedPaths\", \"/current/address\"],\n      (mappedPaths, address) =>\n        []\n          .concat(\n            ...Object.values(\n              (mappedPaths.byAddress[address] || { byType: {} }).byType\n            ).map(({ bySlotAddress }) => Object.values(bySlotAddress))\n          )\n          .filter(slot => slot.key !== undefined)\n    ),\n\n    /*\n     * data.views.blockNumber\n     * returns block number as string\n     */\n    blockNumber: createLeaf([evm.transaction.globals.block], block =>\n      block.number.toString()\n    ),\n\n    /*\n     * data.views.instances\n     * same as evm.current.codex.instances, but we just map address => binary,\n     * we don't bother with context, and also the code is a Uint8Array\n     */\n    instances: createLeaf([evm.current.codex.instances], instances =>\n      Object.assign(\n        {},\n        ...Object.entries(instances).map(([address, { binary }]) => ({\n          [address]: Codec.Conversion.toBytes(binary)\n        }))\n      )\n    ),\n\n    /*\n     * data.views.contexts\n     * same as evm.info.contexts, but:\n     * 0. we only include non-constructor contexts\n     * 1. we strip out sourceMap and primarySource\n     * 2. we alter abi in two ways:\n     * 2a. we strip out everything but functions\n     * 2b. abi is now an object, not an array, and indexed by these signatures\n     */\n    contexts: createLeaf([evm.info.contexts], contexts =>\n      Object.assign(\n        {},\n        ...Object.values(contexts)\n          .filter(context => !context.isConstructor)\n          .map(context => ({\n            [context.contractId]: debuggerContextToDecoderContext(context)\n          }))\n      )\n    )\n  },\n\n  /**\n   * data.info\n   */\n  info: {\n    /**\n     * data.info.scopes\n     */\n    scopes: createLeaf([\"/state\"], state => state.info.scopes),\n\n    /*\n     * data.info.allocations\n     */\n    allocations: {\n      /*\n       * data.info.allocations.storage\n       */\n      storage: createLeaf([\"/state\"], state => state.info.allocations.storage),\n\n      /**\n       * data.info.allocations.state\n       */\n      state: createLeaf([\"/state\"], state => state.info.allocations.state),\n\n      /*\n       * data.info.allocations.memory\n       */\n      memory: createLeaf([\"/state\"], state => state.info.allocations.memory),\n\n      /*\n       * data.info.allocations.abi\n       */\n      abi: createLeaf([\"/state\"], state => state.info.allocations.abi),\n\n      /*\n       * data.info.allocations.calldata\n       */\n      calldata: createLeaf([\"/state\"], state => state.info.allocations.calldata)\n    },\n\n    /**\n     * data.info.userDefinedTypes\n     */\n    userDefinedTypes: createLeaf(\n      [\"/state\"],\n      state => state.info.userDefinedTypes\n    )\n  },\n\n  /**\n   * data.proc\n   */\n  proc: {\n    /**\n     * data.proc.assignments\n     */\n    assignments: createLeaf(\n      [\"/state\"],\n      state => state.proc.assignments\n      //note: this no longer fetches just the byId, but rather the whole\n      //assignments object\n    ),\n\n    /*\n     * data.proc.mappedPaths\n     */\n    mappedPaths: createLeaf([\"/state\"], state => state.proc.mappedPaths),\n\n    /**\n     * data.proc.decodingKeys\n     *\n     * number of keys that are still decoding\n     */\n    decodingKeys: createLeaf(\n      [\"./mappedPaths\"],\n      mappedPaths => mappedPaths.decodingStarted\n    )\n  },\n\n  /**\n   * data.current\n   */\n  current: {\n    /**\n     * data.current.state\n     */\n    state: {\n      /**\n       * data.current.state.stack\n       */\n      stack: createLeaf(\n        [evm.current.state.stack],\n\n        words => (words || []).map(word => Codec.Conversion.toBytes(word))\n      ),\n\n      /**\n       * data.current.state.memory\n       */\n      memory: createLeaf(\n        [evm.current.state.memory],\n\n        words => Codec.Conversion.toBytes(words.join(\"\"))\n      ),\n\n      /**\n       * data.current.state.code\n       */\n      code: createLeaf([evm.current.context], ({ binary }) =>\n        Codec.Conversion.toBytes(binary)\n      ),\n\n      /**\n       * data.current.state.calldata\n       */\n      calldata: createLeaf(\n        [evm.current.call],\n\n        ({ data }) => Codec.Conversion.toBytes(data)\n      ),\n\n      /**\n       * data.current.state.storage\n       */\n      storage: createLeaf(\n        [evm.current.codex.storage],\n\n        mapping =>\n          Object.assign(\n            {},\n            ...Object.entries(mapping).map(([address, word]) => ({\n              [`0x${address}`]: Codec.Conversion.toBytes(word)\n            }))\n          )\n      ),\n\n      /*\n       * data.current.state.specials\n       * I've named these after the solidity variables they correspond to,\n       * which are *mostly* the same as the corresponding EVM opcodes\n       * (FWIW: this = ADDRESS, sender = CALLER, value = CALLVALUE)\n       */\n      specials: createLeaf(\n        [\"/current/address\", evm.current.call, evm.transaction.globals],\n        (address, { sender, value }, { tx, block }) => ({\n          this: Codec.Conversion.toBytes(address),\n\n          sender: Codec.Conversion.toBytes(sender),\n\n          value: Codec.Conversion.toBytes(value),\n\n          //let's crack open that tx and block!\n          ...Object.assign(\n            {},\n            ...Object.entries(tx).map(([variable, value]) => ({\n              [variable]: Codec.Conversion.toBytes(value)\n            }))\n          ),\n\n          ...Object.assign(\n            {},\n            ...Object.entries(block).map(([variable, value]) => ({\n              [variable]: Codec.Conversion.toBytes(value)\n            }))\n          )\n        })\n      )\n    },\n\n    /**\n     * data.current.compilationId\n     */\n    compilationId: createLeaf(\n      [evm.current.context],\n      ({ compilationId }) => compilationId\n    ),\n\n    /**\n     * data.current.sourceId\n     */\n    sourceId: createLeaf([solidity.current.source], ({ id }) => id),\n\n    /**\n     * data.current.root\n     */\n    root: createLeaf([solidity.current.source], ({ ast }) => ast),\n\n    /**\n     * data.current.scopes (namespace)\n     */\n    scopes: {\n      /**\n       * data.current.scopes (selector)\n       * Replacement for the old data.info.scopes;\n       * that one now contains multi-compilation info, this\n       * one contains only the current compilation\n       */\n      _: createLeaf(\n        [\"/views/scopes\", \"../compilationId\"],\n        (scopes, compilationId) => scopes[compilationId]\n      ),\n\n      /**\n       * data.current.scopes.inlined\n       * Replacement for the old data.views.scopes.inlined;\n       * that one now contains multi-compilation info, this\n       * one contains only the current compilation\n       */\n      inlined: createLeaf(\n        [\"/views/scopes/inlined\", \"../compilationId\"],\n        (scopes, compilationId) => scopes[compilationId]\n      )\n    },\n\n    /*\n     * data.current.referenceDeclarations\n     */\n    referenceDeclarations: createLeaf(\n      [\"/views/referenceDeclarations\", \"./compilationId\"],\n      (scopes, compilationId) => scopes[compilationId]\n    ),\n\n    /*\n     * data.current.allocations\n     */\n    allocations: {\n      /*\n       * data.current.allocations.state\n       * Same as data.info.allocations.state, but uses the old allocation\n       * format (more convenient for debugger) where members are stored by ID\n       * in an object instead of by index in an array; also only holds things\n       * from the current compilation\n       * ALSO: if we're in a constructor, replaces all code pointers by appropriate\n       * memory pointers :)\n       */\n      state: createLeaf(\n        [\n          \"/info/allocations/state\",\n          \"/views/userDefinedTypes\",\n          \"../compilationId\",\n          evm.current.context\n        ],\n        (\n          allAllocations,\n          userDefinedTypes,\n          compilationId,\n          { isConstructor }\n        ) => {\n          const allocations = compilationId\n            ? allAllocations[compilationId]\n            : {};\n          //several-deep clone\n          let transformedAllocations = Object.assign(\n            {},\n            ...Object.entries(allocations).map(([id, allocation]) => ({\n              [id]: {\n                members: allocation.members.map(member => ({ ...member }))\n              }\n            }))\n          );\n          //if we're not in a constructor, we don't need to actually transform it.\n          //if we are...\n          if (isConstructor) {\n            //...we must transform code pointers!\n            for (const id in transformedAllocations) {\n              const allocation = transformedAllocations[id];\n              //here, the magic number 4 is the number of reserved memory slots\n              //at the start of memory.  immutables go immediately afterward.\n              let start = 4 * Codec.Evm.Utils.WORD_SIZE;\n              for (const member of allocation.members) {\n                //if it's not a code pointer, leave it alone\n                if (\n                  member.pointer.location === \"code\" ||\n                  member.pointer.location === \"nowhere\"\n                ) {\n                  //if it is, transform it\n                  member.pointer = {\n                    location: \"memory\",\n                    start,\n                    length: Codec.Evm.Utils.WORD_SIZE\n                  };\n                  start += Codec.Evm.Utils.WORD_SIZE;\n                }\n              }\n            }\n          }\n          //having now transformed code pointers if needed,\n          //we now index by ID\n          return Object.assign(\n            {},\n            ...Object.entries(transformedAllocations).map(\n              ([id, allocation]) => ({\n                [id]: {\n                  members: Object.assign(\n                    {},\n                    ...allocation.members.map(memberAllocation => ({\n                      [memberAllocation.definition.id]: memberAllocation\n                    }))\n                  )\n                }\n              })\n            )\n          );\n        }\n      )\n    },\n\n    /**\n     * data.current.compiler\n     */\n    compiler: createLeaf([evm.current.context], ({ compiler }) => compiler),\n\n    /**\n     * data.current.bareLetsInYulAreHit\n     */\n    bareLetsInYulAreHit: createLeaf(\n      [\"./compiler\"],\n      compiler =>\n        compiler !== undefined && //if no compiler we'll assume the old way I guess??\n        semver.satisfies(compiler.version, \">=0.6.8\", {\n          includePrerelease: true\n        })\n    ),\n\n    /**\n     * data.current.node\n     */\n    node: createLeaf([solidity.current.node], identity),\n\n    /**\n     * data.current.pointer\n     */\n    pointer: createLeaf([solidity.current.pointer], identity),\n\n    /**\n     * data.current.scope\n     * old alias for data.current.node (deprecated)\n     */\n    scope: createLeaf([\"./node\"], identity),\n\n    /*\n     * data.current.contract\n     * warning: may return null or similar, even though SourceUnit is included\n     * as fallback\n     */\n    contract: createLeaf(\n      [\"./node\", \"./scopes/inlined\", \"./pointer\", \"./root\"],\n      (node, scopes, pointer, root) => {\n        const types = [\"ContractDefinition\", \"SourceUnit\"];\n        //SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes, pointer, root);\n      }\n    ),\n\n    /*\n     * data.current.function\n     * may be modifier rather than function!\n     */\n    function: createLeaf(\n      [\"./node\", \"./scopes/inlined\", \"./pointer\", \"./root\"],\n      (node, scopes, pointer, root) => {\n        const types = [\n          \"FunctionDefinition\",\n          \"ModifierDefinition\",\n          \"ContractDefinition\",\n          \"SourceUnit\"\n        ];\n        //SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes, pointer, root);\n      }\n    ),\n\n    /*\n     * data.current.inModifier\n     */\n    inModifier: createLeaf(\n      [\"./function\"],\n      node => node && node.nodeType === \"ModifierDefinition\"\n    ),\n\n    /*\n     * data.current.inFunctionOrModifier\n     */\n    inFunctionOrModifier: createLeaf(\n      [\"./function\"],\n      node =>\n        node &&\n        (node.nodeType === \"FunctionDefinition\" ||\n          node.nodeType === \"ModifierDefinition\")\n    ),\n\n    /**\n     * data.current.functionDepth\n     */\n\n    functionDepth: createLeaf([solidity.current.functionDepth], identity),\n\n    /**\n     * data.current.modifierDepth\n     */\n\n    modifierDepth: createLeaf([solidity.current.modifierDepth], identity),\n\n    /**\n     * data.current.address\n     * NOTE: this is the STORAGE address for the current call, not the CODE\n     * address\n     */\n\n    address: createLeaf([evm.current.call], call => call.storageAddress),\n\n    /**\n     * data.current.functionsByProgramCounter\n     */\n    functionsByProgramCounter: createLeaf(\n      [solidity.current.functionsByProgramCounter],\n      functions => functions\n    ),\n\n    /**\n     * data.current.context\n     */\n    context: createLeaf([evm.current.context], debuggerContextToDecoderContext),\n\n    /*\n     * data.current.aboutToModify\n     * HACK\n     * This selector is used to catch those times when we go straight from a\n     * modifier invocation into the modifier itself, skipping over the\n     * definition node (this includes base constructor calls).  So it should\n     * return true when:\n     * 1. we're on the node corresponding to an argument to a modifier\n     * invocation or base constructor call, or, if said argument is a type\n     * conversion, its argument (or nested argument)\n     * 2. the next node is not a FunctionDefinition, ModifierDefinition, or\n     * in the same modifier / base constructor invocation\n     */\n    aboutToModify: createLeaf(\n      [\n        \"./node\",\n        \"./modifierInvocation\",\n        \"./modifierArgumentIndex\",\n        \"/next/node\",\n        \"/next/modifierInvocation\",\n        evm.current.step.isContextChange\n      ],\n      (node, invocation, index, next, nextInvocation, isContextChange) => {\n        //ensure: current instruction is not a context change (because if it is\n        //we cannot rely on the data.next selectors, but also if it is we know\n        //we're not about to call a modifier or base constructor!)\n        //we also want to return false if we can't find things for whatever\n        //reason\n        if (\n          isContextChange ||\n          !node ||\n          node.id === undefined ||\n          !next ||\n          next.id === undefined ||\n          !invocation ||\n          invocation.id === undefined ||\n          !nextInvocation ||\n          nextInvocation.id === undefined\n        ) {\n          return false;\n        }\n\n        //ensure: current position is in a ModifierInvocation or\n        //InheritanceSpecifier (recall that SourceUnit was included as\n        //fallback)\n        if (invocation.nodeType === \"SourceUnit\") {\n          return false;\n        }\n\n        //ensure: next node is not a function definition or modifier definition\n        if (\n          next.nodeType === \"FunctionDefinition\" ||\n          next.nodeType === \"ModifierDefinition\"\n        ) {\n          return false;\n        }\n\n        //ensure: next node is not in the same invocation\n        if (\n          nextInvocation.nodeType !== \"SourceUnit\" &&\n          nextInvocation.id === invocation.id\n        ) {\n          return false;\n        }\n\n        //now: are we on the node corresponding to an argument, or, if\n        //it's a type conversion, its nested argument?\n        if (index === undefined) {\n          return false;\n        }\n        let argument = invocation.arguments[index];\n        while (argument.kind === \"typeConversion\") {\n          if (node.id === argument.id) {\n            return true;\n          }\n          argument = argument.arguments[0];\n        }\n        return node.id === argument.id;\n      }\n    ),\n\n    /*\n     * data.current.modifierInvocation\n     */\n    modifierInvocation: createLeaf(\n      [\"./node\", \"./scopes/inlined\"],\n      (node, scopes) => {\n        const types = [\n          \"ModifierInvocation\",\n          \"InheritanceSpecifier\",\n          \"SourceUnit\"\n        ];\n        //again, SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes);\n      }\n    ),\n\n    /**\n     * data.current.modifierArgumentIndex\n     * gets the index of the current modifier argument that you're in\n     * (undefined when not in a modifier argument)\n     */\n    modifierArgumentIndex: createLeaf(\n      [\"./scopes\", \"./node\", \"./modifierInvocation\"],\n      (scopes, node, invocation) => {\n        if (!invocation || invocation.nodeType === \"SourceUnit\") {\n          return undefined;\n        }\n\n        let pointer = scopes[node.id].pointer;\n        let invocationPointer = scopes[invocation.id].pointer;\n\n        //slice the invocation pointer off the beginning\n        let difference = pointer.slice(invocationPointer.length);\n        debug(\"difference %s\", difference);\n        let rawIndex = difference.match(/^\\/arguments\\/(\\d+)/);\n        //note that that \\d+ is greedy\n        debug(\"rawIndex %o\", rawIndex);\n        if (rawIndex === null) {\n          return undefined;\n        }\n        return parseInt(rawIndex[1]);\n      }\n    ),\n\n    /*\n     * data.current.modifierBeingInvoked\n     * gets the node corresponding to the modifier or base constructor\n     * being invoked\n     */\n    modifierBeingInvoked: createLeaf(\n      [\"./modifierInvocation\", \"./scopes/inlined\"],\n      (invocation, scopes) => {\n        if (!invocation || invocation.nodeType === \"SourceUnit\") {\n          return undefined;\n        }\n\n        return modifierForInvocation(invocation, scopes);\n      }\n    ),\n\n    /**\n     * data.current.identifiers (namespace)\n     */\n    identifiers: {\n      /**\n       * data.current.identifiers (selector)\n       *\n       * returns identifers and corresponding definition node ID or builtin name\n       * (object entries look like [name]: {astRef: astRef}, [name]: {builtin: name})\n       */\n      _: createLeaf(\n        [\n          \"/current/scopes/inlined\",\n          \"/current/node\",\n          \"/current/pointer\",\n          \"/current/sourceId\"\n        ],\n\n        (scopes, scope, pointer, sourceId) => {\n          let variables = {};\n          if (scope !== undefined) {\n            let cur =\n              scope.id !== undefined ? scope.id : makePath(sourceId, pointer);\n\n            while (cur !== null && scopes[cur]) {\n              variables = Object.assign(\n                variables,\n                ...(scopes[cur].variables || [])\n                  .filter(variable => variable.name !== \"\") //exclude anonymous output params\n                  .filter(variable => variables[variable.name] == undefined) //don't add shadowed vars\n                  .map(variable => ({\n                    [variable.name]: { astRef: variable.astRef }\n                  }))\n              );\n              //NOTE: because these assignments are processed in order, that means\n              //that if a base class and derived class have variables with the same\n              //name, the derived version will be processed later and therefore overwrite --\n              //which is exactly what we want, so yay\n\n              if (scopes[cur].definition.nodeType === \"YulFunctionDefinition\") {\n                //Yul functions make the outside invisible\n                break;\n              }\n\n              if (scopes[cur].parentId !== undefined) {\n                cur = scopes[cur].parentId; //may be null!\n                //(undefined means we don't know what's up,\n                //null means there's nothing)\n              } else {\n                //in this case, cur must be a source-and-pointer, so we'll step\n                //up that way (skipping over any arrays)\n                cur = cur.replace(/\\/[^/]*(\\/\\d+)?$/, \"\");\n              }\n            }\n          }\n\n          let builtins = {\n            msg: { builtin: \"msg\" },\n            tx: { builtin: \"tx\" },\n            block: { builtin: \"block\" },\n            this: { builtin: \"this\" },\n            now: { builtin: \"now\" }\n          };\n\n          if (\n            scope &&\n            (scope.nodeType.startsWith(\"Yul\") ||\n              scope.nodeType === \"InlineAssembly\")\n          ) {\n            //builtins aren't visible in Yul\n            return variables;\n          }\n\n          return { ...variables, ...builtins };\n        }\n      ),\n\n      /**\n       * data.current.identifiers.definitions (namespace)\n       */\n      definitions: {\n        /* data.current.identifiers.definitions (selector)\n         * definitions for current variables, by identifier\n         */\n        _: createLeaf(\n          [\"/current/scopes/inlined\", \"../_\", \"./this\"],\n\n          (scopes, identifiers, thisDefinition) => {\n            let variables = Object.assign(\n              {},\n              ...Object.entries(identifiers).map(([identifier, variable]) => {\n                if (variable.astRef !== undefined) {\n                  let { definition } = scopes[variable.astRef];\n                  return { [identifier]: definition };\n                  //there used to be separate code for Yul variables here,\n                  //but now that's handled in definitionToType\n                } else {\n                  return {}; //skip over builtins; we'll handle those separately\n                }\n              })\n            );\n            let builtins = {\n              msg: MSG_DEFINITION,\n              tx: TX_DEFINITION,\n              block: BLOCK_DEFINITION,\n              now: NOW_DEFINITION\n            };\n            //only include this when it has a proper definition\n            if (thisDefinition) {\n              builtins.this = thisDefinition;\n            }\n            return { ...variables, ...builtins };\n          }\n        ),\n\n        /*\n         * data.current.identifiers.definitions.this\n         *\n         * returns a spoofed definition for the this variable\n         */\n        this: createLeaf(\n          [\"/current/contract\"],\n          contractNode =>\n            contractNode && contractNode.nodeType === \"ContractDefinition\"\n              ? spoofThisDefinition(\n                  contractNode.name,\n                  contractNode.id,\n                  contractNode.contractKind\n                )\n              : null\n        )\n      },\n\n      /**\n       * data.current.identifiers.refs\n       *\n       * current variables' value refs\n       */\n      refs: createLeaf(\n        [\n          \"/proc/assignments\",\n          \"./_\",\n          \"/current/compilationId\",\n          \"/current/functionDepth\", //for pruning things too deep on stack\n          \"/current/modifierDepth\", //when it's useful\n          \"/current/inModifier\",\n          \"/current/address\" //for contract variables\n        ],\n\n        (\n          assignments,\n          identifiers,\n          compilationId,\n          currentDepth,\n          modifierDepth,\n          inModifier,\n          address\n        ) =>\n          Object.assign(\n            {},\n            ...Object.entries(identifiers).map(\n              ([identifier, { astRef, builtin }]) => {\n                let id;\n                debug(\"astRef: %o\", astRef);\n                debug(\"builtin: %s\", builtin);\n\n                //is this an ordinary variable or a builtin?\n                if (astRef !== undefined) {\n                  //if not a builtin, first check if it's a contract var\n                  let compilationAssignments =\n                    (assignments.byCompilationId[compilationId] || {})\n                      .byAstRef || {};\n                  id = (compilationAssignments[astRef] || []).find(\n                    idHash => assignments.byId[idHash].address === address\n                  );\n                  debug(\"id after global: %s\", id);\n\n                  //if not contract, it's local, so identify by stackframe\n                  if (id === undefined) {\n                    //if we're in a modifier, include modifierDepth\n                    if (inModifier) {\n                      id = stableKeccak256({\n                        astRef,\n                        compilationId,\n                        stackframe: currentDepth,\n                        modifierDepth\n                      });\n                    } else {\n                      id = stableKeccak256({\n                        astRef,\n                        compilationId,\n                        stackframe: currentDepth\n                      });\n                    }\n                  }\n                  debug(\"id after local: %s\", id);\n                } else {\n                  //otherwise, it's a builtin\n                  //NOTE: for now we assume there is only one assignment per\n                  //builtin, but this will change in the future\n                  debug(\"builtin: %s\", builtin);\n                  id = assignments.byBuiltin[builtin][0];\n                }\n\n                //if we still didn't find it, oh well\n                debug(\"id: %s\", id);\n\n                let { ref } = assignments.byId[id] || {};\n                if (!ref) {\n                  return undefined;\n                }\n\n                return {\n                  [identifier]: ref\n                };\n              }\n            )\n          )\n      )\n    },\n\n    /**\n     * data.current.returnStatus\n     */\n    returnStatus: createLeaf(\n      [evm.current.step.returnStatus],\n      status => (status === null ? undefined : status) //convert null to undefined to be safe\n    ),\n\n    /**\n     * data.current.returnAllocation\n     */\n    returnAllocation: createLeaf(\n      [evm.current.call, \"/current/context\", \"/info/allocations/calldata\"],\n      (\n        { data: calldata },\n        { context, isConstructor },\n        { constructorAllocations, functionAllocations }\n      ) => {\n        if (isConstructor) {\n          //we're in a constructor call\n          let allocation = constructorAllocations[context];\n          if (!allocation) {\n            return null;\n          }\n          return allocation.output;\n        } else {\n          //usual case\n          let selector = calldata.slice(0, 2 + 4 * 2); //extract first 4 bytes of hex string\n          debug(\"selector: %s\", selector);\n          debug(\"bySelector: %o\", functionAllocations[context]);\n          let allocation = (functionAllocations[context] || {})[selector];\n          if (!allocation) {\n            return null;\n          }\n          return allocation.output;\n        }\n      }\n    )\n  },\n\n  /**\n   * data.next\n   */\n  next: {\n    /**\n     * data.next.state\n     * Yes, I'm just repeating the code for data.current.state.stack here;\n     * not worth the trouble to factor out\n     */\n    state: {\n      /**\n       * data.next.state.stack\n       */\n      stack: createLeaf(\n        [evm.next.state.stack],\n\n        words => (words || []).map(word => Codec.Conversion.toBytes(word))\n      ),\n\n      /**\n       * data.next.state.returndata\n       * NOTE: this is only for use by returnValue(); this is *not*\n       * an accurate reflection of the current contents of returndata!\n       * we don't track that at the moment\n       */\n      returndata: createLeaf([evm.current.step.returnValue], data =>\n        Codec.Conversion.toBytes(data)\n      )\n    },\n\n    //HACK WARNING\n    //the following selectors depend on solidity.next\n    //do not use them when the current instruction is a context change!\n\n    /**\n     * data.next.node\n     */\n    node: createLeaf([solidity.next.node], identity),\n\n    /**\n     * data.next.pointer\n     */\n    pointer: createLeaf([solidity.next.pointer], identity),\n\n    /**\n     * data.next.modifierInvocation\n     * Note: yes, I'm just repeating the code from data.current here but with\n     * invalid added\n     */\n    modifierInvocation: createLeaf(\n      [\"./node\", \"/current/scopes/inlined\", evm.current.step.isContextChange],\n      (node, scopes, invalid) => {\n        //don't attempt this at a context change!\n        //(also don't attempt this if we can't find the node for whatever\n        //reason)\n        if (invalid) {\n          return undefined;\n        }\n        const types = [\n          \"ModifierInvocation\",\n          \"InheritanceSpecifier\",\n          \"SourceUnit\"\n        ];\n        //again, SourceUnit included as fallback\n        return findAncestorOfType(node, types, scopes);\n      }\n    ),\n\n    /*\n     * data.next.modifierBeingInvoked\n     */\n    modifierBeingInvoked: createLeaf(\n      [\n        \"./modifierInvocation\",\n        \"/current/scopes/inlined\",\n        evm.current.step.isContextChange\n      ],\n      (invocation, scopes, invalid) => {\n        if (invalid || !invocation || invocation.nodeType === \"SourceUnit\") {\n          return undefined;\n        }\n\n        return modifierForInvocation(invocation, scopes);\n      }\n    )\n    //END HACK WARNING\n  },\n\n  /**\n   * data.nextMapped\n   */\n  nextMapped: {\n    /**\n     * data.nextMapped.state\n     * Yes, I'm just repeating the code for data.current.state.stack here;\n     * not worth the trouble to factor out\n     * HACK: this assumes we're not about to change context! don't use this if we\n     * are!\n     */\n    state: {\n      /**\n       * data.nextMapped.state.stack\n       */\n      stack: createLeaf(\n        [solidity.current.nextMapped],\n\n        step =>\n          ((step || {}).stack || []).map(word => Codec.Conversion.toBytes(word))\n      )\n    }\n  },\n\n  /**\n   * data.nextOfSameDepth\n   */\n  nextOfSameDepth: {\n    /**\n     * data.nextOfSameDepth.state\n     * Yes, I'm just repeating the code for data.current.state.stack here but\n     * with an extra guard... *still* not worth the trouble to factor out\n     * HOWEVER, this one also returns null if there is no nextOfSameDepth\n     */\n    state: {\n      /**\n       * data.nextOfSameDepth.state.stack\n       */\n      stack: createLeaf(\n        [trace.nextOfSameDepth],\n\n        step =>\n          step\n            ? (step.stack || []).map(word => Codec.Conversion.toBytes(word))\n            : null\n      )\n    }\n  }\n});\n\nexport default data;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:stacktrace:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport evm from \"lib/evm/selectors\";\nimport solidity from \"lib/solidity/selectors\";\n\nimport jsonpointer from \"json-pointer\";\nimport zipWith from \"lodash.zipwith\";\nimport { popNWhere } from \"lib/helpers\";\nimport * as Codec from \"@truffle/codec\";\n\nconst identity = (x) => x;\n\nfunction generateReport(callstack, location, status, message) {\n  //step 1: shift everything over by 1 and recombine :)\n  let locations = callstack.map((frame) => frame.calledFromLocation);\n  //remove initial null, add final location on end\n  locations.shift();\n  locations.push(location);\n  debug(\"locations: %O\", locations);\n  const names = callstack.map(({ functionName, contractName, address }) => ({\n    functionName,\n    contractName,\n    address,\n  }));\n  debug(\"names: %O\", names);\n  let report = zipWith(locations, names, (location, nameInfo) => ({\n    ...nameInfo,\n    location,\n  }));\n  //finally: set the status in the top frame\n  //and the message in the bottom\n  if (status !== null) {\n    report[report.length - 1].status = status;\n  }\n  if (message !== undefined) {\n    report[0].message = message;\n  }\n  return report;\n}\n\nfunction createMultistepSelectors(stepSelector) {\n  return {\n    /**\n     * .location\n     */\n    location: {\n      /**\n       * .source\n       */\n      source: createLeaf([stepSelector.source], identity),\n      /**\n       * .sourceRange\n       */\n      sourceRange: createLeaf([stepSelector.sourceRange], identity),\n      /**\n       * .node\n       */\n      node: createLeaf([stepSelector.node], identity),\n      /**\n       * .pointer\n       */\n      pointer: createLeaf([stepSelector.pointer], identity),\n    },\n\n    /**\n     * .strippedLocation\n     */\n    strippedLocation: createLeaf(\n      [\"./location/source\", \"./location/sourceRange\"],\n      ({ id, compilationId, sourcePath }, sourceRange) => ({\n        source: { id, compilationId, sourcePath },\n        sourceRange,\n      })\n    ),\n\n    /**\n     * .contractNode\n     * WARNING: ad-hoc selector only meant to be used\n     * when you're on a function node!\n     * should probably be replaced by something better;\n     * the data submodule handles these things a better way\n     */\n    contractNode: createLeaf(\n      [\"./location/source\", \"./location/pointer\"],\n      ({ ast }, pointer) =>\n        pointer\n          ? jsonpointer.get(\n              ast,\n              pointer.replace(/\\/nodes\\/\\d+$/, \"\") //cut off end\n            )\n          : ast\n    ),\n  };\n}\n\nlet stacktrace = createSelectorTree({\n  /**\n   * stacktrace.state\n   */\n  state: (state) => state.stacktrace,\n\n  /**\n   * stacktrace.current\n   */\n  current: {\n    /**\n     * stacktrace.current.callstack\n     */\n    callstack: createLeaf([\"/state\"], (state) => state.proc.callstack),\n\n    /**\n     * stacktrace.current.returnCounter\n     */\n    returnCounter: createLeaf([\"/state\"], (state) => state.proc.returnCounter),\n\n    /**\n     * stacktrace.current.lastPosition\n     */\n    lastPosition: createLeaf([\"/state\"], (state) => state.proc.lastPosition),\n\n    /**\n     * stacktrace.current.innerReturnPosition\n     */\n    innerReturnPosition: createLeaf(\n      [\"/state\"],\n      (state) => state.proc.innerReturnPosition\n    ),\n\n    /**\n     * stacktrace.current.innerReturnStatus\n     */\n    innerReturnStatus: createLeaf(\n      [\"/state\"],\n      (state) => state.proc.innerReturnStatus\n    ),\n\n    ...createMultistepSelectors(solidity.current),\n\n    /**\n     * stacktrace.current.willJumpIn\n     */\n    willJumpIn: createLeaf(\n      [solidity.current.willJump, solidity.current.jumpDirection],\n      (willJump, jumpDirection) => willJump && jumpDirection === \"i\"\n    ),\n\n    /**\n     * stacktrace.current.willJumpOut\n     */\n    willJumpOut: createLeaf(\n      [solidity.current.willJump, solidity.current.jumpDirection],\n      (willJump, jumpDirection) => willJump && jumpDirection === \"o\"\n    ),\n\n    /**\n     * stacktrace.current.willCall\n     * note: includes creations!\n     */\n    willCall: createLeaf([solidity.current.willCall], identity),\n\n    /**\n     * stacktrace.current.context\n     */\n    context: createLeaf([evm.current.context], identity),\n\n    /**\n     * stacktrace.current.callContext\n     */\n    callContext: createLeaf([evm.current.step.callContext], identity),\n\n    /**\n     * stacktrace.current.willReturn\n     */\n    willReturn: createLeaf([solidity.current.willReturn], identity),\n\n    /**\n     * stacktrace.current.returnStatus\n     */\n    returnStatus: createLeaf([evm.current.step.returnStatus], identity),\n\n    /**\n     * stacktrace.current.address\n     * Initial call can't be a delegate, so we just use the storage address\n     * (thus allowing us to handle both calls & creates in one)\n     */\n    address: createLeaf([evm.current.call], (call) => call.storageAddress),\n\n    /**\n     * stacktrace.current.callAddress\n     *\n     * Covers both calls and creates\n     * NOTE: for this selector, we treat delegates just like any other call!\n     * we want to report the *code* address here, not the storage address\n     * (exception: for creates we report the storage address, as that's where\n     * the code *will* live)\n     */\n    callAddress: createLeaf(\n      [\n        evm.current.step.isCall,\n        evm.current.step.isCreate,\n        evm.current.step.callAddress,\n        evm.current.step.createdAddress,\n      ],\n      (isCall, isCreate, callAddress, createdAddress) => {\n        if (isCall) {\n          return callAddress;\n        } else if (isCreate) {\n          if (createdAddress !== Codec.Evm.Utils.ZERO_ADDRESS) {\n            return createdAddress;\n          } else {\n            return undefined; //if created address appears to be 0, omit it\n          }\n        } else {\n          return null; //I guess??\n        }\n      }\n    ),\n\n    /**\n     * stacktrace.current.revertString\n     * Crudely decodes the current revert string.\n     * Not meant to account for crazy things, just there to produce\n     * a simple string.\n     */\n    revertString: createLeaf(\n      [evm.current.step.returnValue],\n      (rawRevertMessage) => {\n        let revertDecodings = Codec.decodeRevert(\n          Codec.Conversion.toBytes(rawRevertMessage)\n        );\n        if (\n          revertDecodings.length === 1 &&\n          revertDecodings[0].kind === \"revert\"\n        ) {\n          let revertStringInfo = revertDecodings[0].arguments[0].value.value;\n          switch (revertStringInfo.kind) {\n            case \"valid\":\n              return revertStringInfo.asString;\n            case \"malformed\":\n              //turn into a JS string while smoothing over invalid UTF-8\n              //slice 2 to remove 0x prefix\n              return Buffer.from(\n                revertStringInfo.asHex.slice(2),\n                \"hex\"\n              ).toString();\n          }\n        } else {\n          return undefined;\n        }\n      }\n    ),\n\n    /**\n     * stacktrace.current.positionWillChange\n     */\n    positionWillChange: createLeaf(\n      [\"/next/location\", \"/current/location\", \"./lastPosition\"],\n      (nextLocation, currentLocation, lastLocation) => {\n        let oldLocation =\n          currentLocation.source.id !== undefined\n            ? currentLocation\n            : lastLocation;\n        return (\n          Boolean(oldLocation) && //if there's no current or last position, we don't need this check\n          Boolean(nextLocation.source) &&\n          nextLocation.source.id !== undefined && //if next location is unmapped, we consider ourselves to have not moved\n          (nextLocation.source.compilationId !==\n            oldLocation.source.compilationId ||\n            nextLocation.source.id !== oldLocation.source.id ||\n            nextLocation.sourceRange.start !== oldLocation.sourceRange.start ||\n            nextLocation.sourceRange.length !== oldLocation.sourceRange.length)\n        );\n      }\n    ),\n\n    /**\n     * stacktrace.current.finalReport\n     * Contains the report object for outside consumption.\n     * Still needs to be processed into a string, mind you.\n     */\n    finalReport: createLeaf(\n      [\n        \"./callstack\",\n        \"./innerReturnPosition\",\n        \"./innerReturnStatus\",\n        \"./revertString\",\n      ],\n      generateReport\n    ),\n\n    /**\n     * stacktrace.current.report\n     * Similar to stacktrace.current.report, but meant for use as at\n     * an intermediate point instead of at the end (it reflects how things\n     * actually currently are rather than taking into account exited\n     * stackframes that caused the revert)\n     */\n    report: createLeaf(\n      [\n        \"./callstack\",\n        \"./returnCounter\",\n        \"./lastPosition\",\n        \"/current/strippedLocation\",\n      ],\n      (callstack, returnCounter, lastPosition, currentLocation) =>\n        generateReport(\n          popNWhere(\n            callstack,\n            returnCounter,\n            (frame) => frame.type === \"external\"\n          ),\n          currentLocation || lastPosition,\n          null,\n          undefined\n        )\n    ),\n  },\n\n  /**\n   * stacktrace.next\n   */\n  next: {\n    ...createMultistepSelectors(solidity.next),\n  },\n});\n\nexport default stacktrace;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport evm from \"lib/evm/selectors\";\nimport trace from \"lib/trace/selectors\";\nimport solidity from \"lib/solidity/selectors\";\n\nconst session = createSelectorTree({\n  /*\n   * session.state\n   */\n  state: state => state.session,\n\n  /**\n   * session.info\n   */\n  info: {\n    /**\n     * session.info.affectedInstances\n     */\n    affectedInstances: createLeaf(\n      [evm.current.codex.instances, evm.info.contexts, solidity.info.sources],\n\n      (instances, contexts, sources) =>\n        Object.assign(\n          {},\n          ...Object.entries(instances).map(\n            ([address, { context: contextId, binary }]) => {\n              debug(\"instances %O\", instances);\n              debug(\"contexts %O\", contexts);\n              let context = contexts[contextId];\n              if (!context) {\n                return { [address]: { binary } };\n              }\n              let { contractName, compilationId, primarySource } = context;\n\n              debug(\"primarySource: %o\", primarySource);\n              debug(\"compilationId: %s\", compilationId);\n              debug(\"sources: %o\", sources);\n\n              let source =\n                primarySource !== undefined\n                  ? sources[compilationId].byId[primarySource]\n                  : undefined;\n\n              return {\n                [address]: {\n                  contractName,\n                  source,\n                  binary\n                }\n              };\n            }\n          )\n        )\n    )\n  },\n\n  /**\n   * session.transaction (namespace)\n   */\n  transaction: {\n    /**\n     * session.transaction (selector)\n     * contains the web3 transaction object\n     */\n    _: createLeaf([\"/state\"], state => state.transaction),\n\n    /**\n     * session.transaction.receipt\n     * contains the web3 receipt object\n     */\n    receipt: createLeaf([\"/state\"], state => state.receipt),\n\n    /**\n     * session.transaction.block\n     * contains the web3 block object\n     */\n    block: createLeaf([\"/state\"], state => state.block)\n  },\n\n  /*\n   * session.status (namespace)\n   */\n  status: {\n    /*\n     * session.status.readyOrError\n     */\n    readyOrError: createLeaf([\"/state\"], state => state.ready),\n\n    /*\n     * session.status.ready\n     */\n    ready: createLeaf(\n      [\"./readyOrError\", \"./isError\"],\n      (readyOrError, error) => readyOrError && !error\n    ),\n\n    /*\n     * session.status.waiting\n     */\n    waiting: createLeaf([\"/state\"], state => !state.ready),\n\n    /*\n     * session.status.error\n     */\n    error: createLeaf([\"/state\"], state => state.lastLoadingError),\n\n    /*\n     * session.status.isError\n     */\n    isError: createLeaf([\"./error\"], error => error !== null),\n\n    /*\n     * session.status.success\n     */\n    success: createLeaf([\"./error\"], error => error === null),\n\n    /*\n     * session.status.errored\n     */\n    errored: createLeaf(\n      [\"./readyOrError\", \"./isError\"],\n      (readyOrError, error) => readyOrError && error\n    ),\n\n    /*\n     * session.status.loaded\n     */\n    loaded: createLeaf([trace.loaded], loaded => loaded),\n\n    /**\n     * session.status.lightMode\n     */\n    lightMode: createLeaf([\"/state\"], state => state.lightMode)\n  }\n});\n\nexport default session;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:evm:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName, keccak256 } from \"lib/helpers\";\n\nimport { TICK } from \"lib/trace/actions\";\nimport * as actions from \"../actions\";\n\nimport evm from \"../selectors\";\n\nimport * as trace from \"lib/trace/sagas\";\n\n/**\n * Adds EVM bytecode context\n *\n * @return {string} ID (0x-prefixed keccak of binary)\n */\nexport function* addContext(context) {\n  //get context hash if context doesn't already have it\n  const contextHash =\n    context.context || keccak256({ type: \"string\", value: context.binary });\n  //NOTE: we take hash as *string*, not as bytes, because the binary may\n  //contain link references!\n\n  debug(\"context %O\", context);\n  yield put(actions.addContext({ ...context, context: contextHash }));\n\n  return contextHash;\n}\n\n/**\n * Adds known deployed instance of binary at address\n *\n * @param {string} binary - may be undefined (e.g. precompiles)\n * @return {string} ID (0x-prefixed keccak of binary)\n */\nexport function* addInstance(address, binary) {\n  const search = yield select(evm.info.binaries.search);\n  const context = search(binary);\n\n  //now, whether we needed a new context or not, add the instance\n  yield put(actions.addInstance(address, context, binary));\n\n  return context;\n}\n\n//goes through all instances and re-adds them with their new\n//context (used if new contexts have been added -- something\n//that currently only happens when adding external compilations)\nexport function* refreshInstances() {\n  const instances = yield select(evm.current.codex.instances);\n  for (let [address, { binary }] of Object.entries(instances)) {\n    const search = yield select(evm.info.binaries.search);\n    const context = search(binary);\n    yield put(actions.addInstance(address, context, binary));\n  }\n}\n\nexport function* begin({\n  address,\n  binary,\n  data,\n  storageAddress,\n  status,\n  sender,\n  value,\n  gasprice,\n  block\n}) {\n  yield put(actions.saveGlobals(sender, gasprice, block));\n  yield put(actions.saveStatus(status));\n  debug(\"codex: %O\", yield select(evm.current.codex));\n  if (address) {\n    yield put(actions.call(address, data, storageAddress, sender, value));\n  } else {\n    yield put(actions.create(binary, storageAddress, sender, value));\n  }\n}\n\nfunction* tickSaga() {\n  debug(\"got TICK\");\n\n  yield* callstackAndCodexSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\n//NOTE: We don't account here for multiple simultaneous returns.\n//Such a case is *vanishingly* unlikely to come up in real code\n//so it's simply not worth the trouble.  Such a case will screw\n//up the debugger pretty good as a result.\n//(...but I might go back and do it later. :P )\n\nexport function* callstackAndCodexSaga() {\n  if (yield select(evm.current.step.isExceptionalHalting)) {\n    //let's handle this case first so we can be sure everything else is *not*\n    //an exceptional halt\n    debug(\"exceptional halt!\");\n\n    yield put(actions.fail());\n  } else if (yield select(evm.current.step.isInstantCallOrCreate)) {\n    // if there is no binary (e.g. for precompiles or externally owned\n    // accounts), or if the call fails instantly (callstack overflow or not\n    // enough ether), there will be no trace steps for the called code, and so\n    // we shouldn't tell the debugger that we're entering another execution\n    // context\n    // (so we do nothing)\n  } else if (yield select(evm.current.step.isCall)) {\n    debug(\"got call\");\n\n    let address = yield select(evm.current.step.callAddress);\n    let data = yield select(evm.current.step.callData);\n\n    debug(\"calling address %s\", address);\n\n    if (yield select(evm.current.step.isDelegateCallStrict)) {\n      //if delegating, leave storageAddress, sender, and value the same\n      let { storageAddress, sender, value } = yield select(evm.current.call);\n      yield put(actions.call(address, data, storageAddress, sender, value));\n    } else {\n      //this branch covers CALL, CALLCODE, and STATICCALL\n      let currentCall = yield select(evm.current.call);\n      let storageAddress = (yield select(evm.current.step.isDelegateCallBroad))\n        ? currentCall.storageAddress //for CALLCODE\n        : address;\n      let sender = currentCall.storageAddress; //not the code address!\n      let value = yield select(evm.current.step.callValue); //0 if static\n      yield put(actions.call(address, data, storageAddress, sender, value));\n    }\n  } else if (yield select(evm.current.step.isCreate)) {\n    debug(\"got create\");\n    let binary = yield select(evm.current.step.createBinary);\n    let createdAddress = yield select(evm.current.step.createdAddress);\n    let value = yield select(evm.current.step.createValue);\n    let sender = (yield select(evm.current.call)).storageAddress;\n    //not the code address!\n\n    yield put(actions.create(binary, createdAddress, sender, value));\n    //as above, storageAddress handles when calling from a creation call\n  } else if (yield select(evm.current.step.isNormalHalting)) {\n    debug(\"got return\");\n\n    let { binary, storageAddress } = yield select(evm.current.call);\n\n    if (binary) {\n      //if we're returning from a successful creation call, let's log the\n      //result\n      let returnedBinary = yield select(evm.current.step.returnValue);\n      let search = yield select(evm.info.binaries.search);\n      let returnedContext = search(returnedBinary);\n      yield put(\n        actions.returnCreate(storageAddress, returnedBinary, returnedContext)\n      );\n    } else {\n      yield put(actions.returnCall());\n    }\n  } else if (yield select(evm.current.step.isStore)) {\n    let storageAddress = (yield select(evm.current.call)).storageAddress;\n    let slot = yield select(evm.current.step.storageAffected);\n    let storedValue = yield select(evm.current.step.valueStored);\n    yield put(actions.store(storageAddress, slot, storedValue));\n  } else if (yield select(evm.current.step.isLoad)) {\n    let storageAddress = (yield select(evm.current.call)).storageAddress;\n    let slot = yield select(evm.current.step.storageAffected);\n    let loadedValue = yield select(evm.current.step.valueLoaded);\n    yield put(actions.load(storageAddress, slot, loadedValue));\n  }\n}\n\nexport function* reset() {\n  let initialCall = yield select(evm.transaction.initialCall);\n  yield put(actions.reset());\n  yield put(initialCall);\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"evm\", saga);\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:controller:selectors\"); //eslint-disable-line no-unused-vars\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\nimport { isSkippedNodeType } from \"lib/helpers\";\n\nimport evm from \"lib/evm/selectors\";\nimport solidity from \"lib/solidity/selectors\";\nimport trace from \"lib/trace/selectors\";\n\n/**\n * @private\n */\nconst identity = x => x;\n\nfunction anyNonSkippedInRange(\n  findOverlappingRange,\n  node,\n  sourceStart,\n  sourceLength\n) {\n  let sourceEnd = sourceStart + sourceLength;\n  return findOverlappingRange(sourceStart, sourceLength).some(\n    ({ range, node }) =>\n      isOldStyleAssembly(node) ||\n      (sourceStart <= range[0] && //we want to go by starting line\n        range[0] < sourceEnd &&\n        !isSkippedNodeType(node))\n    //NOTE: this doesn't actually catch everything skipped!  But doing better\n    //is hard\n  );\n}\n\n//catches InlineAssembly nodes from before 0.6.0.\n//We want to be able to place breakpoints if something merely *overlaps*\n//one of these, because, well, we can't really look inside and do better.\nfunction isOldStyleAssembly(node) {\n  return node.nodeType === \"InlineAssembly\" && !node.AST;\n}\n\n/**\n * controller\n */\nconst controller = createSelectorTree({\n  /**\n   * controller.state\n   */\n  state: state => state.controller,\n  /**\n   * controller.current\n   */\n  current: {\n    /**\n     * controller.current.functionDepth\n     */\n    functionDepth: createLeaf([solidity.current.functionDepth], identity),\n\n    /**\n     * controller.current.executionContext\n     */\n    executionContext: createLeaf([evm.current.call], identity),\n\n    /**\n     * controller.current.willJump\n     */\n    willJump: createLeaf([evm.current.step.isJump], identity),\n\n    /**\n     * controller.current.location\n     */\n    location: {\n      /**\n       * controller.current.location.sourceRange\n       */\n      sourceRange: createLeaf(\n        [solidity.current.sourceRange, \"/current/trace/loaded\"],\n        (range, loaded) => (loaded ? range : null)\n      ),\n\n      /**\n       * controller.current.location.source\n       */\n      source: createLeaf(\n        [solidity.current.source, \"/current/trace/loaded\"],\n        (source, loaded) => (loaded ? source : null)\n      ),\n\n      /**\n       * controller.current.location.node\n       */\n      node: createLeaf(\n        [solidity.current.node, \"/current/trace/loaded\"],\n        (node, loaded) => (loaded ? node : null)\n      ),\n\n      /**\n       * controller.current.location.isMultiline\n       */\n      isMultiline: createLeaf(\n        [solidity.current.isMultiline, \"/current/trace/loaded\"],\n        (raw, loaded) => (loaded ? raw : false)\n      )\n    },\n\n    /*\n     * controller.current.trace\n     */\n    trace: {\n      /**\n       * controller.current.trace.finished\n       */\n      finished: createLeaf([trace.finished], identity),\n\n      /**\n       * controller.current.trace.loaded\n       */\n      loaded: createLeaf([trace.loaded], identity)\n    }\n  },\n\n  /**\n   * controller.breakpoints (namespace)\n   */\n  breakpoints: {\n    /**\n     * controller.breakpoints (selector)\n     */\n    _: createLeaf([\"/state\"], state => state.breakpoints),\n\n    /**\n     * controller.breakpoints.resolver (selector)\n     * this selector returns a function that adjusts a given line-based\n     * breakpoint (on node-based breakpoints it simply returns the input) by\n     * repeatedly moving it down a line until it lands on a line where there's\n     * actually somewhere to break.  if no such line exists beyond that point, it\n     * returns null instead.\n     */\n    resolver: createLeaf(\n      [solidity.info.sources, solidity.views.findOverlappingRange],\n      (sources, functions) => breakpoint => {\n        let adjustedBreakpoint;\n        if (breakpoint.node === undefined) {\n          let line = breakpoint.line;\n          debug(\"breakpoint: %O\", breakpoint);\n          debug(\"sources: %o\", sources);\n          let { source, ast } = sources[breakpoint.compilationId].byId[\n            breakpoint.sourceId\n          ];\n          let findOverlappingRange =\n            functions[breakpoint.compilationId][breakpoint.sourceId];\n          let lineLengths = source.split(\"\\n\").map(line => line.length);\n          //why does neither JS nor lodash have a scan function like Haskell??\n          //guess we'll have to do our scan manually\n          let lineStarts = [0];\n          for (let length of lineLengths) {\n            lineStarts.push(lineStarts[lineStarts.length - 1] + length + 1);\n            //+1 for the /n itself\n          }\n          debug(\n            \"line: %s\",\n            source.slice(lineStarts[line], lineStarts[line] + lineLengths[line])\n          );\n          while (\n            line < lineLengths.length &&\n            !anyNonSkippedInRange(\n              findOverlappingRange,\n              ast,\n              lineStarts[line],\n              lineLengths[line]\n            )\n          ) {\n            debug(\"incrementing\");\n            line++;\n          }\n          if (line >= lineLengths.length) {\n            adjustedBreakpoint = null;\n          } else {\n            adjustedBreakpoint = { ...breakpoint, line };\n          }\n        } else {\n          debug(\"node-based breakpoint\");\n          adjustedBreakpoint = breakpoint;\n        }\n        return adjustedBreakpoint;\n      }\n    )\n  },\n\n  /**\n   * controller.finished\n   * deprecated alias for controller.current.trace.finished\n   */\n  finished: createLeaf([\"/current/trace/finished\"], finished => finished),\n\n  /**\n   * controller.isStepping\n   */\n  isStepping: createLeaf([\"./state\"], state => state.isStepping)\n});\n\nexport default controller;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:ast:selectors\");\n\nimport { createSelectorTree, createLeaf } from \"reselect-tree\";\n\nimport solidity from \"lib/solidity/selectors\";\n\n/**\n * ast\n */\nconst ast = createSelectorTree({\n  /**\n   * ast.views\n   */\n  views: {\n    /**\n     * ast.views.sources\n     */\n    sources: createLeaf([solidity.info.sources], sources => sources)\n  }\n});\n\nexport default ast;\n","module.exports = require(\"lodash.flatten\");","module.exports = require(\"semver\");","export const SCOPE = \"DATA_SCOPE\";\nexport function scope(id, pointer, parentId, sourceId, compilationId) {\n  return {\n    type: SCOPE,\n    id,\n    pointer,\n    parentId,\n    sourceId,\n    compilationId\n  };\n}\n\nexport const DECLARE = \"DATA_DECLARE_VARIABLE\";\nexport function declare(name, astRef, scopeAstRef, compilationId) {\n  return {\n    type: DECLARE,\n    name,\n    astRef,\n    scopeAstRef,\n    compilationId\n  };\n}\n\nexport const ASSIGN = \"DATA_ASSIGN\";\nexport function assign(assignments) {\n  return {\n    type: ASSIGN,\n    assignments\n  };\n}\n\nexport const MAP_PATH_AND_ASSIGN = \"DATA_MAP_PATH_AND_ASSIGN\";\nexport function mapPathAndAssign(\n  address,\n  slot,\n  assignments,\n  typeIdentifier,\n  parentType\n) {\n  return {\n    type: MAP_PATH_AND_ASSIGN,\n    address,\n    slot,\n    assignments,\n    typeIdentifier,\n    parentType\n  };\n}\n\nexport const RESET = \"DATA_RESET\";\nexport function reset() {\n  return { type: RESET };\n}\n\nexport const DEFINE_TYPE = \"DATA_DEFINE_TYPE\";\nexport function defineType(node, compilationId) {\n  return {\n    type: DEFINE_TYPE,\n    node,\n    compilationId\n  };\n}\n\nexport const ALLOCATE = \"DATA_ALLOCATE\";\nexport function allocate(storage, memory, abi, calldata, state) {\n  return {\n    type: ALLOCATE,\n    storage,\n    memory,\n    abi,\n    calldata,\n    state\n  };\n}\n","module.exports = require(\"babel-runtime/core-js/set\");","export const ADD_CONTEXT = \"EVM_ADD_CONTEXT\";\nexport function addContext({\n  context,\n  contractName,\n  binary,\n  sourceMap,\n  primarySource,\n  immutableReferences,\n  compiler,\n  compilationId,\n  abi,\n  contractId,\n  contractKind,\n  isConstructor,\n  externalSolidity\n}) {\n  return {\n    type: ADD_CONTEXT,\n    context,\n    contractName,\n    binary,\n    sourceMap,\n    primarySource,\n    immutableReferences,\n    compiler,\n    compilationId,\n    abi,\n    contractId,\n    contractKind,\n    isConstructor,\n    externalSolidity\n  };\n}\n\nexport const ADD_INSTANCE = \"EVM_ADD_INSTANCE\";\nexport function addInstance(address, context, binary) {\n  return {\n    type: ADD_INSTANCE,\n    address,\n    context,\n    binary\n  };\n}\n\nexport const REFRESH_INSTANCE = \"EVM_REFRESH_INSTANCE\";\nexport function refreshInstances(address, context) {\n  return {\n    type: REFRESH_INSTANCE,\n    address,\n    context\n  };\n}\n\nexport const SAVE_GLOBALS = \"EVM_SAVE_GLOBALS\";\nexport function saveGlobals(origin, gasprice, block) {\n  return {\n    type: SAVE_GLOBALS,\n    origin,\n    gasprice,\n    block\n  };\n}\n\nexport const SAVE_STATUS = \"EVM_SAVE_STATUS\";\nexport function saveStatus(status) {\n  return {\n    type: SAVE_STATUS,\n    status\n  };\n}\n\nexport const CALL = \"EVM_CALL\";\nexport function call(address, data, storageAddress, sender, value) {\n  return {\n    type: CALL,\n    address,\n    data,\n    storageAddress,\n    sender,\n    value\n  };\n}\n\nexport const CREATE = \"EVM_CREATE\";\nexport function create(binary, storageAddress, sender, value) {\n  return {\n    type: CREATE,\n    binary,\n    storageAddress,\n    sender,\n    value\n  };\n}\n\nexport const RETURN_CALL = \"EVM_RETURN_CALL\";\nexport function returnCall() {\n  return {\n    type: RETURN_CALL\n  };\n}\n\nexport const RETURN_CREATE = \"EVM_RETURN_CREATE\";\nexport function returnCreate(address, code, context) {\n  return {\n    type: RETURN_CREATE,\n    address,\n    code,\n    context\n  };\n}\n\nexport const FAIL = \"EVM_FAIL\";\nexport function fail() {\n  return {\n    type: FAIL\n  };\n}\n\nexport const STORE = \"EVM_STORE\";\nexport function store(address, slot, value) {\n  return {\n    type: STORE,\n    address,\n    slot,\n    value\n  };\n}\n\nexport const LOAD = \"EVM_LOAD\";\nexport function load(address, slot, value) {\n  return {\n    type: LOAD,\n    address,\n    slot,\n    value\n  };\n}\n\nexport const RESET = \"EVM_RESET\";\nexport function reset(storageAddress) {\n  return {\n    type: RESET,\n    storageAddress\n  };\n}\n\nexport const UNLOAD_TRANSACTION = \"EVM_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION\n  };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:web3:sagas\");\n\nimport {\n  all,\n  takeEvery,\n  apply,\n  fork,\n  join,\n  take,\n  put\n} from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\n\nimport * as actions from \"../actions\";\nimport * as session from \"lib/session/actions\";\n\nimport BN from \"bn.js\";\nimport Web3 from \"web3\"; //just for utils!\nimport * as Codec from \"@truffle/codec\";\n\nimport Web3Adapter from \"../adapter\";\n\n//the following two functions are for Besu compatibility\nfunction padStackAndMemory(steps) {\n  return steps.map(step => ({\n    ...step,\n    stack: step.stack.map(padHexString),\n    memory: step.memory.map(padHexString)\n  }));\n}\n\n//turns Besu-style (begins with 0x, may be shorter than 64 hexdigits)\n//to Geth/Ganache-style (no 0x, always 64 hexdigits)\n//(I say 64 hexdigits rather than 32 bytes because Besu-style will use\n//non-whole numbers of bytes!)\nfunction padHexString(hexString) {\n  return hexString.startsWith(\"0x\") //Besu-style or Geth/Ganache-style?\n    ? hexString.slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"0\") //convert Besu to Geth/Ganache\n    : hexString; //leave Geth/Ganache style alone\n}\n\nfunction* fetchTransactionInfo(adapter, { txHash }) {\n  debug(\"inspecting transaction\");\n  var trace;\n  try {\n    trace = yield apply(adapter, adapter.getTrace, [txHash]);\n  } catch (e) {\n    debug(\"putting error\");\n    yield put(actions.error(e));\n    return;\n  }\n\n  debug(\"got trace\");\n  trace = padStackAndMemory(trace); //for Besu compatibility\n  yield put(actions.receiveTrace(trace));\n\n  let tx = yield apply(adapter, adapter.getTransaction, [txHash]);\n  debug(\"tx %O\", tx);\n  let receipt = yield apply(adapter, adapter.getReceipt, [txHash]);\n  debug(\"receipt %O\", receipt);\n  let block = yield apply(adapter, adapter.getBlock, [tx.blockNumber]);\n  debug(\"block %O\", block);\n\n  yield put(session.saveTransaction(tx));\n  yield put(session.saveReceipt(receipt));\n  yield put(session.saveBlock(block));\n\n  //these ones get grouped together for convenience\n  let solidityBlock = {\n    coinbase: block.miner,\n    difficulty: new BN(block.difficulty),\n    gaslimit: new BN(block.gasLimit),\n    number: new BN(block.number),\n    timestamp: new BN(block.timestamp)\n  };\n\n  if (tx.to != null) {\n    yield put(\n      actions.receiveCall({\n        address: tx.to,\n        data: tx.input,\n        storageAddress: tx.to,\n        status: receipt.status,\n        sender: tx.from,\n        value: new BN(tx.value),\n        gasprice: new BN(tx.gasPrice),\n        block: solidityBlock\n      })\n    );\n  } else {\n    let storageAddress = Web3.utils.isAddress(receipt.contractAddress)\n      ? receipt.contractAddress\n      : Codec.Evm.Utils.ZERO_ADDRESS;\n    yield put(\n      actions.receiveCall({\n        binary: tx.input,\n        storageAddress,\n        status: receipt.status,\n        sender: tx.from,\n        value: new BN(tx.value),\n        gasprice: new BN(tx.gasPrice),\n        block: solidityBlock\n      })\n    );\n  }\n}\n\nfunction* fetchBinary(adapter, { address, block }) {\n  debug(\"fetching binary for %s\", address);\n  let binary = yield apply(adapter, adapter.getDeployedCode, [address, block]);\n\n  debug(\"received binary for %s\", address);\n  yield put(actions.receiveBinary(address, binary));\n}\n\nexport function* inspectTransaction(txHash) {\n  yield put(actions.inspect(txHash));\n\n  let action = yield take([actions.RECEIVE_TRACE, actions.ERROR_WEB3]);\n  debug(\"action %o\", action);\n\n  var trace;\n  if (action.type == actions.RECEIVE_TRACE) {\n    trace = action.trace;\n    debug(\"received trace\");\n  } else {\n    return { error: action.error };\n  }\n\n  let {\n    address,\n    binary,\n    data,\n    storageAddress,\n    status,\n    sender,\n    value,\n    gasprice,\n    block\n  } = yield take(actions.RECEIVE_CALL);\n  debug(\"received call\");\n\n  return {\n    trace,\n    address,\n    binary,\n    data,\n    storageAddress,\n    status,\n    sender,\n    value,\n    gasprice,\n    block\n  };\n}\n\n//NOTE: the block argument is optional\nexport function* obtainBinaries(addresses, block) {\n  let tasks = yield all(addresses.map(address => fork(receiveBinary, address)));\n\n  debug(\"requesting binaries\");\n  yield all(addresses.map(address => put(actions.fetchBinary(address, block))));\n\n  let binaries = [];\n  binaries = yield join(tasks);\n\n  debug(\"binaries %o\", binaries);\n\n  return binaries;\n}\n\nfunction* receiveBinary(address) {\n  let { binary } = yield take(\n    action => action.type == actions.RECEIVE_BINARY && action.address == address\n  );\n  debug(\"got binary for %s\", address);\n\n  return binary;\n}\n\nexport function* init(provider) {\n  yield put(actions.init(provider));\n}\n\nexport function* saga() {\n  // wait for web3 init signal\n  let { provider } = yield take(actions.INIT_WEB3);\n  let adapter = new Web3Adapter(provider);\n\n  yield takeEvery(actions.INSPECT, fetchTransactionInfo, adapter);\n  yield takeEvery(actions.FETCH_BINARY, fetchBinary, adapter);\n}\n\nexport default prefixName(\"web3\", saga);\n","module.exports = require(\"web3\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:controller:sagas\");\n\nimport { put, call, race, take, select } from \"redux-saga/effects\";\n\nimport { prefixName, isDeliberatelySkippedNodeType } from \"lib/helpers\";\n\nimport * as trace from \"lib/trace/sagas\";\nimport * as data from \"lib/data/sagas\";\nimport * as evm from \"lib/evm/sagas\";\nimport * as solidity from \"lib/solidity/sagas\";\nimport * as stacktrace from \"lib/stacktrace/sagas\";\n\nimport * as actions from \"../actions\";\n\nimport controller from \"../selectors\";\n\nconst STEP_SAGAS = {\n  [actions.ADVANCE]: advance,\n  [actions.STEP_NEXT]: stepNext,\n  [actions.STEP_OVER]: stepOver,\n  [actions.STEP_INTO]: stepInto,\n  [actions.STEP_OUT]: stepOut,\n  [actions.CONTINUE]: continueUntilBreakpoint\n};\n\nexport function* saga() {\n  while (true) {\n    debug(\"waiting for control action\");\n    let action = yield take(Object.keys(STEP_SAGAS));\n    if (!(yield select(controller.current.trace.loaded))) {\n      continue; //while no trace is loaded, step actions are ignored\n    }\n    debug(\"got control action\");\n    let saga = STEP_SAGAS[action.type];\n\n    yield put(actions.startStepping());\n    yield race({\n      exec: call(saga, action), //not all will use this\n      interrupt: take(actions.INTERRUPT)\n    });\n    yield put(actions.doneStepping());\n  }\n}\n\nexport default prefixName(\"controller\", saga);\n\n/*\n * Advance the state by the given number of instructions (but not past the end)\n * (if no count given, advance 1)\n */\nfunction* advance(action) {\n  let count =\n    action !== undefined && action.count !== undefined ? action.count : 1;\n  //default is, as mentioned, to advance 1\n  for (\n    let i = 0;\n    i < count && !(yield select(controller.current.trace.finished));\n    i++\n  ) {\n    yield* trace.advance();\n  }\n}\n\n/**\n * stepNext - step to the next logical code segment\n *\n * Note: It might take multiple instructions to express the same section of code.\n * \"Stepping\", then, is stepping to the next logical item, not stepping to the next\n * instruction. See advance() if you'd like to advance by one instruction.\n */\nfunction* stepNext() {\n  const starting = yield select(controller.current.location);\n\n  var upcoming, finished;\n\n  do {\n    // advance at least once step\n    yield* advance();\n\n    // and check the next source range\n    upcoming = yield select(controller.current.location);\n\n    finished = yield select(controller.current.trace.finished);\n\n    // if the next step's source range is still the same, keep going\n  } while (\n    !finished &&\n    (!upcoming ||\n      !upcoming.node ||\n      isDeliberatelySkippedNodeType(upcoming.node) ||\n      (upcoming.sourceRange.start === starting.sourceRange.start &&\n        upcoming.sourceRange.length === starting.sourceRange.length &&\n        upcoming.source.id === starting.source.id &&\n        upcoming.source.compilationId === starting.source.compilationId))\n  );\n}\n\n/**\n * stepInto - step into the current function\n *\n * Conceptually this is easy, but from a programming standpoint it's hard.\n * Code like `getBalance(msg.sender)` might be highlighted, but there could\n * be a number of different intermediate steps (like evaluating `msg.sender`)\n * before `getBalance` is stepped into. This function will step into the first\n * function available (where instruction.jump == \"i\"), ignoring any intermediate\n * steps that fall within the same code range. If there's a step encountered\n * that exists outside of the range, then stepInto will only execute until that\n * step.\n */\nfunction* stepInto() {\n  const startingDepth = yield select(controller.current.functionDepth);\n  const startingLocation = yield select(controller.current.location);\n  debug(\"startingDepth: %d\", startingDepth);\n  debug(\"starting source range: %O\", (startingLocation || {}).sourceRange);\n  let currentDepth;\n  let currentLocation;\n  let finished;\n\n  do {\n    yield* stepNext();\n\n    currentDepth = yield select(controller.current.functionDepth);\n    currentLocation = yield select(controller.current.location);\n    finished = yield select(controller.current.trace.finished);\n    debug(\"currentDepth: %d\", currentDepth);\n    debug(\"current source range: %O\", (currentLocation || {}).sourceRange);\n    debug(\"finished: %o\", finished);\n  } while (\n    //we aren't finished,\n    !finished &&\n    // the function stack has not increased,\n    currentDepth <= startingDepth &&\n    // we haven't changed files,\n    currentLocation.source.compilationId ===\n      startingLocation.source.compilationId &&\n    currentLocation.source.id === startingLocation.source.id &&\n    //and we haven't changed lines\n    currentLocation.sourceRange.lines.start.line ===\n      startingLocation.sourceRange.lines.start.line\n  );\n}\n\n/**\n * Step out of the current function\n *\n * This will run until the debugger encounters a decrease in function depth\n * (or finishes)\n */\nfunction* stepOut() {\n  if (yield select(controller.current.location.isMultiline)) {\n    yield* stepOver();\n    return;\n  }\n\n  const startingDepth = yield select(controller.current.functionDepth);\n  var currentDepth;\n  var finished;\n\n  do {\n    yield* stepNext();\n\n    currentDepth = yield select(controller.current.functionDepth);\n    finished = yield select(controller.current.trace.finished);\n  } while (!finished && currentDepth >= startingDepth);\n}\n\n/**\n * stepOver - step over the current line\n *\n * Step over the current line. This will step to the next instruction that\n * exists on a different line of code within the same function depth.\n */\nfunction* stepOver() {\n  const startingDepth = yield select(controller.current.functionDepth);\n  const startingLocation = yield select(controller.current.location);\n  var currentDepth;\n  var currentLocation;\n  var finished;\n\n  do {\n    yield* stepNext();\n\n    currentDepth = yield select(controller.current.functionDepth);\n    currentLocation = yield select(controller.current.location);\n    finished = yield select(controller.current.trace.finished);\n  } while (\n    // keep stepping provided:\n    //\n    // we haven't finished\n    !finished &&\n    // we haven't jumped out\n    currentDepth >= startingDepth &&\n    // either: function depth is greater than starting (ignore function calls)\n    // or, if we're at the same depth, keep stepping until we're on a new\n    // line (which may be in a new file)\n    (currentDepth > startingDepth ||\n      (currentLocation.source.id === startingLocation.source.id &&\n        currentLocation.source.compilationId ===\n          startingLocation.source.compilationId &&\n        currentLocation.sourceRange.lines.start.line ===\n          startingLocation.sourceRange.lines.start.line))\n  );\n}\n\n/**\n * continueUntilBreakpoint - step through execution until a breakpoint\n */\nfunction* continueUntilBreakpoint(action) {\n  //if breakpoints was not specified, use the stored list from the state.\n  //if it was, override that with the specified list.\n  //note that explicitly specifying an empty list will advance to the end.\n  let breakpoints =\n    action !== undefined && action.breakpoints !== undefined\n      ? action.breakpoints\n      : yield select(controller.breakpoints);\n\n  let breakpointHit = false;\n\n  let currentLocation = yield select(controller.current.location);\n  let currentLine = currentLocation.sourceRange.lines.start.line;\n  let currentSourceId = currentLocation.source.id;\n  let currentCompilationId = currentLocation.source.compilationId;\n\n  do {\n    yield* stepNext();\n\n    //note these two have not been updated yet; they'll be updated a\n    //few lines down.  but at this point these are still the previous\n    //values.\n    let previousLine = currentLine;\n    let previousSourceId = currentSourceId;\n\n    currentLocation = yield select(controller.current.location);\n    debug(\"currentLocation: %O\", currentLocation);\n    let finished = yield select(controller.current.trace.finished);\n    if (finished) {\n      break; //can break immediately if finished\n    }\n\n    currentSourceId = currentLocation.source.id;\n    if (currentSourceId === undefined) {\n      continue; //never stop on an unmapped instruction\n    }\n    currentCompilationId = currentLocation.source.compilationId;\n    let currentNode = currentLocation.node.id;\n    currentLine = currentLocation.sourceRange.lines.start.line;\n\n    breakpointHit =\n      breakpoints.filter(({ sourceId, compilationId, line, node }) => {\n        if (node !== undefined) {\n          return (\n            compilationId === currentCompilationId &&\n            sourceId === currentSourceId &&\n            node === currentNode\n          );\n        }\n        //otherwise, we have a line-style breakpoint; we want to stop at the\n        //*first* point on the line\n        return (\n          compilationId === currentCompilationId &&\n          sourceId === currentSourceId &&\n          line === currentLine &&\n          (currentSourceId !== previousSourceId || currentLine !== previousLine)\n        );\n      }).length > 0;\n  } while (!breakpointHit);\n}\n\n/**\n * reset -- reset the state of the debugger\n * (we'll just reset all submodules regardless of which are in use)\n */\nexport function* reset() {\n  yield* data.reset();\n  yield* evm.reset();\n  yield* solidity.reset();\n  yield* trace.reset();\n  yield* stacktrace.reset();\n}\n","module.exports = require(\"babel-runtime/core-js/object/keys\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:solidity:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\n\nimport * as actions from \"../actions\";\nimport { TICK } from \"lib/trace/actions\";\nimport * as trace from \"lib/trace/sagas\";\n\nimport solidity from \"../selectors\";\n\nexport function* addSources(compilations) {\n  yield put(actions.addSources(compilations));\n}\n\nfunction* tickSaga() {\n  debug(\"got TICK\");\n\n  yield* functionDepthSaga();\n  debug(\"instruction: %O\", yield select(solidity.current.instruction));\n  yield* trace.signalTickSagaCompletion();\n}\n\nfunction* functionDepthSaga() {\n  if (yield select(solidity.current.willReturn)) {\n    //we do this case first so we can be sure we're not failing in any of the\n    //other cases below!\n    yield put(actions.externalReturn());\n  } else if (yield select(solidity.current.willJump)) {\n    let jumpDirection = yield select(solidity.current.jumpDirection);\n    debug(\"checking guard\");\n    let guard = yield select(solidity.current.nextFrameIsPhantom);\n    let nextSource = yield select(solidity.next.source);\n    if (jumpDirection === \"i\" && guard && nextSource.id !== undefined) {\n      //note: currently unmapped source will have id undefined, rather than\n      //id -1, in our internal representation.  Might want to change this\n      //later.\n      yield put(actions.clearPhantomGuard());\n    } else {\n      yield put(actions.jump(jumpDirection));\n    }\n  } else if (yield select(solidity.current.willCall)) {\n    //note: includes creations; does not include insta-returns\n    debug(\"checking if guard needed\");\n    let guard = yield select(solidity.current.callRequiresPhantomFrame);\n    yield put(actions.externalCall(guard));\n  }\n}\n\nexport function* reset() {\n  let guard = yield select(\n    solidity.transaction.bottomStackframeRequiresPhantomFrame\n  );\n  yield put(actions.reset(guard));\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* begin() {\n  let guard = yield select(\n    solidity.transaction.bottomStackframeRequiresPhantomFrame\n  );\n  yield put(actions.externalCall(guard));\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"solidity\", saga);\n","export const ADD_SOURCES = \"SOLIDITY_ADD_SOURCES\";\nexport function addSources(compilations) {\n  return {\n    type: ADD_SOURCES,\n    compilations\n  };\n}\n\nexport const JUMP = \"SOLIDITY_JUMP\";\nexport function jump(jumpDirection) {\n  return {\n    type: JUMP,\n    jumpDirection\n  };\n}\n\nexport const EXTERNAL_CALL = \"SOLIDITY_EXTERNAL_CALL\";\nexport function externalCall(guard) {\n  return { type: EXTERNAL_CALL, guard };\n}\n\nexport const EXTERNAL_RETURN = \"SOLIDITY_EXTERNAL_RETURN\";\nexport function externalReturn() {\n  return { type: EXTERNAL_RETURN };\n}\n\nexport const CLEAR_PHANTOM_GUARD = \"SOLIDITY_CLEAR_PHANTOM_GUARD\";\nexport function clearPhantomGuard() {\n  return { type: CLEAR_PHANTOM_GUARD };\n}\n\nexport const RESET = \"SOLIDITY_RESET\";\nexport function reset(guard) {\n  return { type: RESET, guard };\n}\n\nexport const UNLOAD_TRANSACTION = \"SOLIDITY_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return { type: UNLOAD_TRANSACTION };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:stacktrace:sagas\");\n\nimport { put, takeEvery, select } from \"redux-saga/effects\";\nimport { prefixName } from \"lib/helpers\";\n\nimport * as actions from \"../actions\";\nimport { TICK } from \"lib/trace/actions\";\nimport * as trace from \"lib/trace/sagas\";\n\nimport stacktrace from \"../selectors\";\n\nfunction* tickSaga() {\n  yield* stacktraceSaga();\n  yield* trace.signalTickSagaCompletion();\n}\n\n//NOTE: we deliberately *don't* do any phantom-checking in this\n//submodule.  yes, it will result in some junk stackframes, but\n//I really don't want a fallback or constructor frame skipped over\n//due to phantom checking\n\nfunction* stacktraceSaga() {\n  const currentLocation = yield select(stacktrace.current.strippedLocation);\n  const lastLocation = yield select(stacktrace.current.lastPosition);\n  const returnCounter = yield select(stacktrace.current.returnCounter);\n  let positionUpdated = false;\n  //different possible outcomes:\n  //first: are we returning?\n  if (yield select(stacktrace.current.willReturn)) {\n    const status = yield select(stacktrace.current.returnStatus);\n    debug(\"returning!\");\n    yield put(actions.externalReturn(lastLocation, status, currentLocation));\n    positionUpdated = true;\n  } else if (\n    //next: are we *executing* a return?\n    //note this needs to be an else if or else this could execute\n    //in an inconsistent state\n    returnCounter > 0 &&\n    (yield select(stacktrace.current.positionWillChange))\n  ) {\n    debug(\"executing!\");\n    debug(\"location: %o\", yield select(stacktrace.next.location));\n    debug(\"marked: %o\", lastLocation);\n    yield put(actions.executeReturn(returnCounter, currentLocation));\n    positionUpdated = true;\n  }\n  //we now process the other possibilities.\n  //technically, an EXECUTE_RETURN could happen as well as those below,\n  //resulting in 2 actions instead of just one, but it's pretty unlikely.\n  //(an EXTERNAL_RETURN, OTOH, is obviously exclusive of the possibilities below)\n  if (yield select(stacktrace.current.willJumpIn)) {\n    const nextLocation = yield select(stacktrace.next.location);\n    const nextParent = yield select(stacktrace.next.contractNode);\n    yield put(actions.jumpIn(currentLocation, nextLocation.node, nextParent));\n    positionUpdated = true;\n  } else if (yield select(stacktrace.current.willJumpOut)) {\n    yield put(actions.jumpOut(currentLocation));\n    positionUpdated = true;\n  } else if (yield select(stacktrace.current.willCall)) {\n    //note: includes creations\n    //note: does *not* include calls that insta-return.  logically speaking,\n    //such calls should be a call + a return in one, right? and we could do that,\n    //making a call while also incrementing the return counter.  but the stacktraces\n    //this would generate would, I think, be more confusing than helpful, so I'm\n    //deliberately not doing that.\n    //NOTE: we can't use stacktrace.next.location here as that\n    //doesn't work across call contexts!\n    const nextContext = yield select(stacktrace.current.callContext);\n    const nextAddress = yield select(stacktrace.current.callAddress);\n    yield put(actions.externalCall(currentLocation, nextContext, nextAddress));\n    positionUpdated = true;\n  }\n  //finally, if no other action updated the position, do so here\n  if (!positionUpdated) {\n    yield put(actions.updatePosition(currentLocation));\n  }\n}\n\nexport function* reset() {\n  yield put(actions.reset());\n}\n\nexport function* unload() {\n  yield put(actions.unloadTransaction());\n}\n\nexport function* begin() {\n  const context = yield select(stacktrace.current.context);\n  const address = yield select(stacktrace.current.address);\n  yield put(actions.externalCall(null, context, address));\n}\n\nexport function* saga() {\n  yield takeEvery(TICK, tickSaga);\n}\n\nexport default prefixName(\"stacktrace\", saga);\n","export const JUMP_IN = \"STACKTRACE_JUMP_IN\";\nexport function jumpIn(location, functionNode, contractNode) {\n  return {\n    type: JUMP_IN,\n    location,\n    functionNode,\n    contractNode,\n  };\n}\n\nexport const JUMP_OUT = \"STACKTRACE_JUMP_OUT\";\nexport function jumpOut(location) {\n  return {\n    type: JUMP_OUT,\n    location,\n  };\n}\n\nexport const EXTERNAL_CALL = \"STACKTRACE_EXTERNAL_CALL\";\nexport function externalCall(location, context, address) {\n  return {\n    type: EXTERNAL_CALL,\n    location,\n    context,\n    address,\n  };\n}\n\nexport const EXTERNAL_RETURN = \"STACKTRACE_EXTERNAL_RETURN\";\nexport function externalReturn(from, status, location) {\n  return {\n    type: EXTERNAL_RETURN,\n    from,\n    status,\n    location,\n  };\n}\n\nexport const EXECUTE_RETURN = \"STACKTRACE_EXECUTE_RETURN\";\nexport function executeReturn(counter, location) {\n  return {\n    type: EXECUTE_RETURN,\n    counter,\n    location,\n  };\n}\n\nexport const UPDATE_POSITION = \"STACKTRACE_UPDATE_POSITION\";\nexport function updatePosition(location) {\n  return {\n    type: UPDATE_POSITION,\n    location,\n  };\n}\n\nexport const RESET = \"STACKTRACE_RESET\";\nexport function reset() {\n  return {\n    type: RESET,\n  };\n}\n\nexport const UNLOAD_TRANSACTION = \"STACKTRACE_UNLOAD_TRANSACTION\";\nexport function unloadTransaction() {\n  return {\n    type: UNLOAD_TRANSACTION,\n  };\n}\n","require(\"source-map-support/register\");\nvar Debugger = require(\"./lib/debugger\").default;\n\nmodule.exports = Debugger;\n","module.exports = require(\"source-map-support/register\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger\");\n\nimport Session from \"./session\";\n\nimport { createNestedSelector } from \"reselect-tree\";\n\nimport dataSelector from \"./data/selectors\";\nimport astSelector from \"./ast/selectors\";\nimport traceSelector from \"./trace/selectors\";\nimport evmSelector from \"./evm/selectors\";\nimport soliditySelector from \"./solidity/selectors\";\nimport sessionSelector from \"./session/selectors\";\nimport stacktraceSelector from \"./stacktrace/selectors\";\nimport controllerSelector from \"./controller/selectors\";\n\nimport { Compilations } from \"@truffle/codec\";\n\nconst Debugger = {\n  /**\n   * Instantiates a Debugger for a given transaction hash.\n   *\n   * @param {String} txHash - transaction hash with leading \"0x\"\n   * @param {{contracts: Array<Artifact>, files: Array<String>, provider: Web3Provider, compilations: Array<Compilation>}} options -\n   * @return {Debugger} instance\n   */\n  forTx: async function(txHash, options = {}) {\n    let { contracts, files, provider, compilations, lightMode } = options;\n    if (!compilations) {\n      compilations = Compilations.Utils.shimArtifacts(contracts, files);\n    }\n    let session = new Session(compilations, provider, { lightMode }, txHash);\n\n    try {\n      await session.ready();\n      debug(\"session ready\");\n    } catch (e) {\n      debug(\"error occurred, unloaded\");\n      session.unload();\n    }\n\n    return session;\n  },\n\n  /*\n   * Instantiates a Debugger for a given project (with no transaction loaded)\n   *\n   * @param {{contracts: Array<Artifact>, files: Array<String>, provider: Web3Provider, compilations: Array<Compilation>}} options -\n   * @return {Debugger} instance\n   */\n  forProject: async function(options = {}) {\n    let { contracts, files, provider, compilations, lightMode } = options;\n    if (!compilations) {\n      compilations = Compilations.Utils.shimArtifacts(contracts, files);\n    }\n    let session = new Session(compilations, provider, { lightMode });\n\n    await session.ready();\n\n    return session;\n  },\n\n  /**\n   * Exported selectors\n   *\n   * See individual selector docs for full listing\n   *\n   * @example\n   * Debugger.selectors.ast.current.tree\n   *\n   * @example\n   * Debugger.selectors.solidity.current.instruction\n   *\n   * @example\n   * Debugger.selectors.trace.steps\n   */\n  get selectors() {\n    return createNestedSelector({\n      ast: astSelector,\n      data: dataSelector,\n      trace: traceSelector,\n      evm: evmSelector,\n      solidity: soliditySelector,\n      stacktrace: stacktraceSelector,\n      session: sessionSelector,\n      controller: controllerSelector\n    });\n  }\n};\n\nexport default Debugger;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session\");\n\nimport * as Codec from \"@truffle/codec\";\nimport { keccak256 } from \"lib/helpers\";\n\nimport configureStore from \"lib/store\";\n\nimport * as controller from \"lib/controller/actions\";\nimport * as actions from \"./actions\";\nimport data from \"lib/data/selectors\";\nimport stacktrace from \"lib/stacktrace/selectors\";\nimport session from \"lib/session/selectors\";\nimport * as dataSagas from \"lib/data/sagas\";\nimport * as controllerSagas from \"lib/controller/sagas\";\nimport * as sagas from \"./sagas\";\nimport controllerSelector from \"lib/controller/selectors\";\n\nimport { createNestedSelector } from \"reselect-tree\";\n\nimport ast from \"lib/ast/selectors\";\nimport trace from \"lib/trace/selectors\";\nimport evm from \"lib/evm/selectors\";\nimport solidity from \"lib/solidity/selectors\";\n\nimport rootSaga from \"./sagas\";\nimport reducer from \"./reducers\";\n\nimport { shimBytecode } from \"@truffle/compile-solidity/legacy/shims\";\n\n/**\n * Debugger Session\n */\nexport default class Session {\n  /**\n   * @param {Array<Compilations>} compilations\n   * @param {Web3Provider} provider - web3 provider\n   * txHash parameter is now optional!\n   * @private\n   */\n  constructor(compilations, provider, moduleOptions, txHash) {\n    /**\n     * @private\n     */\n    let { store, sagaMiddleware } = configureStore(reducer, rootSaga, [\n      moduleOptions\n    ]);\n    this._store = store;\n    this._sagaMiddleware = sagaMiddleware;\n\n    let { contexts, sources } = Session.normalize(compilations);\n\n    // record contracts\n    this._store.dispatch(actions.recordContracts(contexts, sources));\n\n    //set up the ready listener\n    this._ready = new Promise((accept, reject) => {\n      const unsubscribe = this._store.subscribe(() => {\n        if (this.view(session.status.ready)) {\n          debug(\"ready!\");\n          unsubscribe();\n          accept();\n        } else if (this.view(session.status.errored)) {\n          debug(\"error!\");\n          unsubscribe();\n          reject(this.view(session.status.error));\n        }\n      });\n    });\n\n    //note that txHash is now optional\n    this._store.dispatch(actions.start(provider, txHash));\n  }\n\n  async ready() {\n    await this._ready;\n  }\n\n  async readyAgainAfterLoading(sessionAction) {\n    return new Promise((accept, reject) => {\n      let hasStartedWaiting = false;\n      debug(\"reready listener set up\");\n      const unsubscribe = this._store.subscribe(() => {\n        debug(\"reready?\");\n        if (hasStartedWaiting) {\n          if (this.view(session.status.ready)) {\n            debug(\"reready!\");\n            unsubscribe();\n            accept(true);\n          } else if (this.view(session.status.errored)) {\n            unsubscribe();\n            debug(\"error!\");\n            reject(this.view(session.status.error));\n          }\n        } else {\n          if (this.view(session.status.waiting)) {\n            debug(\"started waiting\");\n            hasStartedWaiting = true;\n          }\n          return;\n        }\n      });\n      this.dispatch(sessionAction);\n    });\n  }\n\n  /**\n   * Split up artifacts into \"contexts\" and \"sources\", dividing artifact\n   * data into appropriate buckets.\n   *\n   * Multiple contracts can be defined in the same source file, but have\n   * different bytecodes.\n   *\n   * (NOTE: now that this takes compilations, the splitting is largely already\n   * done.  However, there's still remaining work to do.)\n   *\n   * @private\n   */\n  static normalize(compilations) {\n    let contexts = [];\n    let sources = {}; //by compilation, then index\n\n    for (let compilation of compilations) {\n      if (compilation.unreliableSourceOrder) {\n        throw new Error(\n          `Error: Compilation ${compilation.id} has unreliable source order.`\n        );\n      }\n      let compiler = compilation.compiler; //note: we'll prefer one listed on contract or source\n      sources[compilation.id] = [];\n      for (let index in compilation.sources) {\n        //not the recommended way to iterate over an array,\n        //but the order doesn't matter here so it's safe\n        let source = compilation.sources[index];\n        if (!source) {\n          continue; //just for safety (in case there are gaps)\n        }\n        sources[compilation.id][index] = {\n          ...source,\n          compiler: source.compiler || compiler,\n          compilationId: compilation.id,\n          id: index\n        };\n      }\n\n      for (let contract of compilation.contracts) {\n        let {\n          contractName,\n          bytecode: binary,\n          sourceMap,\n          deployedBytecode: deployedBinary,\n          deployedSourceMap,\n          immutableReferences,\n          abi,\n          compiler,\n          primarySourceId\n        } = contract;\n\n        //hopefully we can get rid of this step eventually, but not yet\n        if (typeof binary === \"object\") {\n          binary = shimBytecode(binary);\n        }\n        if (typeof deployedBinary === \"object\") {\n          deployedBinary = shimBytecode(deployedBinary);\n        }\n\n        let primarySourceIndex;\n        if (primarySourceId !== undefined) {\n          //I'm assuming this finds it! it had better!\n          primarySourceIndex = compilation.sources.findIndex(\n            source => source && source.id === primarySourceId\n          );\n        }\n        //otherwise leave it undefined\n\n        //now: we need to find the contract node.\n        //note: ideally we'd hold this off till later, but that would break the\n        //direction of the evm/solidity dependence, so we do it now\n        let contractNode = Codec.Compilations.Utils.getContractNode(\n          contract,\n          compilation\n        );\n\n        let contractId = contractNode ? contractNode.id : undefined;\n        let contractKind = contractNode ? contractNode.contractKind : undefined;\n        abi = Codec.AbiData.Utils.schemaAbiToAbi(abi); //let's handle this up front\n\n        debug(\"contractName %s\", contractName);\n        debug(\"sourceMap %o\", sourceMap);\n        debug(\"compiler %o\", compiler);\n        debug(\"abi %O\", abi);\n\n        if (binary && binary != \"0x\") {\n          contexts.push({\n            contractName,\n            binary,\n            sourceMap,\n            primarySource: primarySourceIndex,\n            abi,\n            compiler,\n            compilationId: compilation.id,\n            contractId,\n            contractKind,\n            externalSolidity: compilation.externalSolidity,\n            isConstructor: true\n          });\n        }\n\n        if (deployedBinary && deployedBinary != \"0x\") {\n          contexts.push({\n            contractName,\n            binary: deployedBinary,\n            sourceMap: deployedSourceMap,\n            primarySource: primarySourceIndex,\n            immutableReferences,\n            abi,\n            compiler,\n            compilationId: compilation.id,\n            contractId,\n            contractKind,\n            externalSolidity: compilation.externalSolidity,\n            isConstructor: false\n          });\n        }\n      }\n    }\n\n    //now: turn contexts from array into object\n    contexts = Object.assign(\n      {},\n      ...contexts.map(context => {\n        const contextHash = keccak256({\n          type: \"string\",\n          value: context.binary\n        });\n        //NOTE: we take hash as *string*, not as bytes, because the binary may\n        //contain link references!\n        return {\n          [contextHash]: {\n            ...context,\n            context: contextHash\n          }\n        };\n      })\n    );\n\n    //normalize contexts\n    contexts = Codec.Contexts.Utils.normalizeContexts(contexts);\n\n    return { contexts, sources };\n  }\n\n  get state() {\n    return this._store.getState();\n  }\n\n  view(selector) {\n    return selector(this.state);\n  }\n\n  async dispatch(action) {\n    this._store.dispatch(action);\n\n    return true;\n  }\n\n  /**\n   * @private\n   * Allows running any saga -- for internal use only!\n   * Using this could seriously screw up the debugger state if you\n   * don't know what you're doing!\n   */\n  async _runSaga(saga, ...args) {\n    return await this._sagaMiddleware.run(saga, ...args).toPromise();\n  }\n\n  async interrupt() {\n    await this.dispatch(actions.interrupt());\n    await this.dispatch(controller.interrupt());\n  }\n\n  async doneStepping(stepperAction) {\n    return new Promise(resolve => {\n      let hasStarted = false;\n      const unsubscribe = this._store.subscribe(() => {\n        const isStepping = this.view(controllerSelector.isStepping);\n\n        if (isStepping && !hasStarted) {\n          hasStarted = true;\n          debug(\"heard step start\");\n          return;\n        }\n\n        if (!isStepping && hasStarted) {\n          debug(\"heard step stop\");\n          unsubscribe();\n          resolve(true);\n        }\n      });\n      this.dispatch(stepperAction);\n    });\n  }\n\n  //returns true on success, false on already loaded, error object on failure\n  async load(txHash) {\n    if (this.view(session.status.loaded)) {\n      return false;\n    }\n    try {\n      return await this.readyAgainAfterLoading(actions.loadTransaction(txHash));\n    } catch (e) {\n      this._runSaga(sagas.unload);\n      return e;\n    }\n  }\n\n  //returns true on success, false on already unloaded\n  async unload() {\n    if (!this.view(session.status.loaded)) {\n      return false;\n    }\n    debug(\"unloading\");\n    await this._runSaga(sagas.unload);\n    return true;\n  }\n\n  //Note: count is an optional argument; default behavior is to advance 1\n  async advance(count) {\n    return await this.doneStepping(controller.advance(count));\n  }\n\n  async stepNext() {\n    return await this.doneStepping(controller.stepNext());\n  }\n\n  async stepOver() {\n    return await this.doneStepping(controller.stepOver());\n  }\n\n  async stepInto() {\n    return await this.doneStepping(controller.stepInto());\n  }\n\n  async stepOut() {\n    return await this.doneStepping(controller.stepOut());\n  }\n\n  async reset() {\n    let loaded = this.view(session.status.loaded);\n    if (!loaded) {\n      return;\n    }\n    return await this._runSaga(controllerSagas.reset);\n  }\n\n  //NOTE: breakpoints is an OPTIONAL argument for if you want to supply your\n  //own list of breakpoints; leave it out to use the internal one (as\n  //controlled by the functions below)\n  async continueUntilBreakpoint(breakpoints) {\n    return await this.doneStepping(\n      controller.continueUntilBreakpoint(breakpoints)\n    );\n  }\n\n  async addBreakpoint(breakpoint) {\n    return await this.dispatch(controller.addBreakpoint(breakpoint));\n  }\n\n  async removeBreakpoint(breakpoint) {\n    return await this.dispatch(controller.removeBreakpoint(breakpoint));\n  }\n\n  async removeAllBreakpoints() {\n    return await this.dispatch(controller.removeAllBreakpoints());\n  }\n\n  //deprecated -- decode is now *always* ready!\n  async decodeReady() {\n    return true;\n  }\n\n  async variable(name) {\n    const definitions = this.view(data.current.identifiers.definitions);\n    const refs = this.view(data.current.identifiers.refs);\n    const compilationId = this.view(data.current.compilationId);\n\n    return await this._runSaga(\n      dataSagas.decode,\n      definitions[name],\n      refs[name],\n      compilationId\n    );\n  }\n\n  async variables() {\n    if (!this.view(session.status.loaded)) {\n      return {};\n    }\n    let definitions = this.view(data.current.identifiers.definitions);\n    let refs = this.view(data.current.identifiers.refs);\n    let compilationId = this.view(data.current.compilationId);\n    let decoded = {};\n    for (let [identifier, ref] of Object.entries(refs)) {\n      if (identifier in definitions) {\n        decoded[identifier] = await this._runSaga(\n          dataSagas.decode,\n          definitions[identifier],\n          ref,\n          compilationId\n        );\n      }\n    }\n    return decoded;\n  }\n\n  async returnValue() {\n    if (\n      !this.view(session.status.loaded) ||\n      !this.view(evm.current.step.isHalting)\n    ) {\n      return null;\n    }\n    return await this._runSaga(dataSagas.decodeReturnValue);\n  }\n\n  callstack() {\n    if (!this.view(session.status.loaded)) {\n      return null;\n    }\n    return this.view(stacktrace.current.report);\n  }\n\n  stacktrace() {\n    if (!this.view(session.status.loaded)) {\n      return null;\n    }\n    return this.view(stacktrace.current.finalReport);\n  }\n\n  connect() {\n    return this; //for compatibility\n  }\n\n  async addExternalCompilations(compilations) {\n    let { contexts, sources } = Session.normalize(compilations);\n    return await this.dispatch(actions.addCompilations(sources, contexts));\n  }\n\n  async startFullMode() {\n    return await this.dispatch(actions.startFullMode());\n  }\n\n  get selectors() {\n    return createNestedSelector({\n      ast,\n      data,\n      trace,\n      evm,\n      solidity,\n      stacktrace,\n      session,\n      controller: controllerSelector\n    });\n  }\n}\n","module.exports = require(\"babel-runtime/core-js/promise\");","module.exports = require(\"json-stable-stringify\");","if (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./production\");\n} else if (process.env.NODE_ENV === \"test\") {\n  module.exports = require(\"./test\");\n} else {\n  module.exports = require(\"./development\");\n}\n","import configureStore from \"./common\";\nexport default configureStore;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:store:common\");\n\nimport { compose, createStore, applyMiddleware } from \"redux\";\nimport createSagaMiddleware from \"redux-saga\";\n\nexport default function configureStore(\n  reducer,\n  saga,\n  sagaArgs,\n  initialState,\n  composeEnhancers\n) {\n  const sagaMiddleware = createSagaMiddleware();\n\n  if (!composeEnhancers) {\n    composeEnhancers = compose;\n  }\n\n  let store = createStore(\n    reducer,\n    initialState,\n\n    composeEnhancers(applyMiddleware(sagaMiddleware))\n  );\n\n  sagaMiddleware.run(saga, ...sagaArgs);\n\n  return { store, sagaMiddleware };\n}\n","module.exports = require(\"redux-saga\");","module.exports = require(\"@truffle/solidity-utils\");","module.exports = require(\"lodash.zipwith\");","export const INIT_WEB3 = \"INIT_WEB3\";\nexport function init(provider) {\n  return {\n    type: INIT_WEB3,\n    provider\n  };\n}\n\nexport const INSPECT = \"INSPECT_TRANSACTION\";\nexport function inspect(txHash) {\n  return {\n    type: INSPECT,\n    txHash\n  };\n}\n\nexport const FETCH_BINARY = \"FETCH_BINARY\";\nexport function fetchBinary(address, block) {\n  return {\n    type: FETCH_BINARY,\n    address,\n    block //optional\n  };\n}\n\nexport const RECEIVE_BINARY = \"RECEIVE_BINARY\";\nexport function receiveBinary(address, binary) {\n  return {\n    type: RECEIVE_BINARY,\n    address,\n    binary\n  };\n}\n\nexport const RECEIVE_TRACE = \"RECEIVE_TRACE\";\nexport function receiveTrace(trace) {\n  return {\n    type: RECEIVE_TRACE,\n    trace\n  };\n}\n\nexport const RECEIVE_CALL = \"RECEIVE_CALL\";\nexport function receiveCall({\n  address,\n  binary,\n  data,\n  storageAddress,\n  status,\n  sender,\n  value,\n  gasprice,\n  block\n}) {\n  return {\n    type: RECEIVE_CALL,\n    address,\n    binary,\n    data,\n    storageAddress,\n    status, //only used for creation calls at present!\n    sender,\n    value,\n    gasprice,\n    block\n  };\n}\n\nexport const ERROR_WEB3 = \"ERROR_WEB3\";\nexport function error(error) {\n  return {\n    type: ERROR_WEB3,\n    error\n  };\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:web3:adapter\");\n\nimport Web3 from \"web3\";\nimport { promisify } from \"util\";\n\nexport default class Web3Adapter {\n  constructor(provider) {\n    this.web3 = new Web3(provider);\n  }\n\n  async getTrace(txHash) {\n    let result = await promisify(this.web3.currentProvider.send)(\n      //send *only* uses callbacks, so we use promsifiy to make things more\n      //readable\n      {\n        jsonrpc: \"2.0\",\n        method: \"debug_traceTransaction\",\n        params: [txHash, {}],\n        id: new Date().getTime()\n      }\n    );\n    if (result.error) {\n      throw new Error(result.error.message);\n    } else {\n      return result.result.structLogs;\n    }\n  }\n\n  async getTransaction(txHash) {\n    return await this.web3.eth.getTransaction(txHash);\n  }\n\n  async getReceipt(txHash) {\n    return await this.web3.eth.getTransactionReceipt(txHash);\n  }\n\n  async getBlock(blockNumberOrHash) {\n    return await this.web3.eth.getBlock(blockNumberOrHash);\n  }\n\n  /**\n   * getDeployedCode - get the deployed code for an address from the client\n   * NOTE: the block argument is optional\n   * @param  {String} address\n   * @return {String}         deployedBinary\n   */\n  async getDeployedCode(address, block) {\n    debug(\"getting deployed code for %s\", address);\n    let code = await this.web3.eth.getCode(address, block);\n    return code === \"0x0\" ? \"0x\" : code;\n  }\n}\n","module.exports = require(\"util\");","module.exports = require(\"lodash.sum\");","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session:sagas\");\n\nimport { call, all, fork, take, put, race, select } from \"redux-saga/effects\";\n\nimport { prefixName } from \"lib/helpers\";\n\nimport * as ast from \"lib/ast/sagas\";\nimport * as controller from \"lib/controller/sagas\";\nimport * as solidity from \"lib/solidity/sagas\";\nimport * as stacktrace from \"lib/stacktrace/sagas\";\nimport * as evm from \"lib/evm/sagas\";\nimport * as trace from \"lib/trace/sagas\";\nimport * as data from \"lib/data/sagas\";\nimport * as web3 from \"lib/web3/sagas\";\n\nimport * as actions from \"../actions\";\n\nimport session from \"../selectors\";\n\nconst LOAD_SAGAS = {\n  [actions.LOAD_TRANSACTION]: load,\n  //will also add reconstruct action/saga once it exists\n  //the following ones don't really relate to loading, but, oh well\n  [actions.ADD_COMPILATIONS]: addCompilations,\n  [actions.START_FULL_MODE]: startFullMode\n};\n\nfunction* listenerSaga() {\n  while (true) {\n    let action = yield take(Object.keys(LOAD_SAGAS));\n    let saga = LOAD_SAGAS[action.type];\n\n    yield put(actions.wait());\n    yield race({\n      exec: call(saga, action), //not all will use this\n      interrupt: take(actions.INTERRUPT)\n    });\n    yield put(actions.ready());\n  }\n}\n\nexport function* saga(moduleOptions) {\n  debug(\"starting listeners\");\n  yield* forkListeners(moduleOptions);\n\n  // receiving & saving contracts into state\n  debug(\"waiting for contract information\");\n  let { contexts, sources } = yield take(actions.RECORD_CONTRACTS);\n\n  debug(\"recording contract binaries\");\n  yield* recordContexts(contexts);\n\n  debug(\"recording contract sources\");\n  yield* recordSources(sources);\n\n  debug(\"waiting for start\");\n  // wait for start signal\n  let { txHash, provider } = yield take(actions.START);\n  debug(\"starting\");\n\n  if (!moduleOptions.lightMode) {\n    debug(\"visiting ASTs\");\n    // visit asts\n    yield* ast.visitAll();\n\n    //save allocation table\n    debug(\"saving allocation table\");\n    yield* data.recordAllocations();\n    //note: we don't need to explicitly set full mode, it's the default\n  } else {\n    debug(\"setting light mode\");\n    yield put(actions.setLightMode());\n  }\n\n  //initialize web3 adapter\n  debug(\"initializing adapter\");\n  yield* web3.init(provider);\n\n  //process transaction (if there is one)\n  //(note: this part may also set the error state)\n  if (txHash !== undefined) {\n    yield* processTransaction(txHash);\n  }\n\n  debug(\"readying\");\n  // signal that commands can begin\n  yield* ready();\n}\n\n//please only use in light mode!\nfunction* addCompilations({ sources, contexts }) {\n  debug(\"recording contract binaries\");\n  yield* recordContexts(contexts);\n\n  debug(\"recording contract sources\");\n  yield* recordSources(sources);\n\n  debug(\"refreshing instances\");\n  yield* evm.refreshInstances();\n}\n\nfunction* startFullMode() {\n  debug(\"session: %O\", session);\n  let lightMode = yield select(session.status.lightMode);\n  if (!lightMode) {\n    //better not start this twice!\n    return;\n  }\n  debug(\"turning on data listener\");\n  yield fork(data.saga);\n\n  debug(\"visiting ASTs\");\n  // visit asts\n  yield* ast.visitAll();\n\n  //save allocation table\n  debug(\"saving allocation table\");\n  yield* data.recordAllocations();\n\n  yield* trace.addSubmoduleToCount();\n\n  yield put(actions.setFullMode());\n}\n\nexport function* processTransaction(txHash) {\n  // process transaction\n  debug(\"fetching transaction info\");\n  let err = yield* fetchTx(txHash);\n  if (err) {\n    debug(\"error %o\", err);\n    yield* error(err);\n  }\n}\n\nexport default prefixName(\"session\", saga);\n\nfunction* forkListeners(moduleOptions) {\n  yield fork(listenerSaga); //session listener; this one is separate, sorry\n  //(I didn't want to mess w/ the existing structure of defaults)\n  let mainApps = [evm, solidity, stacktrace];\n  if (!moduleOptions.lightMode) {\n    mainApps.push(data);\n  }\n  let otherApps = [trace, controller, web3];\n  const submoduleCount = mainApps.length;\n  const apps = mainApps.concat(otherApps);\n  yield* trace.setSubmoduleCount(submoduleCount);\n  return yield all(apps.map(app => fork(app.saga)));\n}\n\nfunction* fetchTx(txHash) {\n  let result = yield* web3.inspectTransaction(txHash);\n  debug(\"result %o\", result);\n\n  if (result.error) {\n    return result.error;\n  }\n\n  //get addresses created/called during transaction\n  debug(\"processing trace for addresses\");\n  let addresses = yield* trace.processTrace(result.trace);\n  //add in the address of the call itself (if a call)\n  if (result.address && !addresses.includes(result.address)) {\n    addresses.push(result.address);\n  }\n  //if a create, only add in address if it was successful\n  if (\n    result.binary &&\n    result.status &&\n    !addresses.includes(result.storageAddress)\n  ) {\n    addresses.push(result.storageAddress);\n  }\n\n  let blockNumber = result.block.number.toString(); //a BN is not accepted\n  debug(\"obtaining binaries\");\n  let binaries = yield* web3.obtainBinaries(addresses, blockNumber);\n\n  debug(\"recording instances\");\n  yield all(\n    addresses.map((address, i) => call(recordInstance, address, binaries[i]))\n  );\n\n  debug(\"sending initial call\");\n  yield* evm.begin(result); //note: this must occur *before* the other two\n  yield* solidity.begin();\n  yield* stacktrace.begin();\n}\n\nfunction* recordContexts(contexts) {\n  for (let context of Object.values(contexts)) {\n    yield* evm.addContext(context);\n  }\n}\n\nfunction* recordSources(sources) {\n  yield* solidity.addSources(sources);\n}\n\nfunction* recordInstance(address, binary) {\n  yield* evm.addInstance(address, binary);\n}\n\nfunction* ready() {\n  yield put(actions.ready());\n}\n\nfunction* error(err) {\n  yield put(actions.error(err));\n}\n\n//we'll just unload all modules regardless of which ones are currently present...\nexport function* unload() {\n  debug(\"unloading\");\n  yield* data.reset();\n  yield* solidity.unload();\n  yield* evm.unload();\n  yield* trace.unload();\n  yield* stacktrace.unload();\n  yield put(actions.unloadTransaction());\n}\n\n//note that load takes an action as its argument, which is why it's separate\n//from processTransaction\nfunction* load({ txHash }) {\n  yield* processTransaction(txHash);\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:ast:sagas\");\n\nimport { all, call, select } from \"redux-saga/effects\";\n\nimport * as data from \"lib/data/sagas\";\n\nimport ast from \"../selectors\";\n\nimport flatten from \"lodash.flatten\";\nimport jsonpointer from \"json-pointer\";\n\nfunction* walk(compilationId, sourceId, node, pointer = \"\", parentId = null) {\n  debug(\"walking %d %o %o\", sourceId, pointer, node);\n\n  yield* handleEnter(compilationId, sourceId, node, pointer, parentId);\n\n  if (Array.isArray(node)) {\n    for (let [i, child] of node.entries()) {\n      yield* walk(compilationId, sourceId, child, `${pointer}/${i}`, parentId);\n    }\n  } else if (node && node.nodeType === \"YulBlock\") {\n    //defer to yul handler!\n    yield* handleYul(compilationId, sourceId, node, pointer, parentId);\n  } else if (node instanceof Object) {\n    for (let [key, child] of Object.entries(node)) {\n      yield* walk(compilationId, sourceId, child, `${pointer}/${key}`, node.id);\n    }\n  }\n\n  yield* handleExit(compilationId, sourceId, node, pointer);\n}\n\nfunction* handleEnter(compilationId, sourceId, node, pointer, parentId) {\n  debug(\"entering %d %s\", sourceId, pointer);\n\n  if (!(node instanceof Object)) {\n    return;\n  }\n\n  if (node.id !== undefined) {\n    debug(\"%s recording scope %s\", pointer, node.id);\n    yield* data.scope(node.id, pointer, parentId, sourceId, compilationId);\n  }\n\n  switch (node.nodeType) {\n    case \"VariableDeclaration\":\n      debug(\"%s recording variable %o\", pointer, node);\n      yield* data.declare(node, compilationId);\n      break;\n    case \"ContractDefinition\":\n    case \"StructDefinition\":\n    case \"EnumDefinition\":\n      debug(\"%s recording type %o\", pointer, node);\n      yield* data.defineType(node, compilationId);\n      break;\n  }\n}\n\nfunction* handleExit(compilationId, sourceId, node, pointer) {\n  debug(\"exiting %d %s\", sourceId, pointer);\n\n  // no-op right now\n}\n\nexport function* visitAll() {\n  let compilations = yield select(ast.views.sources);\n\n  let sources = flatten(\n    Object.values(compilations).map(({ byId }) => byId)\n  ).filter(x => x);\n\n  yield all(\n    sources\n      .filter(({ ast }) => ast)\n      .map(({ ast, id, compilationId }) => call(walk, compilationId, id, ast))\n  );\n\n  debug(\"done visiting\");\n}\n\nfunction* handleYul(compilationId, sourceId, node, pointer, parentId) {\n  yield* yulWalk(\n    compilationId,\n    sourceId,\n    node,\n    pointer,\n    node,\n    pointer,\n    parentId\n  );\n}\n\nfunction* yulWalk(\n  compilationId,\n  sourceId,\n  node,\n  pointer,\n  base,\n  basePointer,\n  parentId = undefined\n) {\n  yield* handleYulEnter(\n    compilationId,\n    sourceId,\n    node,\n    pointer,\n    base,\n    basePointer,\n    parentId\n  );\n\n  if (Array.isArray(node)) {\n    for (let [i, child] of node.entries()) {\n      yield* yulWalk(\n        compilationId,\n        sourceId,\n        child,\n        `${pointer}/${i}`,\n        base,\n        basePointer\n      ); //no parent ID for subnodes\n    }\n  } else if (node instanceof Object) {\n    for (let [key, child] of Object.entries(node)) {\n      yield* yulWalk(\n        compilationId,\n        sourceId,\n        child,\n        `${pointer}/${key}`,\n        base,\n        basePointer\n      ); //no parent ID for subnodes\n    }\n  }\n\n  yield* handleYulExit(\n    compilationId,\n    sourceId,\n    node,\n    pointer,\n    base,\n    basePointer,\n    parentId\n  );\n}\n\nfunction* handleYulExit(\n  compilationId,\n  sourceId,\n  node,\n  pointer,\n  base,\n  basePointer,\n  _parentId = undefined\n) {\n  debug(\"exiting %d %s\", sourceId, pointer);\n\n  // no-op right now\n}\n\nfunction* handleYulEnter(\n  compilationId,\n  sourceId,\n  node,\n  pointer,\n  base,\n  basePointer,\n  parentId = undefined\n) {\n  debug(\"entering %d %s\", sourceId, pointer);\n\n  if (!node) {\n    return;\n  }\n\n  if (node.src !== undefined) {\n    debug(\"scoping!\");\n    yield* data.yulScope(pointer, sourceId, compilationId, parentId);\n  }\n\n  if (node.nodeType === \"YulTypedName\") {\n    let scopePointer = findYulScopePointer(node, pointer, base, basePointer);\n    yield* data.yulDeclare(\n      node,\n      pointer,\n      scopePointer,\n      sourceId,\n      compilationId\n    );\n  }\n}\n\nfunction findYulScopePointer(node, pointer, base, basePointer) {\n  //walk upward until we find a YulBlock or YulFunctionDefinition,\n  //with a special case for YulForLoop\n  debug(\"pointer: %s\", pointer);\n  debug(\"basePointer: %s\", basePointer);\n  let relativePointer = pointer.slice(basePointer.length);\n  debug(\"relativePointer: %s\", relativePointer);\n  let relativeParentPointer = relativePointer.replace(/\\/[^/]*$/, \"\"); //chop off last element\n  let parentPointer = basePointer + relativeParentPointer; //make it absolute again\n  debug(\"parentPointer: %s\", parentPointer);\n  let parent = jsonpointer.get(base, relativeParentPointer);\n  //NOTE: if node === base, then we'll just get parent = node,\n  //but that's fine, since we necessarily have base.nodeType === \"YulBlock\"\n  //(and the real parent of base is certainly not a for loop!)\n  if (node.nodeType === \"YulBlock\") {\n    if (parent.nodeType === \"YulForLoop\") {\n      if (pointer === `${parentPointer}/pre`) {\n        //variables declared in the pre block of a for loop\n        //are visible across the entire for loop\n        return parentPointer;\n      } else {\n        return pointer;\n      }\n    } else {\n      return pointer;\n    }\n  } else if (node.nodeType === \"YulFunctionDefinition\") {\n    return pointer;\n  } else {\n    return findYulScopePointer(parent, parentPointer, base, basePointer);\n  }\n}\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:session:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport data from \"lib/data/reducers\";\nimport evm from \"lib/evm/reducers\";\nimport solidity from \"lib/solidity/reducers\";\nimport trace from \"lib/trace/reducers\";\nimport controller from \"lib/controller/reducers\";\nimport stacktrace from \"lib/stacktrace/reducers\";\n\nimport * as actions from \"./actions\";\n\nfunction ready(state = false, action) {\n  switch (action.type) {\n    case actions.READY:\n      debug(\"readying\");\n      return true;\n\n    case actions.WAIT:\n      return false;\n\n    default:\n      return state;\n  }\n}\n\nfunction lastLoadingError(state = null, action) {\n  switch (action.type) {\n    case actions.ERROR:\n      debug(\"error: %o\", action.error);\n      return action.error;\n\n    case actions.WAIT:\n      return null;\n\n    default:\n      return state;\n  }\n}\n\nfunction transaction(state = {}, action) {\n  switch (action.type) {\n    case actions.SAVE_TRANSACTION:\n      return action.transaction;\n    case actions.UNLOAD_TRANSACTION:\n      return {};\n    default:\n      return state;\n  }\n}\n\nfunction receipt(state = {}, action) {\n  switch (action.type) {\n    case actions.SAVE_RECEIPT:\n      return action.receipt;\n    case actions.UNLOAD_TRANSACTION:\n      return {};\n    default:\n      return state;\n  }\n}\n\nfunction block(state = {}, action) {\n  switch (action.type) {\n    case actions.SAVE_BLOCK:\n      return action.block;\n    case actions.UNLOAD_TRANSACTION:\n      return {};\n    default:\n      return state;\n  }\n}\n\nfunction lightMode(state = false, action) {\n  switch (action.type) {\n    case actions.SET_LIGHT_MODE:\n      return true;\n    case actions.SET_FULL_MODE:\n      return false;\n    default:\n      return state;\n  }\n}\n\nconst session = combineReducers({\n  ready,\n  lastLoadingError,\n  transaction,\n  receipt,\n  block,\n  lightMode\n});\n\nconst reduceState = combineReducers({\n  session,\n  data,\n  evm,\n  solidity,\n  stacktrace,\n  trace,\n  controller\n});\n\nexport default reduceState;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:data:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nimport * as Codec from \"@truffle/codec\";\nimport { makeAssignment, makePath } from \"lib/helpers\";\n\nconst DEFAULT_SCOPES = {\n  byCompilationId: {}\n};\n\nfunction scopes(state = DEFAULT_SCOPES, action) {\n  let scope;\n  let newState;\n  let variables;\n\n  switch (action.type) {\n    case actions.SCOPE: {\n      const { compilationId, id, sourceId, parentId, pointer } = action;\n      const astRef = id !== undefined ? id : makePath(sourceId, pointer);\n      //astRef is used throughout the data saga.\n      //it identifies an AST node within a given compilation either by:\n      //1. its ast ID, if it has one, or\n      //2. a combination of its source index and its JSON pointer if not\n\n      newState = {\n        byCompilationId: {\n          ...state.byCompilationId,\n          [compilationId]: {\n            ...state.byCompilationId[compilationId] //just setting this up to avoid errors later\n          }\n        }\n      };\n\n      //apologies for this multi-stage setup, but JS is like that...\n\n      newState.byCompilationId[compilationId] = {\n        ...newState.byCompilationId[compilationId],\n        byAstRef: {\n          ...newState.byCompilationId[compilationId].byAstRef\n        }\n      };\n\n      scope = newState.byCompilationId[compilationId].byAstRef[astRef];\n\n      newState.byCompilationId[compilationId].byAstRef[astRef] = {\n        ...scope,\n        id,\n        sourceId,\n        parentId, //may be null or undefined\n        pointer,\n        compilationId\n      };\n\n      return newState;\n    }\n\n    case actions.DECLARE: {\n      let { compilationId, name, astRef, scopeAstRef } = action;\n\n      //note: we can assume the compilation already exists!\n      scope = state.byCompilationId[compilationId].byAstRef[scopeAstRef] || {};\n      variables = scope.variables || [];\n\n      return {\n        byCompilationId: {\n          ...state.byCompilationId,\n          [compilationId]: {\n            ...state.byCompilationId[compilationId],\n            byAstRef: {\n              ...state.byCompilationId[compilationId].byAstRef,\n\n              [scopeAstRef]: {\n                ...scope,\n\n                variables: [\n                  ...variables,\n\n                  {\n                    name,\n                    astRef,\n                    compilationId\n                  }\n                ]\n              }\n            }\n          }\n        }\n      };\n    }\n\n    default:\n      return state;\n  }\n}\n\n//a note on the following reducer: solidity assigns a unique AST ID to every\n//AST node among all the files being compiled together.  thus, it is, for now,\n//safe to identify user-defined types solely by their AST ID.  In the future,\n//once we eventually support having some files compiled separately from others,\n//this will become a bug you'll have to fix, and you'll have to fix it in the\n//decoder, too.  Sorry, future me! (or whoever's stuck doing this)\n\nfunction userDefinedTypes(state = [], action) {\n  switch (action.type) {\n    case actions.DEFINE_TYPE:\n      return [\n        ...state,\n        { id: action.node.id, compilationId: action.compilationId }\n      ];\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_ALLOCATIONS = {\n  storage: {},\n  memory: {},\n  abi: {},\n  state: {}\n};\n\nfunction allocations(state = DEFAULT_ALLOCATIONS, action) {\n  if (action.type === actions.ALLOCATE) {\n    return {\n      storage: action.storage,\n      memory: action.memory,\n      abi: action.abi,\n      calldata: action.calldata,\n      state: action.state\n    };\n  } else {\n    return state; //not to be confused with action.state!\n  }\n}\n\nconst info = combineReducers({\n  scopes,\n  userDefinedTypes,\n  allocations\n});\n\nconst GLOBAL_ASSIGNMENTS = [\n  [{ builtin: \"msg\" }, { location: \"special\", special: \"msg\" }],\n  [{ builtin: \"tx\" }, { location: \"special\", special: \"tx\" }],\n  [{ builtin: \"block\" }, { location: \"special\", special: \"block\" }],\n  [{ builtin: \"this\" }, { location: \"special\", special: \"this\" }],\n  [{ builtin: \"now\" }, { location: \"special\", special: \"timestamp\" }] //we don't have an alias \"now\"\n].map(([idObj, ref]) => makeAssignment(idObj, ref));\n\nconst DEFAULT_ASSIGNMENTS = {\n  byId: Object.assign(\n    {}, //we start out with all globals assigned\n    ...GLOBAL_ASSIGNMENTS.map(assignment => ({ [assignment.id]: assignment }))\n  ),\n  byCompilationId: {}, //no regular variables assigned at start\n  byBuiltin: Object.assign(\n    {}, //again, all globals start assigned\n    ...GLOBAL_ASSIGNMENTS.map(assignment => ({\n      [assignment.builtin]: [assignment.id] //yes, that's a 1-element array\n    }))\n  )\n};\n\nfunction assignments(state = DEFAULT_ASSIGNMENTS, action) {\n  switch (action.type) {\n    case actions.ASSIGN:\n    case actions.MAP_PATH_AND_ASSIGN:\n      debug(\"action.type %O\", action.type);\n      debug(\"action.assignments %O\", action.assignments);\n      return Object.values(action.assignments).reduce((acc, assignment) => {\n        let { id, astRef, compilationId } = assignment;\n        //we assume for now that only ordinary variables will be assigned this\n        //way, and not globals; globals are handled in DEFAULT_ASSIGNMENTS\n        return {\n          ...acc,\n          byId: {\n            ...acc.byId,\n            [id]: assignment\n          },\n          byCompilationId: {\n            ...acc.byCompilationId,\n            [compilationId]: {\n              ...acc.byCompilationId[compilationId],\n              byAstRef: {\n                ...(acc.byCompilationId[compilationId] || {}).byAstRef,\n                [astRef]: [\n                  ...new Set([\n                    ...(((acc.byCompilationId[compilationId] || {}).byAstRef ||\n                      {})[astRef] || []),\n                    id\n                  ])\n                ]\n              }\n            }\n          }\n        };\n      }, state);\n\n    case actions.RESET:\n      return DEFAULT_ASSIGNMENTS;\n\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_PATHS = {\n  byAddress: {}\n};\n\n//WARNING: do *not* rely on mappedPaths to keep track of paths that do not\n//involve mapping keys!  Yes, many will get mapped, but there is no guarantee.\n//Only when mapping keys are involved does it necessarily work reliably --\n//which is fine, as that's all we need it for.\nfunction mappedPaths(state = DEFAULT_PATHS, action) {\n  switch (action.type) {\n    case actions.MAP_PATH_AND_ASSIGN:\n      let { address, slot, typeIdentifier, parentType } = action;\n      //how this case works: first, we find the spot in our table (based on\n      //address, type identifier, and slot address) where the new entry should\n      //be added; if needed we set up all the objects needed along the way.  If\n      //there's already something there, we do nothing.  If there's nothing\n      //there, we record our given slot in that spot in that table -- however,\n      //we alter it in one key way.  Before entry, we check if the slot's\n      //*parent* has a spot in the table, based on address (same for both child\n      //and parent), parentType, and the parent's slot address (which can be\n      //found as the slotAddress of the slot's path object, if it exists -- if\n      //it doesn't then we conclude that no the parent does not have a spot in\n      //the table).  If the parent has a slot in the table already, then we\n      //alter the child slot by replacing its path with the parent slot.  This\n      //will keep the slotAddress the same, but since the versions kept in the\n      //table here are supposed to preserve path information, we'll be\n      //replacing a fairly bare-bones Slot object with one with a full path.\n\n      //we do NOT want to distinguish between types with and without \"_ptr\" on\n      //the end here! (or _slice)\n      debug(\"typeIdentifier %s\", typeIdentifier);\n      typeIdentifier = Codec.Ast.Utils.regularizeTypeIdentifier(typeIdentifier);\n      parentType = Codec.Ast.Utils.regularizeTypeIdentifier(parentType);\n\n      debug(\"slot %o\", slot);\n      let hexSlotAddress = Codec.Conversion.toHexString(\n        Codec.Storage.Utils.slotAddress(slot),\n        Codec.Evm.Utils.WORD_SIZE\n      );\n      let parentAddress = slot.path\n        ? Codec.Conversion.toHexString(\n            Codec.Storage.Utils.slotAddress(slot.path),\n            Codec.Evm.Utils.WORD_SIZE\n          )\n        : undefined;\n\n      //this is going to be messy and procedural, sorry.  but let's start with\n      //the easy stuff: create the new address if needed, clone if not\n      let newState = {\n        ...state,\n        byAddress: {\n          ...state.byAddress,\n          [address]: {\n            byType: {\n              ...(state.byAddress[address] || { byType: {} }).byType\n            }\n          }\n        }\n      };\n\n      //now, let's add in the new type, if needed\n      newState.byAddress[address].byType = {\n        ...newState.byAddress[address].byType,\n        [typeIdentifier]: {\n          bySlotAddress: {\n            ...(\n              newState.byAddress[address].byType[typeIdentifier] || {\n                bySlotAddress: {}\n              }\n            ).bySlotAddress\n          }\n        }\n      };\n\n      let oldSlot =\n        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[\n          hexSlotAddress\n        ];\n      //yes, this looks strange, but we haven't changed it yet except to\n      //clone or create empty (and we don't want undefined!)\n      //now: is there something already there or no?  if no, we must add\n      if (oldSlot === undefined) {\n        let newSlot;\n        debug(\"parentAddress %o\", parentAddress);\n        if (\n          parentAddress !== undefined &&\n          newState.byAddress[address].byType[parentType] &&\n          newState.byAddress[address].byType[parentType].bySlotAddress[\n            parentAddress\n          ]\n        ) {\n          //if the parent is already present, use that instead of the given\n          //parent!\n          newSlot = {\n            ...slot,\n            path:\n              newState.byAddress[address].byType[parentType].bySlotAddress[\n                parentAddress\n              ]\n          };\n        } else {\n          newSlot = slot;\n        }\n        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[\n          hexSlotAddress\n        ] = newSlot;\n      }\n      //if there's already something there, we don't need to do anything\n\n      return newState;\n\n    case actions.RESET:\n      return DEFAULT_PATHS;\n\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  assignments,\n  mappedPaths\n});\n\nconst reducer = combineReducers({\n  info,\n  proc\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:evm:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\nimport * as Codec from \"@truffle/codec\";\n\nimport BN from \"bn.js\";\n\nconst DEFAULT_CONTEXTS = {\n  byContext: {}\n};\n\nfunction contexts(state = DEFAULT_CONTEXTS, action) {\n  switch (action.type) {\n    /*\n     * Adding a new context\n     */\n    case actions.ADD_CONTEXT:\n      const {\n        context,\n        contractName,\n        binary,\n        sourceMap,\n        primarySource,\n        immutableReferences,\n        compiler,\n        compilationId,\n        abi,\n        contractId,\n        contractKind,\n        isConstructor,\n        externalSolidity\n      } = action;\n      debug(\"action %O\", action);\n\n      return {\n        ...state,\n        byContext: {\n          ...state.byContext,\n          [context]: {\n            context,\n            contractName,\n            context,\n            binary,\n            sourceMap,\n            primarySource,\n            immutableReferences,\n            compiler,\n            compilationId,\n            abi,\n            contractId,\n            contractKind,\n            isConstructor,\n            externalSolidity,\n            payable: Codec.AbiData.Utils.abiHasPayableFallback(abi)\n          }\n        }\n      };\n\n    /*\n     * Default case\n     */\n    default:\n      return state;\n  }\n}\n\nconst info = combineReducers({\n  contexts\n});\n\nconst DEFAULT_TX = {\n  gasprice: new BN(0),\n  origin: Codec.Evm.Utils.ZERO_ADDRESS\n};\n\nfunction tx(state = DEFAULT_TX, action) {\n  switch (action.type) {\n    case actions.SAVE_GLOBALS:\n      let { gasprice, origin } = action;\n      return { gasprice, origin };\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_TX;\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_BLOCK = {\n  coinbase: Codec.Evm.Utils.ZERO_ADDRESS,\n  difficulty: new BN(0),\n  gaslimit: new BN(0),\n  number: new BN(0),\n  timestamp: new BN(0)\n};\n\nfunction block(state = DEFAULT_BLOCK, action) {\n  switch (action.type) {\n    case actions.SAVE_GLOBALS:\n      return action.block;\n    case actions.UNLOAD_TRANSACTION:\n      return DEFAULT_BLOCK;\n    default:\n      return state;\n  }\n}\n\nconst globals = combineReducers({\n  tx,\n  block\n});\n\nfunction status(state = null, action) {\n  switch (action.type) {\n    case actions.SAVE_STATUS:\n      return action.status;\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction initialCall(state = null, action) {\n  switch (action.type) {\n    case actions.CALL:\n    case actions.CREATE:\n      //we only want to save the initial call, so return\n      //the current state if it's not null\n      if (state !== null) {\n        return state;\n      } else {\n        //we'll just store the action itself in the state\n        return action;\n      }\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nconst transaction = combineReducers({\n  globals,\n  status,\n  initialCall\n});\n\nfunction callstack(state = [], action) {\n  switch (action.type) {\n    case actions.CALL: {\n      const { address, data, storageAddress, sender, value } = action;\n      return state.concat([{ address, data, storageAddress, sender, value }]);\n    }\n\n    case actions.CREATE: {\n      const { binary, storageAddress, sender, value } = action;\n      return state.concat(\n        [{ binary, data: \"0x\", storageAddress, sender, value }]\n        //the empty data field is to make msg.data and msg.sig come out right\n      );\n    }\n\n    case actions.RETURN_CALL:\n    case actions.RETURN_CREATE:\n    case actions.FAIL:\n      //pop the stack... unless (HACK) that would leave it empty (this will\n      //only happen at the end when we want to keep the last one around)\n      return state.length > 1 ? state.slice(0, -1) : state;\n\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n\n    default:\n      return state;\n  }\n}\n\nconst DEFAULT_CODEX = [\n  {\n    accounts: {}\n    //will be more here in the future!\n  }\n];\n\nfunction codex(state = DEFAULT_CODEX, action) {\n  let newState, topCodex;\n\n  const updateFrameStorage = (frame, address, slot, value) => ({\n    ...frame,\n    accounts: {\n      ...frame.accounts,\n      [address]: {\n        code: \"0x\", //this will get overridden if it already exists!\n        context: null, //similarly!\n        ...frame.accounts[address], //may be undefined\n        storage: {\n          ...(frame.accounts[address] || {}).storage, //may be undefined\n          [slot]: value\n        }\n      }\n    }\n  });\n  //(note that {...undefined} just expands to {} and is OK)\n\n  const updateFrameCode = (frame, address, code, context) => {\n    let existingPage = frame.accounts[address] || { storage: {} };\n    return {\n      ...frame,\n      accounts: {\n        ...frame.accounts,\n        [address]: {\n          ...existingPage,\n          code: code,\n          context: context\n        }\n      }\n    };\n  };\n\n  //later: will add \"force\" parameter\n  const safePop = array => (array.length > 2 ? array.slice(0, -1) : array);\n\n  //later: will add \"force\" parameter\n  const safeSave = array =>\n    array.length > 2\n      ? array.slice(0, -2).concat([array[array.length - 1]])\n      : array;\n\n  switch (action.type) {\n    case actions.CALL:\n      debug(\"call action\");\n      debug(\"codex: %O\", state);\n      //on a call, we can just make a new stackframe by cloning the top\n      //stackframe; there should already be an account for the address we're\n      //calling into, so we don't need to make one\n      return [...state, state[state.length - 1]];\n\n    case actions.CREATE:\n      debug(\"create action\");\n      //on a create, make a new stackframe, then add a new pages to the\n      //codex if necessary; don't add a zero page though (or pages that already\n      //exist)\n\n      //first, add a new stackframe by cloning the top one\n      newState = [...state, state[state.length - 1]];\n      topCodex = newState[newState.length - 1];\n      //now, do we need to add a new address to this stackframe?\n      if (\n        topCodex.accounts[action.storageAddress] !== undefined ||\n        action.storageAddress === Codec.Evm.Utils.ZERO_ADDRESS\n      ) {\n        //if we don't\n        return newState;\n      }\n      //if we do\n      newState[newState.length - 1] = {\n        ...topCodex,\n        accounts: {\n          ...topCodex.accounts,\n          [action.storageAddress]: {\n            storage: {},\n            code: \"0x\",\n            context: null\n            //there will be more here in the future!\n          }\n        }\n      };\n      return newState;\n\n    case actions.STORE: {\n      debug(\"store action\");\n      //on a store, the relevant page should already exist, so we can just\n      //add or update the needed slot\n      const { address, slot, value } = action;\n      if (address === Codec.Evm.Utils.ZERO_ADDRESS) {\n        //as always, we do not maintain a zero page\n        return state;\n      }\n      newState = state.slice(); //clone the state\n      topCodex = newState[newState.length - 1];\n      newState[newState.length - 1] = updateFrameStorage(\n        topCodex,\n        address,\n        slot,\n        value\n      );\n      return newState;\n    }\n\n    case actions.LOAD: {\n      debug(\"load action\");\n      //loads are a little more complicated -- usually we do nothing, but if\n      //it's an external load (there was nothing already there), then we want\n      //to update *every* stackframe\n      const { address, slot, value } = action;\n      if (address === Codec.Evm.Utils.ZERO_ADDRESS) {\n        //as always, we do not maintain a zero page\n        return state;\n      }\n      topCodex = state[state.length - 1];\n      if (topCodex.accounts[address].storage[slot] !== undefined) {\n        //if we already have a value in the *top* stackframe, update *no*\n        //stackframes; don't update the top (no need, it's just a load, not a\n        //store), don't update the rest (that would be wrong, you might be\n        //loading a value that will get reverted later)\n        return state;\n      } else {\n        //if we *don't* already have a value in the top stackframe, that means\n        //we're loading a value from a previous transaction!  That's not a\n        //value that will get reverted if this call fails, so update *every*\n        //stackframe\n        return state.map(frame =>\n          updateFrameStorage(frame, address, slot, value)\n        );\n      }\n    }\n\n    case actions.RETURN_CALL:\n      debug(\"return from call\");\n      //we want to pop the top while making the new top a copy of the old top;\n      //that is to say, we want to drop just the element *second* from the top\n      //NOTE: we don't ever go down to 1 element!\n      return safeSave(state);\n\n    case actions.RETURN_CREATE: {\n      debug(\"return from create\");\n      //we're going to do the same things in this case as in the usual return\n      //case, but first we need to record the code that was returned\n      const { address, code, context } = action;\n      newState = state.slice(); //clone the state\n      //NOTE: since this is only for RETURN_CREATE, and not FAIL, we shouldn't\n      //have to worry about accidentally getting a zero address here\n      newState[newState.length - 1] = updateFrameCode(\n        newState[newState.length - 1],\n        address,\n        code,\n        context\n      );\n      debug(\"newState: %O\", newState);\n      return safeSave(newState);\n    }\n\n    case actions.FAIL:\n      debug(\"fail action\");\n      //pop the stack\n      //NOTE: we don't ever go down to 1 element!\n      return safePop(state);\n\n    case actions.RESET:\n      debug(\"reset action\");\n      return [state[0]]; //leave the -1 frame on the stack\n\n    case actions.UNLOAD_TRANSACTION:\n      debug(\"unload action\");\n      return DEFAULT_CODEX;\n\n    case actions.ADD_INSTANCE: {\n      //add the instance to every frame\n      //(this is a little HACKy, but it *should* be fine)\n      debug(\"adding instance\");\n      const { address, binary, context } = action;\n      return state.map(frame =>\n        updateFrameCode(frame, address, binary, context)\n      );\n    }\n\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  callstack,\n  codex\n});\n\nconst reducer = combineReducers({\n  info,\n  transaction,\n  proc\n});\n\nexport default reducer;\n","import { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nconst DEFAULT_SOURCES = {\n  byCompilationId: {} //by compilation, then in an array\n};\n\nfunction sources(state = DEFAULT_SOURCES, action) {\n  switch (action.type) {\n    /*\n     * Adding new sources\n     */\n    case actions.ADD_SOURCES:\n      //NOTE: this code assumes that we are only ever adding compilations\n      //wholesale, and never adding to existing ones!\n      return {\n        byCompilationId: {\n          ...state.byCompilationId,\n          ...Object.assign(\n            {},\n            ...Object.entries(action.compilations).map(([id, compilation]) => ({\n              [id]: {\n                byId: compilation\n              }\n            }))\n          )\n        }\n      };\n    /*\n     * Default case\n     */\n    default:\n      return state;\n  }\n}\n\nconst info = combineReducers({\n  sources\n});\n\nfunction functionDepthStack(state = [], action) {\n  switch (action.type) {\n    case actions.JUMP:\n      let newState = state.slice(); //clone the state\n      const delta = spelunk(action.jumpDirection);\n      let top = newState[newState.length - 1];\n      let belowTop = newState.length > 1 ? newState[newState.length - 2] : -1;\n      newState[newState.length - 1] = Math.max(top + delta, belowTop + 1);\n      return newState;\n\n    case actions.RESET:\n      return [0];\n\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n\n    case actions.EXTERNAL_CALL:\n      if (state.length === 0) {\n        return [0];\n      }\n      return [...state, state[state.length - 1] + 1];\n\n    case actions.EXTERNAL_RETURN:\n      //just pop the stack! unless, HACK, that would leave it empty\n      return state.length > 1 ? state.slice(0, -1) : state;\n\n    default:\n      return state;\n  }\n}\n\nfunction nextFrameIsPhantom(state = null, action) {\n  switch (action.type) {\n    case actions.CLEAR_PHANTOM_GUARD:\n      return false;\n    case actions.EXTERNAL_RETURN:\n      return false;\n    case actions.EXTERNAL_CALL:\n      return action.guard;\n    case actions.RESET:\n      return action.guard;\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction spelunk(jump) {\n  if (jump === \"i\") {\n    return 1;\n  } else if (jump === \"o\") {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nconst proc = combineReducers({\n  functionDepthStack,\n  nextFrameIsPhantom\n});\n\nconst reducer = combineReducers({\n  info,\n  proc\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:trace:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nfunction index(state = 0, action) {\n  switch (action.type) {\n    case actions.TOCK:\n      return state + 1;\n\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return 0;\n\n    default:\n      return state;\n  }\n}\n\nfunction finished(state = false, action) {\n  switch (action.type) {\n    case actions.END_OF_TRACE:\n      return true;\n\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return false;\n\n    default:\n      return state;\n  }\n}\n\nfunction steps(state = null, action) {\n  switch (action.type) {\n    case actions.SAVE_STEPS:\n      return action.steps;\n    case actions.UNLOAD_TRANSACTION:\n      debug(\"unloading\");\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction submoduleCount(state = 0, action) {\n  switch (action.type) {\n    case actions.SET_SUBMODULE_COUNT:\n      return action.count;\n    default:\n      return state;\n  }\n}\n\nconst transaction = combineReducers({\n  steps\n});\n\nconst proc = combineReducers({\n  index,\n  finished\n});\n\nconst application = combineReducers({\n  submoduleCount\n});\n\nconst reducer = combineReducers({\n  transaction,\n  proc,\n  application\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:controller:reducers\");\n\nimport { combineReducers } from \"redux\";\n\nimport * as actions from \"./actions\";\n\nfunction breakpoints(state = [], action) {\n  switch (action.type) {\n    case actions.ADD_BREAKPOINT:\n      //check for any existing identical breakpoints to avoid redundancy\n      if (\n        state.filter(\n          breakpoint =>\n            breakpoint.compilationId === action.breakpoint.compilationId &&\n            breakpoint.sourceId === action.breakpoint.sourceId &&\n            breakpoint.line === action.breakpoint.line &&\n            breakpoint.node === action.breakpoint.node //may be undefined\n        ).length > 0\n      ) {\n        //if it's already there, do nothing\n        return state;\n      } else {\n        //otherwise add it\n        return state.concat([action.breakpoint]);\n      }\n      break;\n\n    case actions.REMOVE_BREAKPOINT:\n      return state.filter(\n        breakpoint =>\n          breakpoint.compilationId !== action.breakpoint.compilationId ||\n          breakpoint.sourceId !== action.breakpoint.sourceId ||\n          breakpoint.line !== action.breakpoint.line ||\n          breakpoint.node !== action.breakpoint.node //may be undefined\n      );\n      break;\n\n    case actions.REMOVE_ALL_BREAKPOINTS:\n      return [];\n\n    default:\n      return state;\n  }\n}\n\nfunction isStepping(state = false, action) {\n  switch (action.type) {\n    case actions.START_STEPPING:\n      debug(\"got step start action\");\n      return true;\n    case actions.DONE_STEPPING:\n      debug(\"got step stop action\");\n      return false;\n    default:\n      return state;\n  }\n}\n\nconst reducer = combineReducers({\n  breakpoints,\n  isStepping\n});\n\nexport default reducer;\n","import debugModule from \"debug\";\nconst debug = debugModule(\"debugger:stacktrace:reducers\");\n\nimport { combineReducers } from \"redux\";\nimport { popNWhere } from \"lib/helpers\";\n\nimport * as actions from \"./actions\";\n\nfunction callstack(state = [], action) {\n  let newFrame;\n  switch (action.type) {\n    case actions.JUMP_IN:\n      let { location, functionNode, contractNode } = action;\n      newFrame = {\n        type: \"internal\",\n        calledFromLocation: location,\n        address: state[state.length - 1].address,\n        functionName:\n          functionNode &&\n          (functionNode.nodeType === \"FunctionDefinition\" ||\n            functionNode.nodeType === \"YulFunctionDefinition\")\n            ? functionNode.name\n            : undefined,\n        contractName:\n          contractNode && contractNode.nodeType === \"ContractDefinition\"\n            ? contractNode.name\n            : undefined,\n        //note we don't currently account for getters because currently\n        //we can't; fallback, receive, constructors, & modifiers also remain\n        //unaccounted for at present\n        //(none of these things have associated jump-in markings!)\n      };\n      return [...state, newFrame];\n    case actions.JUMP_OUT:\n      let top = state[state.length - 1];\n      if (top && top.type === \"internal\") {\n        return state.slice(0, -1);\n      } else {\n        return state;\n      }\n    case actions.EXTERNAL_CALL:\n      newFrame = {\n        type: \"external\",\n        address: action.address,\n        calledFromLocation: action.location,\n        functionName: undefined,\n        contractName: action.context.contractName,\n      };\n      return [...state, newFrame];\n    case actions.EXECUTE_RETURN:\n      return popNWhere(\n        state,\n        action.counter,\n        (frame) => frame.type === \"external\"\n      );\n    case actions.RESET:\n      return [state[0]];\n    case actions.UNLOAD_TRANSACTION:\n      return [];\n    default:\n      //note that we don't do anything on EXTERNAL_RETURN!\n      //the callstack only changes on EXECUTE_RETURN!\n      return state;\n  }\n}\n\nfunction returnCounter(state = 0, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      return state + 1;\n    case actions.EXECUTE_RETURN:\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return 0;\n    default:\n      return state;\n  }\n}\n\nfunction lastPosition(state = null, action) {\n  switch (action.type) {\n    case actions.JUMP_IN:\n    case actions.JUMP_OUT:\n    case actions.ETERNAL_CALL:\n    case actions.EXTERNAL_RETURN:\n    case actions.UPDATE_POSITION:\n    case actions.EXECUTE_RETURN:\n      const { location } = action;\n      if (location.source.id === undefined) {\n        //don't update for unmapped!\n        return state;\n      }\n      return location;\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction innerReturnPosition(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      //we want the innermost return, so don't update\n      //this if it's not presently null\n      return state || action.from;\n    case actions.EXECUTE_RETURN:\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nfunction innerReturnStatus(state = null, action) {\n  switch (action.type) {\n    case actions.EXTERNAL_RETURN:\n      //we want the innermost return, so don't update\n      //this if it's not presently null\n      return state === null ? action.status : state;\n    case actions.EXECUTE_RETURN:\n    case actions.RESET:\n    case actions.UNLOAD_TRANSACTION:\n      return null;\n    default:\n      return state;\n  }\n}\n\nconst proc = combineReducers({\n  callstack,\n  returnCounter,\n  lastPosition,\n  innerReturnPosition,\n  innerReturnStatus,\n});\n\nconst reducer = combineReducers({\n  proc,\n});\n\nexport default reducer;\n","module.exports = require(\"@truffle/compile-solidity/legacy/shims\");"],"sourceRoot":""}