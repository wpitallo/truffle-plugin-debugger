{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cleanBool = exports.countDecimalPlaces = exports.shiftBigDown = exports.shiftBigUp = exports.toBytes = exports.toHexString = exports.toBig = exports.toSignedBN = exports.toBN = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:conversion\");\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar big_js_1 = __importDefault(require(\"big.js\"));\n/**\n * @param bytes - undefined | string | number | BN | Uint8Array | Big\n * @return {BN}\n */\n\n\nfunction toBN(bytes) {\n  if (bytes === undefined) {\n    return undefined;\n  } else if (typeof bytes == \"string\") {\n    return new bn_js_1.default(bytes, 16);\n  } else if (typeof bytes == \"number\" || bn_js_1.default.isBN(bytes)) {\n    return new bn_js_1.default(bytes);\n  } else if (bytes instanceof big_js_1.default) {\n    return new bn_js_1.default(bytes.toFixed()); //warning, better hope input is integer!\n    //note: going through string may seem silly but it's actually not terrible here,\n    //since BN is binary-based and Big is decimal-based\n    //[toFixed is like toString except it guarantees scientific notation is not used]\n  } else if (typeof bytes.reduce === \"function\") {\n    return bytes.reduce(function (num, byte) {\n      return num.shln(8).addn(byte);\n    }, new bn_js_1.default(0));\n  }\n}\n\nexports.toBN = toBN;\n/**\n * @param bytes - Uint8Array\n * @return {BN}\n */\n\nfunction toSignedBN(bytes) {\n  if (bytes[0] < 0x80) {\n    // if first bit is 0\n    return toBN(bytes);\n  } else {\n    return toBN(bytes.map(function (b) {\n      return 0xff - b;\n    })).addn(1).neg();\n  }\n}\n\nexports.toSignedBN = toSignedBN;\n\nfunction toBig(value) {\n  //note: going through string may seem silly but it's actually not terrible here,\n  //since BN (& number) is binary-based and Big is decimal-based\n  return new big_js_1.default(value.toString());\n}\n\nexports.toBig = toBig;\n/**\n * @param bytes - Uint8Array | BN\n * @param padLength - number - minimum desired byte length (left-pad with zeroes)\n * @return {string}\n */\n\nfunction toHexString(bytes) {\n  var padLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  if (bn_js_1.default.isBN(bytes)) {\n    bytes = toBytes(bytes);\n  }\n\n  var pad = function pad(s) {\n    return \"\".concat(\"00\".slice(0, 2 - s.length)).concat(s);\n  }; //                                          0  1  2  3  4\n  //                                 0  1  2  3  4  5  6  7\n  // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )\n  // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )\n  //                                `--.---'\n  //                                     offset 3\n\n\n  if (bytes.length < padLength) {\n    var prior = bytes;\n    bytes = new Uint8Array(padLength);\n    bytes.set(prior, padLength - prior.length);\n  }\n\n  debug(\"bytes: %o\", bytes);\n  var string = bytes.reduce(function (str, byte) {\n    return \"\".concat(str).concat(pad(byte.toString(16)));\n  }, \"\");\n  return \"0x\".concat(string);\n}\n\nexports.toHexString = toHexString;\n\nfunction toBytes(data) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  //note that length is a minimum output length\n  //strings will be 0-padded on left\n  //numbers/BNs will be sign-padded on left\n  //NOTE: if a number/BN is passed in that is too big for the given length,\n  //you will get an error!\n  //(note that strings passed in should be hex strings; this is not for converting\n  //generic strings to hex)\n  if (typeof data === \"string\") {\n    var hex = data; //renaming for clarity\n\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.slice(2);\n    }\n\n    if (hex === \"\") {\n      //this special case is necessary because the match below will return null,\n      //not an empty array, when given an empty string\n      return new Uint8Array(0);\n    }\n\n    if (hex.length % 2 == 1) {\n      hex = \"0\".concat(hex);\n    }\n\n    var bytes = new Uint8Array(hex.match(/.{2}/g).map(function (byte) {\n      return parseInt(byte, 16);\n    }));\n\n    if (bytes.length < length) {\n      var prior = bytes;\n      bytes = new Uint8Array(length);\n      bytes.set(prior, length - prior.length);\n    }\n\n    return bytes;\n  } else {\n    // BN/Big/number case\n    if (typeof data === \"number\") {\n      data = new bn_js_1.default(data);\n    } else if (data instanceof big_js_1.default) {\n      //note: going through string may seem silly but it's actually not terrible here,\n      //since BN is binary-based and Big is decimal-based\n      data = new bn_js_1.default(data.toFixed()); //[toFixed is like toString except it guarantees scientific notation is not used]\n    } //note that the argument for toTwos is given in bits\n\n\n    return new Uint8Array(data.toTwos(length * 8).toArrayLike(Buffer, \"be\", length)); //big-endian\n  }\n}\n\nexports.toBytes = toBytes; //computes value * 10**decimalPlaces\n\nfunction shiftBigUp(value, decimalPlaces) {\n  var newValue = new big_js_1.default(value);\n  newValue.e += decimalPlaces;\n  return newValue;\n}\n\nexports.shiftBigUp = shiftBigUp; //computes value * 10**-decimalPlaces\n\nfunction shiftBigDown(value, decimalPlaces) {\n  var newValue = new big_js_1.default(value);\n  newValue.e -= decimalPlaces;\n  return newValue;\n}\n\nexports.shiftBigDown = shiftBigDown; //we don't need this yet, but we will eventually\n\nfunction countDecimalPlaces(value) {\n  return Math.max(0, value.c.length - value.e - 1);\n}\n\nexports.countDecimalPlaces = countDecimalPlaces; //converts out of range booleans to true; something of a HACK\n//NOTE: does NOT do this recursively inside structs, arrays, etc!\n//I mean, those aren't elementary and therefore aren't in the domain\n//anyway, but still\n\nfunction cleanBool(result) {\n  switch (result.kind) {\n    case \"value\":\n      return result;\n\n    case \"error\":\n      switch (result.error.kind) {\n        case \"BoolOutOfRangeError\":\n          //return true\n          return {\n            type: result.type,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          };\n\n        default:\n          return result;\n      }\n\n  }\n}\n\nexports.cleanBool = cleanBool;","map":{"version":3,"sources":["../../lib/conversion.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cleanBool = exports.countDecimalPlaces = exports.shiftBigDown = exports.shiftBigUp = exports.toBytes = exports.toHexString = exports.toBig = exports.toSignedBN = exports.toBN = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:conversion\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst big_js_1 = __importDefault(require(\"big.js\"));\n/**\n * @param bytes - undefined | string | number | BN | Uint8Array | Big\n * @return {BN}\n */\nfunction toBN(bytes) {\n    if (bytes === undefined) {\n        return undefined;\n    }\n    else if (typeof bytes == \"string\") {\n        return new bn_js_1.default(bytes, 16);\n    }\n    else if (typeof bytes == \"number\" || bn_js_1.default.isBN(bytes)) {\n        return new bn_js_1.default(bytes);\n    }\n    else if (bytes instanceof big_js_1.default) {\n        return new bn_js_1.default(bytes.toFixed()); //warning, better hope input is integer!\n        //note: going through string may seem silly but it's actually not terrible here,\n        //since BN is binary-based and Big is decimal-based\n        //[toFixed is like toString except it guarantees scientific notation is not used]\n    }\n    else if (typeof bytes.reduce === \"function\") {\n        return bytes.reduce((num, byte) => num.shln(8).addn(byte), new bn_js_1.default(0));\n    }\n}\nexports.toBN = toBN;\n/**\n * @param bytes - Uint8Array\n * @return {BN}\n */\nfunction toSignedBN(bytes) {\n    if (bytes[0] < 0x80) {\n        // if first bit is 0\n        return toBN(bytes);\n    }\n    else {\n        return toBN(bytes.map(b => 0xff - b))\n            .addn(1)\n            .neg();\n    }\n}\nexports.toSignedBN = toSignedBN;\nfunction toBig(value) {\n    //note: going through string may seem silly but it's actually not terrible here,\n    //since BN (& number) is binary-based and Big is decimal-based\n    return new big_js_1.default(value.toString());\n}\nexports.toBig = toBig;\n/**\n * @param bytes - Uint8Array | BN\n * @param padLength - number - minimum desired byte length (left-pad with zeroes)\n * @return {string}\n */\nfunction toHexString(bytes, padLength = 0) {\n    if (bn_js_1.default.isBN(bytes)) {\n        bytes = toBytes(bytes);\n    }\n    const pad = (s) => `${\"00\".slice(0, 2 - s.length)}${s}`;\n    //                                          0  1  2  3  4\n    //                                 0  1  2  3  4  5  6  7\n    // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )\n    // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )\n    //                                `--.---'\n    //                                     offset 3\n    if (bytes.length < padLength) {\n        let prior = bytes;\n        bytes = new Uint8Array(padLength);\n        bytes.set(prior, padLength - prior.length);\n    }\n    debug(\"bytes: %o\", bytes);\n    let string = bytes.reduce((str, byte) => `${str}${pad(byte.toString(16))}`, \"\");\n    return `0x${string}`;\n}\nexports.toHexString = toHexString;\nfunction toBytes(data, length = 0) {\n    //note that length is a minimum output length\n    //strings will be 0-padded on left\n    //numbers/BNs will be sign-padded on left\n    //NOTE: if a number/BN is passed in that is too big for the given length,\n    //you will get an error!\n    //(note that strings passed in should be hex strings; this is not for converting\n    //generic strings to hex)\n    if (typeof data === \"string\") {\n        let hex = data; //renaming for clarity\n        if (hex.startsWith(\"0x\")) {\n            hex = hex.slice(2);\n        }\n        if (hex === \"\") {\n            //this special case is necessary because the match below will return null,\n            //not an empty array, when given an empty string\n            return new Uint8Array(0);\n        }\n        if (hex.length % 2 == 1) {\n            hex = `0${hex}`;\n        }\n        let bytes = new Uint8Array(hex.match(/.{2}/g).map(byte => parseInt(byte, 16)));\n        if (bytes.length < length) {\n            let prior = bytes;\n            bytes = new Uint8Array(length);\n            bytes.set(prior, length - prior.length);\n        }\n        return bytes;\n    }\n    else {\n        // BN/Big/number case\n        if (typeof data === \"number\") {\n            data = new bn_js_1.default(data);\n        }\n        else if (data instanceof big_js_1.default) {\n            //note: going through string may seem silly but it's actually not terrible here,\n            //since BN is binary-based and Big is decimal-based\n            data = new bn_js_1.default(data.toFixed());\n            //[toFixed is like toString except it guarantees scientific notation is not used]\n        }\n        //note that the argument for toTwos is given in bits\n        return new Uint8Array(data.toTwos(length * 8).toArrayLike(Buffer, \"be\", length)); //big-endian\n    }\n}\nexports.toBytes = toBytes;\n//computes value * 10**decimalPlaces\nfunction shiftBigUp(value, decimalPlaces) {\n    let newValue = new big_js_1.default(value);\n    newValue.e += decimalPlaces;\n    return newValue;\n}\nexports.shiftBigUp = shiftBigUp;\n//computes value * 10**-decimalPlaces\nfunction shiftBigDown(value, decimalPlaces) {\n    let newValue = new big_js_1.default(value);\n    newValue.e -= decimalPlaces;\n    return newValue;\n}\nexports.shiftBigDown = shiftBigDown;\n//we don't need this yet, but we will eventually\nfunction countDecimalPlaces(value) {\n    return Math.max(0, value.c.length - value.e - 1);\n}\nexports.countDecimalPlaces = countDecimalPlaces;\n//converts out of range booleans to true; something of a HACK\n//NOTE: does NOT do this recursively inside structs, arrays, etc!\n//I mean, those aren't elementary and therefore aren't in the domain\n//anyway, but still\nfunction cleanBool(result) {\n    switch (result.kind) {\n        case \"value\":\n            return result;\n        case \"error\":\n            switch (result.error.kind) {\n                case \"BoolOutOfRangeError\":\n                    //return true\n                    return {\n                        type: result.type,\n                        kind: \"value\",\n                        value: {\n                            asBoolean: true\n                        }\n                    };\n                default:\n                    return result;\n            }\n    }\n}\nexports.cleanBool = cleanBool;\n//# sourceMappingURL=conversion.js.map"]},"metadata":{},"sourceType":"script"}