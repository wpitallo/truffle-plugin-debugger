{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar util = require('util');\n\nvar constants = require('./constants');\n\nvar MT = constants.MT;\nvar SIMPLE = constants.SIMPLE;\nvar SYMS = constants.SYMS;\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\n\nvar Simple = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value - the simple value's integer value\n   */\n  function Simple(value) {\n    _classCallCheck(this, Simple);\n\n    if (typeof value !== 'number') {\n      throw new Error('Invalid Simple type: ' + typeof value);\n    }\n\n    if (value < 0 || value > 255 || (value | 0) !== value) {\n      throw new Error('value must be a small positive integer: ' + value);\n    }\n\n    this.value = value;\n  }\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n\n\n  _createClass(Simple, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'simple(' + this.value + ')';\n    }\n    /**\n     * Debug string for simple value\n     *\n     * @returns {string} simple(value)\n     */\n\n  }, {\n    key: util.inspect.custom,\n    value: function value(depth, opts) {\n      return 'simple(' + this.value + ')';\n    }\n    /**\n     * Debug string for simple value (backward-compatibility version)\n     *\n     * @returns {string} simple(value)\n     */\n\n  }, {\n    key: \"inspect\",\n    value: function inspect(depth, opts) {\n      return 'simple(' + this.value + ')';\n    }\n    /**\n     * Push the simple value onto the CBOR stream\n     *\n     * @param {Object} gen The generator to push onto\n     */\n\n  }, {\n    key: \"encodeCBOR\",\n    value: function encodeCBOR(gen) {\n      return gen._pushInt(this.value, MT.SIMPLE_FLOAT);\n    }\n    /**\n     * Is the given object a Simple?\n     *\n     * @param {any} obj - object to test\n     * @returns {boolean} - is it Simple?\n     */\n\n  }], [{\n    key: \"isSimple\",\n    value: function isSimple(obj) {\n      return obj instanceof Simple;\n    }\n    /**\n     * Decode from the CBOR additional information into a JavaScript value.\n     * If the CBOR item has no parent, return a \"safe\" symbol instead of\n     * `null` or `undefined`, so that the value can be passed through a\n     * stream in object mode.\n     *\n     * @param {number} val - the CBOR additional info to convert\n     * @param {boolean} [has_parent=true] - Does the CBOR item have a parent?\n     * @param {boolean} [parent_indefinite=false] - Is the parent element\n     *   indefinitely encoded?\n     * @returns {(null|undefined|boolean|Symbol|Simple)} - the decoded value\n     */\n\n  }, {\n    key: \"decode\",\n    value: function decode(val) {\n      var has_parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var parent_indefinite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      switch (val) {\n        case SIMPLE.FALSE:\n          return false;\n\n        case SIMPLE.TRUE:\n          return true;\n\n        case SIMPLE.NULL:\n          if (has_parent) {\n            return null;\n          } else {\n            return SYMS.NULL;\n          }\n\n        case SIMPLE.UNDEFINED:\n          if (has_parent) {\n            return void 0;\n          } else {\n            return SYMS.UNDEFINED;\n          }\n\n        case -1:\n          if (!has_parent || !parent_indefinite) {\n            throw new Error('Invalid BREAK');\n          }\n\n          return SYMS.BREAK;\n\n        default:\n          return new Simple(val);\n      }\n    }\n  }]);\n\n  return Simple;\n}();\n\nmodule.exports = Simple;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/cbor/lib/simple.js"],"names":["util","require","constants","MT","SIMPLE","SYMS","Simple","value","Error","inspect","custom","depth","opts","gen","_pushInt","SIMPLE_FLOAT","obj","val","has_parent","parent_indefinite","FALSE","TRUE","NULL","UNDEFINED","BREAK","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAME,EAAE,GAAGD,SAAS,CAACC,EAArB;AACA,IAAMC,MAAM,GAAGF,SAAS,CAACE,MAAzB;AACA,IAAMC,IAAI,GAAGH,SAAS,CAACG,IAAvB;AAEA;AACA;AACA;;IACMC,M;AACJ;AACF;AACA;AACA;AACA;AACE,kBAAYC,KAAZ,EAAmB;AAAA;;AACjB,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,YAAM,IAAIC,KAAJ,CAAU,0BAA2B,OAAOD,KAA5C,CAAN;AACD;;AACD,QAAKA,KAAK,GAAG,CAAT,IAAgBA,KAAK,GAAG,GAAxB,IAAiC,CAACA,KAAK,GAAC,CAAP,MAAcA,KAAnD,EAA2D;AACzD,YAAM,IAAIC,KAAJ,CAAU,6CAA6CD,KAAvD,CAAN;AACD;;AACD,SAAKA,KAAL,GAAaA,KAAb;AACD;AAED;AACF;AACA;AACA;AACA;;;;;WACE,oBAAW;AACT,aAAO,YAAY,KAAKA,KAAjB,GAAyB,GAAhC;AACD;AAED;AACF;AACA;AACA;AACA;;;SACGP,IAAI,CAACS,OAAL,CAAaC,M;WAAd,eAAsBC,KAAtB,EAA6BC,IAA7B,EAAmC;AACjC,aAAO,YAAY,KAAKL,KAAjB,GAAyB,GAAhC;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,iBAAQI,KAAR,EAAeC,IAAf,EAAqB;AACnB,aAAO,YAAY,KAAKL,KAAjB,GAAyB,GAAhC;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,oBAAWM,GAAX,EAAgB;AACd,aAAOA,GAAG,CAACC,QAAJ,CAAa,KAAKP,KAAlB,EAAyBJ,EAAE,CAACY,YAA5B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,kBAAgBC,GAAhB,EAAqB;AACnB,aAAOA,GAAG,YAAYV,MAAtB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,gBAAcW,GAAd,EAA6D;AAAA,UAA1CC,UAA0C,uEAA/B,IAA+B;AAAA,UAAzBC,iBAAyB,uEAAP,KAAO;;AAC3D,cAAQF,GAAR;AACE,aAAKb,MAAM,CAACgB,KAAZ;AACE,iBAAO,KAAP;;AACF,aAAKhB,MAAM,CAACiB,IAAZ;AACE,iBAAO,IAAP;;AACF,aAAKjB,MAAM,CAACkB,IAAZ;AACE,cAAIJ,UAAJ,EAAgB;AACd,mBAAO,IAAP;AACD,WAFD,MAEO;AACL,mBAAOb,IAAI,CAACiB,IAAZ;AACD;;AACH,aAAKlB,MAAM,CAACmB,SAAZ;AACE,cAAIL,UAAJ,EAAgB;AACd,mBAAO,KAAK,CAAZ;AACD,WAFD,MAEO;AACL,mBAAOb,IAAI,CAACkB,SAAZ;AACD;;AACH,aAAK,CAAC,CAAN;AACE,cAAI,CAACL,UAAD,IAAe,CAACC,iBAApB,EAAuC;AACrC,kBAAM,IAAIX,KAAJ,CAAU,eAAV,CAAN;AACD;;AACD,iBAAOH,IAAI,CAACmB,KAAZ;;AACF;AACE,iBAAO,IAAIlB,MAAJ,CAAWW,GAAX,CAAP;AAvBJ;AAyBD;;;;;;AAGHQ,MAAM,CAACC,OAAP,GAAiBpB,MAAjB","sourcesContent":["'use strict'\n\nconst util = require('util')\nconst constants = require('./constants')\nconst MT = constants.MT\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value - the simple value's integer value\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error('Invalid Simple type: ' + (typeof value))\n    }\n    if ((value < 0) || (value > 255) || ((value|0) !== value)) {\n      throw new Error('value must be a small positive integer: ' + value)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  toString() {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  [util.inspect.custom](depth, opts) {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Debug string for simple value (backward-compatibility version)\n   *\n   * @returns {string} simple(value)\n   */\n  inspect(depth, opts) {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj - object to test\n   * @returns {boolean} - is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val - the CBOR additional info to convert\n   * @param {boolean} [has_parent=true] - Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] - Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|Symbol|Simple)} - the decoded value\n   */\n  static decode(val, has_parent=true, parent_indefinite=false) {\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null\n        } else {\n          return SYMS.NULL\n        }\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return void 0\n        } else {\n          return SYMS.UNDEFINED\n        }\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n"]},"metadata":{},"sourceType":"script"}