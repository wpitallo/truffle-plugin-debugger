{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeBasic),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeContract),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeContractAndContext),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(decodeExternalFunction);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPaddingLeft = exports.decodeInternalFunction = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:basic:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Contexts = __importStar(require(\"../../contexts\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar errors_1 = require(\"../../errors\");\n\nvar allocate_1 = require(\"../allocate\");\n\nfunction decodeBasic(dataType, pointer, info) {\n  var options,\n      state,\n      strict,\n      paddingMode,\n      bytes,\n      rawBytes,\n      error,\n      numeric,\n      _error,\n      _error2,\n      _error3,\n      _error4,\n      _error5,\n      fullType,\n      contractValueInfo,\n      coercedDataType,\n      _error6,\n      _error7,\n      address,\n      selector,\n      deployedPc,\n      constructorPc,\n      _numeric,\n      _fullType,\n      _error8,\n      numOptions,\n      numBytes,\n      paddingType,\n      _error9,\n      name,\n      _error10,\n      _error11,\n      asBN,\n      rawAsBN,\n      asBig,\n      rawAsBig,\n      _error12,\n      _asBN,\n      _rawAsBN,\n      _asBig,\n      _rawAsBig,\n      _args = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeBasic$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n          state = info.state;\n          strict = options.strictAbiMode; //if this is undefined it'll still be falsy so it's OK\n\n          paddingMode = options.paddingMode || \"default\";\n          _context.prev = 4;\n          return _context.delegateYield(read_1.default(pointer, state), \"t0\", 6);\n\n        case 6:\n          bytes = _context.t0;\n          _context.next = 15;\n          break;\n\n        case 9:\n          _context.prev = 9;\n          _context.t1 = _context[\"catch\"](4);\n          //error: DecodingError\n          debug(\"segfault, pointer %o, state: %O\", pointer, state);\n\n          if (!strict) {\n            _context.next = 14;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_context.t1.error);\n\n        case 14:\n          return _context.abrupt(\"return\", {\n            //no idea why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context.t1.error\n          });\n\n        case 15:\n          rawBytes = bytes;\n          debug(\"type %O\", dataType);\n          debug(\"pointer %o\", pointer);\n          _context.t2 = dataType.typeClass;\n          _context.next = _context.t2 === \"bool\" ? 21 : _context.t2 === \"uint\" ? 40 : _context.t2 === \"int\" ? 47 : _context.t2 === \"address\" ? 54 : _context.t2 === \"contract\" ? 61 : _context.t2 === \"bytes\" ? 71 : _context.t2 === \"function\" ? 79 : _context.t2 === \"enum\" ? 103 : _context.t2 === \"fixed\" ? 129 : _context.t2 === \"ufixed\" ? 140 : 151;\n          break;\n\n        case 21:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 26;\n            break;\n          }\n\n          error = {\n            kind: \"BoolPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 25;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error);\n\n        case 25:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 26:\n          bytes = removePadding(bytes, dataType, paddingMode); //note: the use of the BN is a little silly here,\n          //but, kind of stuck with it for now\n\n          numeric = Conversion.toBN(bytes);\n\n          if (!numeric.eqn(0)) {\n            _context.next = 32;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: false\n            }\n          });\n\n        case 32:\n          if (!numeric.eqn(1)) {\n            _context.next = 36;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          });\n\n        case 36:\n          _error = {\n            kind: \"BoolOutOfRangeError\",\n            rawAsBN: numeric\n          };\n\n          if (!strict) {\n            _context.next = 39;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error);\n\n        case 39:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error\n          });\n\n        case 40:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 45;\n            break;\n          }\n\n          _error2 = {\n            kind: \"UintPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 44;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error2);\n\n        case 44:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error2\n          });\n\n        case 45:\n          //now, truncate to appropriate length\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBN: Conversion.toBN(bytes),\n              rawAsBN: Conversion.toBN(rawBytes)\n            }\n          });\n\n        case 47:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 52;\n            break;\n          }\n\n          _error3 = {\n            kind: \"IntPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 51;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error3);\n\n        case 51:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error3\n          });\n\n        case 52:\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBN: Conversion.toSignedBN(bytes),\n              rawAsBN: Conversion.toSignedBN(rawBytes)\n            }\n          });\n\n        case 54:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 59;\n            break;\n          }\n\n          _error4 = {\n            kind: \"AddressPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 58;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error4);\n\n        case 58:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error4\n          });\n\n        case 59:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asAddress: Evm.Utils.toAddress(bytes),\n              rawAsHex: Conversion.toHexString(rawBytes)\n            }\n          });\n\n        case 61:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 66;\n            break;\n          }\n\n          _error5 = {\n            kind: \"ContractPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 65;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error5);\n\n        case 65:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error5\n          });\n\n        case 66:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n          return _context.delegateYield(decodeContract(bytes, info), \"t3\", 69);\n\n        case 69:\n          contractValueInfo = _context.t3;\n          return _context.abrupt(\"return\", {\n            type: fullType,\n            kind: \"value\",\n            value: contractValueInfo\n          });\n\n        case 71:\n          //NOTE: we assume this is a *static* bytestring,\n          //because this is decodeBasic! dynamic ones should\n          //go to decodeBytes!\n          coercedDataType = dataType; //first, check padding (if needed)\n\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 77;\n            break;\n          }\n\n          _error6 = {\n            kind: \"BytesPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 76;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error6);\n\n        case 76:\n          return _context.abrupt(\"return\", {\n            type: coercedDataType,\n            kind: \"error\",\n            error: _error6\n          });\n\n        case 77:\n          //now, truncate to appropriate length\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: coercedDataType,\n            kind: \"value\",\n            value: {\n              asHex: Conversion.toHexString(bytes),\n              rawAsHex: Conversion.toHexString(rawBytes)\n            }\n          });\n\n        case 79:\n          _context.t4 = dataType.visibility;\n          _context.next = _context.t4 === \"external\" ? 82 : _context.t4 === \"internal\" ? 94 : 102;\n          break;\n\n        case 82:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 87;\n            break;\n          }\n\n          _error7 = {\n            kind: \"FunctionExternalNonStackPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 86;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error7);\n\n        case 86:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error7\n          });\n\n        case 87:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n          selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n          _context.t5 = dataType;\n          return _context.delegateYield(decodeExternalFunction(address, selector, info), \"t6\", 92);\n\n        case 92:\n          _context.t7 = _context.t6;\n          return _context.abrupt(\"return\", {\n            type: _context.t5,\n            kind: \"value\",\n            value: _context.t7\n          });\n\n        case 94:\n          if (!strict) {\n            _context.next = 96;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError({\n            kind: \"InternalFunctionInABIError\"\n          });\n\n        case 96:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 98;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"FunctionInternalPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            }\n          });\n\n        case 98:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n          constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n          return _context.abrupt(\"return\", decodeInternalFunction(dataType, deployedPc, constructorPc, info));\n\n        case 102:\n          return _context.abrupt(\"break\", 151);\n\n        case 103:\n          _numeric = Conversion.toBN(bytes);\n          _fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n          if (_fullType.options) {\n            _context.next = 110;\n            break;\n          }\n\n          _error8 = {\n            kind: \"EnumNotFoundDecodingError\",\n            type: _fullType,\n            rawAsBN: _numeric\n          };\n\n          if (!(strict || options.allowRetry)) {\n            _context.next = 109;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error8, true);\n\n        case 109:\n          return _context.abrupt(\"return\", {\n            type: _fullType,\n            kind: \"error\",\n            error: _error8\n          });\n\n        case 110:\n          //note: I'm doing the padding checks a little more manually on this one\n          //so that we can have the right type of error\n          numOptions = _fullType.options.length;\n          numBytes = Math.ceil(Math.log2(numOptions) / 8);\n          paddingType = getPaddingType(dataType, paddingMode);\n\n          if (checkPaddingDirect(bytes, numBytes, paddingType)) {\n            _context.next = 118;\n            break;\n          }\n\n          _error9 = {\n            kind: \"EnumPaddingError\",\n            type: _fullType,\n            paddingType: paddingType,\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 117;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error9);\n\n        case 117:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error9\n          });\n\n        case 118:\n          bytes = removePaddingDirect(bytes, numBytes, paddingType);\n          _numeric = Conversion.toBN(bytes); //alter numeric!\n\n          if (!_numeric.ltn(numOptions)) {\n            _context.next = 125;\n            break;\n          }\n\n          name = _fullType.options[_numeric.toNumber()]; //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n          //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n          //an enum with that many options in the first place, we have bigger problems!\n\n          return _context.abrupt(\"return\", {\n            type: _fullType,\n            kind: \"value\",\n            value: {\n              name: name,\n              numericAsBN: _numeric\n            }\n          });\n\n        case 125:\n          _error10 = {\n            kind: \"EnumOutOfRangeError\",\n            type: _fullType,\n            rawAsBN: _numeric\n          };\n\n          if (!strict) {\n            _context.next = 128;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error10);\n\n        case 128:\n          return _context.abrupt(\"return\", {\n            type: _fullType,\n            kind: \"error\",\n            error: _error10\n          });\n\n        case 129:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 134;\n            break;\n          }\n\n          _error11 = {\n            kind: \"FixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 133;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error11);\n\n        case 133:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error11\n          });\n\n        case 134:\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          asBN = Conversion.toSignedBN(bytes);\n          rawAsBN = Conversion.toSignedBN(rawBytes);\n          asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n          rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig: asBig,\n              rawAsBig: rawAsBig\n            }\n          });\n\n        case 140:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 145;\n            break;\n          }\n\n          _error12 = {\n            kind: \"UfixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 144;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error12);\n\n        case 144:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error12\n          });\n\n        case 145:\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          _asBN = Conversion.toBN(bytes);\n          _rawAsBN = Conversion.toBN(rawBytes);\n          _asBig = Conversion.shiftBigDown(Conversion.toBig(_asBN), dataType.places);\n          _rawAsBig = Conversion.shiftBigDown(Conversion.toBig(_rawAsBN), dataType.places);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig: _asBig,\n              rawAsBig: _rawAsBig\n            }\n          });\n\n        case 151:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[4, 9]]);\n}\n\nexports.decodeBasic = decodeBasic; //NOTE that this function returns a ContractValueInfo, not a ContractResult\n\nfunction decodeContract(addressBytes, info) {\n  return _regeneratorRuntime.wrap(function decodeContract$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          return _context2.delegateYield(decodeContractAndContext(addressBytes, info), \"t0\", 1);\n\n        case 1:\n          return _context2.abrupt(\"return\", _context2.t0.contractInfo);\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nexports.decodeContract = decodeContract;\n\nfunction decodeContractAndContext(addressBytes, info) {\n  var address, rawAddress, codeBytes, code, context;\n  return _regeneratorRuntime.wrap(function decodeContractAndContext$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          address = Evm.Utils.toAddress(addressBytes);\n          rawAddress = Conversion.toHexString(addressBytes);\n          _context3.next = 4;\n          return {\n            type: \"code\",\n            address: address\n          };\n\n        case 4:\n          codeBytes = _context3.sent;\n          code = Conversion.toHexString(codeBytes);\n          context = Contexts.Utils.findDecoderContext(info.contexts, code);\n\n          if (!(context !== null)) {\n            _context3.next = 11;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            context: context,\n            contractInfo: {\n              kind: \"known\",\n              address: address,\n              rawAddress: rawAddress,\n              class: Contexts.Import.contextToType(context)\n            }\n          });\n\n        case 11:\n          return _context3.abrupt(\"return\", {\n            context: context,\n            contractInfo: {\n              kind: \"unknown\",\n              address: address,\n              rawAddress: rawAddress\n            }\n          });\n\n        case 12:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n} //note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\n\n\nfunction decodeExternalFunction(addressBytes, selectorBytes, info) {\n  var _yield$decodeContract, contract, context, selector, abiEntry;\n\n  return _regeneratorRuntime.wrap(function decodeExternalFunction$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.delegateYield(decodeContractAndContext(addressBytes, info), \"t0\", 1);\n\n        case 1:\n          _yield$decodeContract = _context4.t0;\n          contract = _yield$decodeContract.contractInfo;\n          context = _yield$decodeContract.context;\n          selector = Conversion.toHexString(selectorBytes);\n\n          if (!(contract.kind === \"unknown\")) {\n            _context4.next = 7;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", {\n            kind: \"unknown\",\n            contract: contract,\n            selector: selector\n          });\n\n        case 7:\n          abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n\n          if (!(abiEntry === undefined)) {\n            _context4.next = 10;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", {\n            kind: \"invalid\",\n            contract: contract,\n            selector: selector\n          });\n\n        case 10:\n          return _context4.abrupt(\"return\", {\n            kind: \"known\",\n            contract: contract,\n            selector: selector,\n            abi: abiEntry\n          });\n\n        case 11:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n}\n\nexports.decodeExternalFunction = decodeExternalFunction; //this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\n//also note, I haven't put the same sort of error-handling in this one since it's only intended to run with full info (for now, anyway)\n\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info) {\n  var deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n  var constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n  var context = Contexts.Import.contextToType(info.currentContext); //before anything else: do we even have an internal functions table?\n  //if not, we'll just return the info we have without really attemting to decode\n\n  if (!info.internalFunctionsTable) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"unknown\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //also before we continue: is the PC zero? if so let's just return that\n\n\n  if (deployedPc === 0 && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //another check: is only the deployed PC zero?\n\n\n  if (deployedPc === 0 && constructorPc !== 0) {\n    return {\n      type: dataType,\n      kind: \"error\",\n      error: {\n        kind: \"MalformedInternalFunctionError\",\n        context: context,\n        deployedProgramCounter: 0,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //one last pre-check: is this a deployed-format pointer in a constructor?\n\n\n  if (info.currentContext.isConstructor && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"error\",\n      error: {\n        kind: \"DeployedFunctionInConstructorError\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: 0\n      }\n    };\n  } //otherwise, we get our function\n\n\n  var pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n  var functionEntry = info.internalFunctionsTable[pc];\n\n  if (!functionEntry) {\n    //if it's not zero and there's no entry... error!\n    return {\n      type: dataType,\n      kind: \"error\",\n      error: {\n        kind: \"NoSuchInternalFunctionError\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n\n  if (functionEntry.isDesignatedInvalid) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n\n  var name = functionEntry.name;\n  var mutability = functionEntry.mutability;\n  var definedIn = Evm.Import.functionTableEntryToType(functionEntry);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"function\",\n      context: context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc,\n      name: name,\n      definedIn: definedIn,\n      mutability: mutability\n    }\n  };\n}\n\nexports.decodeInternalFunction = decodeInternalFunction;\n\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  var length = allocate_1.byteLength(dataType, userDefinedTypes);\n  var paddingType = getPaddingType(dataType, paddingMode);\n\n  if (paddingMode === \"permissive\") {\n    switch (dataType.typeClass) {\n      case \"bool\":\n      case \"enum\":\n      case \"function\":\n        //these three types are checked even in permissive mode\n        return checkPaddingDirect(bytes, length, paddingType);\n\n      default:\n        return true;\n    }\n  } else {\n    return checkPaddingDirect(bytes, length, paddingType);\n  }\n}\n\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  var length = allocate_1.byteLength(dataType, userDefinedTypes);\n  var paddingType = getPaddingType(dataType, paddingMode);\n  return removePaddingDirect(bytes, length, paddingType);\n}\n\nfunction removePaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n    case \"signed\":\n      return bytes.slice(-length);\n\n    case \"right\":\n      return bytes.slice(0, length);\n  }\n}\n\nfunction checkPaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n      return checkPaddingLeft(bytes, length);\n\n    case \"right\":\n      return checkPaddingRight(bytes, length);\n\n    case \"signed\":\n      return checkPaddingSigned(bytes, length);\n  }\n}\n\nfunction getPaddingType(dataType, paddingMode) {\n  switch (paddingMode) {\n    case \"right\":\n      return \"right\";\n\n    case \"default\":\n    case \"permissive\":\n      return defaultPaddingType(dataType);\n\n    case \"zero\":\n      var defaultType = defaultPaddingType(dataType);\n      return defaultType === \"signed\" ? \"left\" : defaultType;\n  }\n}\n\nfunction defaultPaddingType(dataType) {\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      return \"right\";\n\n    case \"int\":\n    case \"fixed\":\n      return \"signed\";\n\n    case \"function\":\n      if (dataType.visibility === \"external\") {\n        return \"right\";\n      }\n\n    //otherwise, fall through to default\n\n    default:\n      return \"left\";\n  }\n}\n\nfunction checkPaddingRight(bytes, length) {\n  var padding = bytes.slice(length); //cut off the first length bytes\n\n  return padding.every(function (paddingByte) {\n    return paddingByte === 0;\n  });\n} //exporting this one for use in stack.ts\n\n\nfunction checkPaddingLeft(bytes, length) {\n  var padding = bytes.slice(0, -length); //cut off the last length bytes\n\n  return padding.every(function (paddingByte) {\n    return paddingByte === 0;\n  });\n}\n\nexports.checkPaddingLeft = checkPaddingLeft;\n\nfunction checkPaddingSigned(bytes, length) {\n  var padding = bytes.slice(0, -length); //padding is all but the last length bytes\n\n  var value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n\n  var signByte = value[0] & 0x80 ? 0xff : 0x00;\n  return padding.every(function (paddingByte) {\n    return paddingByte === signByte;\n  });\n}","map":{"version":3,"sources":["../../../../lib/basic/decode/index.ts"],"names":[],"mappings":";;;;oDAkBiB,W;qDAicA,c;qDAOP,wB;qDAoCO,sB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9fjB,IAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,oBAAZ,CAAd;;AAEA,IAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,IAAA,UAAA,GAAA,YAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;;AACA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,YAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AAQA,IAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,SAAiB,WAAjB,CACE,QADF,EAEE,OAFF,EAGE,IAHF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAIE,UAAA,OAJF,2DAI4B,EAJ5B;AAMU,UAAA,KANV,GAMoB,IANpB,CAMU,KANV;AAOyB,UAAA,MAPzB,GAOoC,OAPpC,CAOU,aAPV,EAO6C;;AACrC,UAAA,WARR,GAQmC,OAAO,CAAC,WAAR,IAAuB,SAR1D;AAAA;AAaY,wCAAO,MAAA,CAAA,OAAA,CAAK,OAAL,EAAc,KAAd,CAAP;;AAbZ;AAaI,UAAA,KAbJ;AAAA;AAAA;;AAAA;AAAA;AAAA;AAeI;AACA,UAAA,KAAK,CAAC,iCAAD,EAAoC,OAApC,EAA6C,KAA7C,CAAL;;AAhBJ,eAiBQ,MAjBR;AAAA;AAAA;AAAA;;AAAA,gBAkBY,IAAI,QAAA,CAAA,iBAAJ,CAAsC,YAAO,KAA7C,CAlBZ;;AAAA;AAAA,2CAoBsC;AAChC;AACA,YAAA,IAAI,EAAE,QAF0B;AAGhC,YAAA,IAAI,EAAE,OAH0B;AAIhC,YAAA,KAAK,EAAkB,YAAO;AAJE,WApBtC;;AAAA;AA2BE,UAAA,QAAQ,GAAG,KAAX;AAEA,UAAA,KAAK,CAAC,SAAD,EAAY,QAAZ,CAAL;AACA,UAAA,KAAK,CAAC,YAAD,EAAe,OAAf,CAAL;AA9BF,wBAgCU,QAAQ,CAAC,SAhCnB;AAAA,0CAiCS,MAjCT,wBAiFS,MAjFT,wBA4GS,KA5GT,wBAwIS,SAxIT,wBAkKS,UAlKT,wBA6LS,OA7LT,wBA8NS,UA9NT,wBA6RS,MA7RT,yBAiXS,OAjXT,yBAuZS,QAvZT;AAAA;;AAAA;AAAA,cAkCW,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAlCvB;AAAA;AAAA;AAAA;;AAmCY,UAAA,KAnCZ,GAmCoB;AACV,YAAA,IAAI,EAAE,kBADI;AAEV,YAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFjB;AAGV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHK,WAnCpB;;AAAA,eAwCY,MAxCZ;AAAA;AAAA;AAAA;;AAAA,gBAyCgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,KAAtB,CAzChB;;AAAA;AAAA,2CA2Ce;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WA3Cf;;AAAA;AAiDM,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB,CAjDN,CAkDM;AACA;;AACM,UAAA,OApDZ,GAoDsB,UAAU,CAAC,IAAX,CAAgB,KAAhB,CApDtB;;AAAA,eAqDU,OAAO,CAAC,GAAR,CAAY,CAAZ,CArDV;AAAA;AAAA;AAAA;;AAAA,2CAsDe;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AAAE,cAAA,SAAS,EAAE;AAAb;AAHF,WAtDf;;AAAA;AAAA,eA2DiB,OAAO,CAAC,GAAR,CAAY,CAAZ,CA3DjB;AAAA;AAAA;AAAA;;AAAA,2CA4De;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AAAE,cAAA,SAAS,EAAE;AAAb;AAHF,WA5Df;;AAAA;AAkEY,UAAA,MAlEZ,GAkEoB;AACV,YAAA,IAAI,EAAE,qBADI;AAEV,YAAA,OAAO,EAAE;AAFC,WAlEpB;;AAAA,eAsEY,MAtEZ;AAAA;AAAA;AAAA;;AAAA,gBAuEgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,MAAtB,CAvEhB;;AAAA;AAAA,2CAyEe;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WAzEf;;AAAA;AAAA,cAmFW,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAnFvB;AAAA;AAAA;AAAA;;AAoFY,UAAA,OApFZ,GAoFoB;AACV,YAAA,IAAI,EAAE,kBADI;AAEV,YAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFjB;AAGV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHK,WApFpB;;AAAA,eAyFY,MAzFZ;AAAA;AAAA;AAAA;;AAAA,gBA0FgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,OAAtB,CA1FhB;;AAAA;AAAA,2CA4Fe;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WA5Ff;;AAAA;AAkGM;AACA,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB;AAnGN,2CAoGa;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AACL,cAAA,IAAI,EAAE,UAAU,CAAC,IAAX,CAAgB,KAAhB,CADD;AAEL,cAAA,OAAO,EAAE,UAAU,CAAC,IAAX,CAAgB,QAAhB;AAFJ;AAHF,WApGb;;AAAA;AAAA,cA8GW,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CA9GvB;AAAA;AAAA;AAAA;;AA+GY,UAAA,OA/GZ,GA+GoB;AACV,YAAA,IAAI,EAAE,iBADI;AAEV,YAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFjB;AAGV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHK,WA/GpB;;AAAA,eAoHY,MApHZ;AAAA;AAAA;AAAA;;AAAA,gBAqHgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,OAAtB,CArHhB;;AAAA;AAAA,2CAuHe;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WAvHf;;AAAA;AA6HM;AACA,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB;AA9HN,2CA+Ha;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AACL,cAAA,IAAI,EAAE,UAAU,CAAC,UAAX,CAAsB,KAAtB,CADD;AAEL,cAAA,OAAO,EAAE,UAAU,CAAC,UAAX,CAAsB,QAAtB;AAFJ;AAHF,WA/Hb;;AAAA;AAAA,cAyIW,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAzIvB;AAAA;AAAA;AAAA;;AA0IY,UAAA,OA1IZ,GA0IoB;AACV,YAAA,IAAI,EAAE,qBADI;AAEV,YAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFjB;AAGV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHK,WA1IpB;;AAAA,eA+IY,MA/IZ;AAAA;AAAA;AAAA;;AAAA,gBAgJgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,OAAtB,CAhJhB;;AAAA;AAAA,2CAkJe;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WAlJf;;AAAA;AAwJM,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB;AAxJN,2CAyJa;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AACL,cAAA,SAAS,EAAE,GAAG,CAAC,KAAJ,CAAU,SAAV,CAAoB,KAApB,CADN;AAEL,cAAA,QAAQ,EAAE,UAAU,CAAC,WAAX,CAAuB,QAAvB;AAFL;AAHF,WAzJb;;AAAA;AAAA,cAmKW,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAnKvB;AAAA;AAAA;AAAA;;AAoKY,UAAA,OApKZ,GAoKoB;AACV,YAAA,IAAI,EAAE,sBADI;AAEV,YAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFjB;AAGV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHK,WApKpB;;AAAA,eAyKY,MAzKZ;AAAA;AAAA;AAAA;;AAAA,gBA0KgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,OAAtB,CA1KhB;;AAAA;AAAA,2CA4Ke;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WA5Kf;;AAAA;AAkLM,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB;AACM,UAAA,QAnLZ,GAoLQ,MAAM,CAAC,KAAP,CAAa,QAAb,CAAsB,QAAtB,EAAgC,IAAI,CAAC,gBAArC,CApLR;AAsLgC,wCAAO,cAAc,CAAC,KAAD,EAAQ,IAAR,CAArB;;AAtLhC;AAsLY,UAAA,iBAtLZ;AAAA,2CAuLa;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AAHF,WAvLb;;AAAA;AA8LM;AACA;AACA;AACI,UAAA,eAjMV,GAiM0D,QAjM1D,EAmMM;;AAnMN,cAoMW,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CApMvB;AAAA;AAAA;AAAA;;AAqMY,UAAA,OArMZ,GAqMoB;AACV,YAAA,IAAI,EAAE,mBADI;AAEV,YAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFjB;AAGV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHK,WArMpB;;AAAA,eA0MY,MA1MZ;AAAA;AAAA;AAAA;;AAAA,gBA2MgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,OAAtB,CA3MhB;;AAAA;AAAA,2CA6Me;AACL,YAAA,IAAI,EAAE,eADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WA7Mf;;AAAA;AAmNM;AACA,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB;AApNN,2CAqNa;AACL,YAAA,IAAI,EAAE,eADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AACL,cAAA,KAAK,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB,CADF;AAEL,cAAA,QAAQ,EAAE,UAAU,CAAC,WAAX,CAAuB,QAAvB;AAFL;AAHF,WArNb;;AAAA;AAAA,wBA+Nc,QAAQ,CAAC,UA/NvB;AAAA,0CAgOa,UAhOb,wBA2Pa,UA3Pb;AAAA;;AAAA;AAAA,cAiOe,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAjO3B;AAAA;AAAA;AAAA;;AAkOgB,UAAA,OAlOhB,GAkOwB;AACV,YAAA,IAAI,EAAE,sCADI;AAEV,YAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFjB;AAGV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHK,WAlOxB;;AAAA,eAuOgB,MAvOhB;AAAA;AAAA;AAAA;;AAAA,gBAwOoB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,OAAtB,CAxOpB;;AAAA;AAAA,2CA0OmB;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WA1OnB;;AAAA;AAgPU,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB;AACM,UAAA,OAjPhB,GAiP0B,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,GAAG,CAAC,KAAJ,CAAU,YAAzB,CAjP1B;AAkPgB,UAAA,QAlPhB,GAkP2B,KAAK,CAAC,KAAN,CACf,GAAG,CAAC,KAAJ,CAAU,YADK,EAEf,GAAG,CAAC,KAAJ,CAAU,YAAV,GAAyB,GAAG,CAAC,KAAJ,CAAU,aAFpB,CAlP3B;AAAA,wBAuPkB,QAvPlB;AAyPmB,wCAAO,sBAAsB,CAAC,OAAD,EAAU,QAAV,EAAoB,IAApB,CAA7B;;AAzPnB;AAAA;AAAA;AAuPY,YAAA,IAvPZ;AAwPY,YAAA,IAxPZ,EAwPkB,OAxPlB;AAyPY,YAAA,KAzPZ;AAAA;;AAAA;AAAA,eA4Pc,MA5Pd;AAAA;AAAA;AAAA;;AAAA,gBA+PkB,IAAI,QAAA,CAAA,iBAAJ,CAAsB;AAC1B,YAAA,IAAI,EAAE;AADoB,WAAtB,CA/PlB;;AAAA;AAAA,cAmQe,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAnQ3B;AAAA;AAAA;AAAA;;AAAA,2CAoQmB;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AACL,cAAA,IAAI,EAAE,8BADD;AAEL,cAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFtB;AAGL,cAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHA;AAHF,WApQnB;;AAAA;AA8QU,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB;AACM,UAAA,UA/QhB,GA+Q6B,KAAK,CAAC,KAAN,CAAY,CAAC,GAAG,CAAC,KAAJ,CAAU,OAAvB,CA/Q7B;AAgRgB,UAAA,aAhRhB,GAgRgC,KAAK,CAAC,KAAN,CACpB,CAAC,GAAG,CAAC,KAAJ,CAAU,OAAX,GAAqB,CADD,EAEpB,CAAC,GAAG,CAAC,KAAJ,CAAU,OAFS,CAhRhC;AAAA,2CAoRiB,sBAAsB,CAC3B,QAD2B,EAE3B,UAF2B,EAG3B,aAH2B,EAI3B,IAJ2B,CApRvC;;AAAA;AAAA;;AAAA;AA8RU,UAAA,QA9RV,GA8RoB,UAAU,CAAC,IAAX,CAAgB,KAAhB,CA9RpB;AA+RY,UAAA,SA/RZ,GAgSQ,MAAM,CAAC,KAAP,CAAa,QAAb,CAAsB,QAAtB,EAAgC,IAAI,CAAC,gBAArC,CAhSR;;AAAA,cAkSW,SAAQ,CAAC,OAlSpB;AAAA;AAAA;AAAA;;AAmSY,UAAA,OAnSZ,GAmSoB;AACV,YAAA,IAAI,EAAE,2BADI;AAEV,YAAA,IAAI,EAAE,SAFI;AAGV,YAAA,OAAO,EAAE;AAHC,WAnSpB;;AAAA,gBAwSY,MAAM,IAAI,OAAO,CAAC,UAxS9B;AAAA;AAAA;AAAA;;AAAA,gBAySgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,OAAtB,EAA6B,IAA7B,CAzShB;;AAAA;AAAA,2CA4Se;AACL,YAAA,IAAI,EAAE,SADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WA5Sf;;AAAA;AAkTM;AACA;AACM,UAAA,UApTZ,GAoTyB,SAAQ,CAAC,OAAT,CAAiB,MApT1C;AAqTY,UAAA,QArTZ,GAqTuB,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,IAAL,CAAU,UAAV,IAAwB,CAAlC,CArTvB;AAsTY,UAAA,WAtTZ,GAsT0B,cAAc,CAAC,QAAD,EAAW,WAAX,CAtTxC;;AAAA,cAuTW,kBAAkB,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAvT7B;AAAA;AAAA;AAAA;;AAwTY,UAAA,OAxTZ,GAwToB;AACV,YAAA,IAAI,EAAE,kBADI;AAEV,YAAA,IAAI,EAAE,SAFI;AAGV,YAAA,WAAW,EAAX,WAHU;AAIV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAJK,WAxTpB;;AAAA,eA8TY,MA9TZ;AAAA;AAAA;AAAA;;AAAA,gBA+TgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,OAAtB,CA/ThB;;AAAA;AAAA,2CAiUe;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WAjUf;;AAAA;AAuUM,UAAA,KAAK,GAAG,mBAAmB,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAA3B;AACA,UAAA,QAAO,GAAG,UAAU,CAAC,IAAX,CAAgB,KAAhB,CAAV,CAxUN,CAwUwC;;AAxUxC,eAyUU,QAAO,CAAC,GAAR,CAAY,UAAZ,CAzUV;AAAA;AAAA;AAAA;;AA0Uc,UAAA,IA1Ud,GA0UqB,SAAQ,CAAC,OAAT,CAAiB,QAAO,CAAC,QAAR,EAAjB,CA1UrB,EA2UQ;AACA;AACA;;AA7UR,2CA8Ue;AACL,YAAA,IAAI,EAAE,SADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AACL,cAAA,IAAI,EAAJ,IADK;AAEL,cAAA,WAAW,EAAE;AAFR;AAHF,WA9Uf;;AAAA;AAuVY,UAAA,QAvVZ,GAuVoB;AACV,YAAA,IAAI,EAAE,qBADI;AAEV,YAAA,IAAI,EAAE,SAFI;AAGV,YAAA,OAAO,EAAE;AAHC,WAvVpB;;AAAA,eA4VY,MA5VZ;AAAA;AAAA;AAAA;;AAAA,gBAoWgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,QAAtB,CApWhB;;AAAA;AAAA,2CAyWe;AACL,YAAA,IAAI,EAAE,SADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WAzWf;;AAAA;AAAA,cAmXW,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAnXvB;AAAA;AAAA;AAAA;;AAoXY,UAAA,QApXZ,GAoXoB;AACV,YAAA,IAAI,EAAE,mBADI;AAEV,YAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFjB;AAGV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHK,WApXpB;;AAAA,eAyXY,MAzXZ;AAAA;AAAA;AAAA;;AAAA,gBA0XgB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,QAAtB,CA1XhB;;AAAA;AAAA,2CA4Xe;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WA5Xf;;AAAA;AAkYM;AACA,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB;AACI,UAAA,IApYV,GAoYiB,UAAU,CAAC,UAAX,CAAsB,KAAtB,CApYjB;AAqYU,UAAA,OArYV,GAqYoB,UAAU,CAAC,UAAX,CAAsB,QAAtB,CArYpB;AAsYU,UAAA,KAtYV,GAsYkB,UAAU,CAAC,YAAX,CACV,UAAU,CAAC,KAAX,CAAiB,IAAjB,CADU,EAEV,QAAQ,CAAC,MAFC,CAtYlB;AA0YU,UAAA,QA1YV,GA0YqB,UAAU,CAAC,YAAX,CACb,UAAU,CAAC,KAAX,CAAiB,OAAjB,CADa,EAEb,QAAQ,CAAC,MAFI,CA1YrB;AAAA,2CA8Ya;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AACL,cAAA,KAAK,EAAL,KADK;AAEL,cAAA,QAAQ,EAAR;AAFK;AAHF,WA9Yb;;AAAA;AAAA,cAyZW,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAzZvB;AAAA;AAAA;AAAA;;AA0ZY,UAAA,QA1ZZ,GA0ZoB;AACV,YAAA,IAAI,EAAE,oBADI;AAEV,YAAA,WAAW,EAAE,cAAc,CAAC,QAAD,EAAW,WAAX,CAFjB;AAGV,YAAA,GAAG,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB;AAHK,WA1ZpB;;AAAA,eA+ZY,MA/ZZ;AAAA;AAAA;AAAA;;AAAA,gBAgagB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,QAAtB,CAhahB;;AAAA;AAAA,2CAkae;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAL;AAHK,WAlaf;;AAAA;AAwaM;AACA,UAAA,KAAK,GAAG,aAAa,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,CAArB;AACI,UAAA,KA1aV,GA0aiB,UAAU,CAAC,IAAX,CAAgB,KAAhB,CA1ajB;AA2aU,UAAA,QA3aV,GA2aoB,UAAU,CAAC,IAAX,CAAgB,QAAhB,CA3apB;AA4aU,UAAA,MA5aV,GA4akB,UAAU,CAAC,YAAX,CACV,UAAU,CAAC,KAAX,CAAiB,KAAjB,CADU,EAEV,QAAQ,CAAC,MAFC,CA5alB;AAgbU,UAAA,SAhbV,GAgbqB,UAAU,CAAC,YAAX,CACb,UAAU,CAAC,KAAX,CAAiB,QAAjB,CADa,EAEb,QAAQ,CAAC,MAFI,CAhbrB;AAAA,2CAoba;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,KAAK,EAAE;AACL,cAAA,KAAK,EAAL,MADK;AAEL,cAAA,QAAQ,EAAR;AAFK;AAHF,WApbb;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,OAAA,CAAA,WAAA,GAAA,WAAA,C,CAgcA;;AACA,SAAiB,cAAjB,CACE,YADF,EAEE,IAFF;AAAA;AAAA;AAAA;AAAA;AAIU,yCAAO,wBAAwB,CAAC,YAAD,EAAe,IAAf,CAA/B;;AAJV;AAAA,yDAI+D,YAJ/D;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,OAAA,CAAA,cAAA,GAAA,cAAA;;AAOA,SAAU,wBAAV,CACE,YADF,EAEE,IAFF;AAAA;AAAA;AAAA;AAAA;AAAA;AAIM,UAAA,OAJN,GAIgB,GAAG,CAAC,KAAJ,CAAU,SAAV,CAAoB,YAApB,CAJhB;AAKM,UAAA,UALN,GAKmB,UAAU,CAAC,WAAX,CAAuB,YAAvB,CALnB;AAAA;AAM8B,iBAAM;AAChC,YAAA,IAAI,EAAE,MAD0B;AAEhC,YAAA,OAAO,EAAP;AAFgC,WAAN;;AAN9B;AAMM,UAAA,SANN;AAUM,UAAA,IAVN,GAUa,UAAU,CAAC,WAAX,CAAuB,SAAvB,CAVb;AAWM,UAAA,OAXN,GAWgB,QAAQ,CAAC,KAAT,CAAe,kBAAf,CAAkC,IAAI,CAAC,QAAvC,EAAiD,IAAjD,CAXhB;;AAAA,gBAYM,OAAO,KAAK,IAZlB;AAAA;AAAA;AAAA;;AAAA,4CAaW;AACL,YAAA,OAAO,EAAP,OADK;AAEL,YAAA,YAAY,EAAE;AACZ,cAAA,IAAI,EAAE,OADM;AAEZ,cAAA,OAAO,EAAP,OAFY;AAGZ,cAAA,UAAU,EAAV,UAHY;AAIZ,cAAA,KAAK,EAAE,QAAQ,CAAC,MAAT,CAAgB,aAAhB,CAA8B,OAA9B;AAJK;AAFT,WAbX;;AAAA;AAAA,4CAuBW;AACL,YAAA,OAAO,EAAP,OADK;AAEL,YAAA,YAAY,EAAE;AACZ,cAAA,IAAI,EAAE,SADM;AAEZ,cAAA,OAAO,EAAP,OAFY;AAGZ,cAAA,UAAU,EAAV;AAHY;AAFT,WAvBX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,C,CAkCA;AACA;;;AACA,SAAiB,sBAAjB,CACE,YADF,EAEE,aAFF,EAGE,IAHF;AAAA;;AAAA;AAAA;AAAA;AAAA;AAS4C,yCAAO,wBAAwB,CACvE,YADuE,EAEvE,IAFuE,CAA/B;;AAT5C;AAAA;AASsB,UAAA,QATtB,yBASQ,YATR;AASgC,UAAA,OAThC,yBASgC,OAThC;AAaM,UAAA,QAbN,GAaiB,UAAU,CAAC,WAAX,CAAuB,aAAvB,CAbjB;;AAAA,gBAcM,QAAQ,CAAC,IAAT,KAAkB,SAdxB;AAAA;AAAA;AAAA;;AAAA,4CAeW;AACL,YAAA,IAAI,EAAE,SADD;AAEL,YAAA,QAAQ,EAAR,QAFK;AAGL,YAAA,QAAQ,EAAR;AAHK,WAfX;;AAAA;AAqBM,UAAA,QArBN,GAqBiB,OAAO,CAAC,GAAR,KAAgB,SAAhB,GAA4B,OAAO,CAAC,GAAR,CAAY,QAAZ,CAA5B,GAAoD,SArBrE;;AAAA,gBAsBM,QAAQ,KAAK,SAtBnB;AAAA;AAAA;AAAA;;AAAA,4CAuBW;AACL,YAAA,IAAI,EAAE,SADD;AAEL,YAAA,QAAQ,EAAR,QAFK;AAGL,YAAA,QAAQ,EAAR;AAHK,WAvBX;;AAAA;AAAA,4CA6BS;AACL,YAAA,IAAI,EAAE,OADD;AAEL,YAAA,QAAQ,EAAR,QAFK;AAGL,YAAA,QAAQ,EAAR,QAHK;AAIL,YAAA,GAAG,EAAE;AAJA,WA7BT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,OAAA,CAAA,sBAAA,GAAA,sBAAA,C,CAqCA;AACA;;AACA,SAAgB,sBAAhB,CACE,QADF,EAEE,eAFF,EAGE,kBAHF,EAIE,IAJF,EAImB;AAEjB,MAAI,UAAU,GAAW,UAAU,CAAC,IAAX,CAAgB,eAAhB,EAAiC,QAAjC,EAAzB;AACA,MAAI,aAAa,GAAW,UAAU,CAAC,IAAX,CAAgB,kBAAhB,EAAoC,QAApC,EAA5B;AACA,MAAI,OAAO,GAA8B,QAAQ,CAAC,MAAT,CAAgB,aAAhB,CACvC,IAAI,CAAC,cADkC,CAAzC,CAJiB,CAOjB;AACA;;AACA,MAAI,CAAC,IAAI,CAAC,sBAAV,EAAkC;AAChC,WAAO;AACL,MAAA,IAAI,EAAE,QADD;AAEL,MAAA,IAAI,EAAE,OAFD;AAGL,MAAA,KAAK,EAAE;AACL,QAAA,IAAI,EAAE,SADD;AAEL,QAAA,OAAO,EAAP,OAFK;AAGL,QAAA,sBAAsB,EAAE,UAHnB;AAIL,QAAA,yBAAyB,EAAE;AAJtB;AAHF,KAAP;AAUD,GApBgB,CAqBjB;;;AACA,MAAI,UAAU,KAAK,CAAf,IAAoB,aAAa,KAAK,CAA1C,EAA6C;AAC3C,WAAO;AACL,MAAA,IAAI,EAAE,QADD;AAEL,MAAA,IAAI,EAAE,OAFD;AAGL,MAAA,KAAK,EAAE;AACL,QAAA,IAAI,EAAE,WADD;AAEL,QAAA,OAAO,EAAP,OAFK;AAGL,QAAA,sBAAsB,EAAE,UAHnB;AAIL,QAAA,yBAAyB,EAAE;AAJtB;AAHF,KAAP;AAUD,GAjCgB,CAkCjB;;;AACA,MAAI,UAAU,KAAK,CAAf,IAAoB,aAAa,KAAK,CAA1C,EAA6C;AAC3C,WAAO;AACL,MAAA,IAAI,EAAE,QADD;AAEL,MAAA,IAAI,EAAE,OAFD;AAGL,MAAA,KAAK,EAAE;AACL,QAAA,IAAI,EAAE,gCADD;AAEL,QAAA,OAAO,EAAP,OAFK;AAGL,QAAA,sBAAsB,EAAE,CAHnB;AAIL,QAAA,yBAAyB,EAAE;AAJtB;AAHF,KAAP;AAUD,GA9CgB,CA+CjB;;;AACA,MAAI,IAAI,CAAC,cAAL,CAAoB,aAApB,IAAqC,aAAa,KAAK,CAA3D,EAA8D;AAC5D,WAAO;AACL,MAAA,IAAI,EAAE,QADD;AAEL,MAAA,IAAI,EAAE,OAFD;AAGL,MAAA,KAAK,EAAE;AACL,QAAA,IAAI,EAAE,oCADD;AAEL,QAAA,OAAO,EAAP,OAFK;AAGL,QAAA,sBAAsB,EAAE,UAHnB;AAIL,QAAA,yBAAyB,EAAE;AAJtB;AAHF,KAAP;AAUD,GA3DgB,CA4DjB;;;AACA,MAAI,EAAE,GAAG,IAAI,CAAC,cAAL,CAAoB,aAApB,GAAoC,aAApC,GAAoD,UAA7D;AACA,MAAI,aAAa,GAAG,IAAI,CAAC,sBAAL,CAA4B,EAA5B,CAApB;;AACA,MAAI,CAAC,aAAL,EAAoB;AAClB;AACA,WAAO;AACL,MAAA,IAAI,EAAE,QADD;AAEL,MAAA,IAAI,EAAE,OAFD;AAGL,MAAA,KAAK,EAAE;AACL,QAAA,IAAI,EAAE,6BADD;AAEL,QAAA,OAAO,EAAP,OAFK;AAGL,QAAA,sBAAsB,EAAE,UAHnB;AAIL,QAAA,yBAAyB,EAAE;AAJtB;AAHF,KAAP;AAUD;;AACD,MAAI,aAAa,CAAC,mBAAlB,EAAuC;AACrC,WAAO;AACL,MAAA,IAAI,EAAE,QADD;AAEL,MAAA,IAAI,EAAE,OAFD;AAGL,MAAA,KAAK,EAAE;AACL,QAAA,IAAI,EAAE,WADD;AAEL,QAAA,OAAO,EAAP,OAFK;AAGL,QAAA,sBAAsB,EAAE,UAHnB;AAIL,QAAA,yBAAyB,EAAE;AAJtB;AAHF,KAAP;AAUD;;AACD,MAAI,IAAI,GAAG,aAAa,CAAC,IAAzB;AACA,MAAI,UAAU,GAAG,aAAa,CAAC,UAA/B;AACA,MAAI,SAAS,GAAG,GAAG,CAAC,MAAJ,CAAW,wBAAX,CAAoC,aAApC,CAAhB;AACA,SAAO;AACL,IAAA,IAAI,EAAE,QADD;AAEL,IAAA,IAAI,EAAE,OAFD;AAGL,IAAA,KAAK,EAAE;AACL,MAAA,IAAI,EAAE,UADD;AAEL,MAAA,OAAO,EAAP,OAFK;AAGL,MAAA,sBAAsB,EAAE,UAHnB;AAIL,MAAA,yBAAyB,EAAE,aAJtB;AAKL,MAAA,IAAI,EAAJ,IALK;AAML,MAAA,SAAS,EAAT,SANK;AAOL,MAAA,UAAU,EAAV;AAPK;AAHF,GAAP;AAaD;;AA5GD,OAAA,CAAA,sBAAA,GAAA,sBAAA;;AA8GA,SAAS,YAAT,CACE,KADF,EAEE,QAFF,EAGE,WAHF,EAIE,gBAJF,EAI2C;AAEzC,MAAM,MAAM,GAAG,UAAA,CAAA,UAAA,CAAW,QAAX,EAAqB,gBAArB,CAAf;AACA,MAAI,WAAW,GAAG,cAAc,CAAC,QAAD,EAAW,WAAX,CAAhC;;AACA,MAAI,WAAW,KAAK,YAApB,EAAkC;AAChC,YAAQ,QAAQ,CAAC,SAAjB;AACE,WAAK,MAAL;AACA,WAAK,MAAL;AACA,WAAK,UAAL;AACE;AACA,eAAO,kBAAkB,CAAC,KAAD,EAAQ,MAAR,EAAgB,WAAhB,CAAzB;;AACF;AACE,eAAO,IAAP;AAPJ;AASD,GAVD,MAUO;AACL,WAAO,kBAAkB,CAAC,KAAD,EAAQ,MAAR,EAAgB,WAAhB,CAAzB;AACD;AACF;;AAED,SAAS,aAAT,CACE,KADF,EAEE,QAFF,EAGE,WAHF,EAIE,gBAJF,EAI2C;AAEzC,MAAM,MAAM,GAAG,UAAA,CAAA,UAAA,CAAW,QAAX,EAAqB,gBAArB,CAAf;AACA,MAAM,WAAW,GAAG,cAAc,CAAC,QAAD,EAAW,WAAX,CAAlC;AACA,SAAO,mBAAmB,CAAC,KAAD,EAAQ,MAAR,EAAgB,WAAhB,CAA1B;AACD;;AAED,SAAS,mBAAT,CACE,KADF,EAEE,MAFF,EAGE,WAHF,EAG0B;AAExB,UAAQ,WAAR;AACE,SAAK,MAAL;AACA,SAAK,QAAL;AACE,aAAO,KAAK,CAAC,KAAN,CAAY,CAAC,MAAb,CAAP;;AACF,SAAK,OAAL;AACE,aAAO,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,MAAf,CAAP;AALJ;AAOD;;AAED,SAAS,kBAAT,CACE,KADF,EAEE,MAFF,EAGE,WAHF,EAG0B;AAExB,UAAQ,WAAR;AACE,SAAK,MAAL;AACE,aAAO,gBAAgB,CAAC,KAAD,EAAQ,MAAR,CAAvB;;AACF,SAAK,OAAL;AACE,aAAO,iBAAiB,CAAC,KAAD,EAAQ,MAAR,CAAxB;;AACF,SAAK,QAAL;AACE,aAAO,kBAAkB,CAAC,KAAD,EAAQ,MAAR,CAAzB;AANJ;AAQD;;AAED,SAAS,cAAT,CACE,QADF,EAEE,WAFF,EAE0B;AAExB,UAAQ,WAAR;AACE,SAAK,OAAL;AACE,aAAO,OAAP;;AACF,SAAK,SAAL;AACA,SAAK,YAAL;AACE,aAAO,kBAAkB,CAAC,QAAD,CAAzB;;AACF,SAAK,MAAL;AACE,UAAI,WAAW,GAAG,kBAAkB,CAAC,QAAD,CAApC;AACA,aAAO,WAAW,KAAK,QAAhB,GAA2B,MAA3B,GAAoC,WAA3C;AARJ;AAUD;;AAED,SAAS,kBAAT,CAA4B,QAA5B,EAAuD;AACrD,UAAQ,QAAQ,CAAC,SAAjB;AACE,SAAK,OAAL;AACE,aAAO,OAAP;;AACF,SAAK,KAAL;AACA,SAAK,OAAL;AACE,aAAO,QAAP;;AACF,SAAK,UAAL;AACE,UAAI,QAAQ,CAAC,UAAT,KAAwB,UAA5B,EAAwC;AACtC,eAAO,OAAP;AACD;;AACH;;AACA;AACE,aAAO,MAAP;AAZJ;AAcD;;AAED,SAAS,iBAAT,CAA2B,KAA3B,EAA8C,MAA9C,EAA4D;AAC1D,MAAI,OAAO,GAAG,KAAK,CAAC,KAAN,CAAY,MAAZ,CAAd,CAD0D,CACvB;;AACnC,SAAO,OAAO,CAAC,KAAR,CAAc,UAAA,WAAW;AAAA,WAAI,WAAW,KAAK,CAApB;AAAA,GAAzB,CAAP;AACD,C,CAED;;;AACA,SAAgB,gBAAhB,CAAiC,KAAjC,EAAoD,MAApD,EAAkE;AAChE,MAAI,OAAO,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,CAAC,MAAhB,CAAd,CADgE,CACzB;;AACvC,SAAO,OAAO,CAAC,KAAR,CAAc,UAAA,WAAW;AAAA,WAAI,WAAW,KAAK,CAApB;AAAA,GAAzB,CAAP;AACD;;AAHD,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAKA,SAAS,kBAAT,CAA4B,KAA5B,EAA+C,MAA/C,EAA6D;AAC3D,MAAI,OAAO,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,CAAC,MAAhB,CAAd,CAD2D,CACpB;;AACvC,MAAI,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,CAAC,MAAb,CAAZ,CAF2D,CAEzB;;AAClC,MAAI,QAAQ,GAAG,KAAK,CAAC,CAAD,CAAL,GAAW,IAAX,GAAkB,IAAlB,GAAyB,IAAxC;AACA,SAAO,OAAO,CAAC,KAAR,CAAc,UAAA,WAAW;AAAA,WAAI,WAAW,KAAK,QAApB;AAAA,GAAzB,CAAP;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkPaddingLeft = exports.decodeInternalFunction = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:basic:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Contexts = __importStar(require(\"../../contexts\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nconst allocate_1 = require(\"../allocate\");\nfunction* decodeBasic(dataType, pointer, info, options = {}) {\n    const { state } = info;\n    const { strictAbiMode: strict } = options; //if this is undefined it'll still be falsy so it's OK\n    const paddingMode = options.paddingMode || \"default\";\n    let bytes;\n    let rawBytes;\n    try {\n        bytes = yield* read_1.default(pointer, state);\n    }\n    catch (error) {\n        //error: DecodingError\n        debug(\"segfault, pointer %o, state: %O\", pointer, state);\n        if (strict) {\n            throw new errors_1.StopDecodingError(error.error);\n        }\n        return {\n            //no idea why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: error.error\n        };\n    }\n    rawBytes = bytes;\n    debug(\"type %O\", dataType);\n    debug(\"pointer %o\", pointer);\n    switch (dataType.typeClass) {\n        case \"bool\": {\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"BoolPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            //note: the use of the BN is a little silly here,\n            //but, kind of stuck with it for now\n            const numeric = Conversion.toBN(bytes);\n            if (numeric.eqn(0)) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    value: { asBoolean: false }\n                };\n            }\n            else if (numeric.eqn(1)) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    value: { asBoolean: true }\n                };\n            }\n            else {\n                let error = {\n                    kind: \"BoolOutOfRangeError\",\n                    rawAsBN: numeric\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n        }\n        case \"uint\":\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"UintPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBN: Conversion.toBN(bytes),\n                    rawAsBN: Conversion.toBN(rawBytes)\n                }\n            };\n        case \"int\":\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"IntPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length (keeping the bytes on the right)\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBN: Conversion.toSignedBN(bytes),\n                    rawAsBN: Conversion.toSignedBN(rawBytes)\n                }\n            };\n        case \"address\":\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"AddressPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asAddress: Evm.Utils.toAddress(bytes),\n                    rawAsHex: Conversion.toHexString(rawBytes)\n                }\n            };\n        case \"contract\":\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"ContractPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));\n            const contractValueInfo = yield* decodeContract(bytes, info);\n            return {\n                type: fullType,\n                kind: \"value\",\n                value: contractValueInfo\n            };\n        case \"bytes\":\n            //NOTE: we assume this is a *static* bytestring,\n            //because this is decodeBasic! dynamic ones should\n            //go to decodeBytes!\n            let coercedDataType = dataType;\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"BytesPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: coercedDataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: coercedDataType,\n                kind: \"value\",\n                value: {\n                    asHex: Conversion.toHexString(bytes),\n                    rawAsHex: Conversion.toHexString(rawBytes)\n                }\n            };\n        case \"function\":\n            switch (dataType.visibility) {\n                case \"external\":\n                    if (!checkPadding(bytes, dataType, paddingMode)) {\n                        let error = {\n                            kind: \"FunctionExternalNonStackPaddingError\",\n                            paddingType: getPaddingType(dataType, paddingMode),\n                            raw: Conversion.toHexString(bytes)\n                        };\n                        if (strict) {\n                            throw new errors_1.StopDecodingError(error);\n                        }\n                        return {\n                            type: dataType,\n                            kind: \"error\",\n                            error\n                        };\n                    }\n                    bytes = removePadding(bytes, dataType, paddingMode);\n                    const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n                    const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n                    return {\n                        type: dataType,\n                        kind: \"value\",\n                        value: yield* decodeExternalFunction(address, selector, info)\n                    };\n                case \"internal\":\n                    if (strict) {\n                        //internal functions don't go in the ABI!\n                        //this should never happen, but just to be sure...\n                        throw new errors_1.StopDecodingError({\n                            kind: \"InternalFunctionInABIError\"\n                        });\n                    }\n                    if (!checkPadding(bytes, dataType, paddingMode)) {\n                        return {\n                            type: dataType,\n                            kind: \"error\",\n                            error: {\n                                kind: \"FunctionInternalPaddingError\",\n                                paddingType: getPaddingType(dataType, paddingMode),\n                                raw: Conversion.toHexString(bytes)\n                            }\n                        };\n                    }\n                    bytes = removePadding(bytes, dataType, paddingMode);\n                    const deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n                    const constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n                    return decodeInternalFunction(dataType, deployedPc, constructorPc, info);\n            }\n            break; //to satisfy TypeScript\n        case \"enum\": {\n            let numeric = Conversion.toBN(bytes);\n            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));\n            if (!fullType.options) {\n                let error = {\n                    kind: \"EnumNotFoundDecodingError\",\n                    type: fullType,\n                    rawAsBN: numeric\n                };\n                if (strict || options.allowRetry) {\n                    throw new errors_1.StopDecodingError(error, true);\n                    //note that we allow a retry if we couldn't locate the enum type!\n                }\n                return {\n                    type: fullType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //note: I'm doing the padding checks a little more manually on this one\n            //so that we can have the right type of error\n            const numOptions = fullType.options.length;\n            const numBytes = Math.ceil(Math.log2(numOptions) / 8);\n            const paddingType = getPaddingType(dataType, paddingMode);\n            if (!checkPaddingDirect(bytes, numBytes, paddingType)) {\n                let error = {\n                    kind: \"EnumPaddingError\",\n                    type: fullType,\n                    paddingType,\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePaddingDirect(bytes, numBytes, paddingType);\n            numeric = Conversion.toBN(bytes); //alter numeric!\n            if (numeric.ltn(numOptions)) {\n                const name = fullType.options[numeric.toNumber()];\n                //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n                //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n                //an enum with that many options in the first place, we have bigger problems!\n                return {\n                    type: fullType,\n                    kind: \"value\",\n                    value: {\n                        name,\n                        numericAsBN: numeric\n                    }\n                };\n            }\n            else {\n                let error = {\n                    kind: \"EnumOutOfRangeError\",\n                    type: fullType,\n                    rawAsBN: numeric\n                };\n                if (strict) {\n                    //note:\n                    //if the enum is merely out of range rather than out of the ABI range,\n                    //we do NOT throw an error here!  instead we simply return an error value,\n                    //which we normally avoid doing in strict mode.  (the error will be caught\n                    //later at the re-encoding step instead.)  why?  because we might be running\n                    //in ABI mode, so we may need to abify this \"value\" rather than just throwing\n                    //it out.\n                    throw new errors_1.StopDecodingError(error);\n                    //note that we do NOT allow a retry here!\n                    //if we *can* find the enum type but the value is out of range,\n                    //we *know* that it is invalid!\n                }\n                return {\n                    type: fullType,\n                    kind: \"error\",\n                    error\n                };\n            }\n        }\n        case \"fixed\": {\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"FixedPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length (keeping the bytes on the right)\n            bytes = removePadding(bytes, dataType, paddingMode);\n            let asBN = Conversion.toSignedBN(bytes);\n            let rawAsBN = Conversion.toSignedBN(rawBytes);\n            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBig,\n                    rawAsBig\n                }\n            };\n        }\n        case \"ufixed\": {\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"UfixedPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length (keeping the bytes on the right)\n            bytes = removePadding(bytes, dataType, paddingMode);\n            let asBN = Conversion.toBN(bytes);\n            let rawAsBN = Conversion.toBN(rawBytes);\n            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBig,\n                    rawAsBig\n                }\n            };\n        }\n    }\n}\nexports.decodeBasic = decodeBasic;\n//NOTE that this function returns a ContractValueInfo, not a ContractResult\nfunction* decodeContract(addressBytes, info) {\n    return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;\n}\nexports.decodeContract = decodeContract;\nfunction* decodeContractAndContext(addressBytes, info) {\n    let address = Evm.Utils.toAddress(addressBytes);\n    let rawAddress = Conversion.toHexString(addressBytes);\n    let codeBytes = yield {\n        type: \"code\",\n        address\n    };\n    let code = Conversion.toHexString(codeBytes);\n    let context = Contexts.Utils.findDecoderContext(info.contexts, code);\n    if (context !== null) {\n        return {\n            context,\n            contractInfo: {\n                kind: \"known\",\n                address,\n                rawAddress,\n                class: Contexts.Import.contextToType(context)\n            }\n        };\n    }\n    else {\n        return {\n            context,\n            contractInfo: {\n                kind: \"unknown\",\n                address,\n                rawAddress\n            }\n        };\n    }\n}\n//note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\nfunction* decodeExternalFunction(addressBytes, selectorBytes, info) {\n    let { contractInfo: contract, context } = yield* decodeContractAndContext(addressBytes, info);\n    let selector = Conversion.toHexString(selectorBytes);\n    if (contract.kind === \"unknown\") {\n        return {\n            kind: \"unknown\",\n            contract,\n            selector\n        };\n    }\n    let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n    if (abiEntry === undefined) {\n        return {\n            kind: \"invalid\",\n            contract,\n            selector\n        };\n    }\n    return {\n        kind: \"known\",\n        contract,\n        selector,\n        abi: abiEntry\n    };\n}\nexports.decodeExternalFunction = decodeExternalFunction;\n//this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\n//also note, I haven't put the same sort of error-handling in this one since it's only intended to run with full info (for now, anyway)\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info) {\n    let deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n    let constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n    let context = Contexts.Import.contextToType(info.currentContext);\n    //before anything else: do we even have an internal functions table?\n    //if not, we'll just return the info we have without really attemting to decode\n    if (!info.internalFunctionsTable) {\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                kind: \"unknown\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    //also before we continue: is the PC zero? if so let's just return that\n    if (deployedPc === 0 && constructorPc === 0) {\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                kind: \"exception\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    //another check: is only the deployed PC zero?\n    if (deployedPc === 0 && constructorPc !== 0) {\n        return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n                kind: \"MalformedInternalFunctionError\",\n                context,\n                deployedProgramCounter: 0,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    //one last pre-check: is this a deployed-format pointer in a constructor?\n    if (info.currentContext.isConstructor && constructorPc === 0) {\n        return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n                kind: \"DeployedFunctionInConstructorError\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: 0\n            }\n        };\n    }\n    //otherwise, we get our function\n    let pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n    let functionEntry = info.internalFunctionsTable[pc];\n    if (!functionEntry) {\n        //if it's not zero and there's no entry... error!\n        return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n                kind: \"NoSuchInternalFunctionError\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    if (functionEntry.isDesignatedInvalid) {\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                kind: \"exception\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    let name = functionEntry.name;\n    let mutability = functionEntry.mutability;\n    let definedIn = Evm.Import.functionTableEntryToType(functionEntry);\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            kind: \"function\",\n            context,\n            deployedProgramCounter: deployedPc,\n            constructorProgramCounter: constructorPc,\n            name,\n            definedIn,\n            mutability\n        }\n    };\n}\nexports.decodeInternalFunction = decodeInternalFunction;\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n    const length = allocate_1.byteLength(dataType, userDefinedTypes);\n    let paddingType = getPaddingType(dataType, paddingMode);\n    if (paddingMode === \"permissive\") {\n        switch (dataType.typeClass) {\n            case \"bool\":\n            case \"enum\":\n            case \"function\":\n                //these three types are checked even in permissive mode\n                return checkPaddingDirect(bytes, length, paddingType);\n            default:\n                return true;\n        }\n    }\n    else {\n        return checkPaddingDirect(bytes, length, paddingType);\n    }\n}\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n    const length = allocate_1.byteLength(dataType, userDefinedTypes);\n    const paddingType = getPaddingType(dataType, paddingMode);\n    return removePaddingDirect(bytes, length, paddingType);\n}\nfunction removePaddingDirect(bytes, length, paddingType) {\n    switch (paddingType) {\n        case \"left\":\n        case \"signed\":\n            return bytes.slice(-length);\n        case \"right\":\n            return bytes.slice(0, length);\n    }\n}\nfunction checkPaddingDirect(bytes, length, paddingType) {\n    switch (paddingType) {\n        case \"left\":\n            return checkPaddingLeft(bytes, length);\n        case \"right\":\n            return checkPaddingRight(bytes, length);\n        case \"signed\":\n            return checkPaddingSigned(bytes, length);\n    }\n}\nfunction getPaddingType(dataType, paddingMode) {\n    switch (paddingMode) {\n        case \"right\":\n            return \"right\";\n        case \"default\":\n        case \"permissive\":\n            return defaultPaddingType(dataType);\n        case \"zero\":\n            let defaultType = defaultPaddingType(dataType);\n            return defaultType === \"signed\" ? \"left\" : defaultType;\n    }\n}\nfunction defaultPaddingType(dataType) {\n    switch (dataType.typeClass) {\n        case \"bytes\":\n            return \"right\";\n        case \"int\":\n        case \"fixed\":\n            return \"signed\";\n        case \"function\":\n            if (dataType.visibility === \"external\") {\n                return \"right\";\n            }\n        //otherwise, fall through to default\n        default:\n            return \"left\";\n    }\n}\nfunction checkPaddingRight(bytes, length) {\n    let padding = bytes.slice(length); //cut off the first length bytes\n    return padding.every(paddingByte => paddingByte === 0);\n}\n//exporting this one for use in stack.ts\nfunction checkPaddingLeft(bytes, length) {\n    let padding = bytes.slice(0, -length); //cut off the last length bytes\n    return padding.every(paddingByte => paddingByte === 0);\n}\nexports.checkPaddingLeft = checkPaddingLeft;\nfunction checkPaddingSigned(bytes, length) {\n    let padding = bytes.slice(0, -length); //padding is all but the last length bytes\n    let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n    let signByte = value[0] & 0x80 ? 0xff : 0x00;\n    return padding.every(paddingByte => paddingByte === signByte);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}