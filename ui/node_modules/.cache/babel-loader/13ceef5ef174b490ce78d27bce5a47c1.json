{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbi),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiReferenceByAddress),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiReferenceStatic),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiStructByPosition),\n    _marked5 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiTupleByPosition);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:abi-data:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar allocate_1 = require(\"../allocate\");\n\nvar errors_1 = require(\"../../errors\");\n\nfunction decodeAbi(dataType, pointer, info) {\n  var options,\n      dynamic,\n      _args = arguments;\n  return _regeneratorRuntime.wrap(function decodeAbi$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n\n          if (!(Format.Types.isReferenceType(dataType) || dataType.typeClass === \"tuple\")) {\n            _context.next = 18;\n            break;\n          }\n\n          _context.prev = 2;\n          dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;\n          _context.next = 9;\n          break;\n\n        case 6:\n          _context.prev = 6;\n          _context.t0 = _context[\"catch\"](2);\n          return _context.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context.t0, options.strictAbiMode));\n\n        case 9:\n          if (!dynamic) {\n            _context.next = 14;\n            break;\n          }\n\n          return _context.delegateYield(decodeAbiReferenceByAddress(dataType, pointer, info, options), \"t1\", 11);\n\n        case 11:\n          return _context.abrupt(\"return\", _context.t1);\n\n        case 14:\n          return _context.delegateYield(decodeAbiReferenceStatic(dataType, pointer, info, options), \"t2\", 15);\n\n        case 15:\n          return _context.abrupt(\"return\", _context.t2);\n\n        case 16:\n          _context.next = 21;\n          break;\n\n        case 18:\n          debug(\"pointer %o\", pointer);\n          return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, options), \"t3\", 20);\n\n        case 20:\n          return _context.abrupt(\"return\", _context.t3);\n\n        case 21:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2, 6]]);\n}\n\nexports.decodeAbi = decodeAbi;\n\nfunction decodeAbiReferenceByAddress(dataType, pointer, info) {\n  var options,\n      strict,\n      base,\n      lengthOverride,\n      allocations,\n      state,\n      location,\n      rawValue,\n      rawValueAsBN,\n      rawValueAsNumber,\n      error,\n      startPosition,\n      dynamic,\n      size,\n      _allocate_1$abiSizeIn,\n      staticPointer,\n      length,\n      lengthAsBN,\n      rawLength,\n      childPointer,\n      baseSize,\n      decodedChildren,\n      index,\n      _args2 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeAbiReferenceByAddress$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};\n          strict = options.strictAbiMode, base = options.abiPointerBase, lengthOverride = options.lengthOverride;\n          base = base || 0; //in case base was undefined\n\n          allocations = info.allocations.abi, state = info.state;\n          debug(\"pointer %o\", pointer); //this variable holds the location we should look to *next*\n          //stack pointers point to calldata; other pointers point to same location\n\n          location = pointer.location === \"stack\" || pointer.location === \"stackliteral\" ? \"calldata\" : pointer.location;\n\n          if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n            //length overrides are only applicable when you're decoding a pointer\n            //from the stack!  otherwise they must be ignored!\n            lengthOverride = undefined;\n          }\n\n          _context2.prev = 7;\n          return _context2.delegateYield(read_1.default(pointer, state), \"t0\", 9);\n\n        case 9:\n          rawValue = _context2.t0;\n          _context2.next = 15;\n          break;\n\n        case 12:\n          _context2.prev = 12;\n          _context2.t1 = _context2[\"catch\"](7);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t1, strict));\n\n        case 15:\n          rawValueAsBN = Conversion.toBN(rawValue);\n          debug(\"rawValue: %O\", rawValue);\n          debug(\"rawValueAsBN: %O\", rawValueAsBN);\n          _context2.prev = 18;\n          rawValueAsNumber = rawValueAsBN.toNumber();\n          _context2.next = 28;\n          break;\n\n        case 22:\n          _context2.prev = 22;\n          _context2.t2 = _context2[\"catch\"](18);\n          error = {\n            kind: \"OverlargePointersNotImplementedError\",\n            pointerAsBN: rawValueAsBN\n          };\n\n          if (!strict) {\n            _context2.next = 27;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error);\n\n        case 27:\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 28:\n          startPosition = rawValueAsNumber + base;\n          debug(\"startPosition %d\", startPosition);\n          _context2.prev = 30;\n          _allocate_1$abiSizeIn = allocate_1.abiSizeInfo(dataType, allocations);\n          dynamic = _allocate_1$abiSizeIn.dynamic;\n          size = _allocate_1$abiSizeIn.size;\n          _context2.next = 39;\n          break;\n\n        case 36:\n          _context2.prev = 36;\n          _context2.t3 = _context2[\"catch\"](30);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t3, strict));\n\n        case 39:\n          if (dynamic) {\n            _context2.next = 43;\n            break;\n          }\n\n          //this will only come up when called from stack.ts\n          staticPointer = {\n            location: location,\n            start: startPosition,\n            length: size\n          };\n          return _context2.delegateYield(decodeAbiReferenceStatic(dataType, staticPointer, info, options), \"t4\", 42);\n\n        case 42:\n          return _context2.abrupt(\"return\", _context2.t4);\n\n        case 43:\n          _context2.t5 = dataType.typeClass;\n          _context2.next = _context2.t5 === \"bytes\" ? 46 : _context2.t5 === \"string\" ? 46 : _context2.t5 === \"array\" ? 72 : _context2.t5 === \"struct\" ? 118 : _context2.t5 === \"tuple\" ? 120 : 122;\n          break;\n\n        case 46:\n          if (!(lengthOverride !== undefined)) {\n            _context2.next = 50;\n            break;\n          }\n\n          lengthAsBN = lengthOverride; //note in this case we do *not* increment start position;\n          //if a length override is given, that means the given start\n          //position skips over the length word!\n\n          _context2.next = 60;\n          break;\n\n        case 50:\n          _context2.prev = 50;\n          return _context2.delegateYield(read_1.default({\n            location: location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t6\", 52);\n\n        case 52:\n          rawLength = _context2.t6;\n          _context2.next = 58;\n          break;\n\n        case 55:\n          _context2.prev = 55;\n          _context2.t7 = _context2[\"catch\"](50);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t7, strict));\n\n        case 58:\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n          //so it'll be set up to read the data\n\n        case 60:\n          if (!(strict && lengthAsBN.gtn(state[location].length))) {\n            _context2.next = 62;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArrayOrStringStrictModeError\",\n            lengthAsBN: lengthAsBN,\n            dataLength: state[location].length\n          });\n\n        case 62:\n          _context2.prev = 62;\n          length = lengthAsBN.toNumber();\n          _context2.next = 69;\n          break;\n\n        case 66:\n          _context2.prev = 66;\n          _context2.t8 = _context2[\"catch\"](62);\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 69:\n          childPointer = {\n            location: location,\n            start: startPosition,\n            length: length\n          };\n          return _context2.delegateYield(Bytes.Decode.decodeBytes(dataType, childPointer, info, options), \"t9\", 71);\n\n        case 71:\n          return _context2.abrupt(\"return\", _context2.t9);\n\n        case 72:\n          if (!(dataType.kind === \"static\")) {\n            _context2.next = 76;\n            break;\n          }\n\n          //static-length array\n          lengthAsBN = dataType.length; //note we don't increment start position; static arrays don't\n          //include a length word!\n\n          _context2.next = 91;\n          break;\n\n        case 76:\n          if (!(lengthOverride !== undefined)) {\n            _context2.next = 81;\n            break;\n          }\n\n          debug(\"override: %o\", lengthOverride); //dynamic-length array, but with length override\n\n          lengthAsBN = lengthOverride; //we don't increment start position; if a length override was\n          //given, that means the pointer skipped the length word!\n\n          _context2.next = 91;\n          break;\n\n        case 81:\n          _context2.prev = 81;\n          return _context2.delegateYield(read_1.default({\n            location: location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t10\", 83);\n\n        case 83:\n          rawLength = _context2.t10;\n          _context2.next = 89;\n          break;\n\n        case 86:\n          _context2.prev = 86;\n          _context2.t11 = _context2[\"catch\"](81);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t11, strict));\n\n        case 89:\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n\n        case 91:\n          if (!(strict && lengthAsBN.gtn(state[location].length))) {\n            _context2.next = 93;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN: lengthAsBN,\n            dataLength: state[location].length\n          });\n\n        case 93:\n          _context2.prev = 93;\n          length = lengthAsBN.toNumber();\n          _context2.next = 100;\n          break;\n\n        case 97:\n          _context2.prev = 97;\n          _context2.t12 = _context2[\"catch\"](93);\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 100:\n          _context2.prev = 100;\n          baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;\n          _context2.next = 107;\n          break;\n\n        case 104:\n          _context2.prev = 104;\n          _context2.t13 = _context2[\"catch\"](100);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t13, strict));\n\n        case 107:\n          decodedChildren = [];\n          index = 0;\n\n        case 109:\n          if (!(index < length)) {\n            _context2.next = 117;\n            break;\n          }\n\n          _context2.t14 = decodedChildren;\n          return _context2.delegateYield(decodeAbi(dataType.baseType, {\n            location: location,\n            start: startPosition + index * baseSize,\n            length: baseSize\n          }, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          })), \"t15\", 112);\n\n        case 112:\n          _context2.t16 = _context2.t15;\n\n          _context2.t14.push.call(_context2.t14, _context2.t16);\n\n        case 114:\n          index++;\n          _context2.next = 109;\n          break;\n\n        case 117:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 118:\n          return _context2.delegateYield(decodeAbiStructByPosition(dataType, location, startPosition, info, options), \"t17\", 119);\n\n        case 119:\n          return _context2.abrupt(\"return\", _context2.t17);\n\n        case 120:\n          return _context2.delegateYield(decodeAbiTupleByPosition(dataType, location, startPosition, info, options), \"t18\", 121);\n\n        case 121:\n          return _context2.abrupt(\"return\", _context2.t18);\n\n        case 122:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[7, 12], [18, 22], [30, 36], [50, 55], [62, 66], [81, 86], [93, 97], [100, 104]]);\n}\n\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\n\nfunction decodeAbiReferenceStatic(dataType, pointer, info) {\n  var options,\n      location,\n      lengthAsBN,\n      length,\n      error,\n      baseSize,\n      decodedChildren,\n      index,\n      _args3 = arguments;\n  return _regeneratorRuntime.wrap(function decodeAbiReferenceStatic$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};\n          debug(\"static\");\n          debug(\"pointer %o\", pointer);\n          location = pointer.location;\n          _context3.t0 = dataType.typeClass;\n          _context3.next = _context3.t0 === \"array\" ? 7 : _context3.t0 === \"struct\" ? 36 : _context3.t0 === \"tuple\" ? 38 : 40;\n          break;\n\n        case 7:\n          //we're in the static case, so we know the array must be statically sized\n          lengthAsBN = dataType.length;\n          _context3.prev = 8;\n          length = lengthAsBN.toNumber();\n          _context3.next = 18;\n          break;\n\n        case 12:\n          _context3.prev = 12;\n          _context3.t1 = _context3[\"catch\"](8);\n          //note: since this is the static case, we don't bother including the stronger\n          //strict-mode guard against getting DOSed by large array sizes, since in this\n          //case we're not reading the size from the input; if there's a huge static size\n          //array, well, we'll just have to deal with it\n          error = {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN: lengthAsBN\n          };\n\n          if (!options.strictAbiMode) {\n            _context3.next = 17;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error);\n\n        case 17:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 18:\n          _context3.prev = 18;\n          baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;\n          _context3.next = 25;\n          break;\n\n        case 22:\n          _context3.prev = 22;\n          _context3.t2 = _context3[\"catch\"](18);\n          return _context3.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context3.t2, options.strictAbiMode));\n\n        case 25:\n          decodedChildren = [];\n          index = 0;\n\n        case 27:\n          if (!(index < length)) {\n            _context3.next = 35;\n            break;\n          }\n\n          _context3.t3 = decodedChildren;\n          return _context3.delegateYield(decodeAbi(dataType.baseType, {\n            location: location,\n            start: pointer.start + index * baseSize,\n            length: baseSize\n          }, info, options), \"t4\", 30);\n\n        case 30:\n          _context3.t5 = _context3.t4;\n\n          _context3.t3.push.call(_context3.t3, _context3.t5);\n\n        case 32:\n          index++;\n          _context3.next = 27;\n          break;\n\n        case 35:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 36:\n          return _context3.delegateYield(decodeAbiStructByPosition(dataType, location, pointer.start, info, options), \"t6\", 37);\n\n        case 37:\n          return _context3.abrupt(\"return\", _context3.t6);\n\n        case 38:\n          return _context3.delegateYield(decodeAbiTupleByPosition(dataType, location, pointer.start, info, options), \"t7\", 39);\n\n        case 39:\n          return _context3.abrupt(\"return\", _context3.t7);\n\n        case 40:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, null, [[8, 12], [18, 22]]);\n}\n\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic; //note that this function takes the start position as a *number*; it does not take a pointer\n\nfunction decodeAbiStructByPosition(dataType, location, startPosition, info) {\n  var options,\n      allocations,\n      typeLocation,\n      typeId,\n      structAllocation,\n      error,\n      decodedMembers,\n      index,\n      memberAllocation,\n      memberPointer,\n      childPointer,\n      memberName,\n      memberType,\n      _args4 = arguments;\n  return _regeneratorRuntime.wrap(function decodeAbiStructByPosition$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          options = _args4.length > 4 && _args4[4] !== undefined ? _args4[4] : {};\n          allocations = info.allocations.abi;\n          typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n\n          typeId = dataType.id;\n          structAllocation = allocations[typeId];\n\n          if (structAllocation) {\n            _context4.next = 10;\n            break;\n          }\n\n          error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: dataType\n          };\n\n          if (!(options.strictAbiMode || options.allowRetry)) {\n            _context4.next = 9;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error, true);\n\n        case 9:\n          return _context4.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 10:\n          decodedMembers = [];\n          index = 0;\n\n        case 12:\n          if (!(index < structAllocation.members.length)) {\n            _context4.next = 27;\n            break;\n          }\n\n          memberAllocation = structAllocation.members[index];\n          memberPointer = memberAllocation.pointer;\n          childPointer = {\n            location: location,\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length\n          };\n          memberName = memberAllocation.name;\n          memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n          _context4.t0 = decodedMembers;\n          _context4.t1 = memberName;\n          return _context4.delegateYield(decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          })), \"t2\", 21);\n\n        case 21:\n          _context4.t3 = _context4.t2;\n          _context4.t4 = {\n            name: _context4.t1,\n            value: _context4.t3\n          };\n\n          _context4.t0.push.call(_context4.t0, _context4.t4);\n\n        case 24:\n          index++;\n          _context4.next = 12;\n          break;\n\n        case 27:\n          return _context4.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 28:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n} //note that this function takes the start position as a *number*; it does not take a pointer\n\n\nfunction decodeAbiTupleByPosition(dataType, location, startPosition, info) {\n  var options,\n      decodedMembers,\n      position,\n      _iterator,\n      _step,\n      _step$value,\n      name,\n      memberType,\n      memberSize,\n      childPointer,\n      _args5 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeAbiTupleByPosition$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          options = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : {};\n          //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n          //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n          //However it may be worth revisiting this in the future if performance turns out to be a problem\n          //(changing this may be pretty hard though)\n          decodedMembers = [];\n          position = startPosition;\n          _iterator = _createForOfIteratorHelper(dataType.memberTypes);\n          _context5.prev = 4;\n\n          _iterator.s();\n\n        case 6:\n          if ((_step = _iterator.n()).done) {\n            _context5.next = 19;\n            break;\n          }\n\n          _step$value = _step.value, name = _step$value.name, memberType = _step$value.type;\n          memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;\n          childPointer = {\n            location: location,\n            start: position,\n            length: memberSize\n          };\n          _context5.t0 = decodedMembers;\n          _context5.t1 = name;\n          return _context5.delegateYield(decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          })), \"t2\", 13);\n\n        case 13:\n          _context5.t3 = _context5.t2;\n          _context5.t4 = {\n            name: _context5.t1,\n            value: _context5.t3\n          };\n\n          _context5.t0.push.call(_context5.t0, _context5.t4);\n\n          position += memberSize;\n\n        case 17:\n          _context5.next = 6;\n          break;\n\n        case 19:\n          _context5.next = 24;\n          break;\n\n        case 21:\n          _context5.prev = 21;\n          _context5.t5 = _context5[\"catch\"](4);\n\n          _iterator.e(_context5.t5);\n\n        case 24:\n          _context5.prev = 24;\n\n          _iterator.f();\n\n          return _context5.finish(24);\n\n        case 27:\n          return _context5.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 28:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5, null, [[4, 21, 24, 27]]);\n}","map":{"version":3,"sources":["../../../../lib/abi-data/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abi-data:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst errors_1 = require(\"../../errors\");\nfunction* decodeAbi(dataType, pointer, info, options = {}) {\n    if (Format.Types.isReferenceType(dataType) ||\n        dataType.typeClass === \"tuple\") {\n        //I don't want tuples to be considered a reference type, but it makes sense\n        //to group them for this purpose\n        let dynamic;\n        try {\n            dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;\n        }\n        catch (error) {\n            return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n        }\n        if (dynamic) {\n            return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);\n        }\n        else {\n            return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);\n        }\n    }\n    else {\n        debug(\"pointer %o\", pointer);\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n}\nexports.decodeAbi = decodeAbi;\nfunction* decodeAbiReferenceByAddress(dataType, pointer, info, options = {}) {\n    let { strictAbiMode: strict, abiPointerBase: base, lengthOverride } = options;\n    base = base || 0; //in case base was undefined\n    const { allocations: { abi: allocations }, state } = info;\n    debug(\"pointer %o\", pointer);\n    //this variable holds the location we should look to *next*\n    //stack pointers point to calldata; other pointers point to same location\n    const location = pointer.location === \"stack\" || pointer.location === \"stackliteral\"\n        ? \"calldata\"\n        : pointer.location;\n    if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n        //length overrides are only applicable when you're decoding a pointer\n        //from the stack!  otherwise they must be ignored!\n        lengthOverride = undefined;\n    }\n    let rawValue;\n    try {\n        rawValue = yield* read_1.default(pointer, state);\n    }\n    catch (error) {\n        return errors_1.handleDecodingError(dataType, error, strict);\n    }\n    let rawValueAsBN = Conversion.toBN(rawValue);\n    debug(\"rawValue: %O\", rawValue);\n    debug(\"rawValueAsBN: %O\", rawValueAsBN);\n    let rawValueAsNumber;\n    try {\n        rawValueAsNumber = rawValueAsBN.toNumber();\n    }\n    catch (_a) {\n        let error = {\n            kind: \"OverlargePointersNotImplementedError\",\n            pointerAsBN: rawValueAsBN\n        };\n        if (strict) {\n            throw new errors_1.StopDecodingError(error);\n        }\n        return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error\n        };\n    }\n    let startPosition = rawValueAsNumber + base;\n    debug(\"startPosition %d\", startPosition);\n    let dynamic;\n    let size;\n    try {\n        ({ dynamic, size } = allocate_1.abiSizeInfo(dataType, allocations));\n    }\n    catch (error) {\n        return errors_1.handleDecodingError(dataType, error, strict);\n    }\n    if (!dynamic) {\n        //this will only come up when called from stack.ts\n        let staticPointer = {\n            location,\n            start: startPosition,\n            length: size\n        };\n        return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);\n    }\n    let length;\n    let lengthAsBN;\n    let rawLength;\n    switch (dataType.typeClass) {\n        case \"bytes\":\n        case \"string\":\n            //initial word contains length (unless an override was given)\n            if (lengthOverride !== undefined) {\n                lengthAsBN = lengthOverride;\n                //note in this case we do *not* increment start position;\n                //if a length override is given, that means the given start\n                //position skips over the length word!\n            }\n            else {\n                try {\n                    rawLength = yield* read_1.default({\n                        location,\n                        start: startPosition,\n                        length: Evm.Utils.WORD_SIZE\n                    }, state);\n                }\n                catch (error) {\n                    return errors_1.handleDecodingError(dataType, error, strict);\n                }\n                lengthAsBN = Conversion.toBN(rawLength);\n                startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n                //so it'll be set up to read the data\n            }\n            if (strict && lengthAsBN.gtn(state[location].length)) {\n                //you may notice that the comparison is a bit crude; that's OK, this is\n                //just to prevent huge numbers from DOSing us, other errors will still\n                //be caught regardless\n                throw new errors_1.StopDecodingError({\n                    kind: \"OverlongArrayOrStringStrictModeError\",\n                    lengthAsBN,\n                    dataLength: state[location].length\n                });\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_b) {\n                //note: if we're in this situation, we can assume we're not in strict mode,\n                //as the strict case was handled above\n                return {\n                    //again with the TS failures...\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            let childPointer = {\n                location,\n                start: startPosition,\n                length\n            };\n            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);\n        case \"array\":\n            if (dataType.kind === \"static\") {\n                //static-length array\n                lengthAsBN = dataType.length;\n                //note we don't increment start position; static arrays don't\n                //include a length word!\n            }\n            else if (lengthOverride !== undefined) {\n                debug(\"override: %o\", lengthOverride);\n                //dynamic-length array, but with length override\n                lengthAsBN = lengthOverride;\n                //we don't increment start position; if a length override was\n                //given, that means the pointer skipped the length word!\n            }\n            else {\n                //dynamic-length array, read length from data\n                //initial word contains array length\n                try {\n                    rawLength = yield* read_1.default({\n                        location,\n                        start: startPosition,\n                        length: Evm.Utils.WORD_SIZE\n                    }, state);\n                }\n                catch (error) {\n                    return errors_1.handleDecodingError(dataType, error, strict);\n                }\n                lengthAsBN = Conversion.toBN(rawLength);\n                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n                //to next word, as first word was used for length\n            }\n            if (strict && lengthAsBN.gtn(state[location].length)) {\n                //you may notice that the comparison is a bit crude; that's OK, this is\n                //just to prevent huge numbers from DOSing us, other errors will still\n                //be caught regardless\n                throw new errors_1.StopDecodingError({\n                    kind: \"OverlongArraysAndStringsNotImplementedError\",\n                    lengthAsBN,\n                    dataLength: state[location].length\n                });\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_c) {\n                //again, if we get here, we can assume we're not in strict mode\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            //note: I've written this fairly generically, but it is worth noting that\n            //since this array is of dynamic type, we know that if it's static length\n            //then size must be EVM.WORD_SIZE\n            let baseSize;\n            try {\n                baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;\n            }\n            catch (error) {\n                return errors_1.handleDecodingError(dataType, error, strict);\n            }\n            let decodedChildren = [];\n            for (let index = 0; index < length; index++) {\n                decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n                    location,\n                    start: startPosition + index * baseSize,\n                    length: baseSize\n                }, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))); //pointer base is always start of list, never the length\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        case \"struct\":\n            return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);\n        case \"tuple\":\n            return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);\n    }\n}\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\nfunction* decodeAbiReferenceStatic(dataType, pointer, info, options = {}) {\n    debug(\"static\");\n    debug(\"pointer %o\", pointer);\n    const location = pointer.location;\n    switch (dataType.typeClass) {\n        case \"array\":\n            //we're in the static case, so we know the array must be statically sized\n            const lengthAsBN = dataType.length;\n            let length;\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_a) {\n                //note: since this is the static case, we don't bother including the stronger\n                //strict-mode guard against getting DOSed by large array sizes, since in this\n                //case we're not reading the size from the input; if there's a huge static size\n                //array, well, we'll just have to deal with it\n                let error = {\n                    kind: \"OverlongArraysAndStringsNotImplementedError\",\n                    lengthAsBN\n                };\n                if (options.strictAbiMode) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            let baseSize;\n            try {\n                baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;\n            }\n            catch (error) {\n                return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n            }\n            let decodedChildren = [];\n            for (let index = 0; index < length; index++) {\n                decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n                    location,\n                    start: pointer.start + index * baseSize,\n                    length: baseSize\n                }, info, options));\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        case \"struct\":\n            return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);\n        case \"tuple\":\n            return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);\n    }\n}\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic;\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction* decodeAbiStructByPosition(dataType, location, startPosition, info, options = {}) {\n    const { allocations: { abi: allocations } } = info;\n    const typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n    const typeId = dataType.id;\n    const structAllocation = allocations[typeId];\n    if (!structAllocation) {\n        let error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: dataType\n        };\n        if (options.strictAbiMode || options.allowRetry) {\n            throw new errors_1.StopDecodingError(error, true);\n            //note that we allow a retry if we couldn't locate the allocation!\n        }\n        return {\n            type: dataType,\n            kind: \"error\",\n            error\n        };\n    }\n    let decodedMembers = [];\n    for (let index = 0; index < structAllocation.members.length; index++) {\n        const memberAllocation = structAllocation.members[index];\n        const memberPointer = memberAllocation.pointer;\n        const childPointer = {\n            location,\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length\n        };\n        let memberName = memberAllocation.name;\n        let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n        decodedMembers.push({\n            name: memberName,\n            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))\n            //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n        });\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedMembers\n    };\n}\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction* decodeAbiTupleByPosition(dataType, location, startPosition, info, options = {}) {\n    //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n    //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n    //However it may be worth revisiting this in the future if performance turns out to be a problem\n    //(changing this may be pretty hard though)\n    let decodedMembers = [];\n    let position = startPosition;\n    for (const { name, type: memberType } of dataType.memberTypes) {\n        const memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;\n        const childPointer = {\n            location,\n            start: position,\n            length: memberSize\n        };\n        decodedMembers.push({\n            name,\n            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))\n            //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n        });\n        position += memberSize;\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedMembers\n    };\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}