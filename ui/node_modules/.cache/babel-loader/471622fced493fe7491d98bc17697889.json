{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeStorage),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeStorageReferenceByAddress),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeStorageReference);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:storage:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Utils = __importStar(require(\"../utils\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar allocate_1 = require(\"../allocate\");\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nfunction decodeStorage(dataType, pointer, info) {\n  return _regeneratorRuntime.wrap(function decodeStorage$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!Format.Types.isReferenceType(dataType)) {\n            _context.next = 5;\n            break;\n          }\n\n          return _context.delegateYield(decodeStorageReference(dataType, pointer, info), \"t0\", 2);\n\n        case 2:\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 5:\n          return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info), \"t1\", 6);\n\n        case 6:\n          return _context.abrupt(\"return\", _context.t1);\n\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.decodeStorage = decodeStorage; //decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.\n//NOTE: ONLY for use with pointers to reference types!\n//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...\n\nfunction decodeStorageReferenceByAddress(dataType, pointer, info) {\n  var allocations, rawValue, startOffset, rawSize, size, newPointer;\n  return _regeneratorRuntime.wrap(function decodeStorageReferenceByAddress$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          allocations = info.allocations.storage;\n          _context2.prev = 1;\n          return _context2.delegateYield(read_1.default(pointer, info.state), \"t0\", 3);\n\n        case 3:\n          rawValue = _context2.t0;\n          _context2.next = 9;\n          break;\n\n        case 6:\n          _context2.prev = 6;\n          _context2.t1 = _context2[\"catch\"](1);\n          return _context2.abrupt(\"return\", {\n            //no idea why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t1.error\n          });\n\n        case 9:\n          startOffset = Conversion.toBN(rawValue);\n          _context2.prev = 10;\n          rawSize = allocate_1.storageSize(dataType, info.userDefinedTypes, allocations);\n          _context2.next = 17;\n          break;\n\n        case 14:\n          _context2.prev = 14;\n          _context2.t2 = _context2[\"catch\"](10);\n          return _context2.abrupt(\"return\", {\n            //no idea why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t2.error\n          });\n\n        case 17:\n          //we *know* the type being decoded must be sized in words, because it's a\n          //reference type, but TypeScript doesn't, so we'll have to use a type\n          //coercion\n          size = rawSize.words; //now, construct the storage pointer\n\n          newPointer = {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: {\n                  offset: startOffset\n                },\n                index: 0\n              },\n              to: {\n                slot: {\n                  offset: startOffset.addn(size - 1)\n                },\n                index: Evm.Utils.WORD_SIZE - 1\n              }\n            }\n          }; //dispatch to decodeStorageReference\n\n          return _context2.delegateYield(decodeStorageReference(dataType, newPointer, info), \"t3\", 20);\n\n        case 20:\n          return _context2.abrupt(\"return\", _context2.t3);\n\n        case 21:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[1, 6], [10, 14]]);\n}\n\nexports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;\n\nfunction decodeStorageReference(dataType, pointer, info) {\n  var data, length, state, allocations, lengthAsBN, baseSize, ranges, currentSlot, i, childRange, perWord, currentPosition, _i, _childRange, decodedChildren, _i2, _ranges, _childRange2, lengthByte, _lengthAsBN, typeId, structAllocation, decodedMembers, members, index, memberAllocation, memberPointer, _childRange3, storedType, storedMemberType, memberType, valueType, valueSize, decodedEntries, baseSlot, keySlots, _iterator, _step, key, valuePointer;\n\n  return _regeneratorRuntime.wrap(function decodeStorageReference$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          state = info.state;\n          allocations = info.allocations.storage;\n          _context3.t0 = dataType.typeClass;\n          _context3.next = _context3.t0 === \"array\" ? 5 : _context3.t0 === \"bytes\" ? 55 : _context3.t0 === \"string\" ? 55 : _context3.t0 === \"struct\" ? 82 : _context3.t0 === \"mapping\" ? 109 : 148;\n          break;\n\n        case 5:\n          debug(\"storage array! %o\", pointer);\n          _context3.t1 = dataType.kind;\n          _context3.next = _context3.t1 === \"dynamic\" ? 9 : _context3.t1 === \"static\" ? 21 : 24;\n          break;\n\n        case 9:\n          debug(\"dynamic array\");\n          debug(\"type %O\", dataType);\n          _context3.prev = 11;\n          return _context3.delegateYield(read_1.default(pointer, state), \"t2\", 13);\n\n        case 13:\n          data = _context3.t2;\n          _context3.next = 19;\n          break;\n\n        case 16:\n          _context3.prev = 16;\n          _context3.t3 = _context3[\"catch\"](11);\n          return _context3.abrupt(\"return\", {\n            //no idea why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context3.t3.error\n          });\n\n        case 19:\n          lengthAsBN = Conversion.toBN(data);\n          return _context3.abrupt(\"break\", 24);\n\n        case 21:\n          debug(\"static array\");\n          lengthAsBN = dataType.length;\n          return _context3.abrupt(\"break\", 24);\n\n        case 24:\n          _context3.prev = 24;\n          length = lengthAsBN.toNumber();\n          _context3.next = 31;\n          break;\n\n        case 28:\n          _context3.prev = 28;\n          _context3.t4 = _context3[\"catch\"](24);\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 31:\n          debug(\"length %o\", length);\n          debug(\"about to determine baseSize\");\n          _context3.prev = 33;\n          baseSize = allocate_1.storageSize(dataType.baseType, info.userDefinedTypes, allocations);\n          _context3.next = 40;\n          break;\n\n        case 37:\n          _context3.prev = 37;\n          _context3.t5 = _context3[\"catch\"](33);\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _context3.t5.error\n          });\n\n        case 40:\n          debug(\"baseSize %o\", baseSize); //we are going to make a list of child ranges, pushing them one by one onto\n          //this list, and then decode them; the first part will vary based on whether\n          //we're in the words case or the bytes case, the second will not\n\n          ranges = [];\n\n          if (Utils.isWordsLength(baseSize)) {\n            //currentSlot will point to the start of the entry being decoded\n            currentSlot = {\n              path: pointer.range.from.slot,\n              offset: new bn_js_1.default(0),\n              hashPath: dataType.kind === \"dynamic\"\n            };\n\n            for (i = 0; i < length; i++) {\n              childRange = {\n                from: {\n                  slot: {\n                    path: currentSlot.path,\n                    offset: currentSlot.offset.clone(),\n                    hashPath: currentSlot.hashPath\n                  },\n                  index: 0\n                },\n                to: {\n                  slot: {\n                    path: currentSlot.path,\n                    offset: currentSlot.offset.addn(baseSize.words - 1),\n                    hashPath: currentSlot.hashPath\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              };\n              ranges.push(childRange);\n              currentSlot.offset.iaddn(baseSize.words);\n            }\n          } else {\n            perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n            debug(\"perWord %d\", perWord); //currentPosition will point to the start of the entry being decoded\n            //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE\n\n            currentPosition = {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: new bn_js_1.default(0),\n                hashPath: dataType.kind === \"dynamic\"\n              },\n              index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!\n\n            };\n\n            for (_i = 0; _i < length; _i++) {\n              _childRange = {\n                from: {\n                  slot: {\n                    path: currentPosition.slot.path,\n                    offset: currentPosition.slot.offset.clone(),\n                    hashPath: currentPosition.slot.hashPath\n                  },\n                  index: currentPosition.index\n                },\n                length: baseSize.bytes\n              };\n              ranges.push(_childRange);\n              currentPosition.index -= baseSize.bytes;\n\n              if (currentPosition.index < 0) {\n                currentPosition.slot.offset.iaddn(1);\n                currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;\n              }\n            }\n          }\n\n          decodedChildren = [];\n          _i2 = 0, _ranges = ranges;\n\n        case 45:\n          if (!(_i2 < _ranges.length)) {\n            _context3.next = 54;\n            break;\n          }\n\n          _childRange2 = _ranges[_i2];\n          _context3.t6 = decodedChildren;\n          return _context3.delegateYield(decodeStorage(dataType.baseType, {\n            location: \"storage\",\n            range: _childRange2\n          }, info), \"t7\", 49);\n\n        case 49:\n          _context3.t8 = _context3.t7;\n\n          _context3.t6.push.call(_context3.t6, _context3.t8);\n\n        case 51:\n          _i2++;\n          _context3.next = 45;\n          break;\n\n        case 54:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 55:\n          _context3.prev = 55;\n          return _context3.delegateYield(read_1.default(pointer, state), \"t9\", 57);\n\n        case 57:\n          data = _context3.t9;\n          _context3.next = 63;\n          break;\n\n        case 60:\n          _context3.prev = 60;\n          _context3.t10 = _context3[\"catch\"](55);\n          return _context3.abrupt(\"return\", {\n            //no idea why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context3.t10.error\n          });\n\n        case 63:\n          lengthByte = data[Evm.Utils.WORD_SIZE - 1];\n\n          if (!(lengthByte % 2 == 0)) {\n            _context3.next = 71;\n            break;\n          }\n\n          // string lives in word, length is last byte / 2\n          length = lengthByte / 2;\n          debug(\"in-word; length %o\", length);\n          return _context3.delegateYield(Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: pointer.range.from.slot,\n                index: 0\n              },\n              to: {\n                slot: pointer.range.from.slot,\n                index: length - 1\n              }\n            }\n          }, info), \"t11\", 68);\n\n        case 68:\n          return _context3.abrupt(\"return\", _context3.t11);\n\n        case 71:\n          _lengthAsBN = Conversion.toBN(data).subn(1).divn(2);\n          _context3.prev = 72;\n          length = _lengthAsBN.toNumber();\n          _context3.next = 79;\n          break;\n\n        case 76:\n          _context3.prev = 76;\n          _context3.t12 = _context3[\"catch\"](72);\n          return _context3.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: _lengthAsBN\n            }\n          });\n\n        case 79:\n          debug(\"new-word, length %o\", length);\n          return _context3.delegateYield(Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: {\n                  path: pointer.range.from.slot,\n                  offset: new bn_js_1.default(0),\n                  hashPath: true\n                },\n                index: 0\n              },\n              length: length\n            }\n          }, info), \"t13\", 81);\n\n        case 81:\n          return _context3.abrupt(\"return\", _context3.t13);\n\n        case 82:\n          typeId = dataType.id;\n          structAllocation = allocations[typeId];\n\n          if (structAllocation) {\n            _context3.next = 86;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          });\n\n        case 86:\n          decodedMembers = [];\n          members = structAllocation.members;\n          index = 0;\n\n        case 89:\n          if (!(index < members.length)) {\n            _context3.next = 108;\n            break;\n          }\n\n          memberAllocation = members[index];\n          memberPointer = memberAllocation.pointer; //the type system thinks memberPointer might also be a constant\n          //definition pointer.  However, structs can't contain constants,\n          //so *we* know it's not, and can safely coerce it.\n\n          debug(\"pointer %O\", pointer);\n          _childRange3 = {\n            from: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.from.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.from.index\n            },\n            to: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.to.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.to.index\n            }\n          };\n          storedType = info.userDefinedTypes[typeId];\n\n          if (storedType) {\n            _context3.next = 97;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          });\n\n        case 97:\n          storedMemberType = storedType.memberTypes[index].type;\n          memberType = Format.Types.specifyLocation(storedMemberType, \"storage\");\n          _context3.t14 = decodedMembers;\n          _context3.t15 = memberAllocation.name;\n          return _context3.delegateYield(decodeStorage(memberType, {\n            location: \"storage\",\n            range: _childRange3\n          }, info), \"t16\", 102);\n\n        case 102:\n          _context3.t17 = _context3.t16;\n          _context3.t18 = {\n            name: _context3.t15,\n            value: _context3.t17\n          };\n\n          _context3.t14.push.call(_context3.t14, _context3.t18);\n\n        case 105:\n          index++;\n          _context3.next = 89;\n          break;\n\n        case 108:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 109:\n          debug(\"decoding mapping\");\n          valueType = dataType.valueType;\n          _context3.prev = 111;\n          valueSize = allocate_1.storageSize(valueType, info.userDefinedTypes, allocations);\n          _context3.next = 119;\n          break;\n\n        case 115:\n          _context3.prev = 115;\n          _context3.t19 = _context3[\"catch\"](111);\n          //error: DecodingError\n          debug(\"couldn't get value size! error: %o\", _context3.t19);\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _context3.t19.error\n          });\n\n        case 119:\n          decodedEntries = [];\n          baseSlot = pointer.range.from.slot;\n          debug(\"baseSlot %o\", baseSlot);\n          debug(\"base slot address %o\", Utils.slotAddress(baseSlot));\n          keySlots = info.mappingKeys.filter(function (_ref) {\n            var path = _ref.path;\n            return Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path));\n          });\n          _iterator = _createForOfIteratorHelper(keySlots);\n          _context3.prev = 125;\n\n          _iterator.s();\n\n        case 127:\n          if ((_step = _iterator.n()).done) {\n            _context3.next = 139;\n            break;\n          }\n\n          key = _step.value.key;\n          valuePointer = void 0;\n\n          if (Utils.isWordsLength(valueSize)) {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key: key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: 0\n                },\n                to: {\n                  slot: {\n                    key: key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(valueSize.words - 1)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          } else {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key: key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - valueSize.bytes\n                },\n                to: {\n                  slot: {\n                    key: key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          }\n\n          _context3.t20 = decodedEntries;\n          _context3.t21 = key;\n          return _context3.delegateYield(decodeStorage(valueType, valuePointer, info), \"t22\", 134);\n\n        case 134:\n          _context3.t23 = _context3.t22;\n          _context3.t24 = {\n            key: _context3.t21,\n            value: _context3.t23\n          };\n\n          _context3.t20.push.call(_context3.t20, _context3.t24);\n\n        case 137:\n          _context3.next = 127;\n          break;\n\n        case 139:\n          _context3.next = 144;\n          break;\n\n        case 141:\n          _context3.prev = 141;\n          _context3.t25 = _context3[\"catch\"](125);\n\n          _iterator.e(_context3.t25);\n\n        case 144:\n          _context3.prev = 144;\n\n          _iterator.f();\n\n          return _context3.finish(144);\n\n        case 147:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedEntries\n          });\n\n        case 148:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, null, [[11, 16], [24, 28], [33, 37], [55, 60], [72, 76], [111, 115], [125, 141, 144, 147]]);\n}\n\nexports.decodeStorageReference = decodeStorageReference;","map":{"version":3,"sources":["../../../../lib/storage/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:storage:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nfunction* decodeStorage(dataType, pointer, info) {\n    if (Format.Types.isReferenceType(dataType)) {\n        return yield* decodeStorageReference(dataType, pointer, info);\n    }\n    else {\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info);\n    }\n}\nexports.decodeStorage = decodeStorage;\n//decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.\n//NOTE: ONLY for use with pointers to reference types!\n//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...\nfunction* decodeStorageReferenceByAddress(dataType, pointer, info) {\n    const allocations = info.allocations.storage;\n    let rawValue;\n    try {\n        rawValue = yield* read_1.default(pointer, info.state);\n    }\n    catch (error) {\n        return {\n            //no idea why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: error.error\n        };\n    }\n    const startOffset = Conversion.toBN(rawValue);\n    let rawSize;\n    try {\n        rawSize = allocate_1.storageSize(dataType, info.userDefinedTypes, allocations);\n    }\n    catch (error) {\n        //error: DecodingError\n        return {\n            //no idea why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: error.error\n        };\n    }\n    //we *know* the type being decoded must be sized in words, because it's a\n    //reference type, but TypeScript doesn't, so we'll have to use a type\n    //coercion\n    const size = rawSize.words;\n    //now, construct the storage pointer\n    const newPointer = {\n        location: \"storage\",\n        range: {\n            from: {\n                slot: {\n                    offset: startOffset\n                },\n                index: 0\n            },\n            to: {\n                slot: {\n                    offset: startOffset.addn(size - 1)\n                },\n                index: Evm.Utils.WORD_SIZE - 1\n            }\n        }\n    };\n    //dispatch to decodeStorageReference\n    return yield* decodeStorageReference(dataType, newPointer, info);\n}\nexports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;\nfunction* decodeStorageReference(dataType, pointer, info) {\n    var data;\n    var length;\n    const { state } = info;\n    const allocations = info.allocations.storage;\n    switch (dataType.typeClass) {\n        case \"array\": {\n            debug(\"storage array! %o\", pointer);\n            let lengthAsBN;\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    debug(\"dynamic array\");\n                    debug(\"type %O\", dataType);\n                    try {\n                        data = yield* read_1.default(pointer, state);\n                    }\n                    catch (error) {\n                        return {\n                            //no idea why TS is failing here\n                            type: dataType,\n                            kind: \"error\",\n                            error: error.error\n                        };\n                    }\n                    lengthAsBN = Conversion.toBN(data);\n                    break;\n                case \"static\":\n                    debug(\"static array\");\n                    lengthAsBN = dataType.length;\n                    break;\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            debug(\"length %o\", length);\n            debug(\"about to determine baseSize\");\n            let baseSize;\n            try {\n                baseSize = allocate_1.storageSize(dataType.baseType, info.userDefinedTypes, allocations);\n            }\n            catch (error) {\n                //error: DecodingError\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: error.error\n                };\n            }\n            debug(\"baseSize %o\", baseSize);\n            //we are going to make a list of child ranges, pushing them one by one onto\n            //this list, and then decode them; the first part will vary based on whether\n            //we're in the words case or the bytes case, the second will not\n            let ranges = [];\n            if (Utils.isWordsLength(baseSize)) {\n                //currentSlot will point to the start of the entry being decoded\n                let currentSlot = {\n                    path: pointer.range.from.slot,\n                    offset: new bn_js_1.default(0),\n                    hashPath: dataType.kind === \"dynamic\"\n                };\n                for (let i = 0; i < length; i++) {\n                    let childRange = {\n                        from: {\n                            slot: {\n                                path: currentSlot.path,\n                                offset: currentSlot.offset.clone(),\n                                hashPath: currentSlot.hashPath\n                            },\n                            index: 0\n                        },\n                        to: {\n                            slot: {\n                                path: currentSlot.path,\n                                offset: currentSlot.offset.addn(baseSize.words - 1),\n                                hashPath: currentSlot.hashPath\n                            },\n                            index: Evm.Utils.WORD_SIZE - 1\n                        }\n                    };\n                    ranges.push(childRange);\n                    currentSlot.offset.iaddn(baseSize.words);\n                }\n            }\n            else {\n                const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n                debug(\"perWord %d\", perWord);\n                //currentPosition will point to the start of the entry being decoded\n                //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE\n                let currentPosition = {\n                    slot: {\n                        path: pointer.range.from.slot,\n                        offset: new bn_js_1.default(0),\n                        hashPath: dataType.kind === \"dynamic\"\n                    },\n                    index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!\n                };\n                for (let i = 0; i < length; i++) {\n                    let childRange = {\n                        from: {\n                            slot: {\n                                path: currentPosition.slot.path,\n                                offset: currentPosition.slot.offset.clone(),\n                                hashPath: currentPosition.slot.hashPath\n                            },\n                            index: currentPosition.index\n                        },\n                        length: baseSize.bytes\n                    };\n                    ranges.push(childRange);\n                    currentPosition.index -= baseSize.bytes;\n                    if (currentPosition.index < 0) {\n                        currentPosition.slot.offset.iaddn(1);\n                        currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;\n                    }\n                }\n            }\n            let decodedChildren = [];\n            for (let childRange of ranges) {\n                decodedChildren.push(yield* decodeStorage(dataType.baseType, { location: \"storage\", range: childRange }, info));\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        }\n        case \"bytes\":\n        case \"string\": {\n            try {\n                data = yield* read_1.default(pointer, state);\n            }\n            catch (error) {\n                return {\n                    //no idea why TS is failing here\n                    type: dataType,\n                    kind: \"error\",\n                    error: error.error\n                };\n            }\n            let lengthByte = data[Evm.Utils.WORD_SIZE - 1];\n            if (lengthByte % 2 == 0) {\n                // string lives in word, length is last byte / 2\n                length = lengthByte / 2;\n                debug(\"in-word; length %o\", length);\n                return yield* Bytes.Decode.decodeBytes(dataType, {\n                    location: \"storage\",\n                    range: {\n                        from: { slot: pointer.range.from.slot, index: 0 },\n                        to: { slot: pointer.range.from.slot, index: length - 1 }\n                    }\n                }, info);\n            }\n            else {\n                let lengthAsBN = Conversion.toBN(data)\n                    .subn(1)\n                    .divn(2);\n                try {\n                    length = lengthAsBN.toNumber();\n                }\n                catch (_) {\n                    return {\n                        //again with the TS failures...\n                        type: dataType,\n                        kind: \"error\",\n                        error: {\n                            kind: \"OverlongArraysAndStringsNotImplementedError\",\n                            lengthAsBN\n                        }\n                    };\n                }\n                debug(\"new-word, length %o\", length);\n                return yield* Bytes.Decode.decodeBytes(dataType, {\n                    location: \"storage\",\n                    range: {\n                        from: {\n                            slot: {\n                                path: pointer.range.from.slot,\n                                offset: new bn_js_1.default(0),\n                                hashPath: true\n                            },\n                            index: 0\n                        },\n                        length\n                    }\n                }, info);\n            }\n        }\n        case \"struct\": {\n            const typeId = dataType.id;\n            const structAllocation = allocations[typeId];\n            if (!structAllocation) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"UserDefinedTypeNotFoundError\",\n                        type: dataType\n                    }\n                };\n            }\n            let decodedMembers = [];\n            const members = structAllocation.members;\n            for (let index = 0; index < members.length; index++) {\n                const memberAllocation = members[index];\n                const memberPointer = memberAllocation.pointer;\n                //the type system thinks memberPointer might also be a constant\n                //definition pointer.  However, structs can't contain constants,\n                //so *we* know it's not, and can safely coerce it.\n                debug(\"pointer %O\", pointer);\n                const childRange = {\n                    from: {\n                        slot: {\n                            path: pointer.range.from.slot,\n                            offset: memberPointer.range.from.slot.offset.clone()\n                            //note that memberPointer should have no path\n                        },\n                        index: memberPointer.range.from.index\n                    },\n                    to: {\n                        slot: {\n                            path: pointer.range.from.slot,\n                            offset: memberPointer.range.to.slot.offset.clone()\n                            //note that memberPointer should have no path\n                        },\n                        index: memberPointer.range.to.index\n                    }\n                };\n                let storedType = info.userDefinedTypes[typeId];\n                if (!storedType) {\n                    return {\n                        type: dataType,\n                        kind: \"error\",\n                        error: {\n                            kind: \"UserDefinedTypeNotFoundError\",\n                            type: dataType\n                        }\n                    };\n                }\n                let storedMemberType = storedType.memberTypes[index].type;\n                let memberType = Format.Types.specifyLocation(storedMemberType, \"storage\");\n                decodedMembers.push({\n                    name: memberAllocation.name,\n                    value: yield* decodeStorage(memberType, { location: \"storage\", range: childRange }, info)\n                });\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedMembers\n            };\n        }\n        case \"mapping\": {\n            debug(\"decoding mapping\");\n            const valueType = dataType.valueType;\n            let valueSize;\n            try {\n                valueSize = allocate_1.storageSize(valueType, info.userDefinedTypes, allocations);\n            }\n            catch (error) {\n                //error: DecodingError\n                debug(\"couldn't get value size! error: %o\", error);\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: error.error\n                };\n            }\n            let decodedEntries = [];\n            const baseSlot = pointer.range.from.slot;\n            debug(\"baseSlot %o\", baseSlot);\n            debug(\"base slot address %o\", Utils.slotAddress(baseSlot));\n            const keySlots = info.mappingKeys.filter(({ path }) => Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path)));\n            for (const { key } of keySlots) {\n                let valuePointer;\n                if (Utils.isWordsLength(valueSize)) {\n                    valuePointer = {\n                        location: \"storage\",\n                        range: {\n                            from: {\n                                slot: {\n                                    key,\n                                    path: baseSlot,\n                                    offset: new bn_js_1.default(0)\n                                },\n                                index: 0\n                            },\n                            to: {\n                                slot: {\n                                    key,\n                                    path: baseSlot,\n                                    offset: new bn_js_1.default(valueSize.words - 1)\n                                },\n                                index: Evm.Utils.WORD_SIZE - 1\n                            }\n                        }\n                    };\n                }\n                else {\n                    valuePointer = {\n                        location: \"storage\",\n                        range: {\n                            from: {\n                                slot: {\n                                    key,\n                                    path: baseSlot,\n                                    offset: new bn_js_1.default(0)\n                                },\n                                index: Evm.Utils.WORD_SIZE - valueSize.bytes\n                            },\n                            to: {\n                                slot: {\n                                    key,\n                                    path: baseSlot,\n                                    offset: new bn_js_1.default(0)\n                                },\n                                index: Evm.Utils.WORD_SIZE - 1\n                            }\n                        }\n                    };\n                }\n                decodedEntries.push({\n                    key,\n                    value: yield* decodeStorage(valueType, valuePointer, info)\n                });\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedEntries\n            };\n        }\n    }\n}\nexports.decodeStorageReference = decodeStorageReference;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}