{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(readCode);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readBytes = exports.readCode = void 0;\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar errors_1 = require(\"../../errors\");\n\nfunction readCode(pointer, state) {\n  var code;\n  return _regeneratorRuntime.wrap(function readCode$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          code = state.code;\n\n          if (code) {\n            _context.next = 5;\n            break;\n          }\n\n          _context.next = 4;\n          return {\n            type: \"code\",\n            address: Evm.Utils.toAddress(state.specials.this)\n          };\n\n        case 4:\n          code = _context.sent;\n\n        case 5:\n          return _context.abrupt(\"return\", readBytes(pointer, Object.assign(Object.assign({}, state), {\n            code: code\n          })));\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.readCode = readCode;\n\nfunction readBytes(pointer, state) {\n  var sourceBytes = state[pointer.location];\n  var offset = pointer.start,\n      length = pointer.length;\n\n  if (!Number.isSafeInteger(offset + length)) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorBytes\",\n      location: pointer.location,\n      start: offset,\n      length: length\n    });\n  } // grab `length` bytes no matter what, here fill this array\n\n\n  var bytes = new Uint8Array(length);\n  bytes.fill(0); //fill it wil zeroes to start\n  //if the start is beyond the end of the source, just return those 0s\n\n  if (offset >= sourceBytes.length) {\n    return bytes;\n  } // if we're reading past the end of the source, truncate the length to read\n\n\n  var excess = offset + length - sourceBytes.length;\n  var readLength;\n\n  if (excess > 0) {\n    readLength = sourceBytes.length - offset;\n  } else {\n    readLength = length;\n  } //get the (truncated) bytes\n\n\n  var existing = new Uint8Array(sourceBytes.buffer, offset, readLength); //copy it into our buffer\n\n  bytes.set(existing);\n  return bytes;\n}\n\nexports.readBytes = readBytes;","map":{"version":3,"sources":["../../../../lib/bytes/read/index.ts"],"names":[],"mappings":";;;;oDAKiB,Q;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AALjB,IAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAGA,SAAiB,QAAjB,CACE,OADF,EAEE,KAFF;AAAA;AAAA;AAAA;AAAA;AAAA;AAIM,UAAA,IAJN,GAIa,KAAK,CAAC,IAJnB;;AAAA,cAKO,IALP;AAAA;AAAA;AAAA;;AAAA;AAMW,iBAAM;AACX,YAAA,IAAI,EAAE,MADK;AAEX,YAAA,OAAO,EAAE,GAAG,CAAC,KAAJ,CAAU,SAAV,CAAoB,KAAK,CAAC,QAAN,CAAe,IAAnC;AAFE,WAAN;;AANX;AAMI,UAAA,IANJ;;AAAA;AAAA,2CAWS,SAAS,CAAC,OAAD,EAAQ,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,KAAP,CAAA,EAAY;AAAE,YAAA,IAAI,EAAJ;AAAF,WAAZ,CAAR,CAXlB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,OAAA,CAAA,QAAA,GAAA,QAAA;;AAcA,SAAgB,SAAhB,CACE,OADF,EAEE,KAFF,EAEqB;AAEnB,MAAI,WAAW,GAAG,KAAK,CAAC,OAAO,CAAC,QAAT,CAAvB;AAFmB,MAIJ,MAJI,GAIe,OAJf,CAIX,KAJW;AAAA,MAII,MAJJ,GAIe,OAJf,CAII,MAJJ;;AAKnB,MAAI,CAAC,MAAM,CAAC,aAAP,CAAqB,MAAM,GAAG,MAA9B,CAAL,EAA4C;AAC1C,UAAM,IAAI,QAAA,CAAA,aAAJ,CAAkB;AACtB,MAAA,IAAI,EAAE,gBADgB;AAEtB,MAAA,QAAQ,EAAE,OAAO,CAAC,QAFI;AAGtB,MAAA,KAAK,EAAE,MAHe;AAItB,MAAA,MAAM,EAAN;AAJsB,KAAlB,CAAN;AAMD,GAZkB,CAcnB;;;AACA,MAAI,KAAK,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAZ;AACA,EAAA,KAAK,CAAC,IAAN,CAAW,CAAX,EAhBmB,CAgBJ;AAEf;;AACA,MAAI,MAAM,IAAI,WAAW,CAAC,MAA1B,EAAkC;AAChC,WAAO,KAAP;AACD,GArBkB,CAuBnB;;;AACA,MAAI,MAAM,GAAG,MAAM,GAAG,MAAT,GAAkB,WAAW,CAAC,MAA3C;AACA,MAAI,UAAJ;;AACA,MAAI,MAAM,GAAG,CAAb,EAAgB;AACd,IAAA,UAAU,GAAG,WAAW,CAAC,MAAZ,GAAqB,MAAlC;AACD,GAFD,MAEO;AACL,IAAA,UAAU,GAAG,MAAb;AACD,GA9BkB,CAgCnB;;;AACA,MAAI,QAAQ,GAAG,IAAI,UAAJ,CAAe,WAAW,CAAC,MAA3B,EAAmC,MAAnC,EAA2C,UAA3C,CAAf,CAjCmB,CAmCnB;;AACA,EAAA,KAAK,CAAC,GAAN,CAAU,QAAV;AAEA,SAAO,KAAP;AACD;;AAzCD,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readBytes = exports.readCode = void 0;\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* readCode(pointer, state) {\n    let code = state.code;\n    if (!code) {\n        code = yield {\n            type: \"code\",\n            address: Evm.Utils.toAddress(state.specials.this)\n        };\n    }\n    return readBytes(pointer, Object.assign(Object.assign({}, state), { code }));\n}\nexports.readCode = readCode;\nfunction readBytes(pointer, state) {\n    let sourceBytes = state[pointer.location];\n    const { start: offset, length } = pointer;\n    if (!Number.isSafeInteger(offset + length)) {\n        throw new errors_1.DecodingError({\n            kind: \"ReadErrorBytes\",\n            location: pointer.location,\n            start: offset,\n            length\n        });\n    }\n    // grab `length` bytes no matter what, here fill this array\n    var bytes = new Uint8Array(length);\n    bytes.fill(0); //fill it wil zeroes to start\n    //if the start is beyond the end of the source, just return those 0s\n    if (offset >= sourceBytes.length) {\n        return bytes;\n    }\n    // if we're reading past the end of the source, truncate the length to read\n    let excess = offset + length - sourceBytes.length;\n    let readLength;\n    if (excess > 0) {\n        readLength = sourceBytes.length - offset;\n    }\n    else {\n        readLength = length;\n    }\n    //get the (truncated) bytes\n    let existing = new Uint8Array(sourceBytes.buffer, offset, readLength);\n    //copy it into our buffer\n    bytes.set(existing);\n    return bytes;\n}\nexports.readBytes = readBytes;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}