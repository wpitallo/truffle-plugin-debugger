{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:storage:allocate\");\n\nvar Common = __importStar(require(\"../../common\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Utils = __importStar(require(\"../utils\"));\n\nvar Ast = __importStar(require(\"../../ast\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\n\nvar UnknownBaseContractIdError = /*#__PURE__*/function (_Error) {\n  _inherits(UnknownBaseContractIdError, _Error);\n\n  var _super = _createSuper(UnknownBaseContractIdError);\n\n  function UnknownBaseContractIdError(derivedId, derivedName, derivedKind, baseId) {\n    var _this;\n\n    _classCallCheck(this, UnknownBaseContractIdError);\n\n    var message = \"Cannot locate base contract ID \".concat(baseId, \" of \").concat(derivedKind, \" \").concat(derivedName, \" (ID \").concat(derivedId, \")\");\n    _this = _super.call(this, message);\n    _this.name = \"UnknownBaseContractIdError\";\n    _this.derivedId = derivedId;\n    _this.derivedName = derivedName;\n    _this.derivedKind = derivedKind;\n    _this.baseId = baseId;\n    return _this;\n  }\n\n  return UnknownBaseContractIdError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.UnknownBaseContractIdError = UnknownBaseContractIdError; //contracts contains only the contracts to be allocated; any base classes not\n//being allocated should just be in referenceDeclarations\n\nfunction getStorageAllocations(userDefinedTypes) {\n  var allocations = {};\n\n  for (var _i = 0, _Object$values = Object.values(userDefinedTypes); _i < _Object$values.length; _i++) {\n    var dataType = _Object$values[_i];\n\n    if (dataType.typeClass === \"struct\") {\n      try {\n        allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n      } catch (_) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n        //note: a better way of handling this would probably be to *mark* it\n        //as failed rather than throwing an exception as that would lead to less\n        //recomputation, but this is simpler and I don't think the recomputation\n        //should really be a problem\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getStorageAllocations = getStorageAllocations;\n/**\n * This function gets allocations for the state variables of the contracts;\n * this is distinct from getStorageAllocations, which gets allocations for\n * storage structs.\n *\n * While mostly state variables are kept in storage, constant ones are not.\n * And immutable ones, once those are introduced, will be kept in code!\n * (But those don't exist yet so this function doesn't handle them yet.)\n */\n\nfunction getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  var existingAllocations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var allocations = existingAllocations;\n\n  var _iterator = _createForOfIteratorHelper(contracts),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var contractInfo = _step.value;\n      var contract = contractInfo.contractNode,\n          immutableReferences = contractInfo.immutableReferences,\n          compiler = contractInfo.compiler,\n          compilationId = contractInfo.compilationId;\n\n      try {\n        allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);\n      } catch (_) {//we're just going to allow failure here and catch the problem elsewhere\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return allocations;\n}\n\nexports.getStateAllocations = getStateAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n}\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {\n  var offset = 0; //will convert to BN when placing in slot\n\n  var index = Evm.Utils.WORD_SIZE - 1; //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  var allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n  //otherwise, we need to allocate\n\n  var memberAllocations = [];\n\n  var _iterator2 = _createForOfIteratorHelper(members),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var member = _step2.value;\n      var size = void 0;\n\n      var _storageSizeAndAlloca = storageSizeAndAllocate(member.type, userDefinedTypes, allocations);\n\n      size = _storageSizeAndAlloca.size;\n      allocations = _storageSizeAndAlloca.allocations;\n\n      //if it's sized in words (and we're not at the start of slot) we need to start on a new slot\n      //if it's sized in bytes but there's not enough room, we also need a new slot\n      if (Utils.isWordsLength(size) ? index < Evm.Utils.WORD_SIZE - 1 : size.bytes > index + 1) {\n        index = Evm.Utils.WORD_SIZE - 1;\n        offset += 1;\n      } //otherwise, we remain in place\n\n\n      var range = void 0;\n\n      if (Utils.isWordsLength(size)) {\n        //words case\n        range = {\n          from: {\n            slot: {\n              offset: new bn_js_1.default(offset) //start at the current slot...\n\n            },\n            index: 0 //...at the beginning of the word.\n\n          },\n          to: {\n            slot: {\n              offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...\n\n            },\n            index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.\n\n          }\n        };\n      } else {\n        //bytes case\n        range = {\n          from: {\n            slot: {\n              offset: new bn_js_1.default(offset) //start at the current slot...\n\n            },\n            index: index - (size.bytes - 1) //...early enough to fit what's being allocated.\n\n          },\n          to: {\n            slot: {\n              offset: new bn_js_1.default(offset) //end at the current slot...\n\n            },\n            index: index //...at the current position.\n\n          }\n        };\n      }\n\n      memberAllocations.push({\n        name: member.name,\n        type: member.type,\n        pointer: {\n          location: \"storage\",\n          range: range\n        }\n      }); //finally, adjust the current position.\n      //if it was sized in words, move down that many slots and reset position w/in slot\n\n      if (Utils.isWordsLength(size)) {\n        offset += size.words;\n        index = Evm.Utils.WORD_SIZE - 1;\n      } //if it was sized in bytes, move down an appropriate number of bytes.\n      else {\n          index -= size.bytes; //but if this puts us into the next word, move to the next word.\n\n          if (index < 0) {\n            index = Evm.Utils.WORD_SIZE - 1;\n            offset += 1;\n          }\n        }\n    } //finally, let's determine the overall siz; we're dealing with a struct, so\n    //the size is measured in words\n    //it's one plus the last word used, i.e. one plus the current word... unless the\n    //current word remains entirely unused, then it's just the current word\n    //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how\n    //empty structs behave in versions where they're legal)\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var totalSize;\n\n  if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {\n    totalSize = {\n      words: offset\n    };\n  } else {\n    totalSize = {\n      words: offset + 1\n    };\n  } //having made our allocation, let's add it to allocations!\n\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    size: totalSize\n  }; //...and we're done!\n\n  return allocations;\n}\n\nfunction getStateVariables(contractNode) {\n  // process for state variables\n  return contractNode.nodes.filter(function (node) {\n    return node.nodeType === \"VariableDeclaration\" && node.stateVariable;\n  });\n}\n\nfunction allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  var _ref4;\n\n  var existingAllocations = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  //we're going to do a 2-deep clone here\n  var allocations = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(existingAllocations).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        compilationId = _ref2[0],\n        compilationAllocations = _ref2[1];\n\n    return _defineProperty({}, compilationId, Object.assign({}, compilationAllocations));\n  }))));\n\n  if (!immutableReferences) {\n    immutableReferences = {}; //also, let's set this up for convenience\n  } //base contracts are listed from most derived to most base, so we\n  //have to reverse before processing, but reverse() is in place, so we\n  //clone with slice first\n\n\n  var linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse(); //first, let's get all the variables under consideration\n\n  var variables = (_ref4 = []).concat.apply(_ref4, _toConsumableArray(linearizedBaseContractsFromBase.map(function (id) {\n    var baseNode = referenceDeclarations[id];\n\n    if (baseNode === undefined) {\n      throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);\n    }\n\n    return getStateVariables(baseNode).map(function (definition) {\n      return {\n        definition: definition,\n        definedIn: baseNode\n      };\n    });\n  }))); //just in case the constant field ever gets removed\n\n\n  var isConstant = function isConstant(definition) {\n    return definition.constant || definition.mutability === \"constant\";\n  }; //now: we split the variables into storage, constant, and code\n\n\n  var _lodash_partition_1$d = lodash_partition_1.default(variables, function (variable) {\n    return isConstant(variable.definition);\n  }),\n      _lodash_partition_1$d2 = _slicedToArray(_lodash_partition_1$d, 2),\n      constantVariables = _lodash_partition_1$d2[0],\n      variableVariables = _lodash_partition_1$d2[1]; //why use this function instead of just checking\n  //definition.mutability?\n  //because of a bug in Solidity 0.6.5 that causes the mutability field\n  //not to exist.  So, we also have to check against immutableReferences.\n\n\n  var isImmutable = function isImmutable(definition) {\n    return definition.mutability === \"immutable\" || definition.id.toString() in immutableReferences;\n  };\n\n  var _lodash_partition_1$d3 = lodash_partition_1.default(variableVariables, function (variable) {\n    return isImmutable(variable.definition);\n  }),\n      _lodash_partition_1$d4 = _slicedToArray(_lodash_partition_1$d3, 2),\n      immutableVariables = _lodash_partition_1$d4[0],\n      storageVariables = _lodash_partition_1$d4[1]; //transform storage variables into data types\n\n\n  var storageVariableTypes = storageVariables.map(function (variable) {\n    return {\n      name: variable.definition.name,\n      type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)\n    };\n  }); //let's allocate the storage variables using a fictitious ID\n\n  var id = \"-1\";\n  var storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations)[id]; //transform to new format\n\n  var storageVariableAllocations = storageVariables.map(function (_ref5, index) {\n    var definition = _ref5.definition,\n        definedIn = _ref5.definedIn;\n    return {\n      definition: definition,\n      definedIn: definedIn,\n      compilationId: compilationId,\n      pointer: storageVariableStorageAllocations.members[index].pointer\n    };\n  }); //now let's create allocations for the immutables\n\n  var immutableVariableAllocations = immutableVariables.map(function (_ref6) {\n    var definition = _ref6.definition,\n        definedIn = _ref6.definedIn;\n    var references = immutableReferences[definition.id.toString()] || [];\n    var pointer;\n\n    if (references.length === 0) {\n      pointer = {\n        location: \"nowhere\"\n      };\n    } else {\n      pointer = {\n        location: \"code\",\n        start: references[0].start,\n        length: references[0].length\n      };\n    }\n\n    return {\n      definition: definition,\n      definedIn: definedIn,\n      compilationId: compilationId,\n      pointer: pointer\n    };\n  }); //and let's create allocations for the constants\n\n  var constantVariableAllocations = constantVariables.map(function (_ref7) {\n    var definition = _ref7.definition,\n        definedIn = _ref7.definedIn;\n    return {\n      definition: definition,\n      definedIn: definedIn,\n      compilationId: compilationId,\n      pointer: {\n        location: \"definition\",\n        definition: definition.value\n      }\n    };\n  }); //now, reweave the three together\n\n  var contractAllocation = [];\n\n  var _iterator3 = _createForOfIteratorHelper(variables),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var variable = _step3.value;\n      var arrayToGrabFrom = isConstant(variable.definition) ? constantVariableAllocations : isImmutable(variable.definition) ? immutableVariableAllocations : storageVariableAllocations;\n      contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n    } //finally, set things and return\n\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (!allocations[compilationId]) {\n    allocations[compilationId] = {};\n  }\n\n  allocations[compilationId][contract.id] = {\n    members: contractAllocation\n  };\n  return allocations;\n} //NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.\n//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,\n//not to the wrapper, because it may need the allocations returned.\n\n\nfunction storageSize(dataType, userDefinedTypes, allocations) {\n  return storageSizeAndAllocate(dataType, userDefinedTypes, allocations).size;\n}\n\nexports.storageSize = storageSize;\n\nfunction storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n  //we'll only directly handle reference types here;\n  //direct types will be handled by dispatching to Basic.Allocate.byteLength\n  //in the default case\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      {\n        switch (dataType.kind) {\n          case \"static\":\n            //really a basic type :)\n            return {\n              size: {\n                bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n              },\n              allocations: existingAllocations\n            };\n\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n        }\n      }\n\n    case \"string\":\n    case \"mapping\":\n      return {\n        size: {\n          words: 1\n        },\n        allocations: existingAllocations\n      };\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            //static array case\n            var length = dataType.length.toNumber(); //warning! but if it's too big we have a problem\n\n            if (length === 0) {\n              //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word\n              return {\n                size: {\n                  words: 1\n                },\n                allocations: existingAllocations\n              };\n            }\n\n            var _storageSizeAndAlloca2 = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations),\n                baseSize = _storageSizeAndAlloca2.size,\n                allocations = _storageSizeAndAlloca2.allocations;\n\n            if (!Utils.isWordsLength(baseSize)) {\n              //bytes case\n              var perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n              debug(\"length %o\", length);\n              var numWords = Math.ceil(length / perWord);\n              return {\n                size: {\n                  words: numWords\n                },\n                allocations: allocations\n              };\n            } else {\n              //words case\n              return {\n                size: {\n                  words: baseSize.words * length\n                },\n                allocations: allocations\n              };\n            }\n\n        }\n      }\n\n    case \"struct\":\n      {\n        var _allocations = existingAllocations;\n        var allocation = _allocations[dataType.id]; //may be undefined!\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          var storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          _allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = _allocations[dataType.id];\n        } //having found our allocation, we can just look up its size\n\n\n        return {\n          size: allocation.size,\n          allocations: _allocations\n        };\n      }\n\n    default:\n      //otherwise, it's a direct type\n      return {\n        size: {\n          bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n        },\n        allocations: existingAllocations\n      };\n  }\n}","map":{"version":3,"sources":["../../../../lib/storage/allocate/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,wBAAZ,CAAd;;AAIA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AAEA,IAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,UAAA,CAAA,CAAA;;AACA,IAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAYA,IAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,kBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;;IAWa,0B;;;;;AAKX,sCACE,SADF,EAEE,WAFF,EAGE,WAHF,EAIE,MAJF,EAIgB;AAAA;;AAAA;;AAEd,QAAM,OAAO,4CAAqC,MAArC,iBAAkD,WAAlD,cAAiE,WAAjE,kBAAoF,SAApF,MAAb;AACA,8BAAM,OAAN;AACA,UAAK,IAAL,GAAY,4BAAZ;AACA,UAAK,SAAL,GAAiB,SAAjB;AACA,UAAK,WAAL,GAAmB,WAAnB;AACA,UAAK,WAAL,GAAmB,WAAnB;AACA,UAAK,MAAL,GAAc,MAAd;AARc;AASf;;;iCAlB6C,K;;AAAhD,OAAA,CAAA,0BAAA,GAAA,0BAAA,C,CA0BA;AACA;;AACA,SAAgB,qBAAhB,CACE,gBADF,EAC0C;AAExC,MAAI,WAAW,GAAuB,EAAtC;;AACA,oCAAuB,MAAM,CAAC,MAAP,CAAc,gBAAd,CAAvB,oCAAwD;AAAnD,QAAM,QAAQ,qBAAd;;AACH,QAAI,QAAQ,CAAC,SAAT,KAAuB,QAA3B,EAAqC;AACnC,UAAI;AACF,QAAA,WAAW,GAAG,cAAc,CAAC,QAAD,EAAW,gBAAX,EAA6B,WAA7B,CAA5B;AACD,OAFD,CAEE,OAAO,CAAP,EAAU,CACV;AACA;AACA;AACA;AACA;AACD;AACF;AACF;;AACD,SAAO,WAAP;AACD;;AAlBD,OAAA,CAAA,qBAAA,GAAA,qBAAA;AAoBA;;;;;;;;AAQG;;AACH,SAAgB,mBAAhB,CACE,SADF,EAEE,qBAFF,EAGE,gBAHF,EAIE,kBAJF,EAK4C;AAAA,MAA1C,mBAA0C,uEAAF,EAAE;AAE1C,MAAI,WAAW,GAAG,mBAAlB;;AAF0C,6CAGf,SAHe;AAAA;;AAAA;AAG1C,wDAAsC;AAAA,UAA3B,YAA2B;AAAA,UAEpB,QAFoB,GAMhC,YANgC,CAElC,YAFkC;AAAA,UAGlC,mBAHkC,GAMhC,YANgC,CAGlC,mBAHkC;AAAA,UAIlC,QAJkC,GAMhC,YANgC,CAIlC,QAJkC;AAAA,UAKlC,aALkC,GAMhC,YANgC,CAKlC,aALkC;;AAOpC,UAAI;AACF,QAAA,WAAW,GAAG,qBAAqB,CACjC,QADiC,EAEjC,mBAFiC,EAGjC,aAHiC,EAIjC,QAJiC,EAKjC,qBAAqB,CAAC,aAAD,CALY,EAMjC,gBANiC,EAOjC,kBAPiC,EAQjC,WARiC,CAAnC;AAUD,OAXD,CAWE,OAAO,CAAP,EAAU,CACV;AACD;AACF;AAxByC;AAAA;AAAA;AAAA;AAAA;;AAyB1C,SAAO,WAAP;AACD;;AA/BD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AAiCA,SAAS,cAAT,CACE,QADF,EAEE,gBAFF,EAGE,mBAHF,EAGyC;AAEvC;AACA;AACA,SAAO,eAAe,CACpB,QAAQ,CAAC,EADW,EAEpB,QAAQ,CAAC,WAFW,EAGpB,gBAHoB,EAIpB,mBAJoB,CAAtB;AAMD;;AAED,SAAS,eAAT,CACE,QADF,EAEE,OAFF,EAGE,gBAHF,EAIE,mBAJF,EAIyC;AAEvC,MAAI,MAAM,GAAW,CAArB,CAFuC,CAEf;;AACxB,MAAI,KAAK,GAAW,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,CAA1C,CAHuC,CAKvC;;AACA,MAAI,QAAQ,IAAI,mBAAhB,EAAqC;AACnC,WAAO,mBAAP;AACD;;AAED,MAAI,WAAW,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,mBAAR,CAAf,CAVuC,CAUO;AAE9C;;AACA,MAAI,iBAAiB,GAA8B,EAAnD;;AAbuC,8CAelB,OAfkB;AAAA;;AAAA;AAevC,2DAA8B;AAAA,UAAnB,MAAmB;AAC5B,UAAI,IAA2B,SAA/B;;AAD4B,kCAEH,sBAAsB,CAC7C,MAAM,CAAC,IADsC,EAE7C,gBAF6C,EAG7C,WAH6C,CAFnB;;AAEzB,MAAA,IAFyB,yBAEzB,IAFyB;AAEnB,MAAA,WAFmB,yBAEnB,WAFmB;;AAQ5B;AACA;AACA,UACE,KAAK,CAAC,aAAN,CAAoB,IAApB,IACI,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,CADlC,GAEI,IAAI,CAAC,KAAL,GAAa,KAAK,GAAG,CAH3B,EAIE;AACA,QAAA,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,CAA9B;AACA,QAAA,MAAM,IAAI,CAAV;AACD,OAjB2B,CAkB5B;;;AAEA,UAAI,KAAoB,SAAxB;;AAEA,UAAI,KAAK,CAAC,aAAN,CAAoB,IAApB,CAAJ,EAA+B;AAC7B;AACA,QAAA,KAAK,GAAG;AACN,UAAA,IAAI,EAAE;AACJ,YAAA,IAAI,EAAE;AACJ,cAAA,MAAM,EAAE,IAAI,OAAA,CAAA,OAAJ,CAAO,MAAP,CADJ,CACmB;;AADnB,aADF;AAIJ,YAAA,KAAK,EAAE,CAJH,CAIK;;AAJL,WADA;AAON,UAAA,EAAE,EAAE;AACF,YAAA,IAAI,EAAE;AACJ,cAAA,MAAM,EAAE,IAAI,OAAA,CAAA,OAAJ,CAAO,MAAM,GAAG,IAAI,CAAC,KAAd,GAAsB,CAA7B,CADJ,CACoC;;AADpC,aADJ;AAIF,YAAA,KAAK,EAAE,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,CAJ3B,CAI6B;;AAJ7B;AAPE,SAAR;AAcD,OAhBD,MAgBO;AACL;AACA,QAAA,KAAK,GAAG;AACN,UAAA,IAAI,EAAE;AACJ,YAAA,IAAI,EAAE;AACJ,cAAA,MAAM,EAAE,IAAI,OAAA,CAAA,OAAJ,CAAO,MAAP,CADJ,CACmB;;AADnB,aADF;AAIJ,YAAA,KAAK,EAAE,KAAK,IAAI,IAAI,CAAC,KAAL,GAAa,CAAjB,CAJR,CAI4B;;AAJ5B,WADA;AAON,UAAA,EAAE,EAAE;AACF,YAAA,IAAI,EAAE;AACJ,cAAA,MAAM,EAAE,IAAI,OAAA,CAAA,OAAJ,CAAO,MAAP,CADJ,CACmB;;AADnB,aADJ;AAIF,YAAA,KAAK,EAAE,KAJL,CAIW;;AAJX;AAPE,SAAR;AAcD;;AACD,MAAA,iBAAiB,CAAC,IAAlB,CAAuB;AACrB,QAAA,IAAI,EAAE,MAAM,CAAC,IADQ;AAErB,QAAA,IAAI,EAAE,MAAM,CAAC,IAFQ;AAGrB,QAAA,OAAO,EAAE;AACP,UAAA,QAAQ,EAAE,SADH;AAEP,UAAA,KAAK,EAAL;AAFO;AAHY,OAAvB,EAvD4B,CA+D5B;AACA;;AACA,UAAI,KAAK,CAAC,aAAN,CAAoB,IAApB,CAAJ,EAA+B;AAC7B,QAAA,MAAM,IAAI,IAAI,CAAC,KAAf;AACA,QAAA,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,CAA9B;AACD,OAHD,CAIA;AAJA,WAKK;AACH,UAAA,KAAK,IAAI,IAAI,CAAC,KAAd,CADG,CAEH;;AACA,cAAI,KAAK,GAAG,CAAZ,EAAe;AACb,YAAA,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,CAA9B;AACA,YAAA,MAAM,IAAI,CAAV;AACD;AACF;AACF,KA7FsC,CA+FvC;AACA;AACA;AACA;AACA;AACA;;AApGuC;AAAA;AAAA;AAAA;AAAA;;AAqGvC,MAAI,SAAJ;;AACA,MAAI,KAAK,KAAK,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,CAAhC,IAAqC,MAAM,KAAK,CAApD,EAAuD;AACrD,IAAA,SAAS,GAAG;AAAE,MAAA,KAAK,EAAE;AAAT,KAAZ;AACD,GAFD,MAEO;AACL,IAAA,SAAS,GAAG;AAAE,MAAA,KAAK,EAAE,MAAM,GAAG;AAAlB,KAAZ;AACD,GA1GsC,CA4GvC;;;AACA,EAAA,WAAW,CAAC,QAAD,CAAX,GAAwB;AACtB,IAAA,OAAO,EAAE,iBADa;AAEtB,IAAA,IAAI,EAAE;AAFgB,GAAxB,CA7GuC,CAkHvC;;AACA,SAAO,WAAP;AACD;;AAED,SAAS,iBAAT,CAA2B,YAA3B,EAAoD;AAClD;AACA,SAAO,YAAY,CAAC,KAAb,CAAmB,MAAnB,CACL,UAAC,IAAD;AAAA,WACE,IAAI,CAAC,QAAL,KAAkB,qBAAlB,IAA2C,IAAI,CAAC,aADlD;AAAA,GADK,CAAP;AAID;;AAED,SAAS,qBAAT,CACE,QADF,EAEE,mBAFF,EAGE,aAHF,EAIE,QAJF,EAKE,qBALF,EAME,gBANF,EAOE,kBAPF,EAQ4C;AAAA;;AAAA,MAA1C,mBAA0C,uEAAF,EAAE;AAE1C;AACA,MAAI,WAAW,GAAqB,MAAM,CAAC,MAAP,OAAA,MAAM,GACxC,EADwC,4BAErC,MAAM,CAAC,OAAP,CAAe,mBAAf,EAAoC,GAApC,CACD;AAAA;AAAA,QAAE,aAAF;AAAA,QAAiB,sBAAjB;;AAAA,+BACG,aADH,EACiB,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,sBAAP,CADjB;AAAA,GADC,CAFqC,GAA1C;;AAQA,MAAI,CAAC,mBAAL,EAA0B;AACxB,IAAA,mBAAmB,GAAG,EAAtB,CADwB,CACE;AAC3B,GAbyC,CAe1C;AACA;AACA;;;AACA,MAAI,+BAA+B,GAAa,QAAQ,CAAC,uBAAT,CAC7C,KAD6C,GAE7C,OAF6C,EAAhD,CAlB0C,CAsB1C;;AACA,MAAI,SAAS,GAAG,aAAG,MAAH,iCACX,+BAA+B,CAAC,GAAhC,CAAoC,UAAC,EAAD,EAAe;AACpD,QAAI,QAAQ,GAAG,qBAAqB,CAAC,EAAD,CAApC;;AACA,QAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,YAAM,IAAI,0BAAJ,CACJ,QAAQ,CAAC,EADL,EAEJ,QAAQ,CAAC,IAFL,EAGJ,QAAQ,CAAC,YAHL,EAIJ,EAJI,CAAN;AAMD;;AACD,WAAO,iBAAiB,CAAC,QAAD,CAAjB,CAA4B,GAA5B,CAAgC,UAAA,UAAU;AAAA,aAAK;AACpD,QAAA,UAAU,EAAV,UADoD;AAEpD,QAAA,SAAS,EAAE;AAFyC,OAAL;AAAA,KAA1C,CAAP;AAID,GAdE,CADW,EAAhB,CAvB0C,CAyC1C;;;AACA,MAAM,UAAU,GAAG,SAAb,UAAa,CAAC,UAAD;AAAA,WACjB,UAAU,CAAC,QAAX,IAAuB,UAAU,CAAC,UAAX,KAA0B,UADhC;AAAA,GAAnB,CA1C0C,CA6C1C;;;AA7C0C,8BA8CG,kBAAA,CAAA,OAAA,CAAU,SAAV,EAAqB,UAAA,QAAQ;AAAA,WACxE,UAAU,CAAC,QAAQ,CAAC,UAAV,CAD8D;AAAA,GAA7B,CA9CH;AAAA;AAAA,MA8CrC,iBA9CqC;AAAA,MA8ClB,iBA9CkB,8BAkD1C;AACA;AACA;AACA;;;AACA,MAAM,WAAW,GAAG,SAAd,WAAc,CAAC,UAAD;AAAA,WAClB,UAAU,CAAC,UAAX,KAA0B,WAA1B,IACA,UAAU,CAAC,EAAX,CAAc,QAAd,MAA4B,mBAFV;AAAA,GAApB;;AAtD0C,+BA0DG,kBAAA,CAAA,OAAA,CAC3C,iBAD2C,EAE3C,UAAA,QAAQ;AAAA,WAAI,WAAW,CAAC,QAAQ,CAAC,UAAV,CAAf;AAAA,GAFmC,CA1DH;AAAA;AAAA,MA0DrC,kBA1DqC;AAAA,MA0DjB,gBA1DiB,8BA+D1C;;;AACA,MAAI,oBAAoB,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,UAAA,QAAQ;AAAA,WAAK;AAC3D,MAAA,IAAI,EAAE,QAAQ,CAAC,UAAT,CAAoB,IADiC;AAE3D,MAAA,IAAI,EAAE,GAAG,CAAC,MAAJ,CAAW,gBAAX,CACJ,QAAQ,CAAC,UADL,EAEJ,aAFI,EAGJ,QAHI;AAFqD,KAAL;AAAA,GAA7B,CAA3B,CAhE0C,CAyE1C;;AACA,MAAM,EAAE,GAAG,IAAX;AACA,MAAI,iCAAiC,GAAG,eAAe,CACrD,EADqD,EAErD,oBAFqD,EAGrD,gBAHqD,EAIrD,kBAJqD,CAAf,CAKtC,EALsC,CAAxC,CA3E0C,CAkF1C;;AACA,MAAI,0BAA0B,GAAG,gBAAgB,CAAC,GAAjB,CAC/B,iBAA4B,KAA5B;AAAA,QAAG,UAAH,SAAG,UAAH;AAAA,QAAe,SAAf,SAAe,SAAf;AAAA,WAAuC;AACrC,MAAA,UAAU,EAAV,UADqC;AAErC,MAAA,SAAS,EAAT,SAFqC;AAGrC,MAAA,aAAa,EAAb,aAHqC;AAIrC,MAAA,OAAO,EAAE,iCAAiC,CAAC,OAAlC,CAA0C,KAA1C,EAAiD;AAJrB,KAAvC;AAAA,GAD+B,CAAjC,CAnF0C,CA4F1C;;AACA,MAAI,4BAA4B,GAAG,kBAAkB,CAAC,GAAnB,CACjC,iBAA8B;AAAA,QAA3B,UAA2B,SAA3B,UAA2B;AAAA,QAAf,SAAe,SAAf,SAAe;AAC5B,QAAI,UAAU,GAAG,mBAAmB,CAAC,UAAU,CAAC,EAAX,CAAc,QAAd,EAAD,CAAnB,IAAiD,EAAlE;AACA,QAAI,OAAJ;;AACA,QAAI,UAAU,CAAC,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,MAAA,OAAO,GAAG;AACR,QAAA,QAAQ,EAAE;AADF,OAAV;AAGD,KAJD,MAIO;AACL,MAAA,OAAO,GAAG;AACR,QAAA,QAAQ,EAAE,MADF;AAER,QAAA,KAAK,EAAE,UAAU,CAAC,CAAD,CAAV,CAAc,KAFb;AAGR,QAAA,MAAM,EAAE,UAAU,CAAC,CAAD,CAAV,CAAc;AAHd,OAAV;AAKD;;AACD,WAAO;AACL,MAAA,UAAU,EAAV,UADK;AAEL,MAAA,SAAS,EAAT,SAFK;AAGL,MAAA,aAAa,EAAb,aAHK;AAIL,MAAA,OAAO,EAAP;AAJK,KAAP;AAMD,GArBgC,CAAnC,CA7F0C,CAqH1C;;AACA,MAAI,2BAA2B,GAAG,iBAAiB,CAAC,GAAlB,CAChC;AAAA,QAAG,UAAH,SAAG,UAAH;AAAA,QAAe,SAAf,SAAe,SAAf;AAAA,WAAgC;AAC9B,MAAA,UAAU,EAAV,UAD8B;AAE9B,MAAA,SAAS,EAAT,SAF8B;AAG9B,MAAA,aAAa,EAAb,aAH8B;AAI9B,MAAA,OAAO,EAAE;AACP,QAAA,QAAQ,EAAE,YADH;AAEP,QAAA,UAAU,EAAE,UAAU,CAAC;AAFhB;AAJqB,KAAhC;AAAA,GADgC,CAAlC,CAtH0C,CAkI1C;;AACA,MAAI,kBAAkB,GAA8B,EAApD;;AAnI0C,8CAoIrB,SApIqB;AAAA;;AAAA;AAoI1C,2DAAgC;AAAA,UAAvB,QAAuB;AAC9B,UAAI,eAAe,GAAG,UAAU,CAAC,QAAQ,CAAC,UAAV,CAAV,GAClB,2BADkB,GAElB,WAAW,CAAC,QAAQ,CAAC,UAAV,CAAX,GACE,4BADF,GAEE,0BAJN;AAKA,MAAA,kBAAkB,CAAC,IAAnB,CAAwB,eAAe,CAAC,KAAhB,EAAxB,EAN8B,CAMoB;AACnD,KA3IyC,CA6I1C;;AA7I0C;AAAA;AAAA;AAAA;AAAA;;AA8I1C,MAAI,CAAC,WAAW,CAAC,aAAD,CAAhB,EAAiC;AAC/B,IAAA,WAAW,CAAC,aAAD,CAAX,GAA6B,EAA7B;AACD;;AACD,EAAA,WAAW,CAAC,aAAD,CAAX,CAA2B,QAAQ,CAAC,EAApC,IAA0C;AACxC,IAAA,OAAO,EAAE;AAD+B,GAA1C;AAIA,SAAO,WAAP;AACD,C,CAED;AACA;AACA;;;AACA,SAAgB,WAAhB,CACE,QADF,EAEE,gBAFF,EAGE,WAHF,EAGkC;AAEhC,SAAO,sBAAsB,CAAC,QAAD,EAAW,gBAAX,EAA6B,WAA7B,CAAtB,CAAgE,IAAvE;AACD;;AAND,OAAA,CAAA,WAAA,GAAA,WAAA;;AAQA,SAAS,sBAAT,CACE,QADF,EAEE,gBAFF,EAGE,mBAHF,EAG0C;AAExC;AACA;AACA;AACA,UAAQ,QAAQ,CAAC,SAAjB;AACE,SAAK,OAAL;AAAc;AACZ,gBAAQ,QAAQ,CAAC,IAAjB;AACE,eAAK,QAAL;AACE;AACA,mBAAO;AACL,cAAA,IAAI,EAAE;AACJ,gBAAA,KAAK,EAAE,KAAK,CAAC,QAAN,CAAe,UAAf,CAA0B,QAA1B,EAAoC,gBAApC;AADH,eADD;AAIL,cAAA,WAAW,EAAE;AAJR,aAAP;;AAMF,eAAK,SAAL;AACE,mBAAO;AACL,cAAA,IAAI,EAAE;AAAE,gBAAA,KAAK,EAAE;AAAT,eADD;AAEL,cAAA,WAAW,EAAE;AAFR,aAAP;AAVJ;AAeD;;AAED,SAAK,QAAL;AACA,SAAK,SAAL;AACE,aAAO;AACL,QAAA,IAAI,EAAE;AAAE,UAAA,KAAK,EAAE;AAAT,SADD;AAEL,QAAA,WAAW,EAAE;AAFR,OAAP;;AAKF,SAAK,OAAL;AAAc;AACZ,gBAAQ,QAAQ,CAAC,IAAjB;AACE,eAAK,SAAL;AACE,mBAAO;AACL,cAAA,IAAI,EAAE;AAAE,gBAAA,KAAK,EAAE;AAAT,eADD;AAEL,cAAA,WAAW,EAAE;AAFR,aAAP;;AAIF,eAAK,QAAL;AACE;AACA,gBAAM,MAAM,GAAG,QAAQ,CAAC,MAAT,CAAgB,QAAhB,EAAf,CAFF,CAE6C;;AAC3C,gBAAI,MAAM,KAAK,CAAf,EAAkB;AAChB;AACA,qBAAO;AACL,gBAAA,IAAI,EAAE;AAAE,kBAAA,KAAK,EAAE;AAAT,iBADD;AAEL,gBAAA,WAAW,EAAE;AAFR,eAAP;AAID;;AATH,yCAUwC,sBAAsB,CAC1D,QAAQ,CAAC,QADiD,EAE1D,gBAF0D,EAG1D,mBAH0D,CAV9D;AAAA,gBAUc,QAVd,0BAUQ,IAVR;AAAA,gBAUwB,WAVxB,0BAUwB,WAVxB;;AAeE,gBAAI,CAAC,KAAK,CAAC,aAAN,CAAoB,QAApB,CAAL,EAAoC;AAClC;AACA,kBAAM,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,GAAG,CAAC,KAAJ,CAAU,SAAV,GAAsB,QAAQ,CAAC,KAA1C,CAAhB;AACA,cAAA,KAAK,CAAC,WAAD,EAAc,MAAd,CAAL;AACA,kBAAM,QAAQ,GAAG,IAAI,CAAC,IAAL,CAAU,MAAM,GAAG,OAAnB,CAAjB;AACA,qBAAO;AACL,gBAAA,IAAI,EAAE;AAAE,kBAAA,KAAK,EAAE;AAAT,iBADD;AAEL,gBAAA,WAAW,EAAX;AAFK,eAAP;AAID,aATD,MASO;AACL;AACA,qBAAO;AACL,gBAAA,IAAI,EAAE;AAAE,kBAAA,KAAK,EAAE,QAAQ,CAAC,KAAT,GAAiB;AAA1B,iBADD;AAEL,gBAAA,WAAW,EAAX;AAFK,eAAP;AAID;;AApCL;AAsCD;;AAED,SAAK,QAAL;AAAe;AACb,YAAI,YAAW,GAAuB,mBAAtC;AACA,YAAI,UAAU,GAAkC,YAAW,CAAC,QAAQ,CAAC,EAAV,CAA3D,CAFa,CAE6D;;AAC1E,YAAI,UAAU,KAAK,SAAnB,EAA8B;AAC5B;AACA,cAAM,UAAU,GACd,gBAAgB,CAAC,QAAQ,CAAC,EAAV,CADlB;;AAGA,cAAI,CAAC,UAAL,EAAiB;AACf,kBAAM,IAAI,MAAM,CAAC,2BAAX,CACJ,QAAQ,CAAC,EADL,EAEJ,MAAM,CAAC,KAAP,CAAa,UAAb,CAAwB,QAAxB,CAFI,CAAN;AAID;;AACD,UAAA,YAAW,GAAG,cAAc,CAC1B,UAD0B,EAE1B,gBAF0B,EAG1B,mBAH0B,CAA5B;AAKA,UAAA,UAAU,GAAG,YAAW,CAAC,QAAQ,CAAC,EAAV,CAAxB;AACD,SApBY,CAqBb;;;AACA,eAAO;AACL,UAAA,IAAI,EAAE,UAAU,CAAC,IADZ;AAEL,UAAA,WAAW,EAAX;AAFK,SAAP;AAID;;AAED;AACE;AACA,aAAO;AACL,QAAA,IAAI,EAAE;AAAE,UAAA,KAAK,EAAE,KAAK,CAAC,QAAN,CAAe,UAAf,CAA0B,QAA1B,EAAoC,gBAApC;AAAT,SADD;AAEL,QAAA,WAAW,EAAE;AAFR,OAAP;AAjGJ;AAsGD","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:storage:allocate\");\nconst Common = __importStar(require(\"../../common\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Ast = __importStar(require(\"../../ast\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst Format = __importStar(require(\"../../format\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\nclass UnknownBaseContractIdError extends Error {\n    constructor(derivedId, derivedName, derivedKind, baseId) {\n        const message = `Cannot locate base contract ID ${baseId} of ${derivedKind} ${derivedName} (ID ${derivedId})`;\n        super(message);\n        this.name = \"UnknownBaseContractIdError\";\n        this.derivedId = derivedId;\n        this.derivedName = derivedName;\n        this.derivedKind = derivedKind;\n        this.baseId = baseId;\n    }\n}\nexports.UnknownBaseContractIdError = UnknownBaseContractIdError;\n//contracts contains only the contracts to be allocated; any base classes not\n//being allocated should just be in referenceDeclarations\nfunction getStorageAllocations(userDefinedTypes) {\n    let allocations = {};\n    for (const dataType of Object.values(userDefinedTypes)) {\n        if (dataType.typeClass === \"struct\") {\n            try {\n                allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n            }\n            catch (_) {\n                //if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n                //note: a better way of handling this would probably be to *mark* it\n                //as failed rather than throwing an exception as that would lead to less\n                //recomputation, but this is simpler and I don't think the recomputation\n                //should really be a problem\n            }\n        }\n    }\n    return allocations;\n}\nexports.getStorageAllocations = getStorageAllocations;\n/**\n * This function gets allocations for the state variables of the contracts;\n * this is distinct from getStorageAllocations, which gets allocations for\n * storage structs.\n *\n * While mostly state variables are kept in storage, constant ones are not.\n * And immutable ones, once those are introduced, will be kept in code!\n * (But those don't exist yet so this function doesn't handle them yet.)\n */\nfunction getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {\n    let allocations = existingAllocations;\n    for (const contractInfo of contracts) {\n        let { contractNode: contract, immutableReferences, compiler, compilationId } = contractInfo;\n        try {\n            allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);\n        }\n        catch (_) {\n            //we're just going to allow failure here and catch the problem elsewhere\n        }\n    }\n    return allocations;\n}\nexports.getStateAllocations = getStateAllocations;\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n    //NOTE: dataType here should be a *stored* type!\n    //it is up to the caller to take care of this\n    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n}\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {\n    let offset = 0; //will convert to BN when placing in slot\n    let index = Evm.Utils.WORD_SIZE - 1;\n    //don't allocate things that have already been allocated\n    if (parentId in existingAllocations) {\n        return existingAllocations;\n    }\n    let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n    //otherwise, we need to allocate\n    let memberAllocations = [];\n    for (const member of members) {\n        let size;\n        ({ size, allocations } = storageSizeAndAllocate(member.type, userDefinedTypes, allocations));\n        //if it's sized in words (and we're not at the start of slot) we need to start on a new slot\n        //if it's sized in bytes but there's not enough room, we also need a new slot\n        if (Utils.isWordsLength(size)\n            ? index < Evm.Utils.WORD_SIZE - 1\n            : size.bytes > index + 1) {\n            index = Evm.Utils.WORD_SIZE - 1;\n            offset += 1;\n        }\n        //otherwise, we remain in place\n        let range;\n        if (Utils.isWordsLength(size)) {\n            //words case\n            range = {\n                from: {\n                    slot: {\n                        offset: new bn_js_1.default(offset) //start at the current slot...\n                    },\n                    index: 0 //...at the beginning of the word.\n                },\n                to: {\n                    slot: {\n                        offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...\n                    },\n                    index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.\n                }\n            };\n        }\n        else {\n            //bytes case\n            range = {\n                from: {\n                    slot: {\n                        offset: new bn_js_1.default(offset) //start at the current slot...\n                    },\n                    index: index - (size.bytes - 1) //...early enough to fit what's being allocated.\n                },\n                to: {\n                    slot: {\n                        offset: new bn_js_1.default(offset) //end at the current slot...\n                    },\n                    index: index //...at the current position.\n                }\n            };\n        }\n        memberAllocations.push({\n            name: member.name,\n            type: member.type,\n            pointer: {\n                location: \"storage\",\n                range\n            }\n        });\n        //finally, adjust the current position.\n        //if it was sized in words, move down that many slots and reset position w/in slot\n        if (Utils.isWordsLength(size)) {\n            offset += size.words;\n            index = Evm.Utils.WORD_SIZE - 1;\n        }\n        //if it was sized in bytes, move down an appropriate number of bytes.\n        else {\n            index -= size.bytes;\n            //but if this puts us into the next word, move to the next word.\n            if (index < 0) {\n                index = Evm.Utils.WORD_SIZE - 1;\n                offset += 1;\n            }\n        }\n    }\n    //finally, let's determine the overall siz; we're dealing with a struct, so\n    //the size is measured in words\n    //it's one plus the last word used, i.e. one plus the current word... unless the\n    //current word remains entirely unused, then it's just the current word\n    //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how\n    //empty structs behave in versions where they're legal)\n    let totalSize;\n    if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {\n        totalSize = { words: offset };\n    }\n    else {\n        totalSize = { words: offset + 1 };\n    }\n    //having made our allocation, let's add it to allocations!\n    allocations[parentId] = {\n        members: memberAllocations,\n        size: totalSize\n    };\n    //...and we're done!\n    return allocations;\n}\nfunction getStateVariables(contractNode) {\n    // process for state variables\n    return contractNode.nodes.filter((node) => node.nodeType === \"VariableDeclaration\" && node.stateVariable);\n}\nfunction allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {\n    //we're going to do a 2-deep clone here\n    let allocations = Object.assign({}, ...Object.entries(existingAllocations).map(([compilationId, compilationAllocations]) => ({\n        [compilationId]: Object.assign({}, compilationAllocations)\n    })));\n    if (!immutableReferences) {\n        immutableReferences = {}; //also, let's set this up for convenience\n    }\n    //base contracts are listed from most derived to most base, so we\n    //have to reverse before processing, but reverse() is in place, so we\n    //clone with slice first\n    let linearizedBaseContractsFromBase = contract.linearizedBaseContracts\n        .slice()\n        .reverse();\n    //first, let's get all the variables under consideration\n    let variables = [].concat(...linearizedBaseContractsFromBase.map((id) => {\n        let baseNode = referenceDeclarations[id];\n        if (baseNode === undefined) {\n            throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);\n        }\n        return getStateVariables(baseNode).map(definition => ({\n            definition,\n            definedIn: baseNode\n        }));\n    }));\n    //just in case the constant field ever gets removed\n    const isConstant = (definition) => definition.constant || definition.mutability === \"constant\";\n    //now: we split the variables into storage, constant, and code\n    let [constantVariables, variableVariables] = lodash_partition_1.default(variables, variable => isConstant(variable.definition));\n    //why use this function instead of just checking\n    //definition.mutability?\n    //because of a bug in Solidity 0.6.5 that causes the mutability field\n    //not to exist.  So, we also have to check against immutableReferences.\n    const isImmutable = (definition) => definition.mutability === \"immutable\" ||\n        definition.id.toString() in immutableReferences;\n    let [immutableVariables, storageVariables] = lodash_partition_1.default(variableVariables, variable => isImmutable(variable.definition));\n    //transform storage variables into data types\n    let storageVariableTypes = storageVariables.map(variable => ({\n        name: variable.definition.name,\n        type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)\n    }));\n    //let's allocate the storage variables using a fictitious ID\n    const id = \"-1\";\n    let storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations)[id];\n    //transform to new format\n    let storageVariableAllocations = storageVariables.map(({ definition, definedIn }, index) => ({\n        definition,\n        definedIn,\n        compilationId,\n        pointer: storageVariableStorageAllocations.members[index].pointer\n    }));\n    //now let's create allocations for the immutables\n    let immutableVariableAllocations = immutableVariables.map(({ definition, definedIn }) => {\n        let references = immutableReferences[definition.id.toString()] || [];\n        let pointer;\n        if (references.length === 0) {\n            pointer = {\n                location: \"nowhere\"\n            };\n        }\n        else {\n            pointer = {\n                location: \"code\",\n                start: references[0].start,\n                length: references[0].length\n            };\n        }\n        return {\n            definition,\n            definedIn,\n            compilationId,\n            pointer\n        };\n    });\n    //and let's create allocations for the constants\n    let constantVariableAllocations = constantVariables.map(({ definition, definedIn }) => ({\n        definition,\n        definedIn,\n        compilationId,\n        pointer: {\n            location: \"definition\",\n            definition: definition.value\n        }\n    }));\n    //now, reweave the three together\n    let contractAllocation = [];\n    for (let variable of variables) {\n        let arrayToGrabFrom = isConstant(variable.definition)\n            ? constantVariableAllocations\n            : isImmutable(variable.definition)\n                ? immutableVariableAllocations\n                : storageVariableAllocations;\n        contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n    }\n    //finally, set things and return\n    if (!allocations[compilationId]) {\n        allocations[compilationId] = {};\n    }\n    allocations[compilationId][contract.id] = {\n        members: contractAllocation\n    };\n    return allocations;\n}\n//NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.\n//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,\n//not to the wrapper, because it may need the allocations returned.\nfunction storageSize(dataType, userDefinedTypes, allocations) {\n    return storageSizeAndAllocate(dataType, userDefinedTypes, allocations).size;\n}\nexports.storageSize = storageSize;\nfunction storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n    //we'll only directly handle reference types here;\n    //direct types will be handled by dispatching to Basic.Allocate.byteLength\n    //in the default case\n    switch (dataType.typeClass) {\n        case \"bytes\": {\n            switch (dataType.kind) {\n                case \"static\":\n                    //really a basic type :)\n                    return {\n                        size: {\n                            bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n                        },\n                        allocations: existingAllocations\n                    };\n                case \"dynamic\":\n                    return {\n                        size: { words: 1 },\n                        allocations: existingAllocations\n                    };\n            }\n        }\n        case \"string\":\n        case \"mapping\":\n            return {\n                size: { words: 1 },\n                allocations: existingAllocations\n            };\n        case \"array\": {\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    return {\n                        size: { words: 1 },\n                        allocations: existingAllocations\n                    };\n                case \"static\":\n                    //static array case\n                    const length = dataType.length.toNumber(); //warning! but if it's too big we have a problem\n                    if (length === 0) {\n                        //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word\n                        return {\n                            size: { words: 1 },\n                            allocations: existingAllocations\n                        };\n                    }\n                    let { size: baseSize, allocations } = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n                    if (!Utils.isWordsLength(baseSize)) {\n                        //bytes case\n                        const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n                        debug(\"length %o\", length);\n                        const numWords = Math.ceil(length / perWord);\n                        return {\n                            size: { words: numWords },\n                            allocations\n                        };\n                    }\n                    else {\n                        //words case\n                        return {\n                            size: { words: baseSize.words * length },\n                            allocations\n                        };\n                    }\n            }\n        }\n        case \"struct\": {\n            let allocations = existingAllocations;\n            let allocation = allocations[dataType.id]; //may be undefined!\n            if (allocation === undefined) {\n                //if we don't find an allocation, we'll have to do the allocation ourselves\n                const storedType = (userDefinedTypes[dataType.id]);\n                if (!storedType) {\n                    throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n                }\n                allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n                allocation = allocations[dataType.id];\n            }\n            //having found our allocation, we can just look up its size\n            return {\n                size: allocation.size,\n                allocations\n            };\n        }\n        default:\n            //otherwise, it's a direct type\n            return {\n                size: { bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes) },\n                allocations: existingAllocations\n            };\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}