{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:compilations:utils\");\n\nfunction shimCompilations(inputCompilations) {\n  var shimmedCompilationIdPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return inputCompilations.map(function (compilation, compilationIndex) {\n    return shimCompilation(compilation, \"\".concat(shimmedCompilationIdPrefix, \"Number(\").concat(compilationIndex, \")\"));\n  });\n}\n\nexports.shimCompilations = shimCompilations;\n\nfunction shimCompilation(inputCompilation) {\n  var shimmedCompilationId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {\n    files: inputCompilation.sourceIndexes,\n    sources: inputCompilation.sources,\n    shimmedCompilationId: shimmedCompilationId,\n    compiler: inputCompilation.compiler\n  })), {\n    compiler: inputCompilation.compiler\n  });\n}\n\nexports.shimCompilation = shimCompilation;\n/**\n * wrapper around shimContracts that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\n\nfunction shimArtifacts(artifacts, files) {\n  var shimmedCompilationId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"shimmedcompilation\";\n  return [shimContracts(artifacts, {\n    files: files,\n    shimmedCompilationId: shimmedCompilationId\n  })];\n}\n\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above functions.\n * Note: if you pass in options.sources, options.files will be ignored.\n * Note: if you pass in options.sources, sources will not have\n * compiler set unless you also pass in options.compiler; in this case\n * you should set that up separately, as in shimCompilation().\n */\n\nfunction shimContracts(artifacts) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var files = options.files,\n      inputSources = options.sources;\n  var shimmedCompilationId = options.shimmedCompilationId || \"shimmedcompilation\";\n  var contracts = [];\n  var sources = [];\n  var unreliableSourceOrder = false;\n\n  var _iterator = _createForOfIteratorHelper(artifacts),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var artifact = _step.value;\n      var contractName = artifact.contractName,\n          bytecode = artifact.bytecode,\n          sourceMap = artifact.sourceMap,\n          deployedBytecode = artifact.deployedBytecode,\n          deployedSourceMap = artifact.deployedSourceMap,\n          immutableReferences = artifact.immutableReferences,\n          sourcePath = artifact.sourcePath,\n          source = artifact.source,\n          ast = artifact.ast,\n          abi = artifact.abi,\n          compiler = artifact.compiler,\n          generatedSources = artifact.generatedSources,\n          deployedGeneratedSources = artifact.deployedGeneratedSources;\n\n      if (artifact.contract_name) {\n        //just in case\n        contractName = artifact.contract_name; //dunno what's up w/ the type of contract_name, but it needs coercing\n      }\n\n      debug(\"contractName: %s\", contractName);\n      var contractObject = {\n        contractName: contractName,\n        bytecode: bytecode,\n        sourceMap: sourceMap,\n        deployedBytecode: deployedBytecode,\n        deployedSourceMap: deployedSourceMap,\n        immutableReferences: immutableReferences,\n        abi: abi,\n        generatedSources: normalizeGeneratedSources(generatedSources, compiler),\n        deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),\n        compiler: compiler\n      };\n      var sourceObject = {\n        sourcePath: sourcePath,\n        source: source,\n        ast: ast,\n        compiler: compiler,\n        language: inferLanguage(ast, compiler)\n      }; //ast needs to be coerced because schema doesn't quite match our types here...\n      //if files or sources was passed, trust that to determine the source index\n\n      if (files || inputSources) {\n        //note: we never set the unreliableSourceOrder flag in this branch;\n        //we just trust files/sources.  If this info is bad, then, uh, too bad.\n        var _index2 = inputSources ? inputSources.findIndex(function (source) {\n          return source.sourcePath === sourcePath;\n        }) : files.indexOf(sourcePath);\n\n        if (!inputSources) {\n          //if inputSources was passed, we'll handle this separately below\n          sourceObject.id = _index2.toString(); //HACK\n\n          sources[_index2] = sourceObject;\n        }\n\n        contractObject.primarySourceId = _index2.toString(); //HACK\n      } else {\n        //if neither was passed, attempt to determine it from the ast\n        var _index3;\n\n        if (sourceObject.ast) {\n          //note: this works for both Solidity and Vyper\n          _index3 = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n        } else if (compiler && compiler.name === \"vyper\") {\n          _index3 = 0; //if it's Vyper but there's no AST, we can\n          //assume that it was compiled alone and therefore has index 0\n        } //if that didn't work, try the source map\n\n\n        if (_index3 === undefined && (sourceMap || deployedSourceMap)) {\n          var sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n          _index3 = extractPrimarySource(sourceMapString);\n        } //else leave undefined for now\n\n\n        var _getIndexToAddAt = getIndexToAddAt(sourceObject, _index3, sources, unreliableSourceOrder);\n\n        _index3 = _getIndexToAddAt.index;\n        unreliableSourceOrder = _getIndexToAddAt.unreliableSourceOrder;\n\n        if (_index3 !== null) {\n          //if we're in this case, inputSources was not passed\n          sourceObject.id = _index3.toString(); //HACK\n\n          sources[_index3] = sourceObject;\n          contractObject.primarySourceId = _index3.toString();\n        }\n      }\n\n      contracts.push(contractObject);\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    } //now: check for id overlap with internal sources\n    //(don't bother if inputSources or files was passed)\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (!inputSources && !files) {\n    var _iterator2 = _createForOfIteratorHelper(contracts),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var contract = _step2.value;\n        var generatedSources = contract.generatedSources,\n            deployedGeneratedSources = contract.deployedGeneratedSources;\n\n        for (var index in generatedSources) {\n          if (index in sources) {\n            unreliableSourceOrder = true;\n          }\n        }\n\n        for (var _index in deployedGeneratedSources) {\n          if (_index in sources) {\n            unreliableSourceOrder = true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  var compiler;\n\n  if (options.compiler) {\n    compiler = options.compiler;\n  } else if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    compiler = contracts[0].compiler;\n  } //if input sources was passed, set up the sources object directly :)\n\n\n  if (inputSources) {\n    sources = inputSources.map(function (_ref, index) {\n      var sourcePath = _ref.sourcePath,\n          source = _ref.contents,\n          ast = _ref.ast,\n          language = _ref.language;\n      return {\n        sourcePath: sourcePath,\n        source: source,\n        ast: ast,\n        language: language,\n        id: index.toString(),\n        compiler: compiler //redundant but let's include it\n\n      };\n    });\n  }\n\n  return {\n    id: shimmedCompilationId,\n    unreliableSourceOrder: unreliableSourceOrder,\n    sources: sources,\n    contracts: contracts,\n    compiler: compiler\n  };\n}\n\nexports.shimContracts = shimContracts; //note: this works for Vyper too!\n\nfunction sourceIndexForAst(ast) {\n  if (Array.isArray(ast)) {\n    //special handling for old Vyper versions\n    ast = ast[0];\n  }\n\n  if (!ast) {\n    return undefined;\n  }\n\n  return parseInt(ast.src.split(\":\")[2]); //src is given as start:length:file.\n  //we want just the file.\n}\n\nfunction getContractNode(contract, compilation) {\n  var contractName = contract.contractName,\n      sourceMap = contract.sourceMap,\n      deployedSourceMap = contract.deployedSourceMap,\n      primarySourceId = contract.primarySourceId;\n  var unreliableSourceOrder = compilation.unreliableSourceOrder,\n      sources = compilation.sources;\n  var sourcesToCheck; //we will attempt to locate the primary source;\n  //if we can't find it, we'll just check every source in this\n  //compilation.\n\n  if (primarySourceId !== undefined) {\n    sourcesToCheck = [sources.find(function (source) {\n      return source && source.id === primarySourceId;\n    })];\n  } else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n    var sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n    var sourceId = extractPrimarySource(sourceMapString);\n    sourcesToCheck = [sources[sourceId]];\n  } else {\n    //WARNING: if we end up in this case, we could get the wrong contract!\n    //(but we shouldn't end up here)\n    sourcesToCheck = sources;\n  }\n\n  return sourcesToCheck.reduce(function (foundNode, source) {\n    if (foundNode || !source) {\n      return foundNode;\n    }\n\n    if (!source.ast || source.language !== \"Solidity\") {\n      //ignore non-Solidity ASTs for now, we don't support them yet\n      return undefined;\n    }\n\n    return source.ast.nodes.find(function (node) {\n      return node.nodeType === \"ContractDefinition\" && node.name === contractName;\n    });\n  }, undefined);\n}\n\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n */\n\nfunction extractPrimarySource(sourceMap) {\n  if (!sourceMap) {\n    //HACK?\n    return 0; //in this case (e.g. a Vyper contract with an old-style\n    //source map) we infer that it was compiled by itself\n  }\n\n  return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);\n}\n\nfunction normalizeGeneratedSources(generatedSources, compiler) {\n  if (!generatedSources) {\n    return [];\n  }\n\n  if (!isGeneratedSources(generatedSources)) {\n    return generatedSources; //if already normalizeed, leave alone\n  }\n\n  var sources = []; //output\n\n  var _iterator3 = _createForOfIteratorHelper(generatedSources),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var source = _step3.value;\n      sources[source.id] = {\n        id: source.id.toString(),\n        sourcePath: source.name,\n        source: source.contents,\n        //ast needs to be coerced because schema doesn't quite match our types here...\n        ast: source.ast,\n        compiler: compiler,\n        language: source.language\n      };\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return sources;\n} //HACK\n\n\nfunction isGeneratedSources(sources) {\n  //note: for some reason arr.includes(undefined) returns true on sparse arrays\n  //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization\n  return sources.length > 0 && !sources.includes(undefined) && (sources[0].contents !== undefined || sources[0].name !== undefined);\n} //HACK, maybe?\n\n\nfunction inferLanguage(ast, compiler) {\n  if (ast) {\n    if (ast.nodeType === \"SourceUnit\") {\n      return \"Solidity\";\n    } else if (ast.nodeType && ast.nodeType.startsWith(\"Yul\")) {\n      //Every Yul source I've seen has YulBlock as the root, but\n      //I'm not sure that that's *always* the case\n      return \"Yul\";\n    } else if (Array.isArray(ast) || ast.ast_type === \"Module\") {\n      return \"Vyper\";\n    }\n  } else if (compiler) {\n    if (compiler.name === \"vyper\") {\n      return \"Vyper\";\n    } else if (compiler.name === \"solc\") {\n      //if it's solc but no AST, just assume it's Solidity\n      return \"Solidity\";\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\n\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n  //first: is this already there? only add it if it's not.\n  //(we determine this by sourcePath if present, and the actual source\n  //contents if not)\n  debug(\"sourcePath: %s\", sourceObject.sourcePath);\n  debug(\"given index: %d\", index);\n  debug(\"sources: %o\", sources.map(function (source) {\n    return source.sourcePath;\n  }));\n\n  if (sources.every(function (existingSource) {\n    return existingSource.sourcePath !== sourceObject.sourcePath || !sourceObject.sourcePath && !existingSource.sourcePath && existingSource.source !== sourceObject.source;\n  })) {\n    if (unreliableSourceOrder || index === undefined || index in sources) {\n      //if we can't add it at the correct spot, set the\n      //unreliable source order flag\n      debug(\"collision!\");\n      unreliableSourceOrder = true;\n    } //otherwise, just leave things alone\n\n\n    if (unreliableSourceOrder) {\n      //in case of unreliable source order, we'll ignore what indices\n      //things are *supposed* to have and just append things to the end\n      index = sources.length;\n    }\n\n    return {\n      index: index,\n      unreliableSourceOrder: unreliableSourceOrder\n    };\n  } else {\n    //return index: null indicates don't add this because it's\n    //already present\n    debug(\"already present, not adding\");\n    return {\n      index: null,\n      unreliableSourceOrder: unreliableSourceOrder\n    };\n  }\n}\n/**\n * convert Vyper source maps to solidity ones\n * (note we won't bother handling the case where the compressed\n * version doesn't exist; that will have to wait for a later version)\n */\n\n\nfunction simpleShimSourceMap(sourceMap) {\n  if (sourceMap === undefined) {\n    return undefined; //undefined case\n  } else if (typeof sourceMap === \"object\") {\n    return sourceMap.pc_pos_map_compressed; //Vyper object case\n  } else {\n    try {\n      return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case\n    } catch (_) {\n      return sourceMap; //Solidity case\n    }\n  }\n}\n\nexports.simpleShimSourceMap = simpleShimSourceMap;","map":{"version":3,"sources":["../../../lib/compilations/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:compilations:utils\");\nfunction shimCompilations(inputCompilations, shimmedCompilationIdPrefix = \"shimmedcompilation\") {\n    return inputCompilations.map((compilation, compilationIndex) => shimCompilation(compilation, `${shimmedCompilationIdPrefix}Number(${compilationIndex})`));\n}\nexports.shimCompilations = shimCompilations;\nfunction shimCompilation(inputCompilation, shimmedCompilationId = \"shimmedcompilation\") {\n    return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {\n        files: inputCompilation.sourceIndexes,\n        sources: inputCompilation.sources,\n        shimmedCompilationId,\n        compiler: inputCompilation.compiler\n    })), { compiler: inputCompilation.compiler });\n}\nexports.shimCompilation = shimCompilation;\n/**\n * wrapper around shimContracts that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\nfunction shimArtifacts(artifacts, files, shimmedCompilationId = \"shimmedcompilation\") {\n    return [shimContracts(artifacts, { files, shimmedCompilationId })];\n}\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above functions.\n * Note: if you pass in options.sources, options.files will be ignored.\n * Note: if you pass in options.sources, sources will not have\n * compiler set unless you also pass in options.compiler; in this case\n * you should set that up separately, as in shimCompilation().\n */\nfunction shimContracts(artifacts, options = {}) {\n    const { files, sources: inputSources } = options;\n    const shimmedCompilationId = options.shimmedCompilationId || \"shimmedcompilation\";\n    let contracts = [];\n    let sources = [];\n    let unreliableSourceOrder = false;\n    for (let artifact of artifacts) {\n        let { contractName, bytecode, sourceMap, deployedBytecode, deployedSourceMap, immutableReferences, sourcePath, source, ast, abi, compiler, generatedSources, deployedGeneratedSources } = artifact;\n        if (artifact.contract_name) {\n            //just in case\n            contractName = artifact.contract_name;\n            //dunno what's up w/ the type of contract_name, but it needs coercing\n        }\n        debug(\"contractName: %s\", contractName);\n        let contractObject = {\n            contractName,\n            bytecode,\n            sourceMap,\n            deployedBytecode,\n            deployedSourceMap,\n            immutableReferences,\n            abi,\n            generatedSources: normalizeGeneratedSources(generatedSources, compiler),\n            deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),\n            compiler\n        };\n        let sourceObject = {\n            sourcePath,\n            source,\n            ast: ast,\n            compiler,\n            language: inferLanguage(ast, compiler)\n        };\n        //ast needs to be coerced because schema doesn't quite match our types here...\n        //if files or sources was passed, trust that to determine the source index\n        if (files || inputSources) {\n            //note: we never set the unreliableSourceOrder flag in this branch;\n            //we just trust files/sources.  If this info is bad, then, uh, too bad.\n            const index = inputSources\n                ? inputSources.findIndex(source => source.sourcePath === sourcePath)\n                : files.indexOf(sourcePath);\n            if (!inputSources) {\n                //if inputSources was passed, we'll handle this separately below\n                sourceObject.id = index.toString(); //HACK\n                sources[index] = sourceObject;\n            }\n            contractObject.primarySourceId = index.toString(); //HACK\n        }\n        else {\n            //if neither was passed, attempt to determine it from the ast\n            let index;\n            if (sourceObject.ast) {\n                //note: this works for both Solidity and Vyper\n                index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n            }\n            else if (compiler && compiler.name === \"vyper\") {\n                index = 0; //if it's Vyper but there's no AST, we can\n                //assume that it was compiled alone and therefore has index 0\n            }\n            //if that didn't work, try the source map\n            if (index === undefined && (sourceMap || deployedSourceMap)) {\n                const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n                index = extractPrimarySource(sourceMapString);\n            }\n            //else leave undefined for now\n            ({ index, unreliableSourceOrder } = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder));\n            if (index !== null) {\n                //if we're in this case, inputSources was not passed\n                sourceObject.id = index.toString(); //HACK\n                sources[index] = sourceObject;\n                contractObject.primarySourceId = index.toString();\n            }\n        }\n        contracts.push(contractObject);\n    }\n    //now: check for id overlap with internal sources\n    //(don't bother if inputSources or files was passed)\n    if (!inputSources && !files) {\n        for (let contract of contracts) {\n            const { generatedSources, deployedGeneratedSources } = contract;\n            for (let index in generatedSources) {\n                if (index in sources) {\n                    unreliableSourceOrder = true;\n                }\n            }\n            for (let index in deployedGeneratedSources) {\n                if (index in sources) {\n                    unreliableSourceOrder = true;\n                }\n            }\n        }\n    }\n    let compiler;\n    if (options.compiler) {\n        compiler = options.compiler;\n    }\n    else if (!unreliableSourceOrder && contracts.length > 0) {\n        //if things were actually compiled together, we should just be able\n        //to pick an arbitrary one\n        compiler = contracts[0].compiler;\n    }\n    //if input sources was passed, set up the sources object directly :)\n    if (inputSources) {\n        sources = inputSources.map(({ sourcePath, contents: source, ast, language }, index) => ({\n            sourcePath,\n            source,\n            ast: ast,\n            language,\n            id: index.toString(),\n            compiler //redundant but let's include it\n        }));\n    }\n    return {\n        id: shimmedCompilationId,\n        unreliableSourceOrder,\n        sources,\n        contracts,\n        compiler\n    };\n}\nexports.shimContracts = shimContracts;\n//note: this works for Vyper too!\nfunction sourceIndexForAst(ast) {\n    if (Array.isArray(ast)) {\n        //special handling for old Vyper versions\n        ast = ast[0];\n    }\n    if (!ast) {\n        return undefined;\n    }\n    return parseInt(ast.src.split(\":\")[2]);\n    //src is given as start:length:file.\n    //we want just the file.\n}\nfunction getContractNode(contract, compilation) {\n    const { contractName, sourceMap, deployedSourceMap, primarySourceId } = contract;\n    const { unreliableSourceOrder, sources } = compilation;\n    let sourcesToCheck;\n    //we will attempt to locate the primary source;\n    //if we can't find it, we'll just check every source in this\n    //compilation.\n    if (primarySourceId !== undefined) {\n        sourcesToCheck = [\n            sources.find(source => source && source.id === primarySourceId)\n        ];\n    }\n    else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n        const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n        let sourceId = extractPrimarySource(sourceMapString);\n        sourcesToCheck = [sources[sourceId]];\n    }\n    else {\n        //WARNING: if we end up in this case, we could get the wrong contract!\n        //(but we shouldn't end up here)\n        sourcesToCheck = sources;\n    }\n    return sourcesToCheck.reduce((foundNode, source) => {\n        if (foundNode || !source) {\n            return foundNode;\n        }\n        if (!source.ast || source.language !== \"Solidity\") {\n            //ignore non-Solidity ASTs for now, we don't support them yet\n            return undefined;\n        }\n        return source.ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === contractName);\n    }, undefined);\n}\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n */\nfunction extractPrimarySource(sourceMap) {\n    if (!sourceMap) {\n        //HACK?\n        return 0; //in this case (e.g. a Vyper contract with an old-style\n        //source map) we infer that it was compiled by itself\n    }\n    return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);\n}\nfunction normalizeGeneratedSources(generatedSources, compiler) {\n    if (!generatedSources) {\n        return [];\n    }\n    if (!isGeneratedSources(generatedSources)) {\n        return generatedSources; //if already normalizeed, leave alone\n    }\n    let sources = []; //output\n    for (let source of generatedSources) {\n        sources[source.id] = {\n            id: source.id.toString(),\n            sourcePath: source.name,\n            source: source.contents,\n            //ast needs to be coerced because schema doesn't quite match our types here...\n            ast: source.ast,\n            compiler: compiler,\n            language: source.language\n        };\n    }\n    return sources;\n}\n//HACK\nfunction isGeneratedSources(sources) {\n    //note: for some reason arr.includes(undefined) returns true on sparse arrays\n    //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization\n    return (sources.length > 0 &&\n        !sources.includes(undefined) &&\n        (sources[0].contents !== undefined ||\n            sources[0].name !== undefined));\n}\n//HACK, maybe?\nfunction inferLanguage(ast, compiler) {\n    if (ast) {\n        if (ast.nodeType === \"SourceUnit\") {\n            return \"Solidity\";\n        }\n        else if (ast.nodeType && ast.nodeType.startsWith(\"Yul\")) {\n            //Every Yul source I've seen has YulBlock as the root, but\n            //I'm not sure that that's *always* the case\n            return \"Yul\";\n        }\n        else if (Array.isArray(ast) || ast.ast_type === \"Module\") {\n            return \"Vyper\";\n        }\n    }\n    else if (compiler) {\n        if (compiler.name === \"vyper\") {\n            return \"Vyper\";\n        }\n        else if (compiler.name === \"solc\") {\n            //if it's solc but no AST, just assume it's Solidity\n            return \"Solidity\";\n        }\n        else {\n            return undefined;\n        }\n    }\n    else {\n        return undefined;\n    }\n}\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n    //first: is this already there? only add it if it's not.\n    //(we determine this by sourcePath if present, and the actual source\n    //contents if not)\n    debug(\"sourcePath: %s\", sourceObject.sourcePath);\n    debug(\"given index: %d\", index);\n    debug(\"sources: %o\", sources.map(source => source.sourcePath));\n    if (sources.every(existingSource => existingSource.sourcePath !== sourceObject.sourcePath ||\n        (!sourceObject.sourcePath &&\n            !existingSource.sourcePath &&\n            existingSource.source !== sourceObject.source))) {\n        if (unreliableSourceOrder || index === undefined || index in sources) {\n            //if we can't add it at the correct spot, set the\n            //unreliable source order flag\n            debug(\"collision!\");\n            unreliableSourceOrder = true;\n        }\n        //otherwise, just leave things alone\n        if (unreliableSourceOrder) {\n            //in case of unreliable source order, we'll ignore what indices\n            //things are *supposed* to have and just append things to the end\n            index = sources.length;\n        }\n        return {\n            index,\n            unreliableSourceOrder\n        };\n    }\n    else {\n        //return index: null indicates don't add this because it's\n        //already present\n        debug(\"already present, not adding\");\n        return {\n            index: null,\n            unreliableSourceOrder\n        };\n    }\n}\n/**\n * convert Vyper source maps to solidity ones\n * (note we won't bother handling the case where the compressed\n * version doesn't exist; that will have to wait for a later version)\n */\nfunction simpleShimSourceMap(sourceMap) {\n    if (sourceMap === undefined) {\n        return undefined; //undefined case\n    }\n    else if (typeof sourceMap === \"object\") {\n        return sourceMap.pc_pos_map_compressed; //Vyper object case\n    }\n    else {\n        try {\n            return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case\n        }\n        catch (_) {\n            return sourceMap; //Solidity case\n        }\n    }\n}\nexports.simpleShimSourceMap = simpleShimSourceMap;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}