{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.definitionToStoredType = exports.definitionToType = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:ast:import\");\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar Compiler = __importStar(require(\"../../compiler\"));\n\nvar Utils = __importStar(require(\"../utils\"));\n\nvar import_1 = require(\"../../contexts/import\"); //NOTE: the following function will *not* work for arbitrary nodes! It will,\n//however, work well enough for what we need.  I.e., it will:\n//1. work when given the actual variable definition as the node,\n//2. work when given an elementary type as the node,\n//3. work when given a user-defined type as the node,\n//4. produce something of the correct size in all cases.\n//Use beyond that is at your own risk!\n//NOTE: set forceLocation to *null* to force no location. leave it undefined\n//to not force a location.\n\n\nfunction definitionToType(definition, compilationId, compiler, forceLocation) {\n  var typeClass = Utils.typeClass(definition);\n  var typeHint = Utils.typeStringWithoutLocation(definition);\n\n  switch (typeClass) {\n    case \"bool\":\n      return {\n        typeClass: typeClass,\n        typeHint: typeHint\n      };\n\n    case \"address\":\n      {\n        switch (Compiler.Utils.solidityFamily(compiler)) {\n          case \"pre-0.5.0\":\n            return {\n              typeClass: typeClass,\n              kind: \"general\",\n              typeHint: typeHint\n            };\n\n          case \"0.5.x\":\n            return {\n              typeClass: typeClass,\n              kind: \"specific\",\n              payable: Utils.typeIdentifier(definition) === \"t_address_payable\"\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"uint\":\n      {\n        var bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass: typeClass,\n          bits: bytes * 8,\n          typeHint: typeHint\n        };\n      }\n\n    case \"int\":\n      {\n        //typeScript won't let me group these for some reason\n        var _bytes = Utils.specifiedSize(definition);\n\n        return {\n          typeClass: typeClass,\n          bits: _bytes * 8,\n          typeHint: typeHint\n        };\n      }\n\n    case \"fixed\":\n      {\n        //typeScript won't let me group these for some reason\n        var _bytes2 = Utils.specifiedSize(definition);\n\n        var places = Utils.decimalPlaces(definition);\n        return {\n          typeClass: typeClass,\n          bits: _bytes2 * 8,\n          places: places,\n          typeHint: typeHint\n        };\n      }\n\n    case \"ufixed\":\n      {\n        var _bytes3 = Utils.specifiedSize(definition);\n\n        var _places = Utils.decimalPlaces(definition);\n\n        return {\n          typeClass: typeClass,\n          bits: _bytes3 * 8,\n          places: _places,\n          typeHint: typeHint\n        };\n      }\n\n    case \"string\":\n      {\n        if (forceLocation === null) {\n          return {\n            typeClass: typeClass,\n            typeHint: typeHint\n          };\n        }\n\n        var location = forceLocation || Utils.referenceType(definition);\n        return {\n          typeClass: typeClass,\n          location: location,\n          typeHint: typeHint\n        };\n      }\n\n    case \"bytes\":\n      {\n        var length = Utils.specifiedSize(definition);\n\n        if (length !== null) {\n          return {\n            typeClass: typeClass,\n            kind: \"static\",\n            length: length,\n            typeHint: typeHint\n          };\n        } else {\n          if (forceLocation === null) {\n            return {\n              typeClass: typeClass,\n              kind: \"dynamic\",\n              typeHint: typeHint\n            };\n          }\n\n          var _location = forceLocation || Utils.referenceType(definition);\n\n          return {\n            typeClass: typeClass,\n            kind: \"dynamic\",\n            location: _location,\n            typeHint: typeHint\n          };\n        }\n      }\n\n    case \"array\":\n      {\n        var baseDefinition = Utils.baseDefinition(definition);\n        var baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);\n\n        var _location2 = forceLocation || Utils.referenceType(definition);\n\n        if (Utils.isDynamicArray(definition)) {\n          if (forceLocation !== null) {\n            return {\n              typeClass: typeClass,\n              baseType: baseType,\n              kind: \"dynamic\",\n              location: _location2,\n              typeHint: typeHint\n            };\n          } else {\n            return {\n              typeClass: typeClass,\n              baseType: baseType,\n              kind: \"dynamic\",\n              typeHint: typeHint\n            };\n          }\n        } else {\n          var _length = new bn_js_1.default(Utils.staticLengthAsString(definition));\n\n          if (forceLocation !== null) {\n            return {\n              typeClass: typeClass,\n              baseType: baseType,\n              kind: \"static\",\n              length: _length,\n              location: _location2,\n              typeHint: typeHint\n            };\n          } else {\n            return {\n              typeClass: typeClass,\n              baseType: baseType,\n              kind: \"static\",\n              length: _length,\n              typeHint: typeHint\n            };\n          }\n        }\n      }\n\n    case \"mapping\":\n      {\n        var keyDefinition = Utils.keyDefinition(definition); //note that we can skip the scopes argument here! that's only needed when\n        //a general node, rather than a declaration, is being passed in\n\n        var keyType = definitionToType(keyDefinition, compilationId, compiler, null); //suppress the location on the key type (it'll be given as memory but\n        //this is meaningless)\n        //also, we have to tell TypeScript ourselves that this will be an elementary\n        //type; it has no way of knowing that\n\n        debug(\"definition: %O\", definition);\n        var valueDefinition = Utils.valueDefinition(definition);\n        var valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);\n\n        if (forceLocation === null) {\n          return {\n            typeClass: typeClass,\n            keyType: keyType,\n            valueType: valueType\n          };\n        }\n\n        return {\n          typeClass: typeClass,\n          keyType: keyType,\n          valueType: valueType,\n          location: \"storage\"\n        };\n      }\n\n    case \"function\":\n      {\n        //WARNING! This case will not work unless given the actual\n        //definition!  It should return something *roughly* usable, though.\n        var visibility = Utils.visibility(definition); //undefined if bad node\n\n        var mutability = Utils.mutability(definition); //undefined if bad node\n\n        var _ref = Utils.parameters(definition) || [[], []],\n            _ref2 = _slicedToArray(_ref, 2),\n            inputParameters = _ref2[0],\n            outputParameters = _ref2[1]; //HACK\n        //note: don't force a location on these! use the listed location!\n\n\n        var inputParameterTypes = inputParameters.map(function (parameter) {\n          return definitionToType(parameter, compilationId, compiler);\n        });\n        var outputParameterTypes = outputParameters.map(function (parameter) {\n          return definitionToType(parameter, compilationId, compiler);\n        });\n\n        switch (visibility) {\n          case \"internal\":\n            return {\n              typeClass: typeClass,\n              visibility: visibility,\n              mutability: mutability,\n              inputParameterTypes: inputParameterTypes,\n              outputParameterTypes: outputParameterTypes\n            };\n\n          case \"external\":\n            return {\n              typeClass: typeClass,\n              visibility: visibility,\n              kind: \"specific\",\n              mutability: mutability,\n              inputParameterTypes: inputParameterTypes,\n              outputParameterTypes: outputParameterTypes\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"struct\":\n      {\n        var id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        var qualifiedName = Utils.typeStringWithoutLocation(definition).match(/struct (.*)/)[1];\n        var definingContractName;\n        var typeName;\n\n        if (qualifiedName.includes(\".\")) {\n          var _qualifiedName$split = qualifiedName.split(\".\");\n\n          var _qualifiedName$split2 = _slicedToArray(_qualifiedName$split, 2);\n\n          definingContractName = _qualifiedName$split2[0];\n          typeName = _qualifiedName$split2[1];\n        } else {\n          typeName = qualifiedName; //leave definingContractName undefined\n        }\n\n        if (forceLocation === null) {\n          if (definingContractName) {\n            return {\n              typeClass: typeClass,\n              kind: \"local\",\n              id: id,\n              typeName: typeName,\n              definingContractName: definingContractName\n            };\n          } else {\n            return {\n              typeClass: typeClass,\n              kind: \"global\",\n              id: id,\n              typeName: typeName\n            };\n          }\n        }\n\n        var _location3 = forceLocation || Utils.referenceType(definition);\n\n        if (definingContractName) {\n          return {\n            typeClass: typeClass,\n            kind: \"local\",\n            id: id,\n            typeName: typeName,\n            definingContractName: definingContractName,\n            location: _location3\n          };\n        } else {\n          return {\n            typeClass: typeClass,\n            kind: \"global\",\n            id: id,\n            typeName: typeName,\n            location: _location3\n          };\n        }\n      }\n\n    case \"enum\":\n      {\n        var _id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n\n        var _qualifiedName = Utils.typeStringWithoutLocation(definition).match(/enum (.*)/)[1];\n\n        var _definingContractName;\n\n        var _typeName;\n\n        if (_qualifiedName.includes(\".\")) {\n          var _qualifiedName$split3 = _qualifiedName.split(\".\");\n\n          var _qualifiedName$split4 = _slicedToArray(_qualifiedName$split3, 2);\n\n          _definingContractName = _qualifiedName$split4[0];\n          _typeName = _qualifiedName$split4[1];\n        } else {\n          _typeName = _qualifiedName; //leave definingContractName undefined\n        }\n\n        if (_definingContractName) {\n          return {\n            typeClass: typeClass,\n            kind: \"local\",\n            id: _id,\n            typeName: _typeName,\n            definingContractName: _definingContractName\n          };\n        } else {\n          return {\n            typeClass: typeClass,\n            kind: \"global\",\n            id: _id,\n            typeName: _typeName\n          };\n        }\n      }\n\n    case \"contract\":\n      {\n        var _id2 = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n\n        var _typeName2 = Utils.typeStringWithoutLocation(definition).match(/(contract|library|interface) (.*)/)[2]; //note: we use the type string rather than the type identifier\n        //in order to avoid having to deal with the underscore problem\n\n        var contractKind = Utils.contractKind(definition);\n        return {\n          typeClass: typeClass,\n          kind: \"native\",\n          id: _id2,\n          typeName: _typeName2,\n          contractKind: contractKind\n        };\n      }\n\n    case \"magic\":\n      {\n        var typeIdentifier = Utils.typeIdentifier(definition);\n        var variable = typeIdentifier.match(/^t_magic_(.*)$/)[1];\n        return {\n          typeClass: typeClass,\n          variable: variable\n        };\n      }\n  }\n}\n\nexports.definitionToType = definitionToType; //whereas the above takes variable definitions, this takes the actual type\n//definition\n\nfunction definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {\n  switch (definition.nodeType) {\n    case \"StructDefinition\":\n      {\n        var id = import_1.makeTypeId(definition.id, compilationId);\n        var definingContractName;\n        var typeName;\n\n        if (definition.canonicalName.includes(\".\")) {\n          var _definition$canonical = definition.canonicalName.split(\".\");\n\n          var _definition$canonical2 = _slicedToArray(_definition$canonical, 2);\n\n          definingContractName = _definition$canonical2[0];\n          typeName = _definition$canonical2[1];\n        } else {\n          typeName = definition.canonicalName; //leave definingContractName undefined\n        }\n\n        var memberTypes = definition.members.map(function (member) {\n          return {\n            name: member.name,\n            type: definitionToType(member, compilationId, compiler, null)\n          };\n        });\n        var definingContract;\n\n        if (referenceDeclarations) {\n          var contractDefinition = Object.values(referenceDeclarations).find(function (node) {\n            return node.nodeType === \"ContractDefinition\" && node.nodes.some(function (subNode) {\n              return import_1.makeTypeId(subNode.id, compilationId) === id;\n            });\n          });\n\n          if (contractDefinition) {\n            definingContract = definitionToStoredType(contractDefinition, compilationId, compiler); //can skip reference declarations\n          }\n        }\n\n        if (definingContract) {\n          return {\n            typeClass: \"struct\",\n            kind: \"local\",\n            id: id,\n            typeName: typeName,\n            definingContractName: definingContractName,\n            definingContract: definingContract,\n            memberTypes: memberTypes\n          };\n        } else {\n          return {\n            typeClass: \"struct\",\n            kind: \"global\",\n            id: id,\n            typeName: typeName,\n            memberTypes: memberTypes\n          };\n        }\n      }\n\n    case \"EnumDefinition\":\n      {\n        var _id3 = import_1.makeTypeId(definition.id, compilationId);\n\n        var _definingContractName2;\n\n        var _typeName3;\n\n        debug(\"typeName: %s\", _typeName3);\n\n        if (definition.canonicalName.includes(\".\")) {\n          var _definition$canonical3 = definition.canonicalName.split(\".\");\n\n          var _definition$canonical4 = _slicedToArray(_definition$canonical3, 2);\n\n          _definingContractName2 = _definition$canonical4[0];\n          _typeName3 = _definition$canonical4[1];\n        } else {\n          _typeName3 = definition.canonicalName; //leave definingContractName undefined\n        }\n\n        var options = definition.members.map(function (member) {\n          return member.name;\n        });\n\n        var _definingContract;\n\n        if (referenceDeclarations) {\n          var _contractDefinition = Object.values(referenceDeclarations).find(function (node) {\n            return node.nodeType === \"ContractDefinition\" && node.nodes.some(function (subNode) {\n              return import_1.makeTypeId(subNode.id, compilationId) === _id3;\n            });\n          });\n\n          if (_contractDefinition) {\n            _definingContract = definitionToStoredType(_contractDefinition, compilationId, compiler); //can skip reference declarations\n\n            debug(\"contractDefinition: %o\", _contractDefinition);\n            debug(\"definingContract: %o\", _definingContract);\n          }\n        }\n\n        if (_definingContract) {\n          return {\n            typeClass: \"enum\",\n            kind: \"local\",\n            id: _id3,\n            typeName: _typeName3,\n            definingContractName: _definingContractName2,\n            definingContract: _definingContract,\n            options: options\n          };\n        } else {\n          return {\n            typeClass: \"enum\",\n            kind: \"global\",\n            id: _id3,\n            typeName: _typeName3,\n            options: options\n          };\n        }\n      }\n\n    case \"ContractDefinition\":\n      {\n        var _id4 = import_1.makeTypeId(definition.id, compilationId);\n\n        var _typeName4 = definition.name;\n        var contractKind = definition.contractKind;\n        var payable = Utils.isContractPayable(definition);\n        return {\n          typeClass: \"contract\",\n          kind: \"native\",\n          id: _id4,\n          typeName: _typeName4,\n          contractKind: contractKind,\n          payable: payable\n        };\n      }\n  }\n}\n\nexports.definitionToStoredType = definitionToStoredType;","map":{"version":3,"sources":["../../../../lib/ast/import/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.definitionToStoredType = exports.definitionToType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:ast:import\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst Compiler = __importStar(require(\"../../compiler\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst import_1 = require(\"../../contexts/import\");\n//NOTE: the following function will *not* work for arbitrary nodes! It will,\n//however, work well enough for what we need.  I.e., it will:\n//1. work when given the actual variable definition as the node,\n//2. work when given an elementary type as the node,\n//3. work when given a user-defined type as the node,\n//4. produce something of the correct size in all cases.\n//Use beyond that is at your own risk!\n//NOTE: set forceLocation to *null* to force no location. leave it undefined\n//to not force a location.\nfunction definitionToType(definition, compilationId, compiler, forceLocation) {\n    let typeClass = Utils.typeClass(definition);\n    let typeHint = Utils.typeStringWithoutLocation(definition);\n    switch (typeClass) {\n        case \"bool\":\n            return {\n                typeClass,\n                typeHint\n            };\n        case \"address\": {\n            switch (Compiler.Utils.solidityFamily(compiler)) {\n                case \"pre-0.5.0\":\n                    return {\n                        typeClass,\n                        kind: \"general\",\n                        typeHint\n                    };\n                case \"0.5.x\":\n                    return {\n                        typeClass,\n                        kind: \"specific\",\n                        payable: Utils.typeIdentifier(definition) === \"t_address_payable\"\n                    };\n            }\n            break; //to satisfy typescript\n        }\n        case \"uint\": {\n            let bytes = Utils.specifiedSize(definition);\n            return {\n                typeClass,\n                bits: bytes * 8,\n                typeHint\n            };\n        }\n        case \"int\": {\n            //typeScript won't let me group these for some reason\n            let bytes = Utils.specifiedSize(definition);\n            return {\n                typeClass,\n                bits: bytes * 8,\n                typeHint\n            };\n        }\n        case \"fixed\": {\n            //typeScript won't let me group these for some reason\n            let bytes = Utils.specifiedSize(definition);\n            let places = Utils.decimalPlaces(definition);\n            return {\n                typeClass,\n                bits: bytes * 8,\n                places,\n                typeHint\n            };\n        }\n        case \"ufixed\": {\n            let bytes = Utils.specifiedSize(definition);\n            let places = Utils.decimalPlaces(definition);\n            return {\n                typeClass,\n                bits: bytes * 8,\n                places,\n                typeHint\n            };\n        }\n        case \"string\": {\n            if (forceLocation === null) {\n                return {\n                    typeClass,\n                    typeHint\n                };\n            }\n            let location = forceLocation || Utils.referenceType(definition);\n            return {\n                typeClass,\n                location,\n                typeHint\n            };\n        }\n        case \"bytes\": {\n            let length = Utils.specifiedSize(definition);\n            if (length !== null) {\n                return {\n                    typeClass,\n                    kind: \"static\",\n                    length,\n                    typeHint\n                };\n            }\n            else {\n                if (forceLocation === null) {\n                    return {\n                        typeClass,\n                        kind: \"dynamic\",\n                        typeHint\n                    };\n                }\n                let location = forceLocation || Utils.referenceType(definition);\n                return {\n                    typeClass,\n                    kind: \"dynamic\",\n                    location,\n                    typeHint\n                };\n            }\n        }\n        case \"array\": {\n            let baseDefinition = Utils.baseDefinition(definition);\n            let baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);\n            let location = forceLocation || Utils.referenceType(definition);\n            if (Utils.isDynamicArray(definition)) {\n                if (forceLocation !== null) {\n                    return {\n                        typeClass,\n                        baseType,\n                        kind: \"dynamic\",\n                        location,\n                        typeHint\n                    };\n                }\n                else {\n                    return {\n                        typeClass,\n                        baseType,\n                        kind: \"dynamic\",\n                        typeHint\n                    };\n                }\n            }\n            else {\n                let length = new bn_js_1.default(Utils.staticLengthAsString(definition));\n                if (forceLocation !== null) {\n                    return {\n                        typeClass,\n                        baseType,\n                        kind: \"static\",\n                        length,\n                        location,\n                        typeHint\n                    };\n                }\n                else {\n                    return {\n                        typeClass,\n                        baseType,\n                        kind: \"static\",\n                        length,\n                        typeHint\n                    };\n                }\n            }\n        }\n        case \"mapping\": {\n            let keyDefinition = Utils.keyDefinition(definition);\n            //note that we can skip the scopes argument here! that's only needed when\n            //a general node, rather than a declaration, is being passed in\n            let keyType = (definitionToType(keyDefinition, compilationId, compiler, null));\n            //suppress the location on the key type (it'll be given as memory but\n            //this is meaningless)\n            //also, we have to tell TypeScript ourselves that this will be an elementary\n            //type; it has no way of knowing that\n            debug(\"definition: %O\", definition);\n            let valueDefinition = Utils.valueDefinition(definition);\n            let valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);\n            if (forceLocation === null) {\n                return {\n                    typeClass,\n                    keyType,\n                    valueType\n                };\n            }\n            return {\n                typeClass,\n                keyType,\n                valueType,\n                location: \"storage\"\n            };\n        }\n        case \"function\": {\n            //WARNING! This case will not work unless given the actual\n            //definition!  It should return something *roughly* usable, though.\n            let visibility = Utils.visibility(definition); //undefined if bad node\n            let mutability = Utils.mutability(definition); //undefined if bad node\n            let [inputParameters, outputParameters] = Utils.parameters(definition) || [[], []]; //HACK\n            //note: don't force a location on these! use the listed location!\n            let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n            let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n            switch (visibility) {\n                case \"internal\":\n                    return {\n                        typeClass,\n                        visibility,\n                        mutability,\n                        inputParameterTypes,\n                        outputParameterTypes\n                    };\n                case \"external\":\n                    return {\n                        typeClass,\n                        visibility,\n                        kind: \"specific\",\n                        mutability,\n                        inputParameterTypes,\n                        outputParameterTypes\n                    };\n            }\n            break; //to satisfy typescript\n        }\n        case \"struct\": {\n            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n            let qualifiedName = Utils.typeStringWithoutLocation(definition).match(/struct (.*)/)[1];\n            let definingContractName;\n            let typeName;\n            if (qualifiedName.includes(\".\")) {\n                [definingContractName, typeName] = qualifiedName.split(\".\");\n            }\n            else {\n                typeName = qualifiedName;\n                //leave definingContractName undefined\n            }\n            if (forceLocation === null) {\n                if (definingContractName) {\n                    return {\n                        typeClass,\n                        kind: \"local\",\n                        id,\n                        typeName,\n                        definingContractName\n                    };\n                }\n                else {\n                    return {\n                        typeClass,\n                        kind: \"global\",\n                        id,\n                        typeName\n                    };\n                }\n            }\n            let location = forceLocation || Utils.referenceType(definition);\n            if (definingContractName) {\n                return {\n                    typeClass,\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName,\n                    location\n                };\n            }\n            else {\n                return {\n                    typeClass,\n                    kind: \"global\",\n                    id,\n                    typeName,\n                    location\n                };\n            }\n        }\n        case \"enum\": {\n            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n            let qualifiedName = Utils.typeStringWithoutLocation(definition).match(/enum (.*)/)[1];\n            let definingContractName;\n            let typeName;\n            if (qualifiedName.includes(\".\")) {\n                [definingContractName, typeName] = qualifiedName.split(\".\");\n            }\n            else {\n                typeName = qualifiedName;\n                //leave definingContractName undefined\n            }\n            if (definingContractName) {\n                return {\n                    typeClass,\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName\n                };\n            }\n            else {\n                return {\n                    typeClass,\n                    kind: \"global\",\n                    id,\n                    typeName\n                };\n            }\n        }\n        case \"contract\": {\n            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n            let typeName = Utils.typeStringWithoutLocation(definition).match(/(contract|library|interface) (.*)/)[2]; //note: we use the type string rather than the type identifier\n            //in order to avoid having to deal with the underscore problem\n            let contractKind = Utils.contractKind(definition);\n            return {\n                typeClass,\n                kind: \"native\",\n                id,\n                typeName,\n                contractKind\n            };\n        }\n        case \"magic\": {\n            let typeIdentifier = Utils.typeIdentifier(definition);\n            let variable = (typeIdentifier.match(/^t_magic_(.*)$/)[1]);\n            return {\n                typeClass,\n                variable\n            };\n        }\n    }\n}\nexports.definitionToType = definitionToType;\n//whereas the above takes variable definitions, this takes the actual type\n//definition\nfunction definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {\n    switch (definition.nodeType) {\n        case \"StructDefinition\": {\n            let id = import_1.makeTypeId(definition.id, compilationId);\n            let definingContractName;\n            let typeName;\n            if (definition.canonicalName.includes(\".\")) {\n                [definingContractName, typeName] = definition.canonicalName.split(\".\");\n            }\n            else {\n                typeName = definition.canonicalName;\n                //leave definingContractName undefined\n            }\n            let memberTypes = definition.members.map(member => ({\n                name: member.name,\n                type: definitionToType(member, compilationId, compiler, null)\n            }));\n            let definingContract;\n            if (referenceDeclarations) {\n                let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === \"ContractDefinition\" &&\n                    node.nodes.some((subNode) => import_1.makeTypeId(subNode.id, compilationId) === id));\n                if (contractDefinition) {\n                    definingContract = (definitionToStoredType(contractDefinition, compilationId, compiler)); //can skip reference declarations\n                }\n            }\n            if (definingContract) {\n                return {\n                    typeClass: \"struct\",\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName,\n                    definingContract,\n                    memberTypes\n                };\n            }\n            else {\n                return {\n                    typeClass: \"struct\",\n                    kind: \"global\",\n                    id,\n                    typeName,\n                    memberTypes\n                };\n            }\n        }\n        case \"EnumDefinition\": {\n            let id = import_1.makeTypeId(definition.id, compilationId);\n            let definingContractName;\n            let typeName;\n            debug(\"typeName: %s\", typeName);\n            if (definition.canonicalName.includes(\".\")) {\n                [definingContractName, typeName] = definition.canonicalName.split(\".\");\n            }\n            else {\n                typeName = definition.canonicalName;\n                //leave definingContractName undefined\n            }\n            let options = definition.members.map(member => member.name);\n            let definingContract;\n            if (referenceDeclarations) {\n                let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === \"ContractDefinition\" &&\n                    node.nodes.some((subNode) => import_1.makeTypeId(subNode.id, compilationId) === id));\n                if (contractDefinition) {\n                    definingContract = (definitionToStoredType(contractDefinition, compilationId, compiler)); //can skip reference declarations\n                    debug(\"contractDefinition: %o\", contractDefinition);\n                    debug(\"definingContract: %o\", definingContract);\n                }\n            }\n            if (definingContract) {\n                return {\n                    typeClass: \"enum\",\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName,\n                    definingContract,\n                    options\n                };\n            }\n            else {\n                return {\n                    typeClass: \"enum\",\n                    kind: \"global\",\n                    id,\n                    typeName,\n                    options\n                };\n            }\n        }\n        case \"ContractDefinition\": {\n            let id = import_1.makeTypeId(definition.id, compilationId);\n            let typeName = definition.name;\n            let contractKind = definition.contractKind;\n            let payable = Utils.isContractPayable(definition);\n            return {\n                typeClass: \"contract\",\n                kind: \"native\",\n                id,\n                typeName,\n                contractKind,\n                payable\n            };\n        }\n    }\n}\nexports.definitionToStoredType = definitionToStoredType;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}