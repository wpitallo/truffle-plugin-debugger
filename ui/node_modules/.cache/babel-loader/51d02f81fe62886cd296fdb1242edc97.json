{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tie = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:format:utils:circularity\");\n\nfunction tie(untied) {\n  return tieWithTable(untied, []);\n}\n\nexports.tie = tie;\n\nfunction tieWithTable(untied, seenSoFar) {\n  if (untied.kind === \"error\") {\n    return untied;\n  }\n\n  var reference;\n\n  switch (untied.type.typeClass) {\n    case \"array\":\n      var untiedAsArray = untied; //dammit TS\n\n      reference = untiedAsArray.reference;\n\n      if (reference === undefined) {\n        //we need to do some pointer stuff here, so let's first create our new\n        //object we'll be pointing to\n        //[we don't want to alter the original accidentally so let's clone a bit]\n        var _tied = Object.assign(Object.assign({}, untiedAsArray), {\n          value: _toConsumableArray(untiedAsArray.value)\n        }); //now, we can't use a map here, or we'll screw things up!\n        //we want to *mutate* value, not replace it with a new object\n\n\n        for (var index in _tied.value) {\n          _tied.value[index] = tieWithTable(_tied.value[index], [_tied].concat(_toConsumableArray(seenSoFar)));\n        }\n\n        return _tied;\n      } else {\n        return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {\n          reference: reference\n        });\n      }\n\n    case \"struct\":\n      var untiedAsStruct = untied; //dammit TS\n\n      reference = untiedAsStruct.reference;\n\n      if (reference === undefined) {\n        //we need to do some pointer stuff here, so let's first create our new\n        //object we'll be pointing to\n        //[we don't want to alter the original accidentally so let's clone a bit]\n        var _tied2 = Object.assign(Object.assign({}, untiedAsStruct), {\n          value: untiedAsStruct.value.map(function (component) {\n            return Object.assign({}, component);\n          })\n        }); //now, we can't use a map here, or we'll screw things up!\n        //we want to *mutate* value, not replace it with a new object\n\n\n        for (var _index in _tied2.value) {\n          _tied2.value[_index] = Object.assign(Object.assign({}, _tied2.value[_index]), {\n            value: tieWithTable(_tied2.value[_index].value, [_tied2].concat(_toConsumableArray(seenSoFar)))\n          });\n        }\n\n        return _tied2;\n      } else {\n        return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {\n          reference: reference\n        });\n      }\n\n    case \"tuple\":\n      //currently there are no memory tuples, but may as well\n      //can't be circular, just recurse\n      //note we can just recurse with a straight tie here; don't need tieWithTable\n      var untiedAsTuple = untied; //dammit TS\n      //we need to do some pointer stuff here, so let's first create our new\n      //object we'll be pointing to\n\n      var tied = Object.assign({}, untiedAsTuple);\n      tied.value = tied.value.map(function (component) {\n        return Object.assign(Object.assign({}, component), {\n          value: tie(component.value)\n        });\n      });\n      return tied;\n\n    default:\n      //other types either:\n      //1. aren't containers and so need no recursion\n      //2. are containers but can't go in or contain memory things\n      //and so still need no recursion\n      //(or, in the case of mappings, can't contain *nontrivial* memory\n      //things)\n      return untied;\n  }\n}","map":{"version":3,"sources":["../../../../lib/format/utils/circularity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tie = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:format:utils:circularity\");\nfunction tie(untied) {\n    return tieWithTable(untied, []);\n}\nexports.tie = tie;\nfunction tieWithTable(untied, seenSoFar) {\n    if (untied.kind === \"error\") {\n        return untied;\n    }\n    let reference;\n    switch (untied.type.typeClass) {\n        case \"array\":\n            let untiedAsArray = untied; //dammit TS\n            reference = untiedAsArray.reference;\n            if (reference === undefined) {\n                //we need to do some pointer stuff here, so let's first create our new\n                //object we'll be pointing to\n                //[we don't want to alter the original accidentally so let's clone a bit]\n                let tied = Object.assign(Object.assign({}, untiedAsArray), { value: [...untiedAsArray.value] });\n                //now, we can't use a map here, or we'll screw things up!\n                //we want to *mutate* value, not replace it with a new object\n                for (let index in tied.value) {\n                    tied.value[index] = tieWithTable(tied.value[index], [\n                        tied,\n                        ...seenSoFar\n                    ]);\n                }\n                return tied;\n            }\n            else {\n                return Object.assign(Object.assign({}, seenSoFar[reference - 1]), { reference });\n            }\n        case \"struct\":\n            let untiedAsStruct = untied; //dammit TS\n            reference = untiedAsStruct.reference;\n            if (reference === undefined) {\n                //we need to do some pointer stuff here, so let's first create our new\n                //object we'll be pointing to\n                //[we don't want to alter the original accidentally so let's clone a bit]\n                let tied = Object.assign(Object.assign({}, untiedAsStruct), { value: untiedAsStruct.value.map(component => (Object.assign({}, component))) });\n                //now, we can't use a map here, or we'll screw things up!\n                //we want to *mutate* value, not replace it with a new object\n                for (let index in tied.value) {\n                    tied.value[index] = Object.assign(Object.assign({}, tied.value[index]), { value: tieWithTable(tied.value[index].value, [tied, ...seenSoFar]) });\n                }\n                return tied;\n            }\n            else {\n                return Object.assign(Object.assign({}, seenSoFar[reference - 1]), { reference });\n            }\n        case \"tuple\": //currently there are no memory tuples, but may as well\n            //can't be circular, just recurse\n            //note we can just recurse with a straight tie here; don't need tieWithTable\n            let untiedAsTuple = untied; //dammit TS\n            //we need to do some pointer stuff here, so let's first create our new\n            //object we'll be pointing to\n            let tied = Object.assign({}, untiedAsTuple);\n            tied.value = tied.value.map(component => (Object.assign(Object.assign({}, component), { value: tie(component.value) })));\n            return tied;\n        default:\n            //other types either:\n            //1. aren't containers and so need no recursion\n            //2. are containers but can't go in or contain memory things\n            //and so still need no recursion\n            //(or, in the case of mappings, can't contain *nontrivial* memory\n            //things)\n            return untied;\n    }\n}\n//# sourceMappingURL=circularity.js.map"]},"metadata":{},"sourceType":"script"}