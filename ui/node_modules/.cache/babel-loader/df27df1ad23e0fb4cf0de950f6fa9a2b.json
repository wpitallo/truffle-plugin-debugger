{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar stream = require('stream');\n\nvar util = require('util');\n\nvar Decoder = require('./decoder');\n\nvar Simple = require('./simple');\n\nvar utils = require('./utils');\n\nvar constants = require('./constants');\n\nvar bignumber = require('bignumber.js').BigNumber;\n\nvar NoFilter = require('nofilter');\n\nvar MT = constants.MT;\nvar SYMS = constants.SYMS;\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\n\nvar Diagnose = /*#__PURE__*/function (_stream$Transform) {\n  _inherits(Diagnose, _stream$Transform);\n\n  var _super = _createSuper(Diagnose);\n\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  function Diagnose(options) {\n    var _this;\n\n    _classCallCheck(this, Diagnose);\n\n    var opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    var separator = opts.separator;\n    delete opts.separator;\n    var stream_errors = opts.stream_errors;\n    delete opts.stream_errors;\n    _this = _super.call(this, opts);\n    _this.float_bytes = -1;\n    _this.separator = separator;\n    _this.stream_errors = stream_errors;\n    _this.parser = new Decoder(opts);\n\n    _this.parser.on('more-bytes', _this._on_more.bind(_assertThisInitialized(_this)));\n\n    _this.parser.on('value', _this._on_value.bind(_assertThisInitialized(_this)));\n\n    _this.parser.on('start', _this._on_start.bind(_assertThisInitialized(_this)));\n\n    _this.parser.on('stop', _this._on_stop.bind(_assertThisInitialized(_this)));\n\n    _this.parser.on('data', _this._on_data.bind(_assertThisInitialized(_this)));\n\n    _this.parser.on('error', _this._on_error.bind(_assertThisInitialized(_this)));\n\n    return _this;\n  }\n\n  _createClass(Diagnose, [{\n    key: \"_transform\",\n    value: function _transform(fresh, encoding, cb) {\n      return this.parser.write(fresh, encoding, cb);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(cb) {\n      var _this2 = this;\n\n      return this.parser._flush(function (er) {\n        if (_this2.stream_errors) {\n          if (er) {\n            _this2._on_error(er);\n          }\n\n          return cb();\n        } else {\n          return cb(er);\n        }\n      });\n    }\n    /**\n     * Convenience function to return a string in diagnostic format.\n     *\n     * @param {(Buffer|string)} input - the CBOR bytes to format\n     * @param {string} [encoding='hex'] - the encoding of input, ignored if\n     *   input is Buffer\n     * @param {function(Error, string): undefined} cb - callback\n     * @returns {Promise} if callback not specified\n     */\n\n  }, {\n    key: \"_on_error\",\n    value: function _on_error(er) {\n      if (this.stream_errors) {\n        return this.push(er.toString());\n      } else {\n        return this.emit('error', er);\n      }\n    }\n  }, {\n    key: \"_on_more\",\n    value: function _on_more(mt, len, parent_mt, pos) {\n      if (mt === MT.SIMPLE_FLOAT) {\n        return this.float_bytes = {\n          2: 1,\n          4: 2,\n          8: 3\n        }[len];\n      }\n    }\n  }, {\n    key: \"_fore\",\n    value: function _fore(parent_mt, pos) {\n      switch (parent_mt) {\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n        case MT.ARRAY:\n          if (pos > 0) {\n            return this.push(', ');\n          }\n\n          break;\n\n        case MT.MAP:\n          if (pos > 0) {\n            if (pos % 2) {\n              return this.push(': ');\n            } else {\n              return this.push(', ');\n            }\n          }\n\n      }\n    }\n  }, {\n    key: \"_on_value\",\n    value: function _on_value(val, parent_mt, pos) {\n      var _this3 = this;\n\n      if (val === SYMS.BREAK) {\n        return;\n      }\n\n      this._fore(parent_mt, pos);\n\n      return this.push(function () {\n        switch (false) {\n          case val !== SYMS.NULL:\n            return 'null';\n\n          case val !== SYMS.UNDEFINED:\n            return 'undefined';\n\n          case typeof val !== 'string':\n            return JSON.stringify(val);\n\n          case !(_this3.float_bytes > 0):\n            var fb = _this3.float_bytes;\n            _this3.float_bytes = -1;\n            return util.inspect(val) + '_' + fb;\n\n          case !Buffer.isBuffer(val):\n            return 'h\\'' + val.toString('hex') + '\\'';\n\n          case !(val instanceof bignumber):\n            return val.toString();\n\n          default:\n            return util.inspect(val);\n        }\n      }());\n    }\n  }, {\n    key: \"_on_start\",\n    value: function _on_start(mt, tag, parent_mt, pos) {\n      this._fore(parent_mt, pos);\n\n      switch (mt) {\n        case MT.TAG:\n          this.push(\"\".concat(tag, \"(\"));\n          break;\n\n        case MT.ARRAY:\n          this.push('[');\n          break;\n\n        case MT.MAP:\n          this.push('{');\n          break;\n\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          this.push('(');\n          break;\n      }\n\n      if (tag === SYMS.STREAM) {\n        return this.push('_ ');\n      }\n    }\n  }, {\n    key: \"_on_stop\",\n    value: function _on_stop(mt) {\n      switch (mt) {\n        case MT.TAG:\n          return this.push(')');\n\n        case MT.ARRAY:\n          return this.push(']');\n\n        case MT.MAP:\n          return this.push('}');\n\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          return this.push(')');\n      }\n    }\n  }, {\n    key: \"_on_data\",\n    value: function _on_data() {\n      return this.push(this.separator);\n    }\n  }], [{\n    key: \"diagnose\",\n    value: function diagnose(input, encoding, cb) {\n      if (input == null) {\n        throw new Error('input required');\n      }\n\n      var opts = {};\n      var encod = 'hex';\n\n      switch (typeof encoding) {\n        case 'function':\n          cb = encoding;\n          encod = utils.guessEncoding(input);\n          break;\n\n        case 'object':\n          opts = utils.extend({}, encoding);\n          encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n          delete opts.encoding;\n          break;\n\n        default:\n          encod = encoding != null ? encoding : 'hex';\n      }\n\n      var bs = new NoFilter();\n      var d = new Diagnose(opts);\n      var p = null;\n\n      if (typeof cb === 'function') {\n        d.on('end', function () {\n          return cb(null, bs.toString('utf8'));\n        });\n        d.on('error', cb);\n      } else {\n        p = new Promise(function (resolve, reject) {\n          d.on('end', function () {\n            return resolve(bs.toString('utf8'));\n          });\n          return d.on('error', reject);\n        });\n      }\n\n      d.pipe(bs);\n      d.end(input, encod);\n      return p;\n    }\n  }]);\n\n  return Diagnose;\n}(stream.Transform);\n\nmodule.exports = Diagnose;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/cbor/lib/diagnose.js"],"names":["stream","require","util","Decoder","Simple","utils","constants","bignumber","BigNumber","NoFilter","MT","SYMS","Diagnose","options","opts","Object","assign","separator","stream_errors","readableObjectMode","writableObjectMode","float_bytes","parser","on","_on_more","bind","_on_value","_on_start","_on_stop","_on_data","_on_error","fresh","encoding","cb","write","_flush","er","push","toString","emit","mt","len","parent_mt","pos","SIMPLE_FLOAT","BYTE_STRING","UTF8_STRING","ARRAY","MAP","val","BREAK","_fore","NULL","UNDEFINED","JSON","stringify","fb","inspect","Buffer","isBuffer","tag","TAG","STREAM","input","Error","encod","guessEncoding","extend","bs","d","p","Promise","resolve","reject","pipe","end","Transform","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\nconst Decoder = require('./decoder')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst constants = require('./constants')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\n\nconst MT = constants.MT\nconst SYMS = constants.SYMS\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\nclass Diagnose extends stream.Transform {\n\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    })\n    const separator = opts.separator\n    delete opts.separator\n    const stream_errors = opts.stream_errors\n    delete opts.stream_errors\n    super(opts)\n\n    this.float_bytes = -1\n    this.separator = separator\n    this.stream_errors = stream_errors\n    this.parser = new Decoder(opts)\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb)\n  }\n\n  _flush(cb) {\n    return this.parser._flush((er) => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er)\n        }\n        return cb()\n      } else {\n        return cb(er)\n      }\n    })\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {(Buffer|string)} input - the CBOR bytes to format\n   * @param {string} [encoding='hex'] - the encoding of input, ignored if\n   *   input is Buffer\n   * @param {function(Error, string): undefined} cb - callback\n   * @returns {Promise} if callback not specified\n   */\n  static diagnose(input, encoding, cb) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    let opts = {}\n    let encod = 'hex'\n    switch (typeof encoding) {\n      case 'function':\n        cb = encoding\n        encod = utils.guessEncoding(input)\n        break\n      case 'object':\n        opts = utils.extend({}, encoding)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n        break\n      default:\n        encod = (encoding != null) ? encoding : 'hex'\n    }\n    const bs = new NoFilter()\n    const d = new Diagnose(opts)\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')))\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')))\n        return d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    d.end(input, encod)\n    return p\n  }\n\n  _on_error(er) {\n    if (this.stream_errors) {\n      return this.push(er.toString())\n    } else {\n      return this.emit('error', er)\n    }\n  }\n\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      return this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len]\n    }\n  }\n\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          return this.push(', ')\n        }\n        break\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            return this.push(': ')\n          } else {\n            return this.push(', ')\n          }\n        }\n    }\n  }\n\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return\n    }\n    this._fore(parent_mt, pos)\n    return this.push((() => {\n      switch (false) {\n        case val !== SYMS.NULL:\n          return 'null'\n        case val !== SYMS.UNDEFINED:\n          return 'undefined'\n        case typeof val !== 'string':\n          return JSON.stringify(val)\n        case !(this.float_bytes > 0):\n          const fb = this.float_bytes\n          this.float_bytes = -1\n          return (util.inspect(val)) + '_' + fb\n        case !Buffer.isBuffer(val):\n          return 'h\\'' + (val.toString('hex')) + '\\''\n        case !(val instanceof bignumber):\n          return val.toString()\n        default:\n          return util.inspect(val)\n      }\n    })())\n  }\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos)\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`)\n        break\n      case MT.ARRAY:\n        this.push('[')\n        break\n      case MT.MAP:\n        this.push('{')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(')\n        break\n    }\n    if (tag === SYMS.STREAM) {\n      return this.push('_ ')\n    }\n  }\n\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        return this.push(')')\n      case MT.ARRAY:\n        return this.push(']')\n      case MT.MAP:\n        return this.push('}')\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        return this.push(')')\n    }\n  }\n\n  _on_data() {\n    return this.push(this.separator)\n  }\n}\n\nmodule.exports = Diagnose\n"]},"metadata":{},"sourceType":"script"}