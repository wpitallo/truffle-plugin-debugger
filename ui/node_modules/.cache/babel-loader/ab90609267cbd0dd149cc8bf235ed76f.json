{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbi),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiReferenceByAddress),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiReferenceStatic),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiStructByPosition),\n    _marked5 = /*#__PURE__*/_regeneratorRuntime.mark(decodeAbiTupleByPosition);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:abi-data:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar allocate_1 = require(\"../allocate\");\n\nvar errors_1 = require(\"../../errors\");\n\nfunction decodeAbi(dataType, pointer, info) {\n  var options,\n      dynamic,\n      _args = arguments;\n  return _regeneratorRuntime.wrap(function decodeAbi$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n\n          if (!(Format.Types.isReferenceType(dataType) || dataType.typeClass === \"tuple\")) {\n            _context.next = 20;\n            break;\n          }\n\n          _context.prev = 2;\n          dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;\n          _context.next = 11;\n          break;\n\n        case 6:\n          _context.prev = 6;\n          _context.t0 = _context[\"catch\"](2);\n\n          if (!options.strictAbiMode) {\n            _context.next = 10;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_context.t0.error);\n\n        case 10:\n          return _context.abrupt(\"return\", {\n            //dunno why TS is failing at this inference\n            type: dataType,\n            kind: \"error\",\n            error: _context.t0.error\n          });\n\n        case 11:\n          if (!dynamic) {\n            _context.next = 16;\n            break;\n          }\n\n          return _context.delegateYield(decodeAbiReferenceByAddress(dataType, pointer, info, options), \"t1\", 13);\n\n        case 13:\n          return _context.abrupt(\"return\", _context.t1);\n\n        case 16:\n          return _context.delegateYield(decodeAbiReferenceStatic(dataType, pointer, info, options), \"t2\", 17);\n\n        case 17:\n          return _context.abrupt(\"return\", _context.t2);\n\n        case 18:\n          _context.next = 23;\n          break;\n\n        case 20:\n          debug(\"pointer %o\", pointer);\n          return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, options), \"t3\", 22);\n\n        case 22:\n          return _context.abrupt(\"return\", _context.t3);\n\n        case 23:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2, 6]]);\n}\n\nexports.decodeAbi = decodeAbi;\n\nfunction decodeAbiReferenceByAddress(dataType, pointer, info) {\n  var options,\n      strict,\n      base,\n      lengthOverride,\n      allocations,\n      state,\n      location,\n      rawValue,\n      rawValueAsBN,\n      rawValueAsNumber,\n      error,\n      startPosition,\n      dynamic,\n      size,\n      _allocate_1$abiSizeIn,\n      staticPointer,\n      length,\n      lengthAsBN,\n      rawLength,\n      childPointer,\n      baseSize,\n      decodedChildren,\n      index,\n      _args2 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeAbiReferenceByAddress$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};\n          strict = options.strictAbiMode, base = options.abiPointerBase, lengthOverride = options.lengthOverride;\n          base = base || 0; //in case base was undefined\n\n          allocations = info.allocations.abi, state = info.state;\n          debug(\"pointer %o\", pointer); //this variable holds the location we should look to *next*\n          //stack pointers point to calldata; other pointers point to same location\n\n          location = pointer.location === \"stack\" || pointer.location === \"stackliteral\" ? \"calldata\" : pointer.location;\n\n          if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n            //length overrides are only applicable when you're decoding a pointer\n            //from the stack!  otherwise they must be ignored!\n            lengthOverride = undefined;\n          }\n\n          _context2.prev = 7;\n          return _context2.delegateYield(read_1.default(pointer, state), \"t0\", 9);\n\n        case 9:\n          rawValue = _context2.t0;\n          _context2.next = 17;\n          break;\n\n        case 12:\n          _context2.prev = 12;\n          _context2.t1 = _context2[\"catch\"](7);\n\n          if (!strict) {\n            _context2.next = 16;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_context2.t1.error);\n\n        case 16:\n          return _context2.abrupt(\"return\", {\n            //dunno why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t1.error\n          });\n\n        case 17:\n          rawValueAsBN = Conversion.toBN(rawValue);\n          debug(\"rawValue: %O\", rawValue);\n          debug(\"rawValueAsBN: %O\", rawValueAsBN);\n          _context2.prev = 20;\n          rawValueAsNumber = rawValueAsBN.toNumber();\n          _context2.next = 30;\n          break;\n\n        case 24:\n          _context2.prev = 24;\n          _context2.t2 = _context2[\"catch\"](20);\n          error = {\n            kind: \"OverlargePointersNotImplementedError\",\n            pointerAsBN: rawValueAsBN\n          };\n\n          if (!strict) {\n            _context2.next = 29;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error);\n\n        case 29:\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 30:\n          startPosition = rawValueAsNumber + base;\n          debug(\"startPosition %d\", startPosition);\n          _context2.prev = 32;\n          _allocate_1$abiSizeIn = allocate_1.abiSizeInfo(dataType, allocations);\n          dynamic = _allocate_1$abiSizeIn.dynamic;\n          size = _allocate_1$abiSizeIn.size;\n          _context2.next = 43;\n          break;\n\n        case 38:\n          _context2.prev = 38;\n          _context2.t3 = _context2[\"catch\"](32);\n\n          if (!strict) {\n            _context2.next = 42;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_context2.t3.error);\n\n        case 42:\n          return _context2.abrupt(\"return\", {\n            //dunno why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t3.error\n          });\n\n        case 43:\n          if (dynamic) {\n            _context2.next = 47;\n            break;\n          }\n\n          //this will only come up when called from stack.ts\n          staticPointer = {\n            location: location,\n            start: startPosition,\n            length: size\n          };\n          return _context2.delegateYield(decodeAbiReferenceStatic(dataType, staticPointer, info, options), \"t4\", 46);\n\n        case 46:\n          return _context2.abrupt(\"return\", _context2.t4);\n\n        case 47:\n          _context2.t5 = dataType.typeClass;\n          _context2.next = _context2.t5 === \"bytes\" ? 50 : _context2.t5 === \"string\" ? 50 : _context2.t5 === \"array\" ? 78 : _context2.t5 === \"struct\" ? 128 : _context2.t5 === \"tuple\" ? 130 : 132;\n          break;\n\n        case 50:\n          if (!(lengthOverride !== undefined)) {\n            _context2.next = 54;\n            break;\n          }\n\n          lengthAsBN = lengthOverride; //note in this case we do *not* increment start position;\n          //if a length override is given, that means the given start\n          //position skips over the length word!\n\n          _context2.next = 66;\n          break;\n\n        case 54:\n          _context2.prev = 54;\n          return _context2.delegateYield(read_1.default({\n            location: location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t6\", 56);\n\n        case 56:\n          rawLength = _context2.t6;\n          _context2.next = 64;\n          break;\n\n        case 59:\n          _context2.prev = 59;\n          _context2.t7 = _context2[\"catch\"](54);\n\n          if (!strict) {\n            _context2.next = 63;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_context2.t7.error);\n\n        case 63:\n          return _context2.abrupt(\"return\", {\n            //dunno why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t7.error\n          });\n\n        case 64:\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n          //so it'll be set up to read the data\n\n        case 66:\n          if (!(strict && lengthAsBN.gtn(state[location].length))) {\n            _context2.next = 68;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArrayOrStringStrictModeError\",\n            lengthAsBN: lengthAsBN,\n            dataLength: state[location].length\n          });\n\n        case 68:\n          _context2.prev = 68;\n          length = lengthAsBN.toNumber();\n          _context2.next = 75;\n          break;\n\n        case 72:\n          _context2.prev = 72;\n          _context2.t8 = _context2[\"catch\"](68);\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 75:\n          childPointer = {\n            location: location,\n            start: startPosition,\n            length: length\n          };\n          return _context2.delegateYield(Bytes.Decode.decodeBytes(dataType, childPointer, info, options), \"t9\", 77);\n\n        case 77:\n          return _context2.abrupt(\"return\", _context2.t9);\n\n        case 78:\n          if (!(dataType.kind === \"static\")) {\n            _context2.next = 82;\n            break;\n          }\n\n          //static-length array\n          lengthAsBN = dataType.length; //note we don't increment start position; static arrays don't\n          //include a length word!\n\n          _context2.next = 99;\n          break;\n\n        case 82:\n          if (!(lengthOverride !== undefined)) {\n            _context2.next = 87;\n            break;\n          }\n\n          debug(\"override: %o\", lengthOverride); //dynamic-length array, but with length override\n\n          lengthAsBN = lengthOverride; //we don't increment start position; if a length override was\n          //given, that means the pointer skipped the length word!\n\n          _context2.next = 99;\n          break;\n\n        case 87:\n          _context2.prev = 87;\n          return _context2.delegateYield(read_1.default({\n            location: location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t10\", 89);\n\n        case 89:\n          rawLength = _context2.t10;\n          _context2.next = 97;\n          break;\n\n        case 92:\n          _context2.prev = 92;\n          _context2.t11 = _context2[\"catch\"](87);\n\n          if (!strict) {\n            _context2.next = 96;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_context2.t11.error);\n\n        case 96:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t11.error\n          });\n\n        case 97:\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n\n        case 99:\n          if (!(strict && lengthAsBN.gtn(state[location].length))) {\n            _context2.next = 101;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError({\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN: lengthAsBN,\n            dataLength: state[location].length\n          });\n\n        case 101:\n          _context2.prev = 101;\n          length = lengthAsBN.toNumber();\n          _context2.next = 108;\n          break;\n\n        case 105:\n          _context2.prev = 105;\n          _context2.t12 = _context2[\"catch\"](101);\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 108:\n          _context2.prev = 108;\n          baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;\n          _context2.next = 117;\n          break;\n\n        case 112:\n          _context2.prev = 112;\n          _context2.t13 = _context2[\"catch\"](108);\n\n          if (!strict) {\n            _context2.next = 116;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_context2.t13.error);\n\n        case 116:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t13.error\n          });\n\n        case 117:\n          decodedChildren = [];\n          index = 0;\n\n        case 119:\n          if (!(index < length)) {\n            _context2.next = 127;\n            break;\n          }\n\n          _context2.t14 = decodedChildren;\n          return _context2.delegateYield(decodeAbi(dataType.baseType, {\n            location: location,\n            start: startPosition + index * baseSize,\n            length: baseSize\n          }, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          })), \"t15\", 122);\n\n        case 122:\n          _context2.t16 = _context2.t15;\n\n          _context2.t14.push.call(_context2.t14, _context2.t16);\n\n        case 124:\n          index++;\n          _context2.next = 119;\n          break;\n\n        case 127:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 128:\n          return _context2.delegateYield(decodeAbiStructByPosition(dataType, location, startPosition, info, options), \"t17\", 129);\n\n        case 129:\n          return _context2.abrupt(\"return\", _context2.t17);\n\n        case 130:\n          return _context2.delegateYield(decodeAbiTupleByPosition(dataType, location, startPosition, info, options), \"t18\", 131);\n\n        case 131:\n          return _context2.abrupt(\"return\", _context2.t18);\n\n        case 132:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[7, 12], [20, 24], [32, 38], [54, 59], [68, 72], [87, 92], [101, 105], [108, 112]]);\n}\n\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\n\nfunction decodeAbiReferenceStatic(dataType, pointer, info) {\n  var options,\n      location,\n      lengthAsBN,\n      length,\n      error,\n      baseSize,\n      decodedChildren,\n      index,\n      _args3 = arguments;\n  return _regeneratorRuntime.wrap(function decodeAbiReferenceStatic$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};\n          debug(\"static\");\n          debug(\"pointer %o\", pointer);\n          location = pointer.location;\n          _context3.t0 = dataType.typeClass;\n          _context3.next = _context3.t0 === \"array\" ? 7 : _context3.t0 === \"struct\" ? 38 : _context3.t0 === \"tuple\" ? 40 : 42;\n          break;\n\n        case 7:\n          //we're in the static case, so we know the array must be statically sized\n          lengthAsBN = dataType.length;\n          _context3.prev = 8;\n          length = lengthAsBN.toNumber();\n          _context3.next = 18;\n          break;\n\n        case 12:\n          _context3.prev = 12;\n          _context3.t1 = _context3[\"catch\"](8);\n          //note: since this is the static case, we don't bother including the stronger\n          //strict-mode guard against getting DOSed by large array sizes, since in this\n          //case we're not reading the size from the input; if there's a huge static size\n          //array, well, we'll just have to deal with it\n          error = {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN: lengthAsBN\n          };\n\n          if (!options.strictAbiMode) {\n            _context3.next = 17;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error);\n\n        case 17:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 18:\n          _context3.prev = 18;\n          baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;\n          _context3.next = 27;\n          break;\n\n        case 22:\n          _context3.prev = 22;\n          _context3.t2 = _context3[\"catch\"](18);\n\n          if (!options.strictAbiMode) {\n            _context3.next = 26;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_context3.t2.error);\n\n        case 26:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _context3.t2.error\n          });\n\n        case 27:\n          decodedChildren = [];\n          index = 0;\n\n        case 29:\n          if (!(index < length)) {\n            _context3.next = 37;\n            break;\n          }\n\n          _context3.t3 = decodedChildren;\n          return _context3.delegateYield(decodeAbi(dataType.baseType, {\n            location: location,\n            start: pointer.start + index * baseSize,\n            length: baseSize\n          }, info, options), \"t4\", 32);\n\n        case 32:\n          _context3.t5 = _context3.t4;\n\n          _context3.t3.push.call(_context3.t3, _context3.t5);\n\n        case 34:\n          index++;\n          _context3.next = 29;\n          break;\n\n        case 37:\n          return _context3.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 38:\n          return _context3.delegateYield(decodeAbiStructByPosition(dataType, location, pointer.start, info, options), \"t6\", 39);\n\n        case 39:\n          return _context3.abrupt(\"return\", _context3.t6);\n\n        case 40:\n          return _context3.delegateYield(decodeAbiTupleByPosition(dataType, location, pointer.start, info, options), \"t7\", 41);\n\n        case 41:\n          return _context3.abrupt(\"return\", _context3.t7);\n\n        case 42:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, null, [[8, 12], [18, 22]]);\n}\n\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic; //note that this function takes the start position as a *number*; it does not take a pointer\n\nfunction decodeAbiStructByPosition(dataType, location, startPosition, info) {\n  var options,\n      allocations,\n      typeLocation,\n      typeId,\n      structAllocation,\n      error,\n      decodedMembers,\n      index,\n      memberAllocation,\n      memberPointer,\n      childPointer,\n      memberName,\n      memberType,\n      _args4 = arguments;\n  return _regeneratorRuntime.wrap(function decodeAbiStructByPosition$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          options = _args4.length > 4 && _args4[4] !== undefined ? _args4[4] : {};\n          allocations = info.allocations.abi;\n          typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n\n          typeId = dataType.id;\n          structAllocation = allocations[typeId];\n\n          if (structAllocation) {\n            _context4.next = 10;\n            break;\n          }\n\n          error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: dataType\n          };\n\n          if (!(options.strictAbiMode || options.allowRetry)) {\n            _context4.next = 9;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error, true);\n\n        case 9:\n          return _context4.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 10:\n          decodedMembers = [];\n          index = 0;\n\n        case 12:\n          if (!(index < structAllocation.members.length)) {\n            _context4.next = 27;\n            break;\n          }\n\n          memberAllocation = structAllocation.members[index];\n          memberPointer = memberAllocation.pointer;\n          childPointer = {\n            location: location,\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length\n          };\n          memberName = memberAllocation.name;\n          memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n          _context4.t0 = decodedMembers;\n          _context4.t1 = memberName;\n          return _context4.delegateYield(decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          })), \"t2\", 21);\n\n        case 21:\n          _context4.t3 = _context4.t2;\n          _context4.t4 = {\n            name: _context4.t1,\n            value: _context4.t3\n          };\n\n          _context4.t0.push.call(_context4.t0, _context4.t4);\n\n        case 24:\n          index++;\n          _context4.next = 12;\n          break;\n\n        case 27:\n          return _context4.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 28:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n} //note that this function takes the start position as a *number*; it does not take a pointer\n\n\nfunction decodeAbiTupleByPosition(dataType, location, startPosition, info) {\n  var options,\n      decodedMembers,\n      position,\n      _iterator,\n      _step,\n      _step$value,\n      name,\n      memberType,\n      memberSize,\n      childPointer,\n      _args5 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeAbiTupleByPosition$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          options = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : {};\n          //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n          //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n          //However it may be worth revisiting this in the future if performance turns out to be a problem\n          //(changing this may be pretty hard though)\n          decodedMembers = [];\n          position = startPosition;\n          _iterator = _createForOfIteratorHelper(dataType.memberTypes);\n          _context5.prev = 4;\n\n          _iterator.s();\n\n        case 6:\n          if ((_step = _iterator.n()).done) {\n            _context5.next = 19;\n            break;\n          }\n\n          _step$value = _step.value, name = _step$value.name, memberType = _step$value.type;\n          memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;\n          childPointer = {\n            location: location,\n            start: position,\n            length: memberSize\n          };\n          _context5.t0 = decodedMembers;\n          _context5.t1 = name;\n          return _context5.delegateYield(decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n            abiPointerBase: startPosition\n          })), \"t2\", 13);\n\n        case 13:\n          _context5.t3 = _context5.t2;\n          _context5.t4 = {\n            name: _context5.t1,\n            value: _context5.t3\n          };\n\n          _context5.t0.push.call(_context5.t0, _context5.t4);\n\n          position += memberSize;\n\n        case 17:\n          _context5.next = 6;\n          break;\n\n        case 19:\n          _context5.next = 24;\n          break;\n\n        case 21:\n          _context5.prev = 21;\n          _context5.t5 = _context5[\"catch\"](4);\n\n          _iterator.e(_context5.t5);\n\n        case 24:\n          _context5.prev = 24;\n\n          _iterator.f();\n\n          return _context5.finish(24);\n\n        case 27:\n          return _context5.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 28:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5, null, [[4, 21, 24, 27]]);\n}","map":{"version":3,"sources":["../../../../lib/abi-data/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abi-data:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst errors_1 = require(\"../../errors\");\nfunction* decodeAbi(dataType, pointer, info, options = {}) {\n    if (Format.Types.isReferenceType(dataType) ||\n        dataType.typeClass === \"tuple\") {\n        //I don't want tuples to be considered a reference type, but it makes sense\n        //to group them for this purpose\n        let dynamic;\n        try {\n            dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;\n        }\n        catch (error) {\n            if (options.strictAbiMode) {\n                throw new errors_1.StopDecodingError(error.error);\n            }\n            return {\n                //dunno why TS is failing at this inference\n                type: dataType,\n                kind: \"error\",\n                error: error.error\n            };\n        }\n        if (dynamic) {\n            return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);\n        }\n        else {\n            return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);\n        }\n    }\n    else {\n        debug(\"pointer %o\", pointer);\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n}\nexports.decodeAbi = decodeAbi;\nfunction* decodeAbiReferenceByAddress(dataType, pointer, info, options = {}) {\n    let { strictAbiMode: strict, abiPointerBase: base, lengthOverride } = options;\n    base = base || 0; //in case base was undefined\n    const { allocations: { abi: allocations }, state } = info;\n    debug(\"pointer %o\", pointer);\n    //this variable holds the location we should look to *next*\n    //stack pointers point to calldata; other pointers point to same location\n    const location = pointer.location === \"stack\" || pointer.location === \"stackliteral\"\n        ? \"calldata\"\n        : pointer.location;\n    if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n        //length overrides are only applicable when you're decoding a pointer\n        //from the stack!  otherwise they must be ignored!\n        lengthOverride = undefined;\n    }\n    let rawValue;\n    try {\n        rawValue = yield* read_1.default(pointer, state);\n    }\n    catch (error) {\n        if (strict) {\n            throw new errors_1.StopDecodingError(error.error);\n        }\n        return {\n            //dunno why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: error.error\n        };\n    }\n    let rawValueAsBN = Conversion.toBN(rawValue);\n    debug(\"rawValue: %O\", rawValue);\n    debug(\"rawValueAsBN: %O\", rawValueAsBN);\n    let rawValueAsNumber;\n    try {\n        rawValueAsNumber = rawValueAsBN.toNumber();\n    }\n    catch (_) {\n        let error = {\n            kind: \"OverlargePointersNotImplementedError\",\n            pointerAsBN: rawValueAsBN\n        };\n        if (strict) {\n            throw new errors_1.StopDecodingError(error);\n        }\n        return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error\n        };\n    }\n    let startPosition = rawValueAsNumber + base;\n    debug(\"startPosition %d\", startPosition);\n    let dynamic;\n    let size;\n    try {\n        ({ dynamic, size } = allocate_1.abiSizeInfo(dataType, allocations));\n    }\n    catch (error) {\n        if (strict) {\n            throw new errors_1.StopDecodingError(error.error);\n        }\n        return {\n            //dunno why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: error.error\n        };\n    }\n    if (!dynamic) {\n        //this will only come up when called from stack.ts\n        let staticPointer = {\n            location,\n            start: startPosition,\n            length: size\n        };\n        return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);\n    }\n    let length;\n    let lengthAsBN;\n    let rawLength;\n    switch (dataType.typeClass) {\n        case \"bytes\":\n        case \"string\":\n            //initial word contains length (unless an override was given)\n            if (lengthOverride !== undefined) {\n                lengthAsBN = lengthOverride;\n                //note in this case we do *not* increment start position;\n                //if a length override is given, that means the given start\n                //position skips over the length word!\n            }\n            else {\n                try {\n                    rawLength = yield* read_1.default({\n                        location,\n                        start: startPosition,\n                        length: Evm.Utils.WORD_SIZE\n                    }, state);\n                }\n                catch (error) {\n                    if (strict) {\n                        throw new errors_1.StopDecodingError(error.error);\n                    }\n                    return {\n                        //dunno why TS is failing here\n                        type: dataType,\n                        kind: \"error\",\n                        error: error.error\n                    };\n                }\n                lengthAsBN = Conversion.toBN(rawLength);\n                startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n                //so it'll be set up to read the data\n            }\n            if (strict && lengthAsBN.gtn(state[location].length)) {\n                //you may notice that the comparison is a bit crude; that's OK, this is\n                //just to prevent huge numbers from DOSing us, other errors will still\n                //be caught regardless\n                throw new errors_1.StopDecodingError({\n                    kind: \"OverlongArrayOrStringStrictModeError\",\n                    lengthAsBN,\n                    dataLength: state[location].length\n                });\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_) {\n                //note: if we're in this situation, we can assume we're not in strict mode,\n                //as the strict case was handled above\n                return {\n                    //again with the TS failures...\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            let childPointer = {\n                location,\n                start: startPosition,\n                length\n            };\n            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);\n        case \"array\":\n            if (dataType.kind === \"static\") {\n                //static-length array\n                lengthAsBN = dataType.length;\n                //note we don't increment start position; static arrays don't\n                //include a length word!\n            }\n            else if (lengthOverride !== undefined) {\n                debug(\"override: %o\", lengthOverride);\n                //dynamic-length array, but with length override\n                lengthAsBN = lengthOverride;\n                //we don't increment start position; if a length override was\n                //given, that means the pointer skipped the length word!\n            }\n            else {\n                //dynamic-length array, read length from data\n                //initial word contains array length\n                try {\n                    rawLength = yield* read_1.default({\n                        location,\n                        start: startPosition,\n                        length: Evm.Utils.WORD_SIZE\n                    }, state);\n                }\n                catch (error) {\n                    //error: DecodingError\n                    if (strict) {\n                        throw new errors_1.StopDecodingError(error.error);\n                    }\n                    return {\n                        type: dataType,\n                        kind: \"error\",\n                        error: error.error\n                    };\n                }\n                lengthAsBN = Conversion.toBN(rawLength);\n                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n                //to next word, as first word was used for length\n            }\n            if (strict && lengthAsBN.gtn(state[location].length)) {\n                //you may notice that the comparison is a bit crude; that's OK, this is\n                //just to prevent huge numbers from DOSing us, other errors will still\n                //be caught regardless\n                throw new errors_1.StopDecodingError({\n                    kind: \"OverlongArraysAndStringsNotImplementedError\",\n                    lengthAsBN,\n                    dataLength: state[location].length\n                });\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_) {\n                //again, if we get here, we can assume we're not in strict mode\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            //note: I've written this fairly generically, but it is worth noting that\n            //since this array is of dynamic type, we know that if it's static length\n            //then size must be EVM.WORD_SIZE\n            let baseSize;\n            try {\n                baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;\n            }\n            catch (error) {\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error.error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: error.error\n                };\n            }\n            let decodedChildren = [];\n            for (let index = 0; index < length; index++) {\n                decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n                    location,\n                    start: startPosition + index * baseSize,\n                    length: baseSize\n                }, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))); //pointer base is always start of list, never the length\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        case \"struct\":\n            return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);\n        case \"tuple\":\n            return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);\n    }\n}\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\nfunction* decodeAbiReferenceStatic(dataType, pointer, info, options = {}) {\n    debug(\"static\");\n    debug(\"pointer %o\", pointer);\n    const location = pointer.location;\n    switch (dataType.typeClass) {\n        case \"array\":\n            //we're in the static case, so we know the array must be statically sized\n            const lengthAsBN = dataType.length;\n            let length;\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_) {\n                //note: since this is the static case, we don't bother including the stronger\n                //strict-mode guard against getting DOSed by large array sizes, since in this\n                //case we're not reading the size from the input; if there's a huge static size\n                //array, well, we'll just have to deal with it\n                let error = {\n                    kind: \"OverlongArraysAndStringsNotImplementedError\",\n                    lengthAsBN\n                };\n                if (options.strictAbiMode) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            let baseSize;\n            try {\n                baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;\n            }\n            catch (error) {\n                //error: DecodingError\n                if (options.strictAbiMode) {\n                    throw new errors_1.StopDecodingError(error.error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: error.error\n                };\n            }\n            let decodedChildren = [];\n            for (let index = 0; index < length; index++) {\n                decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n                    location,\n                    start: pointer.start + index * baseSize,\n                    length: baseSize\n                }, info, options));\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        case \"struct\":\n            return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);\n        case \"tuple\":\n            return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);\n    }\n}\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic;\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction* decodeAbiStructByPosition(dataType, location, startPosition, info, options = {}) {\n    const { allocations: { abi: allocations } } = info;\n    const typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n    const typeId = dataType.id;\n    const structAllocation = allocations[typeId];\n    if (!structAllocation) {\n        let error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: dataType\n        };\n        if (options.strictAbiMode || options.allowRetry) {\n            throw new errors_1.StopDecodingError(error, true);\n            //note that we allow a retry if we couldn't locate the allocation!\n        }\n        return {\n            type: dataType,\n            kind: \"error\",\n            error\n        };\n    }\n    let decodedMembers = [];\n    for (let index = 0; index < structAllocation.members.length; index++) {\n        const memberAllocation = structAllocation.members[index];\n        const memberPointer = memberAllocation.pointer;\n        const childPointer = {\n            location,\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length\n        };\n        let memberName = memberAllocation.name;\n        let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n        decodedMembers.push({\n            name: memberName,\n            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))\n            //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n        });\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedMembers\n    };\n}\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction* decodeAbiTupleByPosition(dataType, location, startPosition, info, options = {}) {\n    //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n    //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n    //However it may be worth revisiting this in the future if performance turns out to be a problem\n    //(changing this may be pretty hard though)\n    let decodedMembers = [];\n    let position = startPosition;\n    for (const { name, type: memberType } of dataType.memberTypes) {\n        const memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;\n        const childPointer = {\n            location,\n            start: position,\n            length: memberSize\n        };\n        decodedMembers.push({\n            name,\n            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))\n            //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n        });\n        position += memberSize;\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedMembers\n    };\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}