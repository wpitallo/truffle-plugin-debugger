{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiSelector = exports.abiTupleSignature = exports.abiSignature = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:abi-data:utils\"); // untyped import since no @types/web3-utils exists\n\nvar Web3Utils = require(\"web3-utils\");\n\nvar Evm = __importStar(require(\"../evm\"));\n\nvar Ast = __importStar(require(\"../ast\"));\n\nexports.DEFAULT_CONSTRUCTOR_ABI = {\n  type: \"constructor\",\n  inputs: [],\n  stateMutability: \"nonpayable\"\n}; //note the return value only includes functions!\n\nfunction computeSelectors(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return Object.assign.apply(Object, [{}].concat(_toConsumableArray(abi.filter(function (abiEntry) {\n    return abiEntry.type === \"function\";\n  }).map(function (abiEntry) {\n    return _defineProperty({}, abiSelector(abiEntry), abiEntry);\n  }))));\n}\n\nexports.computeSelectors = computeSelectors; //does this ABI have a payable fallback (or receive) function?\n\nfunction abiHasPayableFallback(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return abi.some(function (abiEntry) {\n    return (abiEntry.type === \"fallback\" || abiEntry.type === \"receive\") && abiEntry.stateMutability === \"payable\";\n  });\n}\n\nexports.abiHasPayableFallback = abiHasPayableFallback; //NOTE: this function returns the written out SIGNATURE, not the SELECTOR\n\nfunction abiSignature(abiEntry) {\n  return abiEntry.name + abiTupleSignature(abiEntry.inputs);\n}\n\nexports.abiSignature = abiSignature;\n\nfunction abiTupleSignature(parameters) {\n  var components = parameters.map(abiTypeSignature);\n  return \"(\" + components.join(\",\") + \")\";\n}\n\nexports.abiTupleSignature = abiTupleSignature;\n\nfunction abiTypeSignature(parameter) {\n  var tupleMatch = parameter.type.match(/tuple(.*)/);\n\n  if (tupleMatch === null) {\n    //does not start with \"tuple\"\n    return parameter.type;\n  } else {\n    var tail = tupleMatch[1]; //everything after \"tuple\"\n\n    var tupleSignature = abiTupleSignature(parameter.components);\n    return tupleSignature + tail;\n  }\n}\n\nfunction abiSelector(abiEntry) {\n  var signature = abiSignature(abiEntry); //NOTE: web3's soliditySha3 has a problem if the empty\n  //string is passed in.  Fortunately, that should never happen here.\n\n  var hash = Web3Utils.soliditySha3({\n    type: \"string\",\n    value: signature\n  });\n\n  switch (abiEntry.type) {\n    case \"event\":\n      return hash;\n\n    case \"function\":\n      return hash.slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE);\n    //arithmetic to account for hex string\n  }\n}\n\nexports.abiSelector = abiSelector; //note: undefined does not match itself :P\n\nfunction abisMatch(entry1, entry2) {\n  //we'll consider two abi entries to match if they have the same\n  //type, name (if applicable), and inputs (if applicable).\n  //since there's already a signature function, we can just use that.\n  if (!entry1 || !entry2) {\n    return false;\n  }\n\n  if (entry1.type !== entry2.type) {\n    return false;\n  }\n\n  switch (entry1.type) {\n    case \"function\":\n    case \"event\":\n      return abiSignature(entry1) === abiSignature(entry2);\n\n    case \"constructor\":\n      return abiTupleSignature(entry1.inputs) === abiTupleSignature(entry2.inputs);\n\n    case \"fallback\":\n    case \"receive\":\n      return true;\n  }\n}\n\nexports.abisMatch = abisMatch;\n\nfunction definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {\n  try {\n    return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));\n  } catch (_) {\n    return false; //if an exception occurs, well, that's not a match!\n  }\n}\n\nexports.definitionMatchesAbi = definitionMatchesAbi;\n\nfunction topicsCount(abiEntry) {\n  var selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector\n\n  return abiEntry.inputs.filter(function (_ref2) {\n    var indexed = _ref2.indexed;\n    return indexed;\n  }).length + selectorCount;\n}\n\nexports.topicsCount = topicsCount;\n\nfunction abiEntryIsObviouslyIllTyped(abiEntry) {\n  switch (abiEntry.type) {\n    case \"fallback\":\n    case \"receive\":\n      return false;\n\n    case \"constructor\":\n    case \"event\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);\n\n    case \"function\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) || abiEntry.outputs.some(abiParameterIsObviouslyIllTyped);\n  }\n}\n\nexports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;\n\nfunction abiParameterIsObviouslyIllTyped(abiParameter) {\n  var legalBaseTypeClasses = [\"uint\", \"int\", \"fixed\", \"ufixed\", \"bool\", \"address\", \"bytes\", \"string\", \"function\", \"tuple\"];\n  var baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];\n  var baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);\n\n  if (abiParameter.components) {\n    return abiParameter.components.some(abiParameterIsObviouslyIllTyped) || baseTypeClassIsObviouslyWrong;\n  } else {\n    return baseTypeClassIsObviouslyWrong;\n  }\n}\n\nfunction abiEntryHasStorageParameters(abiEntry) {\n  var isStorage = function isStorage(parameter) {\n    return parameter.type.endsWith(\" storage\");\n  };\n\n  return abiEntry.type === \"function\" && (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage)); //Note the lack of recursion!  Storage parameters can only occur at\n  //top level so there's no need to recurse here\n  //(they can also only occur for functions)\n}\n\nexports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;","map":{"version":3,"sources":["../../../lib/abi-data/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,sBAAZ,CAAd,C,CAEA;;AACA,IAAM,SAAS,GAAG,OAAO,CAAC,YAAD,CAAzB;;AACA,IAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;AACA,IAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;AAIa,OAAA,CAAA,uBAAA,GAAgD;AAC3D,EAAA,IAAI,EAAE,aADqD;AAE3D,EAAA,MAAM,EAAE,EAFmD;AAG3D,EAAA,eAAe,EAAE;AAH0C,CAAhD,C,CAMb;;AACA,SAAgB,gBAAhB,CACE,GADF,EAC0B;AAExB,MAAI,GAAG,KAAK,SAAZ,EAAuB;AACrB,WAAO,SAAP;AACD;;AACD,SAAO,MAAM,CAAC,MAAP,OAAA,MAAM,GACX,EADW,4BAER,GAAG,CACH,MADA,CACO,UAAC,QAAD;AAAA,WAAyB,QAAQ,CAAC,IAAT,KAAkB,UAA3C;AAAA,GADP,EAEA,GAFA,CAEI,UAAC,QAAD;AAAA,+BACF,WAAW,CAAC,QAAD,CADT,EACsB,QADtB;AAAA,GAFJ,CAFQ,GAAb;AAQD;;AAdD,OAAA,CAAA,gBAAA,GAAA,gBAAA,C,CAgBA;;AACA,SAAgB,qBAAhB,CACE,GADF,EAC0B;AAExB,MAAI,GAAG,KAAK,SAAZ,EAAuB;AACrB,WAAO,SAAP;AACD;;AACD,SAAO,GAAG,CAAC,IAAJ,CACL,UAAA,QAAQ;AAAA,WACN,CAAC,QAAQ,CAAC,IAAT,KAAkB,UAAlB,IAAgC,QAAQ,CAAC,IAAT,KAAkB,SAAnD,KACA,QAAQ,CAAC,eAAT,KAA6B,SAFvB;AAAA,GADH,CAAP;AAKD;;AAXD,OAAA,CAAA,qBAAA,GAAA,qBAAA,C,CAaA;;AACA,SAAgB,YAAhB,CACE,QADF,EAC8C;AAE5C,SAAO,QAAQ,CAAC,IAAT,GAAgB,iBAAiB,CAAC,QAAQ,CAAC,MAAV,CAAxC;AACD;;AAJD,OAAA,CAAA,YAAA,GAAA,YAAA;;AAMA,SAAgB,iBAAhB,CAAkC,UAAlC,EAA6D;AAC3D,MAAI,UAAU,GAAG,UAAU,CAAC,GAAX,CAAe,gBAAf,CAAjB;AACA,SAAO,MAAM,UAAU,CAAC,IAAX,CAAgB,GAAhB,CAAN,GAA6B,GAApC;AACD;;AAHD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAKA,SAAS,gBAAT,CAA0B,SAA1B,EAAkD;AAChD,MAAI,UAAU,GAAG,SAAS,CAAC,IAAV,CAAe,KAAf,CAAqB,WAArB,CAAjB;;AACA,MAAI,UAAU,KAAK,IAAnB,EAAyB;AACvB;AACA,WAAO,SAAS,CAAC,IAAjB;AACD,GAHD,MAGO;AACL,QAAI,IAAI,GAAG,UAAU,CAAC,CAAD,CAArB,CADK,CACqB;;AAC1B,QAAI,cAAc,GAAG,iBAAiB,CAAC,SAAS,CAAC,UAAX,CAAtC;AACA,WAAO,cAAc,GAAG,IAAxB;AACD;AACF;;AAED,SAAgB,WAAhB,CACE,QADF,EAC8C;AAE5C,MAAI,SAAS,GAAG,YAAY,CAAC,QAAD,CAA5B,CAF4C,CAG5C;AACA;;AACA,MAAI,IAAI,GAAG,SAAS,CAAC,YAAV,CAAuB;AAAE,IAAA,IAAI,EAAE,QAAR;AAAkB,IAAA,KAAK,EAAE;AAAzB,GAAvB,CAAX;;AACA,UAAQ,QAAQ,CAAC,IAAjB;AACE,SAAK,OAAL;AACE,aAAO,IAAP;;AACF,SAAK,UAAL;AACE,aAAO,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,IAAI,IAAI,GAAG,CAAC,KAAJ,CAAU,aAAhC,CAAP;AAAuD;AAJ3D;AAMD;;AAbD,OAAA,CAAA,WAAA,GAAA,WAAA,C,CAeA;;AACA,SAAgB,SAAhB,CACE,MADF,EAEE,MAFF,EAE+B;AAE7B;AACA;AACA;AACA,MAAI,CAAC,MAAD,IAAW,CAAC,MAAhB,EAAwB;AACtB,WAAO,KAAP;AACD;;AACD,MAAI,MAAM,CAAC,IAAP,KAAgB,MAAM,CAAC,IAA3B,EAAiC;AAC/B,WAAO,KAAP;AACD;;AACD,UAAQ,MAAM,CAAC,IAAf;AACE,SAAK,UAAL;AACA,SAAK,OAAL;AACE,aACE,YAAY,CAAC,MAAD,CAAZ,KACA,YAAY,CAAqC,MAArC,CAFd;;AAIF,SAAK,aAAL;AACE,aACE,iBAAiB,CAAC,MAAM,CAAC,MAAR,CAAjB,KACA,iBAAiB,CAAwB,MAAO,CAAC,MAAhC,CAFnB;;AAIF,SAAK,UAAL;AACA,SAAK,SAAL;AACE,aAAO,IAAP;AAdJ;AAgBD;;AA7BD,OAAA,CAAA,SAAA,GAAA,SAAA;;AA+BA,SAAgB,oBAAhB,CACE,QADF,EAEE,UAFF,EAGE,qBAHF,EAGqC;AAEnC,MAAI;AACF,WAAO,SAAS,CACd,QADc,EAEd,GAAG,CAAC,KAAJ,CAAU,eAAV,CAA0B,UAA1B,EAAsC,qBAAtC,CAFc,CAAhB;AAID,GALD,CAKE,OAAO,CAAP,EAAU;AACV,WAAO,KAAP,CADU,CACI;AACf;AACF;;AAbD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAeA,SAAgB,WAAhB,CAA4B,QAA5B,EAAoD;AAClD,MAAI,aAAa,GAAG,QAAQ,CAAC,SAAT,GAAqB,CAArB,GAAyB,CAA7C,CADkD,CACF;;AAChD,SACE,QAAQ,CAAC,MAAT,CAAgB,MAAhB,CAAuB;AAAA,QAAG,OAAH,SAAG,OAAH;AAAA,WAAiB,OAAjB;AAAA,GAAvB,EAAiD,MAAjD,GAA0D,aAD5D;AAGD;;AALD,OAAA,CAAA,WAAA,GAAA,WAAA;;AAOA,SAAgB,2BAAhB,CAA4C,QAA5C,EAA+D;AAC7D,UAAQ,QAAQ,CAAC,IAAjB;AACE,SAAK,UAAL;AACA,SAAK,SAAL;AACE,aAAO,KAAP;;AACF,SAAK,aAAL;AACA,SAAK,OAAL;AACE,aAAO,QAAQ,CAAC,MAAT,CAAgB,IAAhB,CAAqB,+BAArB,CAAP;;AACF,SAAK,UAAL;AACE,aACE,QAAQ,CAAC,MAAT,CAAgB,IAAhB,CAAqB,+BAArB,KACA,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAsB,+BAAtB,CAFF;AARJ;AAaD;;AAdD,OAAA,CAAA,2BAAA,GAAA,2BAAA;;AAgBA,SAAS,+BAAT,CAAyC,YAAzC,EAAoE;AAClE,MAAM,oBAAoB,GAAG,CAC3B,MAD2B,EAE3B,KAF2B,EAG3B,OAH2B,EAI3B,QAJ2B,EAK3B,MAL2B,EAM3B,SAN2B,EAO3B,OAP2B,EAQ3B,QAR2B,EAS3B,UAT2B,EAU3B,OAV2B,CAA7B;AAYA,MAAM,aAAa,GAAG,YAAY,CAAC,IAAb,CAAkB,KAAlB,CAAwB,WAAxB,EAAqC,CAArC,CAAtB;AACA,MAAM,6BAA6B,GAAG,CAAC,oBAAoB,CAAC,QAArB,CACrC,aADqC,CAAvC;;AAGA,MAAI,YAAY,CAAC,UAAjB,EAA6B;AAC3B,WACE,YAAY,CAAC,UAAb,CAAwB,IAAxB,CAA6B,+BAA7B,KACA,6BAFF;AAID,GALD,MAKO;AACL,WAAO,6BAAP;AACD;AACF;;AAED,SAAgB,4BAAhB,CAA6C,QAA7C,EAAgE;AAC9D,MAAM,SAAS,GAAG,SAAZ,SAAY,CAAC,SAAD;AAAA,WAChB,SAAS,CAAC,IAAV,CAAe,QAAf,CAAwB,UAAxB,CADgB;AAAA,GAAlB;;AAEA,SACE,QAAQ,CAAC,IAAT,KAAkB,UAAlB,KACC,QAAQ,CAAC,MAAT,CAAgB,IAAhB,CAAqB,SAArB,KAAmC,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAsB,SAAtB,CADpC,CADF,CAH8D,CAO9D;AACA;AACA;AACD;;AAVD,OAAA,CAAA,4BAAA,GAAA,4BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiSelector = exports.abiTupleSignature = exports.abiSignature = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abi-data:utils\");\n// untyped import since no @types/web3-utils exists\nconst Web3Utils = require(\"web3-utils\");\nconst Evm = __importStar(require(\"../evm\"));\nconst Ast = __importStar(require(\"../ast\"));\nexports.DEFAULT_CONSTRUCTOR_ABI = {\n    type: \"constructor\",\n    inputs: [],\n    stateMutability: \"nonpayable\"\n};\n//note the return value only includes functions!\nfunction computeSelectors(abi) {\n    if (abi === undefined) {\n        return undefined;\n    }\n    return Object.assign({}, ...abi\n        .filter((abiEntry) => abiEntry.type === \"function\")\n        .map((abiEntry) => ({\n        [abiSelector(abiEntry)]: abiEntry\n    })));\n}\nexports.computeSelectors = computeSelectors;\n//does this ABI have a payable fallback (or receive) function?\nfunction abiHasPayableFallback(abi) {\n    if (abi === undefined) {\n        return undefined;\n    }\n    return abi.some(abiEntry => (abiEntry.type === \"fallback\" || abiEntry.type === \"receive\") &&\n        abiEntry.stateMutability === \"payable\");\n}\nexports.abiHasPayableFallback = abiHasPayableFallback;\n//NOTE: this function returns the written out SIGNATURE, not the SELECTOR\nfunction abiSignature(abiEntry) {\n    return abiEntry.name + abiTupleSignature(abiEntry.inputs);\n}\nexports.abiSignature = abiSignature;\nfunction abiTupleSignature(parameters) {\n    let components = parameters.map(abiTypeSignature);\n    return \"(\" + components.join(\",\") + \")\";\n}\nexports.abiTupleSignature = abiTupleSignature;\nfunction abiTypeSignature(parameter) {\n    let tupleMatch = parameter.type.match(/tuple(.*)/);\n    if (tupleMatch === null) {\n        //does not start with \"tuple\"\n        return parameter.type;\n    }\n    else {\n        let tail = tupleMatch[1]; //everything after \"tuple\"\n        let tupleSignature = abiTupleSignature(parameter.components);\n        return tupleSignature + tail;\n    }\n}\nfunction abiSelector(abiEntry) {\n    let signature = abiSignature(abiEntry);\n    //NOTE: web3's soliditySha3 has a problem if the empty\n    //string is passed in.  Fortunately, that should never happen here.\n    let hash = Web3Utils.soliditySha3({ type: \"string\", value: signature });\n    switch (abiEntry.type) {\n        case \"event\":\n            return hash;\n        case \"function\":\n            return hash.slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n    }\n}\nexports.abiSelector = abiSelector;\n//note: undefined does not match itself :P\nfunction abisMatch(entry1, entry2) {\n    //we'll consider two abi entries to match if they have the same\n    //type, name (if applicable), and inputs (if applicable).\n    //since there's already a signature function, we can just use that.\n    if (!entry1 || !entry2) {\n        return false;\n    }\n    if (entry1.type !== entry2.type) {\n        return false;\n    }\n    switch (entry1.type) {\n        case \"function\":\n        case \"event\":\n            return (abiSignature(entry1) ===\n                abiSignature(entry2));\n        case \"constructor\":\n            return (abiTupleSignature(entry1.inputs) ===\n                abiTupleSignature(entry2.inputs));\n        case \"fallback\":\n        case \"receive\":\n            return true;\n    }\n}\nexports.abisMatch = abisMatch;\nfunction definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {\n    try {\n        return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));\n    }\n    catch (_) {\n        return false; //if an exception occurs, well, that's not a match!\n    }\n}\nexports.definitionMatchesAbi = definitionMatchesAbi;\nfunction topicsCount(abiEntry) {\n    let selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector\n    return (abiEntry.inputs.filter(({ indexed }) => indexed).length + selectorCount);\n}\nexports.topicsCount = topicsCount;\nfunction abiEntryIsObviouslyIllTyped(abiEntry) {\n    switch (abiEntry.type) {\n        case \"fallback\":\n        case \"receive\":\n            return false;\n        case \"constructor\":\n        case \"event\":\n            return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);\n        case \"function\":\n            return (abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) ||\n                abiEntry.outputs.some(abiParameterIsObviouslyIllTyped));\n    }\n}\nexports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;\nfunction abiParameterIsObviouslyIllTyped(abiParameter) {\n    const legalBaseTypeClasses = [\n        \"uint\",\n        \"int\",\n        \"fixed\",\n        \"ufixed\",\n        \"bool\",\n        \"address\",\n        \"bytes\",\n        \"string\",\n        \"function\",\n        \"tuple\"\n    ];\n    const baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];\n    const baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);\n    if (abiParameter.components) {\n        return (abiParameter.components.some(abiParameterIsObviouslyIllTyped) ||\n            baseTypeClassIsObviouslyWrong);\n    }\n    else {\n        return baseTypeClassIsObviouslyWrong;\n    }\n}\nfunction abiEntryHasStorageParameters(abiEntry) {\n    const isStorage = (parameter) => parameter.type.endsWith(\" storage\");\n    return (abiEntry.type === \"function\" &&\n        (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage)));\n    //Note the lack of recursion!  Storage parameters can only occur at\n    //top level so there's no need to recurse here\n    //(they can also only occur for functions)\n}\nexports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}