{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar bignumber = require('bignumber.js').BigNumber;\n\nvar utils = require('./utils');\n\nvar url = require('url');\n\nvar MINUS_ONE = new bignumber(-1);\nvar TWO = new bignumber(2);\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\n\nvar Tagged = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} [err] - the error that was thrown parsing the tag, or null\n   */\n  function Tagged(tag, value, err) {\n    _classCallCheck(this, Tagged);\n\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + typeof this.tag + ')');\n    }\n\n    if (this.tag < 0 || (this.tag | 0) !== this.tag) {\n      throw new Error('Tag must be a positive integer: ' + this.tag);\n    }\n  }\n  /**\n   * Convert to a String\n   *\n   * @returns {string} string of the form '1(2)'\n   */\n\n\n  _createClass(Tagged, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.tag, \"(\").concat(JSON.stringify(this.value), \")\");\n    }\n    /**\n     * Push the simple value onto the CBOR stream\n     *\n     * @param {Object} gen The generator to push onto\n     */\n\n  }, {\n    key: \"encodeCBOR\",\n    value: function encodeCBOR(gen) {\n      gen._pushTag(this.tag);\n\n      return gen.pushAny(this.value);\n    }\n    /**\n     * If we have a converter for this type, do the conversion.  Some converters\n     * are built-in.  Additional ones can be passed in.  If you want to remove\n     * a built-in converter, pass a converter in whose value is 'null' instead\n     * of a function.\n     *\n     * @param {Object} converters - keys in the object are a tag number, the value\n     *   is a function that takes the decoded CBOR and returns a JavaScript value\n     *   of the appropriate type.  Throw an exception in the function on errors.\n     * @returns {any} - the converted item\n     */\n\n  }, {\n    key: \"convert\",\n    value: function convert(converters) {\n      var f = converters != null ? converters[this.tag] : void 0;\n\n      if (typeof f !== 'function') {\n        f = Tagged['_tag_' + this.tag];\n\n        if (typeof f !== 'function') {\n          return this;\n        }\n      }\n\n      try {\n        return f.call(Tagged, this.value);\n      } catch (error) {\n        this.err = error;\n        return this;\n      }\n    }\n  }], [{\n    key: \"_tag_0\",\n    value: function _tag_0(v) {\n      return new Date(v);\n    }\n  }, {\n    key: \"_tag_1\",\n    value: function _tag_1(v) {\n      return new Date(v * 1000);\n    }\n  }, {\n    key: \"_tag_2\",\n    value: function _tag_2(v) {\n      return utils.bufferToBignumber(v);\n    }\n  }, {\n    key: \"_tag_3\",\n    value: function _tag_3(v) {\n      return MINUS_ONE.minus(utils.bufferToBignumber(v));\n    }\n  }, {\n    key: \"_tag_4\",\n    value: function _tag_4(v) {\n      return bignumber(v[1]).shiftedBy(v[0]);\n    }\n  }, {\n    key: \"_tag_5\",\n    value: function _tag_5(v) {\n      return TWO.pow(v[0]).times(v[1]);\n    }\n  }, {\n    key: \"_tag_32\",\n    value: function _tag_32(v) {\n      return url.parse(v);\n    }\n  }, {\n    key: \"_tag_35\",\n    value: function _tag_35(v) {\n      return new RegExp(v);\n    }\n  }]);\n\n  return Tagged;\n}();\n\nmodule.exports = Tagged;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/cbor/lib/tagged.js"],"names":["bignumber","require","BigNumber","utils","url","MINUS_ONE","TWO","Tagged","tag","value","err","Error","JSON","stringify","gen","_pushTag","pushAny","converters","f","call","error","v","Date","bufferToBignumber","minus","shiftedBy","pow","times","parse","RegExp","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst bignumber = require('bignumber.js').BigNumber\nconst utils = require('./utils')\nconst url = require('url')\n\nconst MINUS_ONE = new bignumber(-1)\nconst TWO = new bignumber(2)\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} [err] - the error that was thrown parsing the tag, or null\n   */\n  constructor(tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error('Tag must be a positive integer: ' + this.tag)\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {string} string of the form '1(2)'\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert(converters) {\n    let f = converters != null ? converters[this.tag] : void 0\n    if (typeof f !== 'function') {\n      f = Tagged['_tag_' + this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(Tagged, this.value)\n    } catch (error) {\n      this.err = error\n      return this\n    }\n  }\n\n  static _tag_0(v) {\n    return new Date(v)\n  }\n\n  static _tag_1(v) {\n    return new Date(v * 1000)\n  }\n\n  static _tag_2(v) {\n    return utils.bufferToBignumber(v)\n  }\n\n  static _tag_3(v) {\n    return MINUS_ONE.minus(utils.bufferToBignumber(v))\n  }\n\n  static _tag_4(v) {\n    return bignumber(v[1]).shiftedBy(v[0])\n  }\n\n  static _tag_5(v) {\n    return TWO.pow(v[0]).times(v[1])\n  }\n\n  static _tag_32(v) {\n    return url.parse(v)\n  }\n\n  static _tag_35(v) {\n    return new RegExp(v)\n  }\n}\n\nmodule.exports = Tagged\n"]},"metadata":{},"sourceType":"script"}