{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeVariable),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeCalldata),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeEvent),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(decodeReturndata),\n    _marked5 = /*#__PURE__*/_regeneratorRuntime.mark(decodeBytecode);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:core\");\n\nvar Ast = __importStar(require(\"./ast\"));\n\nvar AbiData = __importStar(require(\"./abi-data\"));\n\nvar Topic = __importStar(require(\"./topic\"));\n\nvar Evm = __importStar(require(\"./evm\"));\n\nvar Contexts = __importStar(require(\"./contexts\"));\n\nvar abify_1 = require(\"./abify\");\n\nvar Conversion = __importStar(require(\"./conversion\"));\n\nvar errors_1 = require(\"./errors\");\n\nvar read_1 = __importDefault(require(\"./read\"));\n\nvar decode_1 = __importDefault(require(\"./decode\")); // untyped import since no @types/web3-utils exists\n\n\nvar Web3Utils = require(\"web3-utils\");\n/**\n * @Category Decoding\n */\n\n\nfunction decodeVariable(definition, pointer, info, compilationId) {\n  var compiler, dataType;\n  return _regeneratorRuntime.wrap(function decodeVariable$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          compiler = info.currentContext.compiler;\n          dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n          return _context.delegateYield(decode_1.default(dataType, pointer, info), \"t0\", 3);\n\n        case 3:\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.decodeVariable = decodeVariable;\n/**\n * @Category Decoding\n */\n\nfunction decodeCalldata(info, isConstructor //ignored if context! trust context instead if have\n) {\n  var context, compiler, contextHash, contractType, allocations, allocation, selector, rawSelector, abiEntry, decodingMode, decodedArguments, _iterator, _step, argumentAllocation, value, dataType, name;\n\n  return _regeneratorRuntime.wrap(function decodeCalldata$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          context = info.currentContext;\n\n          if (!(context === null)) {\n            _context2.next = 7;\n            break;\n          }\n\n          if (!isConstructor) {\n            _context2.next = 6;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            kind: \"create\",\n            decodingMode: \"full\",\n            bytecode: Conversion.toHexString(info.state.calldata)\n          });\n\n        case 6:\n          return _context2.abrupt(\"return\", {\n            kind: \"unknown\",\n            decodingMode: \"full\",\n            data: Conversion.toHexString(info.state.calldata)\n          });\n\n        case 7:\n          compiler = context.compiler;\n          contextHash = context.context;\n          contractType = Contexts.Import.contextToType(context);\n          isConstructor = context.isConstructor;\n          allocations = info.allocations.calldata;\n\n          if (!isConstructor) {\n            _context2.next = 16;\n            break;\n          }\n\n          allocation = allocations.constructorAllocations[contextHash].input;\n          _context2.next = 20;\n          break;\n\n        case 16:\n          return _context2.delegateYield(read_1.default({\n            location: \"calldata\",\n            start: 0,\n            length: Evm.Utils.SELECTOR_SIZE\n          }, info.state), \"t0\", 17);\n\n        case 17:\n          rawSelector = _context2.t0;\n          selector = Conversion.toHexString(rawSelector);\n          allocation = (allocations.functionAllocations[contextHash][selector] || {\n            input: undefined\n          }).input;\n\n        case 20:\n          if (!(allocation === undefined)) {\n            _context2.next = 24;\n            break;\n          }\n\n          abiEntry = null;\n\n          if (info.state.calldata.length === 0) {\n            //to hell with reads, let's just be direct\n            abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;\n          } else {\n            abiEntry = context.fallbackAbi.fallback;\n          }\n\n          return _context2.abrupt(\"return\", {\n            kind: \"message\",\n            class: contractType,\n            abi: abiEntry,\n            data: Conversion.toHexString(info.state.calldata),\n            decodingMode: \"full\"\n          });\n\n        case 24:\n          decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary\n\n          debug(\"calldata decoding mode: %s\", decodingMode); //you can't map with a generator, so we have to do this map manually\n\n          decodedArguments = [];\n          _iterator = _createForOfIteratorHelper(allocation.arguments);\n          _context2.prev = 28;\n\n          _iterator.s();\n\n        case 30:\n          if ((_step = _iterator.n()).done) {\n            _context2.next = 55;\n            break;\n          }\n\n          argumentAllocation = _step.value;\n          value = void 0;\n          dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n          _context2.prev = 34;\n          return _context2.delegateYield(decode_1.default(dataType, argumentAllocation.pointer, info, {\n            abiPointerBase: allocation.offset,\n            allowRetry: decodingMode === \"full\"\n          }), \"t1\", 36);\n\n        case 36:\n          value = _context2.t1;\n          _context2.next = 51;\n          break;\n\n        case 39:\n          _context2.prev = 39;\n          _context2.t2 = _context2[\"catch\"](34);\n\n          if (!(_context2.t2 instanceof errors_1.StopDecodingError && _context2.t2.allowRetry && decodingMode === \"full\")) {\n            _context2.next = 50;\n            break;\n          }\n\n          debug(\"problem! retrying as ABI\");\n          debug(\"error: %O\", _context2.t2); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(function (argumentDecoding) {\n            return Object.assign(Object.assign({}, argumentDecoding), {\n              value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n            });\n          }); //3. retry this particular decode in ABI mode.\n          //(no try/catch on this one because we can't actually handle errors here!\n          //not that they should be occurring)\n\n          return _context2.delegateYield(decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n          argumentAllocation.pointer, info, {\n            abiPointerBase: allocation.offset\n          }), \"t3\", 47);\n\n        case 47:\n          value = _context2.t3;\n          _context2.next = 51;\n          break;\n\n        case 50:\n          throw _context2.t2;\n\n        case 51:\n          name = argumentAllocation.name;\n          decodedArguments.push(name //deliberate general falsiness test\n          ? {\n            name: name,\n            value: value\n          } : {\n            value: value\n          });\n\n        case 53:\n          _context2.next = 30;\n          break;\n\n        case 55:\n          _context2.next = 60;\n          break;\n\n        case 57:\n          _context2.prev = 57;\n          _context2.t4 = _context2[\"catch\"](28);\n\n          _iterator.e(_context2.t4);\n\n        case 60:\n          _context2.prev = 60;\n\n          _iterator.f();\n\n          return _context2.finish(60);\n\n        case 63:\n          if (!isConstructor) {\n            _context2.next = 67;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            kind: \"constructor\",\n            class: contractType,\n            arguments: decodedArguments,\n            abi: allocation.abi,\n            bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),\n            decodingMode: decodingMode\n          });\n\n        case 67:\n          return _context2.abrupt(\"return\", {\n            kind: \"function\",\n            class: contractType,\n            abi: allocation.abi,\n            arguments: decodedArguments,\n            selector: selector,\n            decodingMode: decodingMode\n          });\n\n        case 68:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[28, 57, 60, 63], [34, 39]]);\n}\n\nexports.decodeCalldata = decodeCalldata; //note: this will likely change in the future to take options rather than targetName, but I'm\n//leaving it alone for now, as I'm not sure what form those options will take\n//(and this is something we're a bit more OK with breaking since it's primarily\n//for internal use :) )\n\n/**\n * @Category Decoding\n */\n\nfunction decodeEvent(info, address, targetName) {\n  var _ref, _ref2;\n\n  var allocations, rawSelector, selector, contractAllocations, libraryAllocations, contractAnonymousAllocations, libraryAnonymousAllocations, topicsCount, _allocations$topicsCo, _allocations$topicsCo2, codeBytes, codeAsHex, contractContext, possibleContractAllocations, possibleContractAnonymousAllocations, contextHash, contractAllocation, contractAnonymousAllocation, possibleLibraryAllocations, possibleLibraryAnonymousAllocations, possibleAllocations, possibleAnonymousAllocations, possibleAllocationsTotal, decodings, _iterator2, _step2, allocation, decodingMode, _contextHash, attemptContext, emittingContractType, contractType, decodedArguments, _iterator3, _step3, argumentAllocation, value, dataType, name, indexed, nonIndexedValues, reEncodedData, encodedData, indexedValues, reEncodedTopics, encodedTopics, selectorAdjustment, i;\n\n  return _regeneratorRuntime.wrap(function decodeEvent$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          allocations = info.allocations.event;\n          topicsCount = info.state.eventtopics.length; //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?\n\n          if (!allocations[topicsCount]) {\n            _context3.next = 17;\n            break;\n          }\n\n          if (!(topicsCount > 0)) {\n            _context3.next = 10;\n            break;\n          }\n\n          return _context3.delegateYield(read_1.default({\n            location: \"eventtopic\",\n            topic: 0\n          }, info.state), \"t0\", 5);\n\n        case 5:\n          rawSelector = _context3.t0;\n          selector = Conversion.toHexString(rawSelector);\n\n          if (allocations[topicsCount].bySelector[selector]) {\n            _allocations$topicsCo = allocations[topicsCount].bySelector[selector];\n            contractAllocations = _allocations$topicsCo.contract;\n            libraryAllocations = _allocations$topicsCo.library;\n          } else {\n            debug(\"no allocations for that selector!\");\n            contractAllocations = {};\n            libraryAllocations = {};\n          }\n\n          _context3.next = 12;\n          break;\n\n        case 10:\n          //if we don't have a selector, it means we don't have any non-anonymous events\n          contractAllocations = {};\n          libraryAllocations = {};\n\n        case 12:\n          _allocations$topicsCo2 = allocations[topicsCount].anonymous;\n          contractAnonymousAllocations = _allocations$topicsCo2.contract;\n          libraryAnonymousAllocations = _allocations$topicsCo2.library;\n          _context3.next = 19;\n          break;\n\n        case 17:\n          //if there's not even an allocation for the topics count, we can't\n          //decode; we could do this the honest way of setting all four allocation\n          //objects to {}, but let's just short circuit\n          debug(\"no allocations for that topic count!\");\n          return _context3.abrupt(\"return\", []);\n\n        case 19:\n          _context3.next = 21;\n          return {\n            type: \"code\",\n            address: address\n          };\n\n        case 21:\n          codeBytes = _context3.sent;\n          codeAsHex = Conversion.toHexString(codeBytes);\n          contractContext = Contexts.Utils.findDecoderContext(info.contexts, codeAsHex);\n\n          if (contractContext) {\n            //if we found the contract, maybe it's from that contract\n            contextHash = contractContext.context;\n            contractAllocation = contractAllocations[contextHash];\n            contractAnonymousAllocation = contractAnonymousAllocations[contextHash];\n            possibleContractAllocations = contractAllocation || [];\n            possibleContractAnonymousAllocations = contractAnonymousAllocation || [];\n          } else {\n            //if we couldn't determine the contract, well, we have to assume it's from a library\n            debug(\"couldn't find context\");\n            possibleContractAllocations = [];\n            possibleContractAnonymousAllocations = [];\n          } //now we get all the library allocations!\n\n\n          possibleLibraryAllocations = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.values(libraryAllocations)));\n          possibleLibraryAnonymousAllocations = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(Object.values(libraryAnonymousAllocations))); //now we put it all together!\n\n          possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);\n          possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);\n          possibleAllocationsTotal = possibleAllocations.concat(possibleAnonymousAllocations);\n          decodings = [];\n          _iterator2 = _createForOfIteratorHelper(possibleAllocationsTotal);\n          _context3.prev = 32;\n\n          _iterator2.s();\n\n        case 34:\n          if ((_step2 = _iterator2.n()).done) {\n            _context3.next = 110;\n            break;\n          }\n\n          allocation = _step2.value;\n          //first: do a name check so we can skip decoding if name is wrong\n          debug(\"trying allocation: %O\", allocation);\n\n          if (!(targetName !== undefined && allocation.abi.name !== targetName)) {\n            _context3.next = 39;\n            break;\n          }\n\n          return _context3.abrupt(\"continue\", 108);\n\n        case 39:\n          decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n\n          _contextHash = allocation.contextHash;\n          attemptContext = info.contexts[_contextHash];\n          emittingContractType = Contexts.Import.contextToType(attemptContext);\n          contractType = allocation.definedIn; //you can't map with a generator, so we have to do this map manually\n\n          decodedArguments = [];\n          _iterator3 = _createForOfIteratorHelper(allocation.arguments);\n          _context3.prev = 46;\n\n          _iterator3.s();\n\n        case 48:\n          if ((_step3 = _iterator3.n()).done) {\n            _context3.next = 80;\n            break;\n          }\n\n          argumentAllocation = _step3.value;\n          value = void 0; //if in full mode, use the allocation's listed data type.\n          //if in ABI mode, abify it before use.\n\n          dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n          _context3.prev = 52;\n          return _context3.delegateYield(decode_1.default(dataType, argumentAllocation.pointer, info, {\n            strictAbiMode: true,\n            allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n          }), \"t1\", 54);\n\n        case 54:\n          value = _context3.t1;\n          _context3.next = 75;\n          break;\n\n        case 57:\n          _context3.prev = 57;\n          _context3.t2 = _context3[\"catch\"](52);\n\n          if (!(_context3.t2 instanceof errors_1.StopDecodingError && _context3.t2.allowRetry && decodingMode === \"full\")) {\n            _context3.next = 73;\n            break;\n          }\n\n          //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(function (argumentDecoding) {\n            return Object.assign(Object.assign({}, argumentDecoding), {\n              value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n            });\n          }); //3. retry this particular decode in ABI mode.\n\n          _context3.prev = 62;\n          return _context3.delegateYield(decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n          argumentAllocation.pointer, info, {\n            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n            //retries no longer allowed, not that this has an effect\n\n          }), \"t3\", 64);\n\n        case 64:\n          value = _context3.t3;\n          _context3.next = 71;\n          break;\n\n        case 67:\n          _context3.prev = 67;\n          _context3.t4 = _context3[\"catch\"](62);\n          //if an error occurred on the retry, this isn't a valid decoding!\n          debug(\"rejected due to exception on retry\");\n          return _context3.abrupt(\"continue\", 108);\n\n        case 71:\n          _context3.next = 75;\n          break;\n\n        case 73:\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", _context3.t2);\n          return _context3.abrupt(\"continue\", 108);\n\n        case 75:\n          name = argumentAllocation.name;\n          indexed = argumentAllocation.pointer.location === \"eventtopic\";\n          decodedArguments.push(name //deliberate general falsiness test\n          ? {\n            name: name,\n            indexed: indexed,\n            value: value\n          } : {\n            indexed: indexed,\n            value: value\n          });\n\n        case 78:\n          _context3.next = 48;\n          break;\n\n        case 80:\n          _context3.next = 85;\n          break;\n\n        case 82:\n          _context3.prev = 82;\n          _context3.t5 = _context3[\"catch\"](46);\n\n          _iterator3.e(_context3.t5);\n\n        case 85:\n          _context3.prev = 85;\n\n          _iterator3.f();\n\n          return _context3.finish(85);\n\n        case 88:\n          //OK, so, having decoded the result, the question is: does it reencode to the original?\n          //first, we have to filter out the indexed arguments, and also get rid of the name information\n          nonIndexedValues = decodedArguments.filter(function (argument) {\n            return !argument.indexed;\n          }).map(function (argument) {\n            return argument.value;\n          }); //now, we can encode!\n\n          reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);\n          encodedData = info.state.eventdata; //again, not great to read this directly, but oh well\n          //are they equal?\n\n          if (Evm.Utils.equalData(reEncodedData, encodedData)) {\n            _context3.next = 94;\n            break;\n          }\n\n          //if not, this allocation doesn't work\n          debug(\"rejected due to [non-indexed] mismatch\");\n          return _context3.abrupt(\"continue\", 108);\n\n        case 94:\n          //one last check -- let's check that the indexed arguments match up, too\n          indexedValues = decodedArguments.filter(function (argument) {\n            return argument.indexed;\n          }).map(function (argument) {\n            return argument.value;\n          });\n          reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);\n          encodedTopics = info.state.eventtopics; //now: do *these* match?\n\n          selectorAdjustment = allocation.anonymous ? 0 : 1;\n          i = 0;\n\n        case 99:\n          if (!(i < reEncodedTopics.length)) {\n            _context3.next = 106;\n            break;\n          }\n\n          if (Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {\n            _context3.next = 103;\n            break;\n          }\n\n          debug(\"rejected due to indexed mismatch\");\n          return _context3.abrupt(\"continue\", 108);\n\n        case 103:\n          i++;\n          _context3.next = 99;\n          break;\n\n        case 106:\n          //if we've made it here, the allocation works!  hooray!\n          debug(\"allocation accepted!\");\n\n          if (allocation.abi.anonymous) {\n            decodings.push({\n              kind: \"anonymous\",\n              definedIn: contractType,\n              class: emittingContractType,\n              abi: allocation.abi,\n              arguments: decodedArguments,\n              decodingMode: decodingMode\n            });\n          } else {\n            decodings.push({\n              kind: \"event\",\n              definedIn: contractType,\n              class: emittingContractType,\n              abi: allocation.abi,\n              arguments: decodedArguments,\n              selector: selector,\n              decodingMode: decodingMode\n            });\n          }\n\n        case 108:\n          _context3.next = 34;\n          break;\n\n        case 110:\n          _context3.next = 115;\n          break;\n\n        case 112:\n          _context3.prev = 112;\n          _context3.t6 = _context3[\"catch\"](32);\n\n          _iterator2.e(_context3.t6);\n\n        case 115:\n          _context3.prev = 115;\n\n          _iterator2.f();\n\n          return _context3.finish(115);\n\n        case 118:\n          return _context3.abrupt(\"return\", decodings);\n\n        case 119:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, null, [[32, 112, 115, 118], [46, 82, 85, 88], [52, 57], [62, 67]]);\n}\n\nexports.decodeEvent = decodeEvent;\nvar errorSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n  type: \"string\",\n  value: \"Error(string)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nvar defaultReturnAllocations = [{\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: errorSelector,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: errorSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"string\",\n      typeHint: \"string\"\n    }\n  }]\n}, {\n  kind: \"failure\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}, {\n  kind: \"selfdestruct\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}];\n/**\n * If there are multiple possibilities, they're always returned in\n * the order: return, revert, failure, empty, bytecode, unknownbytecode\n * @Category Decoding\n */\n\nfunction decodeReturndata(info, successAllocation, //null here must be explicit\nstatus //you can pass this to indicate that you know the status\n) {\n  var possibleAllocations, decodings, _iterator4, _step4, allocation, encodedData, encodedPrefix, successKinds, failKinds, _decoding, decodingMode, decodedArguments, _iterator5, _step5, argumentAllocation, value, dataType, name, decodedArgumentValues, reEncodedData, decoding, kind;\n\n  return _regeneratorRuntime.wrap(function decodeReturndata$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (!(successAllocation === null)) {\n            _context4.next = 4;\n            break;\n          }\n\n          possibleAllocations = defaultReturnAllocations;\n          _context4.next = 11;\n          break;\n\n        case 4:\n          _context4.t0 = successAllocation.kind;\n          _context4.next = _context4.t0 === \"return\" ? 7 : _context4.t0 === \"bytecode\" ? 9 : 11;\n          break;\n\n        case 7:\n          possibleAllocations = [successAllocation].concat(defaultReturnAllocations);\n          return _context4.abrupt(\"break\", 11);\n\n        case 9:\n          possibleAllocations = [].concat(defaultReturnAllocations, [successAllocation]);\n          return _context4.abrupt(\"break\", 11);\n\n        case 11:\n          decodings = [];\n          _iterator4 = _createForOfIteratorHelper(possibleAllocations);\n          _context4.prev = 13;\n\n          _iterator4.s();\n\n        case 15:\n          if ((_step4 = _iterator4.n()).done) {\n            _context4.next = 108;\n            break;\n          }\n\n          allocation = _step4.value;\n          debug(\"trying allocation: %O\", allocation); //before we attempt to use this allocation, we check: does the selector match?\n\n          encodedData = info.state.returndata; //again, not great to read this directly, but oh well\n\n          encodedPrefix = encodedData.subarray(0, allocation.selector.length);\n\n          if (Evm.Utils.equalData(encodedPrefix, allocation.selector)) {\n            _context4.next = 22;\n            break;\n          }\n\n          return _context4.abrupt(\"continue\", 106);\n\n        case 22:\n          encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later\n          //also we check, does the status match?\n\n          if (!(status !== undefined)) {\n            _context4.next = 33;\n            break;\n          }\n\n          successKinds = [\"return\", \"selfdestruct\", \"bytecode\"];\n          failKinds = [\"failure\", \"revert\"];\n\n          if (!status) {\n            _context4.next = 31;\n            break;\n          }\n\n          if (successKinds.includes(allocation.kind)) {\n            _context4.next = 29;\n            break;\n          }\n\n          return _context4.abrupt(\"continue\", 106);\n\n        case 29:\n          _context4.next = 33;\n          break;\n\n        case 31:\n          if (failKinds.includes(allocation.kind)) {\n            _context4.next = 33;\n            break;\n          }\n\n          return _context4.abrupt(\"continue\", 106);\n\n        case 33:\n          if (!(allocation.kind === \"bytecode\")) {\n            _context4.next = 38;\n            break;\n          }\n\n          return _context4.delegateYield(decodeBytecode(info), \"t1\", 35);\n\n        case 35:\n          _decoding = _context4.t1;\n\n          if (_decoding) {\n            decodings.push(_decoding);\n          }\n\n          return _context4.abrupt(\"continue\", 106);\n\n        case 38:\n          decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n          //you can't map with a generator, so we have to do this map manually\n\n          decodedArguments = [];\n          _iterator5 = _createForOfIteratorHelper(allocation.arguments);\n          _context4.prev = 41;\n\n          _iterator5.s();\n\n        case 43:\n          if ((_step5 = _iterator5.n()).done) {\n            _context4.next = 77;\n            break;\n          }\n\n          argumentAllocation = _step5.value;\n          value = void 0; //if in full mode, use the allocation's listed data type.\n          //if in ABI mode, abify it before use.\n\n          dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes); //now, let's decode!\n\n          _context4.prev = 47;\n          return _context4.delegateYield(decode_1.default(dataType, argumentAllocation.pointer, info, {\n            abiPointerBase: allocation.selector.length,\n            strictAbiMode: true,\n            allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n          }), \"t2\", 49);\n\n        case 49:\n          value = _context4.t2;\n          debug(\"value on first try: %O\", value);\n          _context4.next = 73;\n          break;\n\n        case 53:\n          _context4.prev = 53;\n          _context4.t3 = _context4[\"catch\"](47);\n\n          if (!(_context4.t3 instanceof errors_1.StopDecodingError && _context4.t3.allowRetry && decodingMode === \"full\")) {\n            _context4.next = 71;\n            break;\n          }\n\n          debug(\"retry!\"); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(function (argumentDecoding) {\n            return Object.assign(Object.assign({}, argumentDecoding), {\n              value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n            });\n          }); //3. retry this particular decode in ABI mode.\n\n          _context4.prev = 59;\n          return _context4.delegateYield(decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n          argumentAllocation.pointer, info, {\n            abiPointerBase: allocation.selector.length,\n            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n            //retries no longer allowed, not that this has an effect\n\n          }), \"t4\", 61);\n\n        case 61:\n          value = _context4.t4;\n          debug(\"value on retry: %O\", value);\n          _context4.next = 69;\n          break;\n\n        case 65:\n          _context4.prev = 65;\n          _context4.t5 = _context4[\"catch\"](59);\n          //if an error occurred on the retry, this isn't a valid decoding!\n          debug(\"rejected due to exception on retry\");\n          return _context4.abrupt(\"continue\", 106);\n\n        case 69:\n          _context4.next = 73;\n          break;\n\n        case 71:\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", _context4.t3);\n          return _context4.abrupt(\"continue\", 106);\n\n        case 73:\n          name = argumentAllocation.name;\n          decodedArguments.push(name //deliberate general falsiness test\n          ? {\n            name: name,\n            value: value\n          } : {\n            value: value\n          });\n\n        case 75:\n          _context4.next = 43;\n          break;\n\n        case 77:\n          _context4.next = 82;\n          break;\n\n        case 79:\n          _context4.prev = 79;\n          _context4.t6 = _context4[\"catch\"](41);\n\n          _iterator5.e(_context4.t6);\n\n        case 82:\n          _context4.prev = 82;\n\n          _iterator5.f();\n\n          return _context4.finish(82);\n\n        case 85:\n          //OK, so, having decoded the result, the question is: does it reencode to the original?\n          //first, we have to filter out the indexed arguments, and also get rid of the name information\n          debug(\"decodedArguments: %O\", decodedArguments);\n          decodedArgumentValues = decodedArguments.map(function (argument) {\n            return argument.value;\n          });\n          reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi); //are they equal? note the selector has been stripped off encodedData!\n\n          if (Evm.Utils.equalData(reEncodedData, encodedData)) {\n            _context4.next = 91;\n            break;\n          }\n\n          //if not, this allocation doesn't work\n          debug(\"rejected due to mismatch\");\n          return _context4.abrupt(\"continue\", 106);\n\n        case 91:\n          //if we've made it here, the allocation works!  hooray!\n          debug(\"allocation accepted!\");\n          decoding = void 0;\n          kind = allocation.kind;\n          _context4.t7 = kind;\n          _context4.next = _context4.t7 === \"return\" ? 97 : _context4.t7 === \"revert\" ? 99 : _context4.t7 === \"selfdestruct\" ? 101 : _context4.t7 === \"failure\" ? 103 : 105;\n          break;\n\n        case 97:\n          decoding = {\n            kind: kind,\n            status: true,\n            arguments: decodedArguments,\n            decodingMode: decodingMode\n          };\n          return _context4.abrupt(\"break\", 105);\n\n        case 99:\n          decoding = {\n            kind: kind,\n            status: false,\n            arguments: decodedArguments,\n            decodingMode: decodingMode\n          };\n          return _context4.abrupt(\"break\", 105);\n\n        case 101:\n          decoding = {\n            kind: kind,\n            status: true,\n            decodingMode: decodingMode\n          };\n          return _context4.abrupt(\"break\", 105);\n\n        case 103:\n          decoding = {\n            kind: kind,\n            status: false,\n            decodingMode: decodingMode\n          };\n          return _context4.abrupt(\"break\", 105);\n\n        case 105:\n          decodings.push(decoding);\n\n        case 106:\n          _context4.next = 15;\n          break;\n\n        case 108:\n          _context4.next = 113;\n          break;\n\n        case 110:\n          _context4.prev = 110;\n          _context4.t8 = _context4[\"catch\"](13);\n\n          _iterator4.e(_context4.t8);\n\n        case 113:\n          _context4.prev = 113;\n\n          _iterator4.f();\n\n          return _context4.finish(113);\n\n        case 116:\n          return _context4.abrupt(\"return\", decodings);\n\n        case 117:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4, null, [[13, 110, 113, 116], [41, 79, 82, 85], [47, 53], [59, 65]]);\n}\n\nexports.decodeReturndata = decodeReturndata; //note: requires the bytecode to be in returndata, not code\n\nfunction decodeBytecode(info) {\n  var decodingMode, bytecode, context, contractType, allocation, immutables, _iterator6, _step6, variable, dataType, value, decoding;\n\n  return _regeneratorRuntime.wrap(function decodeBytecode$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          decodingMode = \"full\"; //as always, degrade as necessary\n\n          bytecode = Conversion.toHexString(info.state.returndata);\n          context = Contexts.Utils.findDecoderContext(info.contexts, bytecode);\n\n          if (context) {\n            _context5.next = 5;\n            break;\n          }\n\n          return _context5.abrupt(\"return\", {\n            kind: \"unknownbytecode\",\n            status: true,\n            decodingMode: \"full\",\n            bytecode: bytecode\n          });\n\n        case 5:\n          contractType = Contexts.Import.contextToType(context); //now: ignore original allocation (which we didn't even pass :) )\n          //and lookup allocation by context\n\n          allocation = info.allocations.calldata.constructorAllocations[context.context].output;\n          debug(\"bytecode allocation: %O\", allocation); //now: add immutables if applicable\n\n          if (!allocation.immutables) {\n            _context5.next = 42;\n            break;\n          }\n\n          immutables = []; //NOTE: if we're in here, we can assume decodingMode === \"full\"\n\n          _iterator6 = _createForOfIteratorHelper(allocation.immutables);\n          _context5.prev = 11;\n\n          _iterator6.s();\n\n        case 13:\n          if ((_step6 = _iterator6.n()).done) {\n            _context5.next = 34;\n            break;\n          }\n\n          variable = _step6.value;\n          dataType = variable.type; //we don't conditioning on decodingMode here because we know it\n\n          value = void 0;\n          _context5.prev = 17;\n          return _context5.delegateYield(decode_1.default(dataType, variable.pointer, info, {\n            allowRetry: true,\n            strictAbiMode: true,\n            paddingMode: \"zero\" //force zero-padding!\n\n          }), \"t0\", 19);\n\n        case 19:\n          value = _context5.t0;\n          _context5.next = 31;\n          break;\n\n        case 22:\n          _context5.prev = 22;\n          _context5.t1 = _context5[\"catch\"](17);\n\n          if (!(_context5.t1 instanceof errors_1.StopDecodingError && _context5.t1.allowRetry)) {\n            _context5.next = 30;\n            break;\n          }\n\n          //we \"retry\" by... not bothering with immutables :P\n          //(but we do set the mode to ABI)\n          decodingMode = \"abi\";\n          immutables = undefined;\n          return _context5.abrupt(\"break\", 34);\n\n        case 30:\n          return _context5.abrupt(\"return\", null);\n\n        case 31:\n          immutables.push({\n            name: variable.name,\n            class: variable.definedIn,\n            value: value\n          });\n\n        case 32:\n          _context5.next = 13;\n          break;\n\n        case 34:\n          _context5.next = 39;\n          break;\n\n        case 36:\n          _context5.prev = 36;\n          _context5.t2 = _context5[\"catch\"](11);\n\n          _iterator6.e(_context5.t2);\n\n        case 39:\n          _context5.prev = 39;\n\n          _iterator6.f();\n\n          return _context5.finish(39);\n\n        case 42:\n          decoding = {\n            kind: \"bytecode\",\n            status: true,\n            decodingMode: decodingMode,\n            bytecode: bytecode,\n            immutables: immutables,\n            class: contractType\n          }; //finally: add address if applicable\n\n          if (allocation.delegatecallGuard) {\n            decoding.address = Web3Utils.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = \"0x73\".length\n            );\n          }\n\n          return _context5.abrupt(\"return\", decoding);\n\n        case 45:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5, null, [[11, 36, 39, 42], [17, 22]]);\n}\n/**\n * Decodes the return data from a failed call.\n *\n * @param returndata The returned data, as a Uint8Array.\n * @return An array of possible decodings.  At the moment it's\n *   impossible for there to be more than one.  (If the call didn't actually\n *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)\n *\n *   Decodings can either be decodings of revert messages, or decodings\n *   indicating that there was no revert message.  If somehow both were to be\n *   possible, they'd go in that order, although as mentioned, there (at least\n *   currently) isn't any way for that to occur.\n * @Category Decoding convenience\n */\n\n\nfunction decodeRevert(returndata) {\n  //coercing because TS doesn't know it'll finish in one go\n  return decodeReturndata({\n    allocations: {},\n    state: {\n      storage: {},\n      returndata: returndata\n    }\n  }, null, false).next().value;\n}\n\nexports.decodeRevert = decodeRevert;","map":{"version":3,"sources":["../../lib/core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:core\");\nconst Ast = __importStar(require(\"./ast\"));\nconst AbiData = __importStar(require(\"./abi-data\"));\nconst Topic = __importStar(require(\"./topic\"));\nconst Evm = __importStar(require(\"./evm\"));\nconst Contexts = __importStar(require(\"./contexts\"));\nconst abify_1 = require(\"./abify\");\nconst Conversion = __importStar(require(\"./conversion\"));\nconst errors_1 = require(\"./errors\");\nconst read_1 = __importDefault(require(\"./read\"));\nconst decode_1 = __importDefault(require(\"./decode\"));\n// untyped import since no @types/web3-utils exists\nconst Web3Utils = require(\"web3-utils\");\n/**\n * @Category Decoding\n */\nfunction* decodeVariable(definition, pointer, info, compilationId) {\n    let compiler = info.currentContext.compiler;\n    let dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n    return yield* decode_1.default(dataType, pointer, info); //no need to pass an offset\n}\nexports.decodeVariable = decodeVariable;\n/**\n * @Category Decoding\n */\nfunction* decodeCalldata(info, isConstructor //ignored if context! trust context instead if have\n) {\n    const context = info.currentContext;\n    if (context === null) {\n        //if we don't know the contract ID, we can't decode\n        if (isConstructor) {\n            return {\n                kind: \"create\",\n                decodingMode: \"full\",\n                bytecode: Conversion.toHexString(info.state.calldata)\n            };\n        }\n        else {\n            return {\n                kind: \"unknown\",\n                decodingMode: \"full\",\n                data: Conversion.toHexString(info.state.calldata)\n            };\n        }\n    }\n    const compiler = context.compiler;\n    const contextHash = context.context;\n    const contractType = Contexts.Import.contextToType(context);\n    isConstructor = context.isConstructor;\n    const allocations = info.allocations.calldata;\n    let allocation;\n    let selector;\n    //first: is this a creation call?\n    if (isConstructor) {\n        allocation = allocations.constructorAllocations[contextHash].input;\n    }\n    else {\n        //skipping any error-handling on this read, as a calldata read can't throw anyway\n        let rawSelector = yield* read_1.default({\n            location: \"calldata\",\n            start: 0,\n            length: Evm.Utils.SELECTOR_SIZE\n        }, info.state);\n        selector = Conversion.toHexString(rawSelector);\n        allocation = (allocations.functionAllocations[contextHash][selector] || {\n            input: undefined\n        }).input;\n    }\n    if (allocation === undefined) {\n        let abiEntry = null;\n        if (info.state.calldata.length === 0) {\n            //to hell with reads, let's just be direct\n            abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;\n        }\n        else {\n            abiEntry = context.fallbackAbi.fallback;\n        }\n        return {\n            kind: \"message\",\n            class: contractType,\n            abi: abiEntry,\n            data: Conversion.toHexString(info.state.calldata),\n            decodingMode: \"full\"\n        };\n    }\n    let decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary\n    debug(\"calldata decoding mode: %s\", decodingMode);\n    //you can't map with a generator, so we have to do this map manually\n    let decodedArguments = [];\n    for (const argumentAllocation of allocation.arguments) {\n        let value;\n        let dataType = decodingMode === \"full\"\n            ? argumentAllocation.type\n            : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n        try {\n            value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n                abiPointerBase: allocation.offset,\n                allowRetry: decodingMode === \"full\"\n            });\n        }\n        catch (error) {\n            if (error instanceof errors_1.StopDecodingError &&\n                error.allowRetry &&\n                decodingMode === \"full\") {\n                debug(\"problem! retrying as ABI\");\n                debug(\"error: %O\", error);\n                //if a retry happens, we've got to do several things in order to switch to ABI mode:\n                //1. mark that we're switching to ABI mode;\n                decodingMode = \"abi\";\n                //2. abify all previously decoded values;\n                decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes) })));\n                //3. retry this particular decode in ABI mode.\n                //(no try/catch on this one because we can't actually handle errors here!\n                //not that they should be occurring)\n                value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n                argumentAllocation.pointer, info, {\n                    abiPointerBase: allocation.offset\n                });\n                //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n                //so we don't need to do anything special there.\n            }\n            else {\n                //we shouldn't be getting other exceptions, but if we do, we don't know\n                //how to handle them, so uhhhh just rethrow I guess??\n                throw error;\n            }\n        }\n        const name = argumentAllocation.name;\n        decodedArguments.push(name //deliberate general falsiness test\n            ? { name, value }\n            : { value });\n    }\n    if (isConstructor) {\n        return {\n            kind: \"constructor\",\n            class: contractType,\n            arguments: decodedArguments,\n            abi: allocation.abi,\n            bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),\n            decodingMode\n        };\n    }\n    else {\n        return {\n            kind: \"function\",\n            class: contractType,\n            abi: allocation.abi,\n            arguments: decodedArguments,\n            selector,\n            decodingMode\n        };\n    }\n}\nexports.decodeCalldata = decodeCalldata;\n//note: this will likely change in the future to take options rather than targetName, but I'm\n//leaving it alone for now, as I'm not sure what form those options will take\n//(and this is something we're a bit more OK with breaking since it's primarily\n//for internal use :) )\n/**\n * @Category Decoding\n */\nfunction* decodeEvent(info, address, targetName) {\n    const allocations = info.allocations.event;\n    let rawSelector;\n    let selector;\n    let contractAllocations; //for non-anonymous events\n    let libraryAllocations; //similar\n    let contractAnonymousAllocations;\n    let libraryAnonymousAllocations;\n    const topicsCount = info.state.eventtopics.length;\n    //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?\n    if (allocations[topicsCount]) {\n        if (topicsCount > 0) {\n            rawSelector = yield* read_1.default({\n                location: \"eventtopic\",\n                topic: 0\n            }, info.state);\n            selector = Conversion.toHexString(rawSelector);\n            if (allocations[topicsCount].bySelector[selector]) {\n                ({\n                    contract: contractAllocations,\n                    library: libraryAllocations\n                } = allocations[topicsCount].bySelector[selector]);\n            }\n            else {\n                debug(\"no allocations for that selector!\");\n                contractAllocations = {};\n                libraryAllocations = {};\n            }\n        }\n        else {\n            //if we don't have a selector, it means we don't have any non-anonymous events\n            contractAllocations = {};\n            libraryAllocations = {};\n        }\n        //now: let's get our allocations for anonymous events\n        ({\n            contract: contractAnonymousAllocations,\n            library: libraryAnonymousAllocations\n        } = allocations[topicsCount].anonymous);\n    }\n    else {\n        //if there's not even an allocation for the topics count, we can't\n        //decode; we could do this the honest way of setting all four allocation\n        //objects to {}, but let's just short circuit\n        debug(\"no allocations for that topic count!\");\n        return [];\n    }\n    //now: what contract are we (probably) dealing with? let's get its code to find out\n    const codeBytes = yield {\n        type: \"code\",\n        address\n    };\n    const codeAsHex = Conversion.toHexString(codeBytes);\n    const contractContext = Contexts.Utils.findDecoderContext(info.contexts, codeAsHex);\n    let possibleContractAllocations; //excludes anonymous events\n    let possibleContractAnonymousAllocations;\n    if (contractContext) {\n        //if we found the contract, maybe it's from that contract\n        const contextHash = contractContext.context;\n        const contractAllocation = contractAllocations[contextHash];\n        const contractAnonymousAllocation = contractAnonymousAllocations[contextHash];\n        possibleContractAllocations = contractAllocation || [];\n        possibleContractAnonymousAllocations = contractAnonymousAllocation || [];\n    }\n    else {\n        //if we couldn't determine the contract, well, we have to assume it's from a library\n        debug(\"couldn't find context\");\n        possibleContractAllocations = [];\n        possibleContractAnonymousAllocations = [];\n    }\n    //now we get all the library allocations!\n    const possibleLibraryAllocations = [].concat(...Object.values(libraryAllocations));\n    const possibleLibraryAnonymousAllocations = [].concat(...Object.values(libraryAnonymousAllocations));\n    //now we put it all together!\n    const possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);\n    const possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);\n    const possibleAllocationsTotal = possibleAllocations.concat(possibleAnonymousAllocations);\n    let decodings = [];\n    allocationAttempts: for (const allocation of possibleAllocationsTotal) {\n        //first: do a name check so we can skip decoding if name is wrong\n        debug(\"trying allocation: %O\", allocation);\n        if (targetName !== undefined && allocation.abi.name !== targetName) {\n            continue;\n        }\n        let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n        const contextHash = allocation.contextHash;\n        const attemptContext = info.contexts[contextHash];\n        const emittingContractType = Contexts.Import.contextToType(attemptContext);\n        const contractType = allocation.definedIn;\n        //you can't map with a generator, so we have to do this map manually\n        let decodedArguments = [];\n        for (const argumentAllocation of allocation.arguments) {\n            let value;\n            //if in full mode, use the allocation's listed data type.\n            //if in ABI mode, abify it before use.\n            let dataType = decodingMode === \"full\"\n                ? argumentAllocation.type\n                : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n            try {\n                value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n                    strictAbiMode: true,\n                    allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n                });\n            }\n            catch (error) {\n                if (error instanceof errors_1.StopDecodingError &&\n                    error.allowRetry &&\n                    decodingMode === \"full\") {\n                    //if a retry happens, we've got to do several things in order to switch to ABI mode:\n                    //1. mark that we're switching to ABI mode;\n                    decodingMode = \"abi\";\n                    //2. abify all previously decoded values;\n                    decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes) })));\n                    //3. retry this particular decode in ABI mode.\n                    try {\n                        value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n                        argumentAllocation.pointer, info, {\n                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n                            //retries no longer allowed, not that this has an effect\n                        });\n                    }\n                    catch (_) {\n                        //if an error occurred on the retry, this isn't a valid decoding!\n                        debug(\"rejected due to exception on retry\");\n                        continue allocationAttempts;\n                    }\n                    //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n                    //so we don't need to do anything special there.\n                }\n                else {\n                    //if any other sort of error occurred, this isn't a valid decoding!\n                    debug(\"rejected due to exception on first try: %O\", error);\n                    continue allocationAttempts;\n                }\n            }\n            const name = argumentAllocation.name;\n            const indexed = argumentAllocation.pointer.location === \"eventtopic\";\n            decodedArguments.push(name //deliberate general falsiness test\n                ? { name, indexed, value }\n                : { indexed, value });\n        }\n        //OK, so, having decoded the result, the question is: does it reencode to the original?\n        //first, we have to filter out the indexed arguments, and also get rid of the name information\n        const nonIndexedValues = decodedArguments\n            .filter(argument => !argument.indexed)\n            .map(argument => argument.value);\n        //now, we can encode!\n        const reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);\n        const encodedData = info.state.eventdata; //again, not great to read this directly, but oh well\n        //are they equal?\n        if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n            //if not, this allocation doesn't work\n            debug(\"rejected due to [non-indexed] mismatch\");\n            continue;\n        }\n        //one last check -- let's check that the indexed arguments match up, too\n        const indexedValues = decodedArguments\n            .filter(argument => argument.indexed)\n            .map(argument => argument.value);\n        const reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);\n        const encodedTopics = info.state.eventtopics;\n        //now: do *these* match?\n        const selectorAdjustment = allocation.anonymous ? 0 : 1;\n        for (let i = 0; i < reEncodedTopics.length; i++) {\n            if (!Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {\n                debug(\"rejected due to indexed mismatch\");\n                continue allocationAttempts;\n            }\n        }\n        //if we've made it here, the allocation works!  hooray!\n        debug(\"allocation accepted!\");\n        if (allocation.abi.anonymous) {\n            decodings.push({\n                kind: \"anonymous\",\n                definedIn: contractType,\n                class: emittingContractType,\n                abi: allocation.abi,\n                arguments: decodedArguments,\n                decodingMode\n            });\n        }\n        else {\n            decodings.push({\n                kind: \"event\",\n                definedIn: contractType,\n                class: emittingContractType,\n                abi: allocation.abi,\n                arguments: decodedArguments,\n                selector,\n                decodingMode\n            });\n        }\n    }\n    return decodings;\n}\nexports.decodeEvent = decodeEvent;\nconst errorSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n    type: \"string\",\n    value: \"Error(string)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst defaultReturnAllocations = [\n    {\n        kind: \"revert\",\n        allocationMode: \"full\",\n        selector: errorSelector,\n        arguments: [\n            {\n                name: \"\",\n                pointer: {\n                    location: \"returndata\",\n                    start: errorSelector.length,\n                    length: Evm.Utils.WORD_SIZE\n                },\n                type: {\n                    typeClass: \"string\",\n                    typeHint: \"string\"\n                }\n            }\n        ]\n    },\n    {\n        kind: \"failure\",\n        allocationMode: \"full\",\n        selector: new Uint8Array(),\n        arguments: []\n    },\n    {\n        kind: \"selfdestruct\",\n        allocationMode: \"full\",\n        selector: new Uint8Array(),\n        arguments: []\n    }\n];\n/**\n * If there are multiple possibilities, they're always returned in\n * the order: return, revert, failure, empty, bytecode, unknownbytecode\n * @Category Decoding\n */\nfunction* decodeReturndata(info, successAllocation, //null here must be explicit\nstatus //you can pass this to indicate that you know the status\n) {\n    let possibleAllocations;\n    if (successAllocation === null) {\n        possibleAllocations = defaultReturnAllocations;\n    }\n    else {\n        switch (successAllocation.kind) {\n            case \"return\":\n                possibleAllocations = [successAllocation, ...defaultReturnAllocations];\n                break;\n            case \"bytecode\":\n                possibleAllocations = [...defaultReturnAllocations, successAllocation];\n                break;\n            //Other cases shouldn't happen so I'm leaving them to cause errors!\n        }\n    }\n    let decodings = [];\n    allocationAttempts: for (const allocation of possibleAllocations) {\n        debug(\"trying allocation: %O\", allocation);\n        //before we attempt to use this allocation, we check: does the selector match?\n        let encodedData = info.state.returndata; //again, not great to read this directly, but oh well\n        const encodedPrefix = encodedData.subarray(0, allocation.selector.length);\n        if (!Evm.Utils.equalData(encodedPrefix, allocation.selector)) {\n            continue;\n        }\n        encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later\n        //also we check, does the status match?\n        if (status !== undefined) {\n            const successKinds = [\"return\", \"selfdestruct\", \"bytecode\"];\n            const failKinds = [\"failure\", \"revert\"];\n            if (status) {\n                if (!successKinds.includes(allocation.kind)) {\n                    continue;\n                }\n            }\n            else {\n                if (!failKinds.includes(allocation.kind)) {\n                    continue;\n                }\n            }\n        }\n        if (allocation.kind === \"bytecode\") {\n            //bytecode is special and can't really be integrated with the other cases.\n            //so it gets its own function.\n            const decoding = yield* decodeBytecode(info);\n            if (decoding) {\n                decodings.push(decoding);\n            }\n            continue;\n        }\n        let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n        //you can't map with a generator, so we have to do this map manually\n        let decodedArguments = [];\n        for (const argumentAllocation of allocation.arguments) {\n            let value;\n            //if in full mode, use the allocation's listed data type.\n            //if in ABI mode, abify it before use.\n            let dataType = decodingMode === \"full\"\n                ? argumentAllocation.type\n                : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n            //now, let's decode!\n            try {\n                value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n                    abiPointerBase: allocation.selector.length,\n                    strictAbiMode: true,\n                    allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n                });\n                debug(\"value on first try: %O\", value);\n            }\n            catch (error) {\n                if (error instanceof errors_1.StopDecodingError &&\n                    error.allowRetry &&\n                    decodingMode === \"full\") {\n                    debug(\"retry!\");\n                    //if a retry happens, we've got to do several things in order to switch to ABI mode:\n                    //1. mark that we're switching to ABI mode;\n                    decodingMode = \"abi\";\n                    //2. abify all previously decoded values;\n                    decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes) })));\n                    //3. retry this particular decode in ABI mode.\n                    try {\n                        value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n                        argumentAllocation.pointer, info, {\n                            abiPointerBase: allocation.selector.length,\n                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n                            //retries no longer allowed, not that this has an effect\n                        });\n                        debug(\"value on retry: %O\", value);\n                    }\n                    catch (_) {\n                        //if an error occurred on the retry, this isn't a valid decoding!\n                        debug(\"rejected due to exception on retry\");\n                        continue allocationAttempts;\n                    }\n                    //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n                    //so we don't need to do anything special there.\n                }\n                else {\n                    //if any other sort of error occurred, this isn't a valid decoding!\n                    debug(\"rejected due to exception on first try: %O\", error);\n                    continue allocationAttempts;\n                }\n            }\n            const name = argumentAllocation.name;\n            decodedArguments.push(name //deliberate general falsiness test\n                ? { name, value }\n                : { value });\n        }\n        //OK, so, having decoded the result, the question is: does it reencode to the original?\n        //first, we have to filter out the indexed arguments, and also get rid of the name information\n        debug(\"decodedArguments: %O\", decodedArguments);\n        const decodedArgumentValues = decodedArguments.map(argument => argument.value);\n        const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi);\n        //are they equal? note the selector has been stripped off encodedData!\n        if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n            //if not, this allocation doesn't work\n            debug(\"rejected due to mismatch\");\n            continue;\n        }\n        //if we've made it here, the allocation works!  hooray!\n        debug(\"allocation accepted!\");\n        let decoding;\n        let kind = allocation.kind;\n        switch (kind) {\n            case \"return\":\n                decoding = {\n                    kind,\n                    status: true,\n                    arguments: decodedArguments,\n                    decodingMode\n                };\n                break;\n            case \"revert\":\n                decoding = {\n                    kind,\n                    status: false,\n                    arguments: decodedArguments,\n                    decodingMode\n                };\n                break;\n            case \"selfdestruct\":\n                decoding = {\n                    kind,\n                    status: true,\n                    decodingMode\n                };\n                break;\n            case \"failure\":\n                decoding = {\n                    kind,\n                    status: false,\n                    decodingMode\n                };\n                break;\n        }\n        decodings.push(decoding);\n    }\n    return decodings;\n}\nexports.decodeReturndata = decodeReturndata;\n//note: requires the bytecode to be in returndata, not code\nfunction* decodeBytecode(info) {\n    let decodingMode = \"full\"; //as always, degrade as necessary\n    const bytecode = Conversion.toHexString(info.state.returndata);\n    const context = Contexts.Utils.findDecoderContext(info.contexts, bytecode);\n    if (!context) {\n        return {\n            kind: \"unknownbytecode\",\n            status: true,\n            decodingMode: \"full\",\n            bytecode\n        };\n    }\n    const contractType = Contexts.Import.contextToType(context);\n    //now: ignore original allocation (which we didn't even pass :) )\n    //and lookup allocation by context\n    const allocation = (info.allocations.calldata.constructorAllocations[context.context].output);\n    debug(\"bytecode allocation: %O\", allocation);\n    //now: add immutables if applicable\n    let immutables;\n    if (allocation.immutables) {\n        immutables = [];\n        //NOTE: if we're in here, we can assume decodingMode === \"full\"\n        for (const variable of allocation.immutables) {\n            const dataType = variable.type; //we don't conditioning on decodingMode here because we know it\n            let value;\n            try {\n                value = yield* decode_1.default(dataType, variable.pointer, info, {\n                    allowRetry: true,\n                    strictAbiMode: true,\n                    paddingMode: \"zero\" //force zero-padding!\n                });\n            }\n            catch (error) {\n                if (error instanceof errors_1.StopDecodingError && error.allowRetry) {\n                    //we \"retry\" by... not bothering with immutables :P\n                    //(but we do set the mode to ABI)\n                    decodingMode = \"abi\";\n                    immutables = undefined;\n                    break;\n                }\n                else {\n                    //otherwise, this isn't a valid decoding I guess\n                    return null;\n                }\n            }\n            immutables.push({\n                name: variable.name,\n                class: variable.definedIn,\n                value\n            });\n        }\n    }\n    let decoding = {\n        kind: \"bytecode\",\n        status: true,\n        decodingMode,\n        bytecode,\n        immutables,\n        class: contractType\n    };\n    //finally: add address if applicable\n    if (allocation.delegatecallGuard) {\n        decoding.address = Web3Utils.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = \"0x73\".length\n        );\n    }\n    return decoding;\n}\n/**\n * Decodes the return data from a failed call.\n *\n * @param returndata The returned data, as a Uint8Array.\n * @return An array of possible decodings.  At the moment it's\n *   impossible for there to be more than one.  (If the call didn't actually\n *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)\n *\n *   Decodings can either be decodings of revert messages, or decodings\n *   indicating that there was no revert message.  If somehow both were to be\n *   possible, they'd go in that order, although as mentioned, there (at least\n *   currently) isn't any way for that to occur.\n * @Category Decoding convenience\n */\nfunction decodeRevert(returndata) {\n    //coercing because TS doesn't know it'll finish in one go\n    return decodeReturndata({\n        allocations: {},\n        state: {\n            storage: {},\n            returndata\n        }\n    }, null, false).next().value;\n}\nexports.decodeRevert = decodeRevert;\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"script"}