{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar OS = require(\"os\");\n\nvar debug = require(\"debug\")(\"debug-utils\");\n\nvar util = require(\"util\");\n\nvar Codec = require(\"@truffle/codec\");\n\nvar chromafi = require(\"@trufflesuite/chromafi\");\n\nvar hljsDefineSolidity = require(\"highlightjs-solidity\");\n\nhljsDefineSolidity(chromafi.hljs);\n\nvar chalk = require(\"chalk\");\n\nvar commandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  \"p\": \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  \"l\": \"print additional source context\",\n  \"h\": \"print this help\",\n  \"v\": \"print variables and values\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  \"b\": \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  \"B\": \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  \"c\": \"continue until breakpoint\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load new transaction\",\n  \"T\": \"unload transaction\",\n  \"s\": \"print stacktrace\"\n};\nvar shortCommandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction\",\n  \"p\": \"print state\",\n  \"l\": \"print context\",\n  \"h\": \"print help\",\n  \"v\": \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  \"b\": \"add breakpoint\",\n  \"B\": \"remove breakpoint\",\n  \"c\": \"continue\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load\",\n  \"T\": \"unload\",\n  \"s\": \"stacktrace\"\n};\nvar truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\nvar DEFAULT_TAB_WIDTH = 8;\nvar DebugUtils = {\n  truffleColors: truffleColors,\n  //make these externally available\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function isUsableCompilation(compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      return false;\n    } //check #2: are source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n\n\n    if (compilation.sources.includes(undefined)) {\n      return false;\n    } //check #3: are there any AST ID collisions?\n\n\n    var astIds = new Set();\n\n    var allIDsUnseenSoFar = function allIDsUnseenSoFar(node) {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    }; //now: walk each AST\n\n\n    return compilation.sources.every(function (source) {\n      return source ? allIDsUnseenSoFar(source.ast) : true;\n    });\n  },\n  formatStartMessage: function formatStartMessage(withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n  formatTransactionStartMessage: function formatTransactionStartMessage() {\n    return \"Gathering information about the transaction...\";\n  },\n  formatCommandDescription: function formatCommandDescription(commandId) {\n    return truffleColors.mint(\"(\".concat(commandId, \")\")) + \" \" + commandReference[commandId];\n  },\n  formatPrompt: function formatPrompt(network, txHash) {\n    return txHash !== undefined ? \"debug(\".concat(network, \":\").concat(txHash.substring(0, 10), \"...)> \") : \"debug(\".concat(network, \")> \");\n  },\n  formatAffectedInstances: function formatAffectedInstances(instances) {\n    var hasAllSource = true;\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(\"\".concat(chalk.bold(\"Warning:\"), \" The source code for one or more contracts could not be found.\"));\n    }\n\n    return lines.join(OS.EOL);\n  },\n  formatHelp: function formatHelp() {\n    var lastCommand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"n\";\n    var prefix = [\"Commands:\", truffleColors.mint(\"(enter)\") + \" last command entered (\" + shortCommandReference[lastCommand] + \")\"];\n    var commandSections = [[\"o\", \"i\", \"u\", \"n\"], [\"c\"], [\";\"], [\"p\"], [\"l\", \"s\", \"h\"], [\"q\", \"r\", \"t\", \"T\"], [\"b\"], [\"B\"], [\"+\", \"-\"], [\"?\"], [\"v\", \":\"]].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n    var suffix = [\"\"];\n    var lines = prefix.concat(commandSections).concat(suffix);\n    return lines.join(OS.EOL);\n  },\n  tabsToSpaces: function tabsToSpaces(inputLine) {\n    var tabLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TAB_WIDTH;\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    var line = \"\";\n    var counter = 0;\n\n    for (var i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        var remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n\n    return line;\n  },\n  formatLineNumberPrefix: function formatLineNumberPrefix(line, number, cols) {\n    var prefix = String(number).padStart(cols) + \": \";\n    return prefix + line;\n  },\n  formatLinePointer: function formatLinePointer(line, startCol, endCol, padding) {\n    var tabLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_TAB_WIDTH;\n    var prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    var output = \"\";\n    var counter = 0;\n\n    for (var i = 0; i < line.length; i++) {\n      var pointedAt = i >= startCol && i < endCol;\n      var additional = void 0;\n\n      if (line[i] === \"\\t\") {\n        var remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function formatRangeLines(source, range, uncolorizedSource) {\n    var contextBefore = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    var contextAfter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n    //note: beforeLines now includes the line itself\n\n    var beforeLines = source.slice(startIndex, range.start.line + 1).map(function (line, index) {\n      var number = startIndex + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var afterLines = source.slice(range.start.line + 1, endIndex + 1).map(function (line, index) {\n      var number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var pointerStart = range.start.column;\n    var pointerEnd;\n    var uncolorizedLine = uncolorizedSource[range.start.line]; // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat([DebugUtils.formatLinePointer( //the line-pointer formatter doesn't work right with colorized\n    //lines, so we pass in the uncolored version\n    uncolorizedLine, pointerStart, pointerEnd, prefixLength)], afterLines);\n    return allLines.join(OS.EOL);\n  },\n  formatBreakpointLocation: function formatBreakpointLocation(breakpoint, here, currentCompilationId, currentSourceId, sourceNames) {\n    var baseMessage;\n\n    if (breakpoint.node !== undefined) {\n      baseMessage = here ? \"this point in line \".concat(breakpoint.line + 1) : \"a point in line \".concat(breakpoint.line + 1); //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = \"line \".concat(breakpoint.line + 1);\n    }\n\n    if (breakpoint.compilationId !== currentCompilationId || breakpoint.sourceId !== currentSourceId) {\n      var sourceName = sourceNames[breakpoint.compilationId][breakpoint.sourceId];\n      return baseMessage + \" in \".concat(sourceName);\n    } else {\n      return baseMessage;\n    }\n  },\n  formatInstruction: function formatInstruction(traceIndex, traceLength, instruction) {\n    return \"(\" + traceIndex + \"/\" + traceLength + \") \" + truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"));\n  },\n  formatPC: function formatPC(pc) {\n    var hex = pc.toString(16);\n\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n\n    return \"  PC = \" + pc.toString() + \" = 0x\" + hex;\n  },\n  formatStack: function formatStack(stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map(function (item, index) {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += \" (\".concat(stack.length - index - 1, \" from top)\");\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatMemory: function formatMemory(memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    var maxPrefixLength = Math.max(2, ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    var formatted = memory.map(function (word, index) {\n      var address = (index * Codec.Evm.Utils.WORD_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      return \"  0x\".concat(address, \":  \").concat(truffleColors.pink(word));\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatStorage: function formatStorage(storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    var slots = Object.keys(storage).slice().sort();\n    var formatted = slots.map(function (slot, index) {\n      if (index === 0 || !Codec.Conversion.toBN(slot).eq(Codec.Conversion.toBN(slots[index - 1]).addn(1))) {\n        return \"0x\".concat(slot, \":\\n\") + \"  \".concat(truffleColors.blue(storage[slot]));\n      } else {\n        return \"  \".concat(truffleColors.blue(storage[slot]));\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatCalldata: function formatCalldata(calldata) {\n    //takes a Uint8Array\n    var selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    var words = [];\n\n    for (var wordIndex = Codec.Evm.Utils.SELECTOR_SIZE; wordIndex < calldata.length; wordIndex += Codec.Evm.Utils.WORD_SIZE) {\n      words.push(calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE));\n    }\n\n    var maxWordIndex = (words.length - 1) * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE;\n    var maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n\n    var formattedSelector;\n\n    if (selector.length > 0) {\n      formattedSelector = \"Calldata:\\n\" + \"  0x\".concat(\"00\".padStart(maxPrefixLength, \"0\"), \":  \") + truffleColors.pink(Codec.Conversion.toHexString(selector).slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \"));\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    var formatted = words.map(function (word, index) {\n      var address = (index * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      var data = Codec.Conversion.toHexString(word).slice(2).padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return \"  0x\".concat(address, \":  \").concat(truffleColors.pink(data));\n    });\n    formatted.unshift(formattedSelector);\n    return formatted.join(OS.EOL);\n  },\n  formatValue: function formatValue(value) {\n    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var nativized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    var valueToInspect = nativized ? value : new Codec.Format.Utils.Inspect.ResultInspector(value);\n    return util.inspect(valueToInspect, inspectOptions).split(/\\r?\\n/g).map(function (line, i) {\n      // don't indent first line\n      var padding = i > 0 ? Array(indent).join(\" \") : \"\";\n      return padding + line;\n    }).join(OS.EOL);\n  },\n  formatStacktrace: function formatStacktrace(stacktrace) {\n    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    //get message from stacktrace\n    var message = stacktrace[0].message; //we want to print inner to outer, so first, let's\n    //reverse\n\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n\n    var lines = stacktrace.map(function (_ref) {\n      var functionName = _ref.functionName,\n          contractName = _ref.contractName,\n          address = _ref.address,\n          location = _ref.location;\n      var name;\n\n      if (contractName && functionName) {\n        name = \"\".concat(contractName, \".\").concat(functionName);\n      } else if (contractName) {\n        name = contractName;\n      } else if (functionName) {\n        name = functionName;\n      } else {\n        name = \"unknown function\";\n      }\n\n      var locationString;\n\n      if (location) {\n        var sourcePath = location.source.sourcePath,\n            _location$sourceRange = location.sourceRange.lines.start,\n            line = _location$sourceRange.line,\n            column = _location$sourceRange.column;\n        locationString = sourcePath ? \"\".concat(sourcePath, \":\").concat(line + 1, \":\").concat(column + 1) //add 1 to account for 0-indexing\n        : \"unknown location\";\n      } else {\n        locationString = \"unknown location\";\n      }\n\n      var addressString = address !== undefined ? \"address \".concat(address) : \"unknown address\";\n      return \"at \".concat(name, \" [\").concat(addressString, \"] (\").concat(locationString, \")\");\n    });\n    var status = stacktrace[0].status;\n\n    if (status != undefined) {\n      lines.unshift(status ? message !== undefined ? \"Error: Improper return (caused message: \".concat(message, \")\") : \"Error: Improper return (may be an unexpected self-destruct)\" : message !== undefined ? \"Error: Revert (message: \".concat(message, \")\") : \"Error: Revert or exceptional halt\");\n    }\n\n    var indented = lines.map(function (line, index) {\n      return index === 0 ? line : \" \".repeat(indent) + line;\n    });\n    return indented.join(OS.EOL);\n  },\n  colorize: function colorize(code) {\n    var yul = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    //I'd put these outside the function\n    //but then it gives me errors, because\n    //you can't just define self-referential objects like that...\n    var trufflePalette = {\n      /* base (chromafi special, not hljs) */\n      \"base\": chalk,\n      \"lineNumbers\": chalk,\n      \"trailingSpace\": chalk,\n\n      /* classes hljs-solidity actually uses */\n      \"keyword\": truffleColors.mint,\n      \"number\": truffleColors.red,\n      \"string\": truffleColors.green,\n      \"params\": truffleColors.pink,\n      \"builtIn\": truffleColors.watermelon,\n      \"built_in\": truffleColors.watermelon,\n      //just to be sure\n      \"literal\": truffleColors.watermelon,\n      \"function\": truffleColors.orange,\n      \"title\": truffleColors.orange,\n      \"class\": truffleColors.orange,\n      \"comment\": truffleColors.comment,\n      \"doctag\": truffleColors.comment,\n\n      /* classes it might soon use! */\n      \"meta\": truffleColors.pink,\n      \"metaString\": truffleColors.green,\n      \"meta-string\": truffleColors.green,\n      //similar\n\n      /* classes it doesn't currently use but notionally could */\n      \"type\": truffleColors.orange,\n      \"symbol\": truffleColors.orange,\n      \"metaKeyword\": truffleColors.mint,\n      \"meta-keyword\": truffleColors.mint,\n      //again, to be sure\n\n      /* classes that don't make sense for Solidity */\n      \"regexp\": chalk,\n      //solidity does not have regexps\n      \"subst\": chalk,\n      //or string interpolation\n      \"name\": chalk,\n      //or s-expressions\n      \"builtInName\": chalk,\n      //or s-expressions, again\n      \"builtin-name\": chalk,\n      //just to be sure\n\n      /* classes for config, markup, CSS, templates, diffs (not programming) */\n      \"section\": chalk,\n      \"tag\": chalk,\n      \"attr\": chalk,\n      \"attribute\": chalk,\n      \"variable\": chalk,\n      \"bullet\": chalk,\n      \"code\": chalk,\n      \"emphasis\": chalk,\n      \"strong\": chalk,\n      \"formula\": chalk,\n      \"link\": chalk,\n      \"quote\": chalk,\n      \"selectorAttr\": chalk,\n      //lotta redundancy follows\n      \"selector-attr\": chalk,\n      \"selectorClass\": chalk,\n      \"selector-class\": chalk,\n      \"selectorId\": chalk,\n      \"selector-id\": chalk,\n      \"selectorPseudo\": chalk,\n      \"selector-pseudo\": chalk,\n      \"selectorTag\": chalk,\n      \"selector-tag\": chalk,\n      \"templateTag\": chalk,\n      \"template-tag\": chalk,\n      \"templateVariable\": chalk,\n      \"template-variable\": chalk,\n      \"addition\": chalk,\n      \"deletion\": chalk\n    };\n    var options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false,\n      //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false //NOTE: you might think you should pass highlight: true,\n      //but you'd be wrong!  I don't understand this either\n\n    };\n\n    if (!yul) {\n      //normal case: solidity\n      return chromafi(code, options);\n    } else {\n      //HACK: stick the code in an assembly block since we don't\n      //have a separate Yul language for HLJS at the moment,\n      //colorize it there, then extract it after colorization\n      var wrappedCode = \"assembly {\\n\" + code + \"\\n}\";\n      var colorizedWrapped = chromafi(wrappedCode, options);\n      var firstNewLine = colorizedWrapped.indexOf(\"\\n\");\n      var lastNewLine = colorizedWrapped.lastIndexOf(\"\\n\");\n      return colorizedWrapped.slice(firstNewLine + 1, lastNewLine);\n    }\n  },\n  //HACK\n  cleanThis: function cleanThis(variables, replacement) {\n    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(variables).map(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          variable = _ref3[0],\n          value = _ref3[1];\n\n      return variable === \"this\" ? _defineProperty({}, replacement, value) : _defineProperty({}, variable, value);\n    }))));\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: function () {\n    var _getTransactionSourcesBeforeStarting = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(bugger) {\n      var _ref6;\n\n      var sources, controller, source, compilationId, id, internal;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return bugger.reset();\n\n            case 2:\n              sources = {};\n              controller = bugger.selectors.controller;\n\n            case 4:\n              if (bugger.view(controller.current.trace.finished)) {\n                _context.next = 12;\n                break;\n              }\n\n              source = bugger.view(controller.current.location.source);\n              compilationId = source.compilationId, id = source.id, internal = source.internal; //stepInto should skip internal sources, but there still might be\n              //one at the end\n\n              if (!internal && compilationId !== undefined && id !== undefined) {\n                sources[compilationId] = _objectSpread(_objectSpread({}, sources[compilationId]), {}, _defineProperty({}, id, source));\n              }\n\n              _context.next = 10;\n              return bugger.stepInto();\n\n            case 10:\n              _context.next = 4;\n              break;\n\n            case 12:\n              _context.next = 14;\n              return bugger.reset();\n\n            case 14:\n              return _context.abrupt(\"return\", (_ref6 = []).concat.apply(_ref6, _toConsumableArray(Object.values(sources).map(Object.values))));\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function getTransactionSourcesBeforeStarting(_x) {\n      return _getTransactionSourcesBeforeStarting.apply(this, arguments);\n    }\n\n    return getTransactionSourcesBeforeStarting;\n  }()\n};\nmodule.exports = DebugUtils;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/@truffle/debug-utils/index.js"],"names":["OS","require","debug","util","Codec","chromafi","hljsDefineSolidity","hljs","chalk","commandReference","shortCommandReference","truffleColors","mint","hex","orange","pink","purple","green","red","yellow","blue","comment","hsl","watermelon","periwinkle","DEFAULT_TAB_WIDTH","DebugUtils","isUsableCompilation","compilation","unreliableSourceOrder","sources","includes","undefined","astIds","Set","allIDsUnseenSoFar","node","Array","isArray","every","id","has","add","Object","values","source","ast","formatStartMessage","withTransaction","formatTransactionStartMessage","formatCommandDescription","commandId","formatPrompt","network","txHash","substring","formatAffectedInstances","instances","hasAllSource","lines","keys","map","address","instance","contractName","length","push","bold","join","EOL","formatHelp","lastCommand","prefix","commandSections","shortcuts","suffix","concat","tabsToSpaces","inputLine","tabLength","line","counter","i","remaining","repeat","formatLineNumberPrefix","number","cols","String","padStart","formatLinePointer","startCol","endCol","padding","output","pointedAt","additional","replace","formatRangeLines","range","uncolorizedSource","contextBefore","contextAfter","startIndex","Math","max","start","endIndex","min","prefixLength","beforeLines","slice","index","afterLines","pointerStart","column","pointerEnd","uncolorizedLine","end","allLines","formatBreakpointLocation","breakpoint","here","currentCompilationId","currentSourceId","sourceNames","baseMessage","compilationId","sourceId","sourceName","formatInstruction","traceIndex","traceLength","instruction","name","pushData","formatPC","pc","toString","formatStack","stack","formatted","item","unshift","formatMemory","memory","maxPrefixLength","Evm","Utils","WORD_SIZE","word","formatStorage","storage","slots","sort","slot","Conversion","toBN","eq","addn","formatCalldata","calldata","selector","SELECTOR_SIZE","words","wordIndex","maxWordIndex","formattedSelector","toHexString","data","padEnd","formatValue","value","indent","nativized","inspectOptions","colors","depth","maxArrayLength","breakLength","valueToInspect","Format","Inspect","ResultInspector","inspect","split","formatStacktrace","stacktrace","message","reverse","functionName","location","locationString","sourcePath","sourceRange","addressString","status","indented","colorize","code","yul","trufflePalette","options","lang","lineNumbers","stripIndent","codePad","lineEndPad","wrappedCode","colorizedWrapped","firstNewLine","indexOf","lastNewLine","lastIndexOf","cleanThis","variables","replacement","assign","entries","variable","getTransactionSourcesBeforeStarting","bugger","reset","controller","selectors","view","current","trace","finished","internal","stepInto","module","exports"],"mappings":"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","sourcesContent":["var OS = require(\"os\");\nvar debug = require(\"debug\")(\"debug-utils\");\nvar util = require(\"util\");\nvar Codec = require(\"@truffle/codec\");\n\nvar chromafi = require(\"@trufflesuite/chromafi\");\nvar hljsDefineSolidity = require(\"highlightjs-solidity\");\nhljsDefineSolidity(chromafi.hljs);\nvar chalk = require(\"chalk\");\n\nconst commandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  \"p\": \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  \"l\": \"print additional source context\",\n  \"h\": \"print this help\",\n  \"v\": \"print variables and values\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  \"b\": \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  \"B\": \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  \"c\": \"continue until breakpoint\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load new transaction\",\n  \"T\": \"unload transaction\",\n  \"s\": \"print stacktrace\"\n};\n\nconst shortCommandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction\",\n  \"p\": \"print state\",\n  \"l\": \"print context\",\n  \"h\": \"print help\",\n  \"v\": \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  \"b\": \"add breakpoint\",\n  \"B\": \"remove breakpoint\",\n  \"c\": \"continue\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load\",\n  \"T\": \"unload\",\n  \"s\": \"stacktrace\"\n};\n\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\n\nconst DEFAULT_TAB_WIDTH = 8;\n\nvar DebugUtils = {\n  truffleColors, //make these externally available\n\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      return false;\n    }\n\n    //check #2: are source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n    if (compilation.sources.includes(undefined)) {\n      return false;\n    }\n\n    //check #3: are there any AST ID collisions?\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    };\n\n    //now: walk each AST\n    return compilation.sources.every(source =>\n      source ? allIDsUnseenSoFar(source.ast) : true\n    );\n  },\n\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n\n  formatCommandDescription: function (commandId) {\n    return (\n      truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId]\n    );\n  },\n\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined\n      ? `debug(${network}:${txHash.substring(0, 10)}...)> `\n      : `debug(${network})> `;\n  },\n\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(\n        `${chalk.bold(\n          \"Warning:\"\n        )} The source code for one or more contracts could not be found.`\n      );\n    }\n\n    return lines.join(OS.EOL);\n  },\n\n  formatHelp: function (lastCommand = \"n\") {\n    var prefix = [\n      \"Commands:\",\n      truffleColors.mint(\"(enter)\") +\n        \" last command entered (\" +\n        shortCommandReference[lastCommand] +\n        \")\"\n    ];\n\n    var commandSections = [\n      [\"o\", \"i\", \"u\", \"n\"],\n      [\"c\"],\n      [\";\"],\n      [\"p\"],\n      [\"l\", \"s\", \"h\"],\n      [\"q\", \"r\", \"t\", \"T\"],\n      [\"b\"],\n      [\"B\"],\n      [\"+\", \"-\"],\n      [\"?\"],\n      [\"v\", \":\"]\n    ].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n\n    var suffix = [\"\"];\n\n    var lines = prefix.concat(commandSections).concat(suffix);\n\n    return lines.join(OS.EOL);\n  },\n\n  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n    return line;\n  },\n\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n\n    return prefix + line;\n  },\n\n  formatLinePointer: function (\n    line,\n    startCol,\n    endCol,\n    padding,\n    tabLength = DEFAULT_TAB_WIDTH\n  ) {\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n\n      let additional;\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (\n    source,\n    range,\n    uncolorizedSource,\n    contextBefore = 2,\n    contextAfter = 0\n  ) {\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n\n    //note: beforeLines now includes the line itself\n    var beforeLines = source\n      .slice(startIndex, range.start.line + 1)\n      .map((line, index) => {\n        let number = startIndex + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n    var afterLines = source\n      .slice(range.start.line + 1, endIndex + 1)\n      .map((line, index) => {\n        let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n\n    var pointerStart = range.start.column;\n    var pointerEnd;\n\n    let uncolorizedLine = uncolorizedSource[range.start.line];\n\n    // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat(\n      [\n        DebugUtils.formatLinePointer(\n          //the line-pointer formatter doesn't work right with colorized\n          //lines, so we pass in the uncolored version\n          uncolorizedLine,\n          pointerStart,\n          pointerEnd,\n          prefixLength\n        )\n      ],\n      afterLines\n    );\n\n    return allLines.join(OS.EOL);\n  },\n\n  formatBreakpointLocation: function (\n    breakpoint,\n    here,\n    currentCompilationId,\n    currentSourceId,\n    sourceNames\n  ) {\n    let baseMessage;\n    if (breakpoint.node !== undefined) {\n      baseMessage = here\n        ? `this point in line ${breakpoint.line + 1}`\n        : `a point in line ${breakpoint.line + 1}`;\n      //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n    if (\n      breakpoint.compilationId !== currentCompilationId ||\n      breakpoint.sourceId !== currentSourceId\n    ) {\n      let sourceName =\n        sourceNames[breakpoint.compilationId][breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n\n  formatInstruction: function (traceIndex, traceLength, instruction) {\n    return (\n      \"(\" +\n      traceIndex +\n      \"/\" +\n      traceLength +\n      \") \" +\n      truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"))\n    );\n  },\n\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n    return \"  PC = \" + pc.toString() + \" = 0x\" + hex;\n  },\n\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(\n      2,\n      ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length\n    );\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE)\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n\n    let formatted = slots.map((slot, index) => {\n      if (\n        index === 0 ||\n        !Codec.Conversion.toBN(slot).eq(\n          Codec.Conversion.toBN(slots[index - 1]).addn(1)\n        )\n      ) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n    for (\n      let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE;\n      wordIndex < calldata.length;\n      wordIndex += Codec.Evm.Utils.WORD_SIZE\n    ) {\n      words.push(\n        calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE)\n      );\n    }\n    let maxWordIndex =\n      (words.length - 1) * Codec.Evm.Utils.WORD_SIZE +\n      Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n    let formattedSelector;\n    if (selector.length > 0) {\n      formattedSelector =\n        \"Calldata:\\n\" +\n        `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` +\n        truffleColors.pink(\n          Codec.Conversion.toHexString(selector)\n            .slice(2)\n            .padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \")\n        );\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (\n        index * Codec.Evm.Utils.WORD_SIZE +\n        Codec.Evm.Utils.SELECTOR_SIZE\n      )\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word)\n        .slice(2)\n        .padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n\n    formatted.unshift(formattedSelector);\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatValue: function (value, indent = 0, nativized = false) {\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized\n      ? value\n      : new Codec.Format.Utils.Inspect.ResultInspector(value);\n    return util\n      .inspect(valueToInspect, inspectOptions)\n      .split(/\\r?\\n/g)\n      .map((line, i) => {\n        // don't indent first line\n        const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n        return padding + line;\n      })\n      .join(OS.EOL);\n  },\n\n  formatStacktrace: function (stacktrace, indent = 2) {\n    //get message from stacktrace\n    const message = stacktrace[0].message;\n    //we want to print inner to outer, so first, let's\n    //reverse\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n    let lines = stacktrace.map(\n      ({ functionName, contractName, address, location }) => {\n        let name;\n        if (contractName && functionName) {\n          name = `${contractName}.${functionName}`;\n        } else if (contractName) {\n          name = contractName;\n        } else if (functionName) {\n          name = functionName;\n        } else {\n          name = \"unknown function\";\n        }\n        let locationString;\n        if (location) {\n          let {\n            source: { sourcePath },\n            sourceRange: {\n              lines: {\n                start: { line, column }\n              }\n            }\n          } = location;\n          locationString = sourcePath\n            ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n            : \"unknown location\";\n        } else {\n          locationString = \"unknown location\";\n        }\n        let addressString =\n          address !== undefined ? `address ${address}` : \"unknown address\";\n        return `at ${name} [${addressString}] (${locationString})`;\n      }\n    );\n    let status = stacktrace[0].status;\n    if (status != undefined) {\n      lines.unshift(\n        status\n          ? message !== undefined\n            ? `Error: Improper return (caused message: ${message})`\n            : \"Error: Improper return (may be an unexpected self-destruct)\"\n          : message !== undefined\n          ? `Error: Revert (message: ${message})`\n          : \"Error: Revert or exceptional halt\"\n      );\n    }\n    let indented = lines.map((line, index) =>\n      index === 0 ? line : \" \".repeat(indent) + line\n    );\n    return indented.join(OS.EOL);\n  },\n\n  colorize: function (code, yul = false) {\n    //I'd put these outside the function\n    //but then it gives me errors, because\n    //you can't just define self-referential objects like that...\n\n    const trufflePalette = {\n      /* base (chromafi special, not hljs) */\n      \"base\": chalk,\n      \"lineNumbers\": chalk,\n      \"trailingSpace\": chalk,\n      /* classes hljs-solidity actually uses */\n      \"keyword\": truffleColors.mint,\n      \"number\": truffleColors.red,\n      \"string\": truffleColors.green,\n      \"params\": truffleColors.pink,\n      \"builtIn\": truffleColors.watermelon,\n      \"built_in\": truffleColors.watermelon, //just to be sure\n      \"literal\": truffleColors.watermelon,\n      \"function\": truffleColors.orange,\n      \"title\": truffleColors.orange,\n      \"class\": truffleColors.orange,\n      \"comment\": truffleColors.comment,\n      \"doctag\": truffleColors.comment,\n      /* classes it might soon use! */\n      \"meta\": truffleColors.pink,\n      \"metaString\": truffleColors.green,\n      \"meta-string\": truffleColors.green, //similar\n      /* classes it doesn't currently use but notionally could */\n      \"type\": truffleColors.orange,\n      \"symbol\": truffleColors.orange,\n      \"metaKeyword\": truffleColors.mint,\n      \"meta-keyword\": truffleColors.mint, //again, to be sure\n      /* classes that don't make sense for Solidity */\n      \"regexp\": chalk, //solidity does not have regexps\n      \"subst\": chalk, //or string interpolation\n      \"name\": chalk, //or s-expressions\n      \"builtInName\": chalk, //or s-expressions, again\n      \"builtin-name\": chalk, //just to be sure\n      /* classes for config, markup, CSS, templates, diffs (not programming) */\n      \"section\": chalk,\n      \"tag\": chalk,\n      \"attr\": chalk,\n      \"attribute\": chalk,\n      \"variable\": chalk,\n      \"bullet\": chalk,\n      \"code\": chalk,\n      \"emphasis\": chalk,\n      \"strong\": chalk,\n      \"formula\": chalk,\n      \"link\": chalk,\n      \"quote\": chalk,\n      \"selectorAttr\": chalk, //lotta redundancy follows\n      \"selector-attr\": chalk,\n      \"selectorClass\": chalk,\n      \"selector-class\": chalk,\n      \"selectorId\": chalk,\n      \"selector-id\": chalk,\n      \"selectorPseudo\": chalk,\n      \"selector-pseudo\": chalk,\n      \"selectorTag\": chalk,\n      \"selector-tag\": chalk,\n      \"templateTag\": chalk,\n      \"template-tag\": chalk,\n      \"templateVariable\": chalk,\n      \"template-variable\": chalk,\n      \"addition\": chalk,\n      \"deletion\": chalk\n    };\n\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false, //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n      //NOTE: you might think you should pass highlight: true,\n      //but you'd be wrong!  I don't understand this either\n    };\n    if (!yul) {\n      //normal case: solidity\n      return chromafi(code, options);\n    } else {\n      //HACK: stick the code in an assembly block since we don't\n      //have a separate Yul language for HLJS at the moment,\n      //colorize it there, then extract it after colorization\n      const wrappedCode = \"assembly {\\n\" + code + \"\\n}\";\n      const colorizedWrapped = chromafi(wrappedCode, options);\n      const firstNewLine = colorizedWrapped.indexOf(\"\\n\");\n      const lastNewLine = colorizedWrapped.lastIndexOf(\"\\n\");\n      return colorizedWrapped.slice(firstNewLine + 1, lastNewLine);\n    }\n  },\n\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign(\n      {},\n      ...Object.entries(variables).map(([variable, value]) =>\n        variable === \"this\" ? { [replacement]: value } : { [variable]: value }\n      )\n    );\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const { controller } = bugger.selectors;\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const { compilationId, id, internal } = source;\n      //stepInto should skip internal sources, but there still might be\n      //one at the end\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = {\n          ...sources[compilationId],\n          [id]: source\n        };\n      }\n      await bugger.stepInto();\n    }\n    await bugger.reset();\n    //flatten sources before returning\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\n\nmodule.exports = DebugUtils;\n"]},"metadata":{},"sourceType":"script"}