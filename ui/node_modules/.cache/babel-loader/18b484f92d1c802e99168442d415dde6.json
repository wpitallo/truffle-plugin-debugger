{"ast":null,"code":"'use strict';\n\nvar each = require('foreach');\n\nmodule.exports = api;\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api(obj, pointer, value) {\n  // .set()\n  if (arguments.length === 3) {\n    return api.set(obj, pointer, value);\n  } // .get()\n\n\n  if (arguments.length === 2) {\n    return api.get(obj, pointer);\n  } // Return a partially applied function on `obj`.\n\n\n  var wrapped = api.bind(api, obj); // Support for oo style\n\n  for (var name in api) {\n    if (api.hasOwnProperty(name)) {\n      wrapped[name] = api[name].bind(wrapped, obj);\n    }\n  }\n\n  return wrapped;\n}\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\n\n\napi.get = function get(obj, pointer) {\n  var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n  for (var i = 0; i < refTokens.length; ++i) {\n    var tok = refTokens[i];\n\n    if (!(typeof obj == 'object' && tok in obj)) {\n      throw new Error('Invalid reference token: ' + tok);\n    }\n\n    obj = obj[tok];\n  }\n\n  return obj;\n};\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\n\n\napi.set = function set(obj, pointer, value) {\n  var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n  if (refTokens.length === 0) {\n    throw Error('Can not set the root object');\n  }\n\n  for (var i = 0; i < refTokens.length - 1; ++i) {\n    var tok = refTokens[i];\n\n    if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n      continue;\n    }\n\n    if (tok === '-' && Array.isArray(obj)) {\n      tok = obj.length;\n    }\n\n    nextTok = refTokens[i + 1];\n\n    if (!(tok in obj)) {\n      if (nextTok.match(/^(\\d+|-)$/)) {\n        obj[tok] = [];\n      } else {\n        obj[tok] = {};\n      }\n    }\n\n    obj = obj[tok];\n  }\n\n  if (nextTok === '-' && Array.isArray(obj)) {\n    nextTok = obj.length;\n  }\n\n  obj[nextTok] = value;\n  return this;\n};\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\n\n\napi.remove = function (obj, pointer) {\n  var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n  var finalToken = refTokens[refTokens.length - 1];\n\n  if (finalToken === undefined) {\n    throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n  }\n\n  var parent = api.get(obj, refTokens.slice(0, -1));\n\n  if (Array.isArray(parent)) {\n    var index = +finalToken;\n\n    if (finalToken === '' && isNaN(index)) {\n      throw new Error('Invalid array index: \"' + finalToken + '\"');\n    }\n\n    Array.prototype.splice.call(parent, index, 1);\n  } else {\n    delete parent[finalToken];\n  }\n};\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\n\n\napi.dict = function dict(obj, descend) {\n  var results = {};\n  api.walk(obj, function (value, pointer) {\n    results[pointer] = value;\n  }, descend);\n  return results;\n};\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\n\n\napi.walk = function walk(obj, iterator, descend) {\n  var refTokens = [];\n\n  descend = descend || function (value) {\n    var type = Object.prototype.toString.call(value);\n    return type === '[object Object]' || type === '[object Array]';\n  };\n\n  (function next(cur) {\n    each(cur, function (value, key) {\n      refTokens.push(String(key));\n\n      if (descend(value)) {\n        next(value);\n      } else {\n        iterator(value, api.compile(refTokens));\n      }\n\n      refTokens.pop();\n    });\n  })(obj);\n};\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\n\n\napi.has = function has(obj, pointer) {\n  try {\n    api.get(obj, pointer);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\n\n\napi.escape = function escape(str) {\n  return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\n\n\napi.unescape = function unescape(str) {\n  return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\n\n\napi.parse = function parse(pointer) {\n  if (pointer === '') {\n    return [];\n  }\n\n  if (pointer.charAt(0) !== '/') {\n    throw new Error('Invalid JSON pointer: ' + pointer);\n  }\n\n  return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\n\n\napi.compile = function compile(refTokens) {\n  if (refTokens.length === 0) {\n    return '';\n  }\n\n  return '/' + refTokens.map(api.escape).join('/');\n};","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/json-pointer/index.js"],"names":["each","require","module","exports","api","obj","pointer","value","arguments","length","set","get","wrapped","bind","name","hasOwnProperty","refTokens","Array","isArray","parse","i","tok","Error","nextTok","match","remove","finalToken","undefined","parent","slice","index","isNaN","prototype","splice","call","dict","descend","results","walk","iterator","type","Object","toString","next","cur","key","push","String","compile","pop","has","e","escape","str","replace","unescape","charAt","substring","split","map","join"],"mappings":"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","sourcesContent":["'use strict';\n\nvar each = require('foreach');\nmodule.exports = api;\n\n\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api (obj, pointer, value) {\n    // .set()\n    if (arguments.length === 3) {\n        return api.set(obj, pointer, value);\n    }\n    // .get()\n    if (arguments.length === 2) {\n        return api.get(obj, pointer);\n    }\n    // Return a partially applied function on `obj`.\n    var wrapped = api.bind(api, obj);\n\n    // Support for oo style\n    for (var name in api) {\n        if (api.hasOwnProperty(name)) {\n            wrapped[name] = api[name].bind(wrapped, obj);\n        }\n    }\n    return wrapped;\n}\n\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\napi.get = function get (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n    for (var i = 0; i < refTokens.length; ++i) {\n        var tok = refTokens[i];\n        if (!(typeof obj == 'object' && tok in obj)) {\n            throw new Error('Invalid reference token: ' + tok);\n        }\n        obj = obj[tok];\n    }\n    return obj;\n};\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\napi.set = function set (obj, pointer, value) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n    if (refTokens.length === 0) {\n      throw Error('Can not set the root object');\n    }\n\n    for (var i = 0; i < refTokens.length - 1; ++i) {\n        var tok = refTokens[i];\n        if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n            continue\n        }\n        if (tok === '-' && Array.isArray(obj)) {\n          tok = obj.length;\n        }\n        nextTok = refTokens[i + 1];\n\n        if (!(tok in obj)) {\n            if (nextTok.match(/^(\\d+|-)$/)) {\n                obj[tok] = [];\n            } else {\n                obj[tok] = {};\n            }\n        }\n        obj = obj[tok];\n    }\n    if (nextTok === '-' && Array.isArray(obj)) {\n      nextTok = obj.length;\n    }\n    obj[nextTok] = value;\n    return this;\n};\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\napi.remove = function (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n    var finalToken = refTokens[refTokens.length -1];\n    if (finalToken === undefined) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    var parent = api.get(obj, refTokens.slice(0, -1));\n    if (Array.isArray(parent)) {\n      var index = +finalToken;\n      if (finalToken === '' && isNaN(index)) {\n        throw new Error('Invalid array index: \"' + finalToken + '\"');\n      }\n\n      Array.prototype.splice.call(parent, index, 1);\n    } else {\n      delete parent[finalToken];\n    }\n};\n\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\napi.dict = function dict (obj, descend) {\n    var results = {};\n    api.walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n};\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\napi.walk = function walk (obj, iterator, descend) {\n    var refTokens = [];\n\n    descend = descend || function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Object]' || type === '[object Array]';\n    };\n\n    (function next (cur) {\n        each(cur, function (value, key) {\n            refTokens.push(String(key));\n            if (descend(value)) {\n                next(value);\n            } else {\n                iterator(value, api.compile(refTokens));\n            }\n            refTokens.pop();\n        });\n    }(obj));\n};\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\napi.has = function has (obj, pointer) {\n    try {\n        api.get(obj, pointer);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.escape = function escape (str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.unescape = function unescape (str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\napi.parse = function parse (pointer) {\n    if (pointer === '') { return []; }\n    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }\n    return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\napi.compile = function compile (refTokens) {\n    if (refTokens.length === 0) { return ''; }\n    return '/' + refTokens.map(api.escape).join('/');\n};\n"]},"metadata":{},"sourceType":"script"}