{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeMemory),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeMemoryReferenceByAddress);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:memory:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar allocate_1 = require(\"../allocate\");\n\nvar errors_1 = require(\"../../errors\");\n\nfunction decodeMemory(dataType, pointer, info) {\n  var options,\n      _args = arguments;\n  return _regeneratorRuntime.wrap(function decodeMemory$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n\n          if (!Format.Types.isReferenceType(dataType)) {\n            _context.next = 10;\n            break;\n          }\n\n          if (!allocate_1.isSkippedInMemoryStructs(dataType)) {\n            _context.next = 6;\n            break;\n          }\n\n          return _context.abrupt(\"return\", decodeMemorySkippedType(dataType));\n\n        case 6:\n          return _context.delegateYield(decodeMemoryReferenceByAddress(dataType, pointer, info, options), \"t0\", 7);\n\n        case 7:\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 8:\n          _context.next = 12;\n          break;\n\n        case 10:\n          return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, options), \"t1\", 11);\n\n        case 11:\n          return _context.abrupt(\"return\", _context.t1);\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.decodeMemory = decodeMemory;\n\nfunction decodeMemorySkippedType(dataType) {\n  switch (dataType.typeClass) {\n    case \"mapping\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n\n    case \"array\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n    //other cases should not arise!\n  }\n}\n\nfunction decodeMemoryReferenceByAddress(dataType, pointer, info) {\n  var options,\n      state,\n      memoryVisited,\n      rawValue,\n      startPositionAsBN,\n      startPosition,\n      objectPosition,\n      rawLength,\n      lengthAsBN,\n      length,\n      seenPreviously,\n      childPointer,\n      memoryNowVisited,\n      baseType,\n      decodedChildren,\n      index,\n      allocations,\n      typeId,\n      structAllocation,\n      _memoryNowVisited,\n      decodedMembers,\n      _index,\n      memberAllocation,\n      memberPointer,\n      _childPointer,\n      memberName,\n      memberType,\n      _args2 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeMemoryReferenceByAddress$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};\n          state = info.state;\n          memoryVisited = options.memoryVisited || [];\n          debug(\"pointer %o\", pointer);\n          _context2.prev = 4;\n          return _context2.delegateYield(read_1.default(pointer, state), \"t0\", 6);\n\n        case 6:\n          rawValue = _context2.t0;\n          _context2.next = 12;\n          break;\n\n        case 9:\n          _context2.prev = 9;\n          _context2.t1 = _context2[\"catch\"](4);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t1));\n\n        case 12:\n          startPositionAsBN = Conversion.toBN(rawValue);\n          _context2.prev = 13;\n          startPosition = startPositionAsBN.toNumber();\n          _context2.next = 20;\n          break;\n\n        case 17:\n          _context2.prev = 17;\n          _context2.t2 = _context2[\"catch\"](13);\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlargePointersNotImplementedError\",\n              pointerAsBN: startPositionAsBN\n            }\n          });\n\n        case 20:\n          //startPosition may get modified later, so let's save the current\n          //value for circularity detection purposes\n          objectPosition = startPosition;\n          _context2.t3 = dataType.typeClass;\n          _context2.next = _context2.t3 === \"bytes\" ? 24 : _context2.t3 === \"string\" ? 24 : _context2.t3 === \"array\" ? 43 : _context2.t3 === \"struct\" ? 80 : 108;\n          break;\n\n        case 24:\n          _context2.prev = 24;\n          return _context2.delegateYield(read_1.default({\n            location: \"memory\",\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t4\", 26);\n\n        case 26:\n          rawLength = _context2.t4;\n          _context2.next = 32;\n          break;\n\n        case 29:\n          _context2.prev = 29;\n          _context2.t5 = _context2[\"catch\"](24);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t5));\n\n        case 32:\n          lengthAsBN = Conversion.toBN(rawLength);\n          _context2.prev = 33;\n          length = lengthAsBN.toNumber();\n          _context2.next = 40;\n          break;\n\n        case 37:\n          _context2.prev = 37;\n          _context2.t6 = _context2[\"catch\"](33);\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 40:\n          childPointer = {\n            location: \"memory\",\n            start: startPosition + Evm.Utils.WORD_SIZE,\n            length: length\n          };\n          return _context2.delegateYield(Bytes.Decode.decodeBytes(dataType, childPointer, info), \"t7\", 42);\n\n        case 42:\n          return _context2.abrupt(\"return\", _context2.t7);\n\n        case 43:\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n\n          if (!(seenPreviously !== -1)) {\n            _context2.next = 46;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          });\n\n        case 46:\n          if (!(dataType.kind === \"dynamic\")) {\n            _context2.next = 59;\n            break;\n          }\n\n          _context2.prev = 47;\n          return _context2.delegateYield(read_1.default({\n            location: \"memory\",\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t8\", 49);\n\n        case 49:\n          rawLength = _context2.t8;\n          _context2.next = 55;\n          break;\n\n        case 52:\n          _context2.prev = 52;\n          _context2.t9 = _context2[\"catch\"](47);\n          return _context2.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context2.t9));\n\n        case 55:\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n\n          _context2.next = 60;\n          break;\n\n        case 59:\n          lengthAsBN = dataType.length;\n\n        case 60:\n          _context2.prev = 60;\n          length = lengthAsBN.toNumber();\n          _context2.next = 67;\n          break;\n\n        case 64:\n          _context2.prev = 64;\n          _context2.t10 = _context2[\"catch\"](60);\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 67:\n          memoryNowVisited = [objectPosition].concat(_toConsumableArray(memoryVisited));\n          baseType = dataType.baseType;\n          decodedChildren = [];\n          index = 0;\n\n        case 71:\n          if (!(index < length)) {\n            _context2.next = 79;\n            break;\n          }\n\n          _context2.t11 = decodedChildren;\n          return _context2.delegateYield(decodeMemory(baseType, {\n            location: \"memory\",\n            start: startPosition + index * Evm.Utils.WORD_SIZE,\n            length: Evm.Utils.WORD_SIZE\n          }, info, {\n            memoryVisited: memoryNowVisited\n          }), \"t12\", 74);\n\n        case 74:\n          _context2.t13 = _context2.t12;\n\n          _context2.t11.push.call(_context2.t11, _context2.t13);\n\n        case 76:\n          index++;\n          _context2.next = 71;\n          break;\n\n        case 79:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 80:\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n\n          if (!(seenPreviously !== -1)) {\n            _context2.next = 83;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          });\n\n        case 83:\n          //otherwise, decode as normal\n          allocations = info.allocations.memory;\n          typeId = dataType.id;\n          structAllocation = allocations[typeId];\n\n          if (structAllocation) {\n            _context2.next = 88;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          });\n\n        case 88:\n          debug(\"structAllocation %O\", structAllocation);\n          _memoryNowVisited = [objectPosition].concat(_toConsumableArray(memoryVisited));\n          decodedMembers = [];\n          _index = 0;\n\n        case 92:\n          if (!(_index < structAllocation.members.length)) {\n            _context2.next = 107;\n            break;\n          }\n\n          memberAllocation = structAllocation.members[_index];\n          memberPointer = memberAllocation.pointer;\n          _childPointer = {\n            location: \"memory\",\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length //always equals WORD_SIZE or 0\n\n          };\n          memberName = memberAllocation.name;\n          memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n          _context2.t14 = decodedMembers;\n          _context2.t15 = memberName;\n          return _context2.delegateYield(decodeMemory(memberType, _childPointer, info, {\n            memoryVisited: _memoryNowVisited\n          }), \"t16\", 101);\n\n        case 101:\n          _context2.t17 = _context2.t16;\n          _context2.t18 = {\n            name: _context2.t15,\n            value: _context2.t17\n          };\n\n          _context2.t14.push.call(_context2.t14, _context2.t18);\n\n        case 104:\n          _index++;\n          _context2.next = 92;\n          break;\n\n        case 107:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 108:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[4, 9], [13, 17], [24, 29], [33, 37], [47, 52], [60, 64]]);\n}\n\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;","map":{"version":3,"sources":["../../../../lib/memory/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:memory:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst errors_1 = require(\"../../errors\");\nfunction* decodeMemory(dataType, pointer, info, options = {}) {\n    if (Format.Types.isReferenceType(dataType)) {\n        if (allocate_1.isSkippedInMemoryStructs(dataType)) {\n            //special case; these types are always empty in memory\n            return decodeMemorySkippedType(dataType);\n        }\n        else {\n            return yield* decodeMemoryReferenceByAddress(dataType, pointer, info, options);\n        }\n    }\n    else {\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n}\nexports.decodeMemory = decodeMemory;\nfunction decodeMemorySkippedType(dataType) {\n    switch (dataType.typeClass) {\n        case \"mapping\":\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: []\n            };\n        case \"array\":\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: []\n            };\n        //other cases should not arise!\n    }\n}\nfunction* decodeMemoryReferenceByAddress(dataType, pointer, info, options = {}) {\n    const { state } = info;\n    const memoryVisited = options.memoryVisited || [];\n    debug(\"pointer %o\", pointer);\n    let rawValue;\n    try {\n        rawValue = yield* read_1.default(pointer, state);\n    }\n    catch (error) {\n        return errors_1.handleDecodingError(dataType, error);\n    }\n    let startPositionAsBN = Conversion.toBN(rawValue);\n    let startPosition;\n    try {\n        startPosition = startPositionAsBN.toNumber();\n    }\n    catch (_a) {\n        return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n                kind: \"OverlargePointersNotImplementedError\",\n                pointerAsBN: startPositionAsBN\n            }\n        };\n    }\n    //startPosition may get modified later, so let's save the current\n    //value for circularity detection purposes\n    const objectPosition = startPosition;\n    let rawLength;\n    let lengthAsBN;\n    let length;\n    let seenPreviously;\n    switch (dataType.typeClass) {\n        case \"bytes\":\n        case \"string\":\n            //initial word contains length\n            try {\n                rawLength = yield* read_1.default({\n                    location: \"memory\",\n                    start: startPosition,\n                    length: Evm.Utils.WORD_SIZE\n                }, state);\n            }\n            catch (error) {\n                return errors_1.handleDecodingError(dataType, error);\n            }\n            lengthAsBN = Conversion.toBN(rawLength);\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_b) {\n                return {\n                    //again with the TS failures...\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            let childPointer = {\n                location: \"memory\",\n                start: startPosition + Evm.Utils.WORD_SIZE,\n                length\n            };\n            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info);\n        case \"array\": {\n            //first: circularity check!\n            seenPreviously = memoryVisited.indexOf(objectPosition);\n            if (seenPreviously !== -1) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    reference: seenPreviously + 1,\n                    value: [] //will be fixed later by the tie function\n                };\n            }\n            //otherwise, decode as normal\n            if (dataType.kind === \"dynamic\") {\n                //initial word contains array length\n                try {\n                    rawLength = yield* read_1.default({\n                        location: \"memory\",\n                        start: startPosition,\n                        length: Evm.Utils.WORD_SIZE\n                    }, state);\n                }\n                catch (error) {\n                    return errors_1.handleDecodingError(dataType, error);\n                }\n                lengthAsBN = Conversion.toBN(rawLength);\n                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n                //to next word, as first word was used for length\n            }\n            else {\n                lengthAsBN = dataType.length;\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_c) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            let memoryNowVisited = [objectPosition, ...memoryVisited];\n            let baseType = dataType.baseType;\n            let decodedChildren = [];\n            for (let index = 0; index < length; index++) {\n                decodedChildren.push(yield* decodeMemory(baseType, {\n                    location: \"memory\",\n                    start: startPosition + index * Evm.Utils.WORD_SIZE,\n                    length: Evm.Utils.WORD_SIZE\n                }, info, { memoryVisited: memoryNowVisited }));\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        }\n        case \"struct\": {\n            //first: circularity check!\n            seenPreviously = memoryVisited.indexOf(objectPosition);\n            if (seenPreviously !== -1) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    reference: seenPreviously + 1,\n                    value: [] //will be fixed later by the tie function\n                };\n            }\n            //otherwise, decode as normal\n            const { allocations: { memory: allocations } } = info;\n            const typeId = dataType.id;\n            const structAllocation = allocations[typeId];\n            if (!structAllocation) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"UserDefinedTypeNotFoundError\",\n                        type: dataType\n                    }\n                };\n            }\n            debug(\"structAllocation %O\", structAllocation);\n            let memoryNowVisited = [objectPosition, ...memoryVisited];\n            let decodedMembers = [];\n            for (let index = 0; index < structAllocation.members.length; index++) {\n                const memberAllocation = structAllocation.members[index];\n                const memberPointer = memberAllocation.pointer;\n                const childPointer = {\n                    location: \"memory\",\n                    start: startPosition + memberPointer.start,\n                    length: memberPointer.length //always equals WORD_SIZE or 0\n                };\n                let memberName = memberAllocation.name;\n                let memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n                decodedMembers.push({\n                    name: memberName,\n                    value: yield* decodeMemory(memberType, childPointer, info, {\n                        memoryVisited: memoryNowVisited\n                    })\n                });\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedMembers\n            };\n        }\n    }\n}\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}