{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.equalSlots = exports.slotAddress = exports.storageLengthToBytes = exports.isWordsLength = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:storage:utils\");\n\nvar Evm = __importStar(require(\"../evm\"));\n\nvar MappingKey = __importStar(require(\"../mapping-key\"));\n\nfunction isWordsLength(size) {\n  return size.words !== undefined;\n}\n\nexports.isWordsLength = isWordsLength;\n\nfunction storageLengthToBytes(size) {\n  if (isWordsLength(size)) {\n    debug(\"size.words %d\", size.words);\n    return size.words * Evm.Utils.WORD_SIZE;\n  } else {\n    return size.bytes;\n  }\n}\n\nexports.storageLengthToBytes = storageLengthToBytes;\n/**\n * convert a slot to a word corresponding to actual storage address\n *\n * if `slot` is an array, return hash of array values.\n * if `slot` array is nested, recurse on sub-arrays\n *\n * @param slot - number or possibly-nested array of numbers\n */\n\nfunction slotAddress(slot) {\n  if (slot.key !== undefined && slot.path !== undefined) {\n    // mapping reference\n    return Evm.Utils.keccak256(MappingKey.Encode.mappingKeyAsHex(slot.key), slotAddress(slot.path)).add(slot.offset);\n  } else if (slot.path !== undefined) {\n    var pathAddress = slotAddress(slot.path);\n    var path = slot.hashPath ? Evm.Utils.keccak256(pathAddress) : pathAddress;\n    return path.add(slot.offset);\n  } else {\n    return slot.offset;\n  }\n}\n\nexports.slotAddress = slotAddress; //note: this function compares slots mostly by structure,\n//rather than by their numerical value\n\nfunction equalSlots(slot1, slot2) {\n  if (!slot1 || !slot2) {\n    return !slot1 && !slot2; //if either is undefined, it's true only if both are\n  }\n\n  if (!slot1.offset.eq(slot2.offset)) {\n    return false;\n  }\n\n  if (slot1.hashPath !== slot2.hashPath) {\n    return false;\n  }\n\n  if (!equalSlots(slot1.path, slot2.path)) {\n    return false;\n  } //to compare keys, we'll just compare their hex encodings\n  //(yes, that leaves some wiggle room, as it could consider different\n  //*types* of keys to be equal, but if keys are the only difference then\n  //that should determine those types, so it shouldn't be a problem)\n\n\n  if (!slot1.key || !slot2.key) {\n    //first, though, they likely don't *have* keys\n    return !slot1.key && !slot2.key;\n  } //if they do have keys, though...\n\n\n  return Evm.Utils.equalData(MappingKey.Encode.encodeMappingKey(slot1.key), MappingKey.Encode.encodeMappingKey(slot2.key));\n}\n\nexports.equalSlots = equalSlots;","map":{"version":3,"sources":["../../../lib/storage/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.equalSlots = exports.slotAddress = exports.storageLengthToBytes = exports.isWordsLength = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:storage:utils\");\nconst Evm = __importStar(require(\"../evm\"));\nconst MappingKey = __importStar(require(\"../mapping-key\"));\nfunction isWordsLength(size) {\n    return size.words !== undefined;\n}\nexports.isWordsLength = isWordsLength;\nfunction storageLengthToBytes(size) {\n    if (isWordsLength(size)) {\n        debug(\"size.words %d\", size.words);\n        return size.words * Evm.Utils.WORD_SIZE;\n    }\n    else {\n        return size.bytes;\n    }\n}\nexports.storageLengthToBytes = storageLengthToBytes;\n/**\n * convert a slot to a word corresponding to actual storage address\n *\n * if `slot` is an array, return hash of array values.\n * if `slot` array is nested, recurse on sub-arrays\n *\n * @param slot - number or possibly-nested array of numbers\n */\nfunction slotAddress(slot) {\n    if (slot.key !== undefined && slot.path !== undefined) {\n        // mapping reference\n        return Evm.Utils.keccak256(MappingKey.Encode.mappingKeyAsHex(slot.key), slotAddress(slot.path)).add(slot.offset);\n    }\n    else if (slot.path !== undefined) {\n        const pathAddress = slotAddress(slot.path);\n        const path = slot.hashPath\n            ? Evm.Utils.keccak256(pathAddress)\n            : pathAddress;\n        return path.add(slot.offset);\n    }\n    else {\n        return slot.offset;\n    }\n}\nexports.slotAddress = slotAddress;\n//note: this function compares slots mostly by structure,\n//rather than by their numerical value\nfunction equalSlots(slot1, slot2) {\n    if (!slot1 || !slot2) {\n        return !slot1 && !slot2; //if either is undefined, it's true only if both are\n    }\n    if (!slot1.offset.eq(slot2.offset)) {\n        return false;\n    }\n    if (slot1.hashPath !== slot2.hashPath) {\n        return false;\n    }\n    if (!equalSlots(slot1.path, slot2.path)) {\n        return false;\n    }\n    //to compare keys, we'll just compare their hex encodings\n    //(yes, that leaves some wiggle room, as it could consider different\n    //*types* of keys to be equal, but if keys are the only difference then\n    //that should determine those types, so it shouldn't be a problem)\n    if (!slot1.key || !slot2.key) {\n        //first, though, they likely don't *have* keys\n        return !slot1.key && !slot2.key;\n    }\n    //if they do have keys, though...\n    return Evm.Utils.equalData(MappingKey.Encode.encodeMappingKey(slot1.key), MappingKey.Encode.encodeMappingKey(slot2.key));\n}\nexports.equalSlots = equalSlots;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}