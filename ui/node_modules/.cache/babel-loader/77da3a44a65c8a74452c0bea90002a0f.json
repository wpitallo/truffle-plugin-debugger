{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.message = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:format:utils:exception\");\n\nvar Format = __importStar(require(\"../common\"));\n\nvar Ast = __importStar(require(\"../../ast\")); //this function gives an error message\n//for those errors that are meant to possibly\n//be wrapped in a DecodingError and thrown\n\n\nfunction message(error) {\n  switch (error.kind) {\n    case \"UserDefinedTypeNotFoundError\":\n      var typeName = Format.Types.isContractDefinedType(error.type) ? error.type.definingContractName + \".\" + error.type.typeName : error.type.typeName;\n      return \"Unknown \".concat(error.type.typeClass, \" type \").concat(typeName, \" of id \").concat(error.type.id);\n\n    case \"UnsupportedConstantError\":\n      return \"Unsupported constant type \".concat(Ast.Utils.typeClass(error.definition));\n\n    case \"UnusedImmutableError\":\n      return \"Cannot read unused immutable\";\n\n    case \"ReadErrorStack\":\n      return \"Can't read stack from position \".concat(error.from, \" to \").concat(error.to);\n\n    case \"ReadErrorBytes\":\n      return \"Can't read \".concat(error.length, \" bytes from \").concat(error.location, \" starting at \").concat(error.start);\n\n    case \"ReadErrorStorage\":\n      if (error.range.length) {\n        return \"Can't read \".concat(error.range.length, \" bytes from storage starting at index \").concat(error.range.from.index, \" in \").concat(slotAddressPrintout(error.range.from.slot));\n      } else {\n        return \"Can't read storage from index \".concat(error.range.from.index, \" in \").concat(slotAddressPrintout(error.range.from.slot), \" to index \").concat(error.range.to.index, \" in \").concat(slotAddressPrintout(error.range.to.slot));\n      }\n\n  }\n}\n\nexports.message = message;\n\nfunction slotAddressPrintout(slot) {\n  if (slot.key !== undefined && slot.path !== undefined) {\n    // mapping reference\n    var _keyInfoForPrinting = keyInfoForPrinting(slot.key),\n        keyEncoding = _keyInfoForPrinting.type,\n        keyValue = _keyInfoForPrinting.value;\n\n    return \"keccak(\" + keyValue + \" as \" + keyEncoding + \", \" + slotAddressPrintout(slot.path) + \") + \" + slot.offset.toString();\n  } else if (slot.path !== undefined) {\n    var pathAddressPrintout = slotAddressPrintout(slot.path);\n    return slot.hashPath ? \"keccak(\" + pathAddressPrintout + \")\" + slot.offset.toString() : pathAddressPrintout + slot.offset.toString();\n  } else {\n    return slot.offset.toString();\n  }\n} //this is like the old toSoliditySha3Input, but for debugging purposes ONLY\n//it will NOT produce correct input to soliditySha3\n//please use mappingKeyAsHex instead if you wish to encode a mapping key.\n\n\nfunction keyInfoForPrinting(input) {\n  switch (input.type.typeClass) {\n    case \"uint\":\n      return {\n        type: \"uint\",\n        value: input.value.asBN.toString()\n      };\n\n    case \"int\":\n      return {\n        type: \"int\",\n        value: input.value.asBN.toString()\n      };\n\n    case \"fixed\":\n      return {\n        type: \"fixed256x\".concat(input.type.places),\n        value: input.value.asBig.toString()\n      };\n\n    case \"ufixed\":\n      return {\n        type: \"ufixed256x\".concat(input.type.places),\n        value: input.value.asBig.toString()\n      };\n\n    case \"bool\":\n      //this is the case that won't work as valid input to soliditySha3 :)\n      return {\n        type: \"uint\",\n        value: input.value.asBoolean.toString()\n      };\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return {\n            type: \"bytes32\",\n            value: input.value.asHex\n          };\n\n        case \"dynamic\":\n          return {\n            type: \"bytes\",\n            value: input.value.asHex\n          };\n      }\n\n    case \"address\":\n      return {\n        type: \"address\",\n        value: input.value.asAddress\n      };\n\n    case \"string\":\n      var coercedInput = input;\n\n      switch (coercedInput.value.kind) {\n        case \"valid\":\n          return {\n            type: \"string\",\n            value: coercedInput.value.asString\n          };\n\n        case \"malformed\":\n          return {\n            type: \"bytes\",\n            value: coercedInput.value.asHex\n          };\n      }\n\n    //fixed and ufixed are skipped for now\n  }\n}","map":{"version":3,"sources":["../../../../lib/format/utils/exception.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.message = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:format:utils:exception\");\nconst Format = __importStar(require(\"../common\"));\nconst Ast = __importStar(require(\"../../ast\"));\n//this function gives an error message\n//for those errors that are meant to possibly\n//be wrapped in a DecodingError and thrown\nfunction message(error) {\n    switch (error.kind) {\n        case \"UserDefinedTypeNotFoundError\":\n            let typeName = Format.Types.isContractDefinedType(error.type)\n                ? error.type.definingContractName + \".\" + error.type.typeName\n                : error.type.typeName;\n            return `Unknown ${error.type.typeClass} type ${typeName} of id ${error.type.id}`;\n        case \"UnsupportedConstantError\":\n            return `Unsupported constant type ${Ast.Utils.typeClass(error.definition)}`;\n        case \"UnusedImmutableError\":\n            return \"Cannot read unused immutable\";\n        case \"ReadErrorStack\":\n            return `Can't read stack from position ${error.from} to ${error.to}`;\n        case \"ReadErrorBytes\":\n            return `Can't read ${error.length} bytes from ${error.location} starting at ${error.start}`;\n        case \"ReadErrorStorage\":\n            if (error.range.length) {\n                return `Can't read ${error.range.length} bytes from storage starting at index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)}`;\n            }\n            else {\n                return `Can't read storage from index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)} to index ${error.range.to.index} in ${slotAddressPrintout(error.range.to.slot)}`;\n            }\n    }\n}\nexports.message = message;\nfunction slotAddressPrintout(slot) {\n    if (slot.key !== undefined && slot.path !== undefined) {\n        // mapping reference\n        let { type: keyEncoding, value: keyValue } = keyInfoForPrinting(slot.key);\n        return (\"keccak(\" +\n            keyValue +\n            \" as \" +\n            keyEncoding +\n            \", \" +\n            slotAddressPrintout(slot.path) +\n            \") + \" +\n            slot.offset.toString());\n    }\n    else if (slot.path !== undefined) {\n        const pathAddressPrintout = slotAddressPrintout(slot.path);\n        return slot.hashPath\n            ? \"keccak(\" + pathAddressPrintout + \")\" + slot.offset.toString()\n            : pathAddressPrintout + slot.offset.toString();\n    }\n    else {\n        return slot.offset.toString();\n    }\n}\n//this is like the old toSoliditySha3Input, but for debugging purposes ONLY\n//it will NOT produce correct input to soliditySha3\n//please use mappingKeyAsHex instead if you wish to encode a mapping key.\nfunction keyInfoForPrinting(input) {\n    switch (input.type.typeClass) {\n        case \"uint\":\n            return {\n                type: \"uint\",\n                value: input.value.asBN.toString()\n            };\n        case \"int\":\n            return {\n                type: \"int\",\n                value: input.value.asBN.toString()\n            };\n        case \"fixed\":\n            return {\n                type: `fixed256x${input.type.places}`,\n                value: input.value.asBig.toString()\n            };\n        case \"ufixed\":\n            return {\n                type: `ufixed256x${input.type.places}`,\n                value: input.value.asBig.toString()\n            };\n        case \"bool\":\n            //this is the case that won't work as valid input to soliditySha3 :)\n            return {\n                type: \"uint\",\n                value: input.value.asBoolean.toString()\n            };\n        case \"bytes\":\n            switch (input.type.kind) {\n                case \"static\":\n                    return {\n                        type: \"bytes32\",\n                        value: input.value.asHex\n                    };\n                case \"dynamic\":\n                    return {\n                        type: \"bytes\",\n                        value: input.value.asHex\n                    };\n            }\n        case \"address\":\n            return {\n                type: \"address\",\n                value: input.value.asAddress\n            };\n        case \"string\":\n            let coercedInput = (input);\n            switch (coercedInput.value.kind) {\n                case \"valid\":\n                    return {\n                        type: \"string\",\n                        value: coercedInput.value.asString\n                    };\n                case \"malformed\":\n                    return {\n                        type: \"bytes\",\n                        value: coercedInput.value.asHex\n                    };\n            }\n        //fixed and ufixed are skipped for now\n    }\n}\n//# sourceMappingURL=exception.js.map"]},"metadata":{},"sourceType":"script"}