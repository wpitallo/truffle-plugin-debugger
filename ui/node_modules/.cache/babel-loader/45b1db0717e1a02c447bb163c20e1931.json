{"ast":null,"code":"\"use strict\"; // An augmented AVL Tree where each node maintains a list of records and their search intervals.\n// Record is composed of an interval and its underlying data, sent by a client. This allows the\n// interval tree to have the same interval inserted multiple times, as long its data is different.\n// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`\n// is the number of intervals in the output list.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar isSame = require(\"shallowequal\");\n\nfunction height(node) {\n  if (node === undefined) {\n    return -1;\n  } else {\n    return node.height;\n  }\n}\n\nvar Node =\n/** @class */\nfunction () {\n  function Node(intervalTree, record) {\n    this.intervalTree = intervalTree;\n    this.records = [];\n    this.height = 0;\n    this.key = record.low;\n    this.max = record.high; // Save the array of all records with the same key for this node\n\n    this.records.push(record);\n  } // Gets the highest record.high value for this node\n\n\n  Node.prototype.getNodeHigh = function () {\n    var high = this.records[0].high;\n\n    for (var i = 1; i < this.records.length; i++) {\n      if (this.records[i].high > high) {\n        high = this.records[i].high;\n      }\n    }\n\n    return high;\n  }; // Updates height value of the node. Called during insertion, rebalance, removal\n\n\n  Node.prototype.updateHeight = function () {\n    this.height = Math.max(height(this.left), height(this.right)) + 1;\n  }; // Updates the max value of all the parents after inserting into already existing node, as well as\n  // removing the node completely or removing the record of an already existing node. Starts with\n  // the parent of an affected node and bubbles up to root\n\n\n  Node.prototype.updateMaxOfParents = function () {\n    if (this === undefined) {\n      return;\n    }\n\n    var thisHigh = this.getNodeHigh();\n\n    if (this.left !== undefined && this.right !== undefined) {\n      this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);\n    } else if (this.left !== undefined && this.right === undefined) {\n      this.max = Math.max(this.left.max, thisHigh);\n    } else if (this.left === undefined && this.right !== undefined) {\n      this.max = Math.max(this.right.max, thisHigh);\n    } else {\n      this.max = thisHigh;\n    }\n\n    if (this.parent) {\n      this.parent.updateMaxOfParents();\n    }\n  };\n  /*\r\n  Left-Left case:\r\n             z                                      y\r\n        / \\                                   /   \\\r\n       y   T4      Right Rotate (z)          x     z\r\n      / \\          - - - - - - - - ->       / \\   / \\\r\n     x   T3                                T1 T2 T3 T4\r\n    / \\\r\n  T1   T2\r\n      Left-Right case:\r\n           z                               z                           x\r\n      / \\                             / \\                        /   \\\r\n     y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z\r\n    / \\      - - - - - - - - ->     / \\      - - - - - - - ->  / \\   / \\\r\n  T1   x                           y  T3                      T1 T2 T3 T4\r\n      / \\                         / \\\r\n    T2   T3                      T1 T2\r\n  */\n  // Handles Left-Left case and Left-Right case after rebalancing AVL tree\n\n\n  Node.prototype._updateMaxAfterRightRotate = function () {\n    var parent = this.parent;\n    var left = parent.left; // Update max of left sibling (x in first case, y in second)\n\n    var thisParentLeftHigh = left.getNodeHigh();\n\n    if (left.left === undefined && left.right !== undefined) {\n      left.max = Math.max(thisParentLeftHigh, left.right.max);\n    } else if (left.left !== undefined && left.right === undefined) {\n      left.max = Math.max(thisParentLeftHigh, left.left.max);\n    } else if (left.left === undefined && left.right === undefined) {\n      left.max = thisParentLeftHigh;\n    } else {\n      left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);\n    } // Update max of itself (z)\n\n\n    var thisHigh = this.getNodeHigh();\n\n    if (this.left === undefined && this.right !== undefined) {\n      this.max = Math.max(thisHigh, this.right.max);\n    } else if (this.left !== undefined && this.right === undefined) {\n      this.max = Math.max(thisHigh, this.left.max);\n    } else if (this.left === undefined && this.right === undefined) {\n      this.max = thisHigh;\n    } else {\n      this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);\n    } // Update max of parent (y in first case, x in second)\n\n\n    parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());\n  };\n  /*\r\n  Right-Right case:\r\n        z                               y\r\n   / \\                            /   \\\r\n  T1  y     Left Rotate(z)       z     x\r\n     / \\   - - - - - - - ->     / \\   / \\\r\n    T2  x                      T1 T2 T3 T4\r\n       / \\\r\n      T3 T4\r\n      Right-Left case:\r\n         z                            z                            x\r\n    / \\                          / \\                         /   \\\r\n   T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y\r\n      / \\  - - - - - - - - ->      / \\   - - - - - - - ->  / \\   / \\\r\n     x  T4                        T2  y                   T1 T2 T3 T4\r\n    / \\                              / \\\r\n  T2   T3                           T3 T4\r\n  */\n  // Handles Right-Right case and Right-Left case in rebalancing AVL tree\n\n\n  Node.prototype._updateMaxAfterLeftRotate = function () {\n    var parent = this.parent;\n    var right = parent.right; // Update max of right sibling (x in first case, y in second)\n\n    var thisParentRightHigh = right.getNodeHigh();\n\n    if (right.left === undefined && right.right !== undefined) {\n      right.max = Math.max(thisParentRightHigh, right.right.max);\n    } else if (right.left !== undefined && right.right === undefined) {\n      right.max = Math.max(thisParentRightHigh, right.left.max);\n    } else if (right.left === undefined && right.right === undefined) {\n      right.max = thisParentRightHigh;\n    } else {\n      right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);\n    } // Update max of itself (z)\n\n\n    var thisHigh = this.getNodeHigh();\n\n    if (this.left === undefined && this.right !== undefined) {\n      this.max = Math.max(thisHigh, this.right.max);\n    } else if (this.left !== undefined && this.right === undefined) {\n      this.max = Math.max(thisHigh, this.left.max);\n    } else if (this.left === undefined && this.right === undefined) {\n      this.max = thisHigh;\n    } else {\n      this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);\n    } // Update max of parent (y in first case, x in second)\n\n\n    parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());\n  };\n\n  Node.prototype._leftRotate = function () {\n    var rightChild = this.right;\n    rightChild.parent = this.parent;\n\n    if (rightChild.parent === undefined) {\n      this.intervalTree.root = rightChild;\n    } else {\n      if (rightChild.parent.left === this) {\n        rightChild.parent.left = rightChild;\n      } else if (rightChild.parent.right === this) {\n        rightChild.parent.right = rightChild;\n      }\n    }\n\n    this.right = rightChild.left;\n\n    if (this.right !== undefined) {\n      this.right.parent = this;\n    }\n\n    rightChild.left = this;\n    this.parent = rightChild;\n    this.updateHeight();\n    rightChild.updateHeight();\n  };\n\n  Node.prototype._rightRotate = function () {\n    var leftChild = this.left;\n    leftChild.parent = this.parent;\n\n    if (leftChild.parent === undefined) {\n      this.intervalTree.root = leftChild;\n    } else {\n      if (leftChild.parent.left === this) {\n        leftChild.parent.left = leftChild;\n      } else if (leftChild.parent.right === this) {\n        leftChild.parent.right = leftChild;\n      }\n    }\n\n    this.left = leftChild.right;\n\n    if (this.left !== undefined) {\n      this.left.parent = this;\n    }\n\n    leftChild.right = this;\n    this.parent = leftChild;\n    this.updateHeight();\n    leftChild.updateHeight();\n  }; // Rebalances the tree if the height value between two nodes of the same parent is greater than\n  // two. There are 4 cases that can happen which are outlined in the graphics above\n\n\n  Node.prototype._rebalance = function () {\n    if (height(this.left) >= 2 + height(this.right)) {\n      var left = this.left;\n\n      if (height(left.left) >= height(left.right)) {\n        // Left-Left case\n        this._rightRotate();\n\n        this._updateMaxAfterRightRotate();\n      } else {\n        // Left-Right case\n        left._leftRotate();\n\n        this._rightRotate();\n\n        this._updateMaxAfterRightRotate();\n      }\n    } else if (height(this.right) >= 2 + height(this.left)) {\n      var right = this.right;\n\n      if (height(right.right) >= height(right.left)) {\n        // Right-Right case\n        this._leftRotate();\n\n        this._updateMaxAfterLeftRotate();\n      } else {\n        // Right-Left case\n        right._rightRotate();\n\n        this._leftRotate();\n\n        this._updateMaxAfterLeftRotate();\n      }\n    }\n  };\n\n  Node.prototype.insert = function (record) {\n    if (record.low < this.key) {\n      // Insert into left subtree\n      if (this.left === undefined) {\n        this.left = new Node(this.intervalTree, record);\n        this.left.parent = this;\n      } else {\n        this.left.insert(record);\n      }\n    } else {\n      // Insert into right subtree\n      if (this.right === undefined) {\n        this.right = new Node(this.intervalTree, record);\n        this.right.parent = this;\n      } else {\n        this.right.insert(record);\n      }\n    } // Update the max value of this ancestor if needed\n\n\n    if (this.max < record.high) {\n      this.max = record.high;\n    } // Update height of each node\n\n\n    this.updateHeight(); // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially\n    // important in searching, as the tree has a high chance of degenerating without the rebalancing\n\n    this._rebalance();\n  };\n\n  Node.prototype._getOverlappingRecords = function (currentNode, low, high) {\n    if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {\n      // Nodes are overlapping, check if individual records in the node are overlapping\n      var tempResults = [];\n\n      for (var i = 0; i < currentNode.records.length; i++) {\n        if (currentNode.records[i].high >= low) {\n          tempResults.push(currentNode.records[i]);\n        }\n      }\n\n      return tempResults;\n    }\n\n    return [];\n  };\n\n  Node.prototype.search = function (low, high) {\n    // Don't search nodes that don't exist\n    if (this === undefined) {\n      return [];\n    }\n\n    var leftSearch = [];\n    var ownSearch = [];\n    var rightSearch = []; // If interval is to the right of the rightmost point of any interval in this node and all its\n    // children, there won't be any matches\n\n    if (low > this.max) {\n      return [];\n    } // Search left children\n\n\n    if (this.left !== undefined && this.left.max >= low) {\n      leftSearch = this.left.search(low, high);\n    } // Check this node\n\n\n    ownSearch = this._getOverlappingRecords(this, low, high); // If interval is to the left of the start of this interval, then it can't be in any child to\n    // the right\n\n    if (high < this.key) {\n      return leftSearch.concat(ownSearch);\n    } // Otherwise, search right children\n\n\n    if (this.right !== undefined) {\n      rightSearch = this.right.search(low, high);\n    } // Return accumulated results, if any\n\n\n    return leftSearch.concat(ownSearch, rightSearch);\n  }; // Searches for a node by a `key` value\n\n\n  Node.prototype.searchExisting = function (low) {\n    if (this === undefined) {\n      return undefined;\n    }\n\n    if (this.key === low) {\n      return this;\n    } else if (low < this.key) {\n      if (this.left !== undefined) {\n        return this.left.searchExisting(low);\n      }\n    } else {\n      if (this.right !== undefined) {\n        return this.right.searchExisting(low);\n      }\n    }\n\n    return undefined;\n  }; // Returns the smallest node of the subtree\n\n\n  Node.prototype._minValue = function () {\n    if (this.left === undefined) {\n      return this;\n    } else {\n      return this.left._minValue();\n    }\n  };\n\n  Node.prototype.remove = function (node) {\n    var parent = this.parent;\n\n    if (node.key < this.key) {\n      // Node to be removed is on the left side\n      if (this.left !== undefined) {\n        return this.left.remove(node);\n      } else {\n        return undefined;\n      }\n    } else if (node.key > this.key) {\n      // Node to be removed is on the right side\n      if (this.right !== undefined) {\n        return this.right.remove(node);\n      } else {\n        return undefined;\n      }\n    } else {\n      if (this.left !== undefined && this.right !== undefined) {\n        // Node has two children\n        var minValue = this.right._minValue();\n\n        this.key = minValue.key;\n        this.records = minValue.records;\n        return this.right.remove(this);\n      } else if (parent.left === this) {\n        // One child or no child case on left side\n        if (this.right !== undefined) {\n          parent.left = this.right;\n          this.right.parent = parent;\n        } else {\n          parent.left = this.left;\n\n          if (this.left !== undefined) {\n            this.left.parent = parent;\n          }\n        }\n\n        parent.updateMaxOfParents();\n        parent.updateHeight();\n\n        parent._rebalance();\n\n        return this;\n      } else if (parent.right === this) {\n        // One child or no child case on right side\n        if (this.right !== undefined) {\n          parent.right = this.right;\n          this.right.parent = parent;\n        } else {\n          parent.right = this.left;\n\n          if (this.left !== undefined) {\n            this.left.parent = parent;\n          }\n        }\n\n        parent.updateMaxOfParents();\n        parent.updateHeight();\n\n        parent._rebalance();\n\n        return this;\n      }\n    }\n  };\n\n  return Node;\n}();\n\nexports.Node = Node;\n\nvar IntervalTree =\n/** @class */\nfunction () {\n  function IntervalTree() {\n    this.count = 0;\n  }\n\n  IntervalTree.prototype.insert = function (record) {\n    if (record.low > record.high) {\n      throw new Error('`low` value must be lower or equal to `high` value');\n    }\n\n    if (this.root === undefined) {\n      // Base case: Tree is empty, new node becomes root\n      this.root = new Node(this, record);\n      this.count++;\n      return true;\n    } else {\n      // Otherwise, check if node already exists with the same key\n      var node = this.root.searchExisting(record.low);\n\n      if (node !== undefined) {\n        // Check the records in this node if there already is the one with same low, high, data\n        for (var i = 0; i < node.records.length; i++) {\n          if (isSame(node.records[i], record)) {\n            // This record is same as the one we're trying to insert; return false to indicate\n            // nothing has been inserted\n            return false;\n          }\n        } // Add the record to the node\n\n\n        node.records.push(record); // Update max of the node and its parents if necessary\n\n        if (record.high > node.max) {\n          node.max = record.high;\n\n          if (node.parent) {\n            node.parent.updateMaxOfParents();\n          }\n        }\n\n        this.count++;\n        return true;\n      } else {\n        // Node with this key doesn't already exist. Call insert function on root's node\n        this.root.insert(record);\n        this.count++;\n        return true;\n      }\n    }\n  };\n\n  IntervalTree.prototype.search = function (low, high) {\n    if (this.root === undefined) {\n      // Tree is empty; return empty array\n      return [];\n    } else {\n      return this.root.search(low, high);\n    }\n  };\n\n  IntervalTree.prototype.remove = function (record) {\n    if (this.root === undefined) {\n      // Tree is empty; nothing to remove\n      return false;\n    } else {\n      var node = this.root.searchExisting(record.low);\n\n      if (node === undefined) {\n        return false;\n      } else if (node.records.length > 1) {\n        var removedRecord = void 0; // Node with this key has 2 or more records. Find the one we need and remove it\n\n        for (var i = 0; i < node.records.length; i++) {\n          if (isSame(node.records[i], record)) {\n            removedRecord = node.records[i];\n            node.records.splice(i, 1);\n            break;\n          }\n        }\n\n        if (removedRecord) {\n          removedRecord = undefined; // Update max of that node and its parents if necessary\n\n          if (record.high === node.max) {\n            var nodeHigh = node.getNodeHigh();\n\n            if (node.left !== undefined && node.right !== undefined) {\n              node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);\n            } else if (node.left !== undefined && node.right === undefined) {\n              node.max = Math.max(node.left.max, nodeHigh);\n            } else if (node.left === undefined && node.right !== undefined) {\n              node.max = Math.max(node.right.max, nodeHigh);\n            } else {\n              node.max = nodeHigh;\n            }\n\n            if (node.parent) {\n              node.parent.updateMaxOfParents();\n            }\n          }\n\n          this.count--;\n          return true;\n        } else {\n          return false;\n        }\n      } else if (node.records.length === 1) {\n        // Node with this key has only 1 record. Check if the remaining record in this node is\n        // actually the one we want to remove\n        if (isSame(node.records[0], record)) {\n          // The remaining record is the one we want to remove. Remove the whole node from the tree\n          if (this.root.key === node.key) {\n            // We're removing the root element. Create a dummy node that will temporarily take\n            // root's parent role\n            var rootParent = new Node(this, {\n              low: record.low,\n              high: record.low\n            });\n            rootParent.left = this.root;\n            this.root.parent = rootParent;\n            var removedNode = this.root.remove(node);\n            this.root = rootParent.left;\n\n            if (this.root !== undefined) {\n              this.root.parent = undefined;\n            }\n\n            if (removedNode) {\n              removedNode = undefined;\n              this.count--;\n              return true;\n            } else {\n              return false;\n            }\n          } else {\n            var removedNode = this.root.remove(node);\n\n            if (removedNode) {\n              removedNode = undefined;\n              this.count--;\n              return true;\n            } else {\n              return false;\n            }\n          }\n        } else {\n          // The remaining record is not the one we want to remove\n          return false;\n        }\n      } else {\n        // No records at all in this node?! Shouldn't happen\n        return false;\n      }\n    }\n  };\n\n  IntervalTree.prototype.inOrder = function () {\n    return new InOrder(this.root);\n  };\n\n  IntervalTree.prototype.preOrder = function () {\n    return new PreOrder(this.root);\n  };\n\n  return IntervalTree;\n}();\n\nexports.IntervalTree = IntervalTree;\n\nvar DataIntervalTree =\n/** @class */\nfunction () {\n  function DataIntervalTree() {\n    this.tree = new IntervalTree();\n  }\n\n  DataIntervalTree.prototype.insert = function (low, high, data) {\n    return this.tree.insert({\n      low: low,\n      high: high,\n      data: data\n    });\n  };\n\n  DataIntervalTree.prototype.remove = function (low, high, data) {\n    return this.tree.remove({\n      low: low,\n      high: high,\n      data: data\n    });\n  };\n\n  DataIntervalTree.prototype.search = function (low, high) {\n    return this.tree.search(low, high).map(function (v) {\n      return v.data;\n    });\n  };\n\n  DataIntervalTree.prototype.inOrder = function () {\n    return this.tree.inOrder();\n  };\n\n  DataIntervalTree.prototype.preOrder = function () {\n    return this.tree.preOrder();\n  };\n\n  Object.defineProperty(DataIntervalTree.prototype, \"count\", {\n    get: function get() {\n      return this.tree.count;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DataIntervalTree;\n}();\n\nexports.default = DataIntervalTree;\n\nvar InOrder =\n/** @class */\nfunction () {\n  function InOrder(startNode) {\n    this.stack = [];\n\n    if (startNode !== undefined) {\n      this.push(startNode);\n    }\n  }\n\n  InOrder.prototype.next = function () {\n    // Will only happen if stack is empty and pop is called\n    if (this.currentNode === undefined) {\n      return {\n        done: true,\n        value: undefined\n      };\n    } // Process this node\n\n\n    if (this.i < this.currentNode.records.length) {\n      return {\n        done: false,\n        value: this.currentNode.records[this.i++]\n      };\n    }\n\n    if (this.currentNode.right !== undefined) {\n      this.push(this.currentNode.right);\n    } else {\n      // Might pop the last and set this.currentNode = undefined\n      this.pop();\n    }\n\n    return this.next();\n  };\n\n  InOrder.prototype.push = function (node) {\n    this.currentNode = node;\n    this.i = 0;\n\n    while (this.currentNode.left !== undefined) {\n      this.stack.push(this.currentNode);\n      this.currentNode = this.currentNode.left;\n    }\n  };\n\n  InOrder.prototype.pop = function () {\n    this.currentNode = this.stack.pop();\n    this.i = 0;\n  };\n\n  return InOrder;\n}();\n\nexports.InOrder = InOrder;\n\nif (typeof Symbol === 'function') {\n  InOrder.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n}\n\nvar PreOrder =\n/** @class */\nfunction () {\n  function PreOrder(startNode) {\n    this.stack = [];\n    this.i = 0;\n    this.currentNode = startNode;\n  }\n\n  PreOrder.prototype.next = function () {\n    // Will only happen if stack is empty and pop is called,\n    // which only happens if there is no right node (i.e we are done)\n    if (this.currentNode === undefined) {\n      return {\n        done: true,\n        value: undefined\n      };\n    } // Process this node\n\n\n    if (this.i < this.currentNode.records.length) {\n      return {\n        done: false,\n        value: this.currentNode.records[this.i++]\n      };\n    }\n\n    if (this.currentNode.right !== undefined) {\n      this.push(this.currentNode.right);\n    }\n\n    if (this.currentNode.left !== undefined) {\n      this.push(this.currentNode.left);\n    }\n\n    this.pop();\n    return this.next();\n  };\n\n  PreOrder.prototype.push = function (node) {\n    this.stack.push(node);\n  };\n\n  PreOrder.prototype.pop = function () {\n    this.currentNode = this.stack.pop();\n    this.i = 0;\n  };\n\n  return PreOrder;\n}();\n\nexports.PreOrder = PreOrder;\n\nif (typeof Symbol === 'function') {\n  PreOrder.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n}","map":{"version":3,"sources":["../index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n// An augmented AVL Tree where each node maintains a list of records and their search intervals.\r\n// Record is composed of an interval and its underlying data, sent by a client. This allows the\r\n// interval tree to have the same interval inserted multiple times, as long its data is different.\r\n// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`\r\n// is the number of intervals in the output list.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar isSame = require(\"shallowequal\");\r\nfunction height(node) {\r\n    if (node === undefined) {\r\n        return -1;\r\n    }\r\n    else {\r\n        return node.height;\r\n    }\r\n}\r\nvar Node = /** @class */ (function () {\r\n    function Node(intervalTree, record) {\r\n        this.intervalTree = intervalTree;\r\n        this.records = [];\r\n        this.height = 0;\r\n        this.key = record.low;\r\n        this.max = record.high;\r\n        // Save the array of all records with the same key for this node\r\n        this.records.push(record);\r\n    }\r\n    // Gets the highest record.high value for this node\r\n    Node.prototype.getNodeHigh = function () {\r\n        var high = this.records[0].high;\r\n        for (var i = 1; i < this.records.length; i++) {\r\n            if (this.records[i].high > high) {\r\n                high = this.records[i].high;\r\n            }\r\n        }\r\n        return high;\r\n    };\r\n    // Updates height value of the node. Called during insertion, rebalance, removal\r\n    Node.prototype.updateHeight = function () {\r\n        this.height = Math.max(height(this.left), height(this.right)) + 1;\r\n    };\r\n    // Updates the max value of all the parents after inserting into already existing node, as well as\r\n    // removing the node completely or removing the record of an already existing node. Starts with\r\n    // the parent of an affected node and bubbles up to root\r\n    Node.prototype.updateMaxOfParents = function () {\r\n        if (this === undefined) {\r\n            return;\r\n        }\r\n        var thisHigh = this.getNodeHigh();\r\n        if (this.left !== undefined && this.right !== undefined) {\r\n            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);\r\n        }\r\n        else if (this.left !== undefined && this.right === undefined) {\r\n            this.max = Math.max(this.left.max, thisHigh);\r\n        }\r\n        else if (this.left === undefined && this.right !== undefined) {\r\n            this.max = Math.max(this.right.max, thisHigh);\r\n        }\r\n        else {\r\n            this.max = thisHigh;\r\n        }\r\n        if (this.parent) {\r\n            this.parent.updateMaxOfParents();\r\n        }\r\n    };\r\n    /*\r\n    Left-Left case:\r\n  \r\n           z                                      y\r\n          / \\                                   /   \\\r\n         y   T4      Right Rotate (z)          x     z\r\n        / \\          - - - - - - - - ->       / \\   / \\\r\n       x   T3                                T1 T2 T3 T4\r\n      / \\\r\n    T1   T2\r\n  \r\n    Left-Right case:\r\n  \r\n         z                               z                           x\r\n        / \\                             / \\                        /   \\\r\n       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z\r\n      / \\      - - - - - - - - ->     / \\      - - - - - - - ->  / \\   / \\\r\n    T1   x                           y  T3                      T1 T2 T3 T4\r\n        / \\                         / \\\r\n      T2   T3                      T1 T2\r\n    */\r\n    // Handles Left-Left case and Left-Right case after rebalancing AVL tree\r\n    Node.prototype._updateMaxAfterRightRotate = function () {\r\n        var parent = this.parent;\r\n        var left = parent.left;\r\n        // Update max of left sibling (x in first case, y in second)\r\n        var thisParentLeftHigh = left.getNodeHigh();\r\n        if (left.left === undefined && left.right !== undefined) {\r\n            left.max = Math.max(thisParentLeftHigh, left.right.max);\r\n        }\r\n        else if (left.left !== undefined && left.right === undefined) {\r\n            left.max = Math.max(thisParentLeftHigh, left.left.max);\r\n        }\r\n        else if (left.left === undefined && left.right === undefined) {\r\n            left.max = thisParentLeftHigh;\r\n        }\r\n        else {\r\n            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);\r\n        }\r\n        // Update max of itself (z)\r\n        var thisHigh = this.getNodeHigh();\r\n        if (this.left === undefined && this.right !== undefined) {\r\n            this.max = Math.max(thisHigh, this.right.max);\r\n        }\r\n        else if (this.left !== undefined && this.right === undefined) {\r\n            this.max = Math.max(thisHigh, this.left.max);\r\n        }\r\n        else if (this.left === undefined && this.right === undefined) {\r\n            this.max = thisHigh;\r\n        }\r\n        else {\r\n            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);\r\n        }\r\n        // Update max of parent (y in first case, x in second)\r\n        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());\r\n    };\r\n    /*\r\n    Right-Right case:\r\n  \r\n      z                               y\r\n     / \\                            /   \\\r\n    T1  y     Left Rotate(z)       z     x\r\n       / \\   - - - - - - - ->     / \\   / \\\r\n      T2  x                      T1 T2 T3 T4\r\n         / \\\r\n        T3 T4\r\n  \r\n    Right-Left case:\r\n  \r\n       z                            z                            x\r\n      / \\                          / \\                         /   \\\r\n     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y\r\n        / \\  - - - - - - - - ->      / \\   - - - - - - - ->  / \\   / \\\r\n       x  T4                        T2  y                   T1 T2 T3 T4\r\n      / \\                              / \\\r\n    T2   T3                           T3 T4\r\n    */\r\n    // Handles Right-Right case and Right-Left case in rebalancing AVL tree\r\n    Node.prototype._updateMaxAfterLeftRotate = function () {\r\n        var parent = this.parent;\r\n        var right = parent.right;\r\n        // Update max of right sibling (x in first case, y in second)\r\n        var thisParentRightHigh = right.getNodeHigh();\r\n        if (right.left === undefined && right.right !== undefined) {\r\n            right.max = Math.max(thisParentRightHigh, right.right.max);\r\n        }\r\n        else if (right.left !== undefined && right.right === undefined) {\r\n            right.max = Math.max(thisParentRightHigh, right.left.max);\r\n        }\r\n        else if (right.left === undefined && right.right === undefined) {\r\n            right.max = thisParentRightHigh;\r\n        }\r\n        else {\r\n            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);\r\n        }\r\n        // Update max of itself (z)\r\n        var thisHigh = this.getNodeHigh();\r\n        if (this.left === undefined && this.right !== undefined) {\r\n            this.max = Math.max(thisHigh, this.right.max);\r\n        }\r\n        else if (this.left !== undefined && this.right === undefined) {\r\n            this.max = Math.max(thisHigh, this.left.max);\r\n        }\r\n        else if (this.left === undefined && this.right === undefined) {\r\n            this.max = thisHigh;\r\n        }\r\n        else {\r\n            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);\r\n        }\r\n        // Update max of parent (y in first case, x in second)\r\n        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());\r\n    };\r\n    Node.prototype._leftRotate = function () {\r\n        var rightChild = this.right;\r\n        rightChild.parent = this.parent;\r\n        if (rightChild.parent === undefined) {\r\n            this.intervalTree.root = rightChild;\r\n        }\r\n        else {\r\n            if (rightChild.parent.left === this) {\r\n                rightChild.parent.left = rightChild;\r\n            }\r\n            else if (rightChild.parent.right === this) {\r\n                rightChild.parent.right = rightChild;\r\n            }\r\n        }\r\n        this.right = rightChild.left;\r\n        if (this.right !== undefined) {\r\n            this.right.parent = this;\r\n        }\r\n        rightChild.left = this;\r\n        this.parent = rightChild;\r\n        this.updateHeight();\r\n        rightChild.updateHeight();\r\n    };\r\n    Node.prototype._rightRotate = function () {\r\n        var leftChild = this.left;\r\n        leftChild.parent = this.parent;\r\n        if (leftChild.parent === undefined) {\r\n            this.intervalTree.root = leftChild;\r\n        }\r\n        else {\r\n            if (leftChild.parent.left === this) {\r\n                leftChild.parent.left = leftChild;\r\n            }\r\n            else if (leftChild.parent.right === this) {\r\n                leftChild.parent.right = leftChild;\r\n            }\r\n        }\r\n        this.left = leftChild.right;\r\n        if (this.left !== undefined) {\r\n            this.left.parent = this;\r\n        }\r\n        leftChild.right = this;\r\n        this.parent = leftChild;\r\n        this.updateHeight();\r\n        leftChild.updateHeight();\r\n    };\r\n    // Rebalances the tree if the height value between two nodes of the same parent is greater than\r\n    // two. There are 4 cases that can happen which are outlined in the graphics above\r\n    Node.prototype._rebalance = function () {\r\n        if (height(this.left) >= 2 + height(this.right)) {\r\n            var left = this.left;\r\n            if (height(left.left) >= height(left.right)) {\r\n                // Left-Left case\r\n                this._rightRotate();\r\n                this._updateMaxAfterRightRotate();\r\n            }\r\n            else {\r\n                // Left-Right case\r\n                left._leftRotate();\r\n                this._rightRotate();\r\n                this._updateMaxAfterRightRotate();\r\n            }\r\n        }\r\n        else if (height(this.right) >= 2 + height(this.left)) {\r\n            var right = this.right;\r\n            if (height(right.right) >= height(right.left)) {\r\n                // Right-Right case\r\n                this._leftRotate();\r\n                this._updateMaxAfterLeftRotate();\r\n            }\r\n            else {\r\n                // Right-Left case\r\n                right._rightRotate();\r\n                this._leftRotate();\r\n                this._updateMaxAfterLeftRotate();\r\n            }\r\n        }\r\n    };\r\n    Node.prototype.insert = function (record) {\r\n        if (record.low < this.key) {\r\n            // Insert into left subtree\r\n            if (this.left === undefined) {\r\n                this.left = new Node(this.intervalTree, record);\r\n                this.left.parent = this;\r\n            }\r\n            else {\r\n                this.left.insert(record);\r\n            }\r\n        }\r\n        else {\r\n            // Insert into right subtree\r\n            if (this.right === undefined) {\r\n                this.right = new Node(this.intervalTree, record);\r\n                this.right.parent = this;\r\n            }\r\n            else {\r\n                this.right.insert(record);\r\n            }\r\n        }\r\n        // Update the max value of this ancestor if needed\r\n        if (this.max < record.high) {\r\n            this.max = record.high;\r\n        }\r\n        // Update height of each node\r\n        this.updateHeight();\r\n        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially\r\n        // important in searching, as the tree has a high chance of degenerating without the rebalancing\r\n        this._rebalance();\r\n    };\r\n    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {\r\n        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {\r\n            // Nodes are overlapping, check if individual records in the node are overlapping\r\n            var tempResults = [];\r\n            for (var i = 0; i < currentNode.records.length; i++) {\r\n                if (currentNode.records[i].high >= low) {\r\n                    tempResults.push(currentNode.records[i]);\r\n                }\r\n            }\r\n            return tempResults;\r\n        }\r\n        return [];\r\n    };\r\n    Node.prototype.search = function (low, high) {\r\n        // Don't search nodes that don't exist\r\n        if (this === undefined) {\r\n            return [];\r\n        }\r\n        var leftSearch = [];\r\n        var ownSearch = [];\r\n        var rightSearch = [];\r\n        // If interval is to the right of the rightmost point of any interval in this node and all its\r\n        // children, there won't be any matches\r\n        if (low > this.max) {\r\n            return [];\r\n        }\r\n        // Search left children\r\n        if (this.left !== undefined && this.left.max >= low) {\r\n            leftSearch = this.left.search(low, high);\r\n        }\r\n        // Check this node\r\n        ownSearch = this._getOverlappingRecords(this, low, high);\r\n        // If interval is to the left of the start of this interval, then it can't be in any child to\r\n        // the right\r\n        if (high < this.key) {\r\n            return leftSearch.concat(ownSearch);\r\n        }\r\n        // Otherwise, search right children\r\n        if (this.right !== undefined) {\r\n            rightSearch = this.right.search(low, high);\r\n        }\r\n        // Return accumulated results, if any\r\n        return leftSearch.concat(ownSearch, rightSearch);\r\n    };\r\n    // Searches for a node by a `key` value\r\n    Node.prototype.searchExisting = function (low) {\r\n        if (this === undefined) {\r\n            return undefined;\r\n        }\r\n        if (this.key === low) {\r\n            return this;\r\n        }\r\n        else if (low < this.key) {\r\n            if (this.left !== undefined) {\r\n                return this.left.searchExisting(low);\r\n            }\r\n        }\r\n        else {\r\n            if (this.right !== undefined) {\r\n                return this.right.searchExisting(low);\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    // Returns the smallest node of the subtree\r\n    Node.prototype._minValue = function () {\r\n        if (this.left === undefined) {\r\n            return this;\r\n        }\r\n        else {\r\n            return this.left._minValue();\r\n        }\r\n    };\r\n    Node.prototype.remove = function (node) {\r\n        var parent = this.parent;\r\n        if (node.key < this.key) {\r\n            // Node to be removed is on the left side\r\n            if (this.left !== undefined) {\r\n                return this.left.remove(node);\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        }\r\n        else if (node.key > this.key) {\r\n            // Node to be removed is on the right side\r\n            if (this.right !== undefined) {\r\n                return this.right.remove(node);\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        }\r\n        else {\r\n            if (this.left !== undefined && this.right !== undefined) {\r\n                // Node has two children\r\n                var minValue = this.right._minValue();\r\n                this.key = minValue.key;\r\n                this.records = minValue.records;\r\n                return this.right.remove(this);\r\n            }\r\n            else if (parent.left === this) {\r\n                // One child or no child case on left side\r\n                if (this.right !== undefined) {\r\n                    parent.left = this.right;\r\n                    this.right.parent = parent;\r\n                }\r\n                else {\r\n                    parent.left = this.left;\r\n                    if (this.left !== undefined) {\r\n                        this.left.parent = parent;\r\n                    }\r\n                }\r\n                parent.updateMaxOfParents();\r\n                parent.updateHeight();\r\n                parent._rebalance();\r\n                return this;\r\n            }\r\n            else if (parent.right === this) {\r\n                // One child or no child case on right side\r\n                if (this.right !== undefined) {\r\n                    parent.right = this.right;\r\n                    this.right.parent = parent;\r\n                }\r\n                else {\r\n                    parent.right = this.left;\r\n                    if (this.left !== undefined) {\r\n                        this.left.parent = parent;\r\n                    }\r\n                }\r\n                parent.updateMaxOfParents();\r\n                parent.updateHeight();\r\n                parent._rebalance();\r\n                return this;\r\n            }\r\n        }\r\n    };\r\n    return Node;\r\n}());\r\nexports.Node = Node;\r\nvar IntervalTree = /** @class */ (function () {\r\n    function IntervalTree() {\r\n        this.count = 0;\r\n    }\r\n    IntervalTree.prototype.insert = function (record) {\r\n        if (record.low > record.high) {\r\n            throw new Error('`low` value must be lower or equal to `high` value');\r\n        }\r\n        if (this.root === undefined) {\r\n            // Base case: Tree is empty, new node becomes root\r\n            this.root = new Node(this, record);\r\n            this.count++;\r\n            return true;\r\n        }\r\n        else {\r\n            // Otherwise, check if node already exists with the same key\r\n            var node = this.root.searchExisting(record.low);\r\n            if (node !== undefined) {\r\n                // Check the records in this node if there already is the one with same low, high, data\r\n                for (var i = 0; i < node.records.length; i++) {\r\n                    if (isSame(node.records[i], record)) {\r\n                        // This record is same as the one we're trying to insert; return false to indicate\r\n                        // nothing has been inserted\r\n                        return false;\r\n                    }\r\n                }\r\n                // Add the record to the node\r\n                node.records.push(record);\r\n                // Update max of the node and its parents if necessary\r\n                if (record.high > node.max) {\r\n                    node.max = record.high;\r\n                    if (node.parent) {\r\n                        node.parent.updateMaxOfParents();\r\n                    }\r\n                }\r\n                this.count++;\r\n                return true;\r\n            }\r\n            else {\r\n                // Node with this key doesn't already exist. Call insert function on root's node\r\n                this.root.insert(record);\r\n                this.count++;\r\n                return true;\r\n            }\r\n        }\r\n    };\r\n    IntervalTree.prototype.search = function (low, high) {\r\n        if (this.root === undefined) {\r\n            // Tree is empty; return empty array\r\n            return [];\r\n        }\r\n        else {\r\n            return this.root.search(low, high);\r\n        }\r\n    };\r\n    IntervalTree.prototype.remove = function (record) {\r\n        if (this.root === undefined) {\r\n            // Tree is empty; nothing to remove\r\n            return false;\r\n        }\r\n        else {\r\n            var node = this.root.searchExisting(record.low);\r\n            if (node === undefined) {\r\n                return false;\r\n            }\r\n            else if (node.records.length > 1) {\r\n                var removedRecord = void 0;\r\n                // Node with this key has 2 or more records. Find the one we need and remove it\r\n                for (var i = 0; i < node.records.length; i++) {\r\n                    if (isSame(node.records[i], record)) {\r\n                        removedRecord = node.records[i];\r\n                        node.records.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n                if (removedRecord) {\r\n                    removedRecord = undefined;\r\n                    // Update max of that node and its parents if necessary\r\n                    if (record.high === node.max) {\r\n                        var nodeHigh = node.getNodeHigh();\r\n                        if (node.left !== undefined && node.right !== undefined) {\r\n                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);\r\n                        }\r\n                        else if (node.left !== undefined && node.right === undefined) {\r\n                            node.max = Math.max(node.left.max, nodeHigh);\r\n                        }\r\n                        else if (node.left === undefined && node.right !== undefined) {\r\n                            node.max = Math.max(node.right.max, nodeHigh);\r\n                        }\r\n                        else {\r\n                            node.max = nodeHigh;\r\n                        }\r\n                        if (node.parent) {\r\n                            node.parent.updateMaxOfParents();\r\n                        }\r\n                    }\r\n                    this.count--;\r\n                    return true;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            else if (node.records.length === 1) {\r\n                // Node with this key has only 1 record. Check if the remaining record in this node is\r\n                // actually the one we want to remove\r\n                if (isSame(node.records[0], record)) {\r\n                    // The remaining record is the one we want to remove. Remove the whole node from the tree\r\n                    if (this.root.key === node.key) {\r\n                        // We're removing the root element. Create a dummy node that will temporarily take\r\n                        // root's parent role\r\n                        var rootParent = new Node(this, { low: record.low, high: record.low });\r\n                        rootParent.left = this.root;\r\n                        this.root.parent = rootParent;\r\n                        var removedNode = this.root.remove(node);\r\n                        this.root = rootParent.left;\r\n                        if (this.root !== undefined) {\r\n                            this.root.parent = undefined;\r\n                        }\r\n                        if (removedNode) {\r\n                            removedNode = undefined;\r\n                            this.count--;\r\n                            return true;\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        var removedNode = this.root.remove(node);\r\n                        if (removedNode) {\r\n                            removedNode = undefined;\r\n                            this.count--;\r\n                            return true;\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // The remaining record is not the one we want to remove\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                // No records at all in this node?! Shouldn't happen\r\n                return false;\r\n            }\r\n        }\r\n    };\r\n    IntervalTree.prototype.inOrder = function () {\r\n        return new InOrder(this.root);\r\n    };\r\n    IntervalTree.prototype.preOrder = function () {\r\n        return new PreOrder(this.root);\r\n    };\r\n    return IntervalTree;\r\n}());\r\nexports.IntervalTree = IntervalTree;\r\nvar DataIntervalTree = /** @class */ (function () {\r\n    function DataIntervalTree() {\r\n        this.tree = new IntervalTree();\r\n    }\r\n    DataIntervalTree.prototype.insert = function (low, high, data) {\r\n        return this.tree.insert({ low: low, high: high, data: data });\r\n    };\r\n    DataIntervalTree.prototype.remove = function (low, high, data) {\r\n        return this.tree.remove({ low: low, high: high, data: data });\r\n    };\r\n    DataIntervalTree.prototype.search = function (low, high) {\r\n        return this.tree.search(low, high).map(function (v) { return v.data; });\r\n    };\r\n    DataIntervalTree.prototype.inOrder = function () {\r\n        return this.tree.inOrder();\r\n    };\r\n    DataIntervalTree.prototype.preOrder = function () {\r\n        return this.tree.preOrder();\r\n    };\r\n    Object.defineProperty(DataIntervalTree.prototype, \"count\", {\r\n        get: function () {\r\n            return this.tree.count;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return DataIntervalTree;\r\n}());\r\nexports.default = DataIntervalTree;\r\nvar InOrder = /** @class */ (function () {\r\n    function InOrder(startNode) {\r\n        this.stack = [];\r\n        if (startNode !== undefined) {\r\n            this.push(startNode);\r\n        }\r\n    }\r\n    InOrder.prototype.next = function () {\r\n        // Will only happen if stack is empty and pop is called\r\n        if (this.currentNode === undefined) {\r\n            return {\r\n                done: true,\r\n                value: undefined,\r\n            };\r\n        }\r\n        // Process this node\r\n        if (this.i < this.currentNode.records.length) {\r\n            return {\r\n                done: false,\r\n                value: this.currentNode.records[this.i++],\r\n            };\r\n        }\r\n        if (this.currentNode.right !== undefined) {\r\n            this.push(this.currentNode.right);\r\n        }\r\n        else {\r\n            // Might pop the last and set this.currentNode = undefined\r\n            this.pop();\r\n        }\r\n        return this.next();\r\n    };\r\n    InOrder.prototype.push = function (node) {\r\n        this.currentNode = node;\r\n        this.i = 0;\r\n        while (this.currentNode.left !== undefined) {\r\n            this.stack.push(this.currentNode);\r\n            this.currentNode = this.currentNode.left;\r\n        }\r\n    };\r\n    InOrder.prototype.pop = function () {\r\n        this.currentNode = this.stack.pop();\r\n        this.i = 0;\r\n    };\r\n    return InOrder;\r\n}());\r\nexports.InOrder = InOrder;\r\nif (typeof Symbol === 'function') {\r\n    InOrder.prototype[Symbol.iterator] = function () { return this; };\r\n}\r\nvar PreOrder = /** @class */ (function () {\r\n    function PreOrder(startNode) {\r\n        this.stack = [];\r\n        this.i = 0;\r\n        this.currentNode = startNode;\r\n    }\r\n    PreOrder.prototype.next = function () {\r\n        // Will only happen if stack is empty and pop is called,\r\n        // which only happens if there is no right node (i.e we are done)\r\n        if (this.currentNode === undefined) {\r\n            return {\r\n                done: true,\r\n                value: undefined,\r\n            };\r\n        }\r\n        // Process this node\r\n        if (this.i < this.currentNode.records.length) {\r\n            return {\r\n                done: false,\r\n                value: this.currentNode.records[this.i++],\r\n            };\r\n        }\r\n        if (this.currentNode.right !== undefined) {\r\n            this.push(this.currentNode.right);\r\n        }\r\n        if (this.currentNode.left !== undefined) {\r\n            this.push(this.currentNode.left);\r\n        }\r\n        this.pop();\r\n        return this.next();\r\n    };\r\n    PreOrder.prototype.push = function (node) {\r\n        this.stack.push(node);\r\n    };\r\n    PreOrder.prototype.pop = function () {\r\n        this.currentNode = this.stack.pop();\r\n        this.i = 0;\r\n    };\r\n    return PreOrder;\r\n}());\r\nexports.PreOrder = PreOrder;\r\nif (typeof Symbol === 'function') {\r\n    PreOrder.prototype[Symbol.iterator] = function () { return this; };\r\n}\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}