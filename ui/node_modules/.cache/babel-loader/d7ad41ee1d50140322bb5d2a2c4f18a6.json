{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.handleDecodingError = exports.StopDecodingError = exports.DecodingError = void 0;\n\nvar Format = __importStar(require(\"./format\")); //For when we need to throw an error, here's a wrapper class that extends Error.\n//Apologies about the confusing name, but I wanted something that would make\n//sense should it not be caught and thus accidentally exposed to the outside.\n\n/**\n * @hidden\n */\n\n\nvar DecodingError = /*#__PURE__*/function (_Error) {\n  _inherits(DecodingError, _Error);\n\n  var _super = _createSuper(DecodingError);\n\n  function DecodingError(error) {\n    var _this;\n\n    _classCallCheck(this, DecodingError);\n\n    _this = _super.call(this, Format.Utils.Exception.message(error));\n    _this.error = error;\n    _this.name = \"DecodingError\";\n    return _this;\n  }\n\n  return DecodingError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.DecodingError = DecodingError; //used to stop decoding; like DecodingError, but used in contexts\n//where I don't expect it to be caught\n//NOTE: currently we don't actually check the type of a thrown error,\n//we just rely on context.  still, I think it makes sense to be a separate\n//type.\n\n/**\n * @hidden\n */\n\nvar StopDecodingError = /*#__PURE__*/function (_Error2) {\n  _inherits(StopDecodingError, _Error2);\n\n  var _super2 = _createSuper(StopDecodingError);\n\n  //when decoding in full mode, we allow an ABI-mode retry.  (if we were already in\n  //ABI mode, we give up.)\n  function StopDecodingError(error, allowRetry) {\n    var _this2;\n\n    _classCallCheck(this, StopDecodingError);\n\n    var message = \"Stopping decoding: \".concat(error.kind); //sorry about the bare-bones message,\n    //but again, users shouldn't actually see this, so I think this should suffice for now\n\n    _this2 = _super2.call(this, message);\n    _this2.error = error;\n    _this2.allowRetry = Boolean(allowRetry);\n    return _this2;\n  }\n\n  return StopDecodingError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.StopDecodingError = StopDecodingError;\n/**\n * @hidden\n */\n\nfunction handleDecodingError(dataType, error) {\n  var strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (error instanceof DecodingError) {\n    //expected error\n    if (strict) {\n      //strict mode -- stop decoding on errors\n      throw new StopDecodingError(error.error);\n    } else {\n      //nonstrict mode -- return an error result\n      return {\n        //I don't know why TS's inference is failing here and needs the coercion\n        type: dataType,\n        kind: \"error\",\n        error: error.error\n      };\n    }\n  } else {\n    //if it's *not* an expected error, we better not swallow it -- rethrow!\n    throw error;\n  }\n}\n\nexports.handleDecodingError = handleDecodingError;","map":{"version":3,"sources":["../../lib/errors.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,UAAA,CAAA,CAAA,C,CAEA;AACA;AACA;;AACA;;AAEG;;;IACU,a;;;;;AAEX,yBAAY,KAAZ,EAAiD;AAAA;;AAAA;;AAC/C,8BAAM,MAAM,CAAC,KAAP,CAAa,SAAb,CAAuB,OAAvB,CAA+B,KAA/B,CAAN;AACA,UAAK,KAAL,GAAa,KAAb;AACA,UAAK,IAAL,GAAY,eAAZ;AAH+C;AAIhD;;;iCANgC,K;;AAAnC,OAAA,CAAA,aAAA,GAAA,aAAA,C,CASA;AACA;AACA;AACA;AACA;;AACA;;AAEG;;IACU,iB;;;;;AAGX;AACA;AACA,6BAAY,KAAZ,EAA+C,UAA/C,EAAmE;AAAA;;AAAA;;AACjE,QAAM,OAAO,gCAAyB,KAAK,CAAC,IAA/B,CAAb,CADiE,CACb;AACpD;;AACA,gCAAM,OAAN;AACA,WAAK,KAAL,GAAa,KAAb;AACA,WAAK,UAAL,GAAkB,OAAO,CAAC,UAAD,CAAzB;AALiE;AAMlE;;;iCAXoC,K;;AAAvC,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAcA;;AAEG;;AACH,SAAgB,mBAAhB,CACE,QADF,EAEE,KAFF,EAGyB;AAAA,MAAvB,MAAuB,uEAAL,KAAK;;AAEvB,MAAI,KAAK,YAAY,aAArB,EAAoC;AAClC;AACA,QAAI,MAAJ,EAAY;AACV;AACA,YAAM,IAAI,iBAAJ,CAAsB,KAAK,CAAC,KAA5B,CAAN;AACD,KAHD,MAGO;AACL;AACA,aAAkC;AAChC;AACA,QAAA,IAAI,EAAE,QAF0B;AAGhC,QAAA,IAAI,EAAE,OAH0B;AAIhC,QAAA,KAAK,EAAE,KAAK,CAAC;AAJmB,OAAlC;AAMD;AACF,GAdD,MAcO;AACL;AACA,UAAM,KAAN;AACD;AACF;;AAvBD,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.handleDecodingError = exports.StopDecodingError = exports.DecodingError = void 0;\nconst Format = __importStar(require(\"./format\"));\n//For when we need to throw an error, here's a wrapper class that extends Error.\n//Apologies about the confusing name, but I wanted something that would make\n//sense should it not be caught and thus accidentally exposed to the outside.\n/**\n * @hidden\n */\nclass DecodingError extends Error {\n    constructor(error) {\n        super(Format.Utils.Exception.message(error));\n        this.error = error;\n        this.name = \"DecodingError\";\n    }\n}\nexports.DecodingError = DecodingError;\n//used to stop decoding; like DecodingError, but used in contexts\n//where I don't expect it to be caught\n//NOTE: currently we don't actually check the type of a thrown error,\n//we just rely on context.  still, I think it makes sense to be a separate\n//type.\n/**\n * @hidden\n */\nclass StopDecodingError extends Error {\n    //when decoding in full mode, we allow an ABI-mode retry.  (if we were already in\n    //ABI mode, we give up.)\n    constructor(error, allowRetry) {\n        const message = `Stopping decoding: ${error.kind}`; //sorry about the bare-bones message,\n        //but again, users shouldn't actually see this, so I think this should suffice for now\n        super(message);\n        this.error = error;\n        this.allowRetry = Boolean(allowRetry);\n    }\n}\nexports.StopDecodingError = StopDecodingError;\n/**\n * @hidden\n */\nfunction handleDecodingError(dataType, error, strict = false) {\n    if (error instanceof DecodingError) {\n        //expected error\n        if (strict) {\n            //strict mode -- stop decoding on errors\n            throw new StopDecodingError(error.error);\n        }\n        else {\n            //nonstrict mode -- return an error result\n            return {\n                //I don't know why TS's inference is failing here and needs the coercion\n                type: dataType,\n                kind: \"error\",\n                error: error.error\n            };\n        }\n    }\n    else {\n        //if it's *not* an expected error, we better not swallow it -- rethrow!\n        throw error;\n    }\n}\nexports.handleDecodingError = handleDecodingError;\n//# sourceMappingURL=errors.js.map"]},"metadata":{},"sourceType":"script"}