{"ast":null,"code":"var ansiRegex = require('ansi-regex');\n\nvar superSplit = require('super-split');\n\nvar arrayUniq = require('array-uniq');\n\nvar stripAnsi = require('strip-ansi');\n\nvar realignOutOfBoundsCoords = function realignOutOfBoundsCoords(text, opts) {\n  var plain = stripAnsi(text);\n  var lines = plain.split('\\n');\n  var totalLines = lines.length; // 'End.line marker out of bounds (max).'\n\n  if (opts.end.line > totalLines) {\n    opts.end.line = totalLines;\n  } // 'Start.line marker out of bounds (min).'\n\n\n  if (opts.start.line < 1) {\n    opts.start.line = 1;\n  } // 'Start.column marker out of bounds (min).'\n\n\n  if (opts.start.column < 1) {\n    opts.start.column = 1;\n  } // 'End.column marker out of bounds (max).'\n\n\n  if (opts.end.column > lines[opts.end.line - 1].length) {\n    opts.end.column = lines[opts.end.line - 1].length;\n  }\n\n  if (opts.start.line > opts.end.line) {\n    throw new Error('Your start line is after your end line.');\n  }\n\n  if (opts.start.line === opts.end.line && opts.end.column < opts.start.column) {\n    throw new Error('Your end column is after your start column.');\n  }\n\n  return false;\n}; // Returns arys:\n// 1 - ANSI Escape sequences from section\n// 2 - Glyphs in section (ansi escape seq - or - ascii character)\n\n\nvar atomize = function atomize(section) {\n  var ansies = arrayUniq(section.match(ansiRegex()));\n  var words = superSplit(section, ansies);\n  var glyphs = [];\n  words.forEach(function (word) {\n    if (ansies.includes(word) === false) {\n      glyphs = glyphs.concat(word.split(''));\n      return;\n    }\n\n    glyphs.push(word);\n  });\n  return {\n    ansies: ansies,\n    glyphs: glyphs\n  };\n};\n\nvar markSection = function markSection(section, opts, linear) {\n  var _atomize = atomize(section),\n      ansies = _atomize.ansies,\n      glyphs = _atomize.glyphs;\n\n  var x = 0;\n  var y = 0;\n  var inPoint;\n  var outPoint;\n  var output = '';\n  var height = opts.end.line - opts.start.line;\n\n  var markNotBegun = function markNotBegun() {\n    return typeof inPoint !== 'number' && typeof outPoint !== 'number';\n  };\n\n  var markHasEnded = function markHasEnded() {\n    return typeof inPoint === 'number' && typeof outPoint === 'number';\n  };\n\n  var outsideOfMark = function outsideOfMark() {\n    return markNotBegun() || markHasEnded();\n  };\n\n  glyphs.forEach(function (glyph) {\n    if (ansies.includes(glyph) === false) {\n      if (glyph === '\\n' && !linear) {\n        y += 1;\n        x = -1;\n      }\n\n      x += 1;\n\n      if (x === opts.start.column && y === 0) {\n        inPoint = output.length;\n      }\n\n      output += glyph;\n\n      if (x === opts.end.column && y === height) {\n        outPoint = output.length;\n      }\n\n      return;\n    }\n\n    if (outsideOfMark()) {\n      output += glyph;\n    } else if (!outsideOfMark() && !opts.resetColor) {\n      output += glyph;\n    }\n  });\n  var pre = output.substr(0, inPoint);\n  var mark = opts.color(output.substr(inPoint, outPoint - inPoint));\n  var post = output.substr(outPoint);\n  var sectionMarked = pre + mark + post;\n  return sectionMarked;\n};\n\nvar mark2d = function mark2d(text, opts) {\n  realignOutOfBoundsCoords(text, opts);\n  var lines = text.split('\\n'); // Minus 1: because line and column numbers start at 1\n\n  var startLine = opts.start.line - 1;\n  var endLine = opts.end.line - 1; // Plus 1: because slice does not include the end indice\n\n  var unmarkedSection = lines.slice(startLine, endLine + 1).join('\\n');\n  var preSection = lines.slice(0, startLine);\n  var markedSection = markSection(unmarkedSection, opts);\n  var postSection = lines.slice(endLine + 1);\n  var result = preSection.concat([markedSection]).concat(postSection).join('\\n');\n  return result;\n};\n\nvar mark1d = function mark1d(text, opts, linear) {\n  var markedSection = markSection(text, opts, linear);\n  return markedSection;\n};\n\nvar mark = function mark(text, opts, linear) {\n  return linear ? mark1d(text, opts, linear) : mark2d(text, opts);\n};\n\nvar validMarkersNumbers = function validMarkersNumbers(opts) {\n  return typeof opts.start === 'number' && typeof opts.end === 'number';\n};\n\nvar validMarkersObject = function validMarkersObject(opts) {\n  return typeof opts.start === 'object' && typeof opts.end === 'object' && typeof opts.start.line === 'number' && typeof opts.start.column === 'number' && typeof opts.end.line === 'number' && typeof opts.end.column === 'number';\n};\n\nvar ansiMark = function ansiMark(text, opts) {\n  if (validMarkersObject(opts)) {\n    return mark(text, opts);\n  }\n\n  if (validMarkersNumbers(opts)) {\n    opts.start = {\n      line: 1,\n      column: opts.start\n    };\n    opts.end = {\n      line: 1,\n      column: opts.end\n    };\n    var linear = true;\n    return mark(text, opts, linear);\n  }\n\n  throw new Error('Invalid marker definition.');\n};\n\nmodule.exports = ansiMark;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/ansi-mark/index.js"],"names":["ansiRegex","require","superSplit","arrayUniq","stripAnsi","realignOutOfBoundsCoords","text","opts","plain","lines","split","totalLines","length","end","line","start","column","Error","atomize","section","ansies","match","words","glyphs","forEach","word","includes","concat","push","markSection","linear","x","y","inPoint","outPoint","output","height","markNotBegun","markHasEnded","outsideOfMark","glyph","resetColor","pre","substr","mark","color","post","sectionMarked","mark2d","startLine","endLine","unmarkedSection","slice","join","preSection","markedSection","postSection","result","mark1d","validMarkersNumbers","validMarkersObject","ansiMark","module","exports"],"mappings":"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","sourcesContent":["const ansiRegex = require('ansi-regex')\nconst superSplit = require('super-split')\nconst arrayUniq = require('array-uniq')\nconst stripAnsi = require('strip-ansi')\n\nconst realignOutOfBoundsCoords = (text, opts) => {\n\tconst plain = stripAnsi(text)\n\tconst lines = plain.split('\\n')\n\tconst totalLines = lines.length\n\n\t// 'End.line marker out of bounds (max).'\n\tif (opts.end.line > totalLines) {\n\t\topts.end.line = totalLines\n\t}\n\n\t// 'Start.line marker out of bounds (min).'\n\tif (opts.start.line < 1) {\n\t\topts.start.line = 1\n\t}\n\n\t// 'Start.column marker out of bounds (min).'\n\tif (opts.start.column < 1) {\n\t\topts.start.column = 1\n\t}\n\n\t// 'End.column marker out of bounds (max).'\n\tif (opts.end.column > lines[opts.end.line - 1].length) {\n\t\topts.end.column = lines[opts.end.line - 1].length\n\t}\n\n\tif (opts.start.line > opts.end.line) {\n\t\tthrow new Error('Your start line is after your end line.')\n\t}\n\n\tif (opts.start.line === opts.end.line &&\n\t\topts.end.column < opts.start.column) {\n\t\tthrow new Error('Your end column is after your start column.')\n\t}\n\n\treturn false\n}\n\n// Returns arys:\n// 1 - ANSI Escape sequences from section\n// 2 - Glyphs in section (ansi escape seq - or - ascii character)\nconst atomize = section => {\n\tconst ansies = arrayUniq(section.match(ansiRegex()))\n\tconst words = superSplit(section, ansies)\n\n\tlet glyphs = []\n\twords.forEach(word => {\n\t\tif (ansies.includes(word) === false) {\n\t\t\tglyphs = glyphs.concat(word.split(''))\n\t\t\treturn\n\t\t}\n\t\tglyphs.push(word)\n\t})\n\n\treturn {ansies, glyphs}\n}\n\nconst markSection = (section, opts, linear) => {\n\tconst {ansies, glyphs} = atomize(section)\n\n\tlet x = 0\n\tlet y = 0\n\tlet inPoint\n\tlet outPoint\n\tlet output = ''\n\tconst height = opts.end.line - opts.start.line\n\n\tconst markNotBegun = () => {\n\t\treturn typeof inPoint !== 'number' &&\n\t\t\ttypeof outPoint !== 'number'\n\t}\n\n\tconst markHasEnded = () => {\n\t\treturn typeof inPoint === 'number' &&\n\t\t\ttypeof outPoint === 'number'\n\t}\n\n\tconst outsideOfMark = () => {\n\t\treturn markNotBegun() || markHasEnded()\n\t}\n\n\tglyphs.forEach(glyph => {\n\t\tif (ansies.includes(glyph) === false) {\n\t\t\tif (glyph === '\\n' && !linear) {\n\t\t\t\ty += 1\n\t\t\t\tx = -1\n\t\t\t}\n\n\t\t\tx += 1\n\n\t\t\tif (x === opts.start.column && y === 0) {\n\t\t\t\tinPoint = output.length\n\t\t\t}\n\n\t\t\toutput += glyph\n\n\t\t\tif (x === opts.end.column && y === height) {\n\t\t\t\toutPoint = output.length\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif (outsideOfMark()) {\n\t\t\toutput += glyph\n\t\t} else if (!outsideOfMark() && !opts.resetColor) {\n\t\t\toutput += glyph\n\t\t}\n\t})\n\n\tconst pre = output.substr(0, inPoint)\n\tconst mark = opts.color(output.substr(inPoint, outPoint - inPoint))\n\tconst post = output.substr(outPoint)\n\tconst sectionMarked = pre + mark + post\n\n\treturn sectionMarked\n}\n\nconst mark2d = (text, opts) => {\n\trealignOutOfBoundsCoords(text, opts)\n\n\tconst lines = text.split('\\n')\n\n\t// Minus 1: because line and column numbers start at 1\n\tconst startLine = opts.start.line - 1\n\tconst endLine = opts.end.line - 1\n\n\t// Plus 1: because slice does not include the end indice\n\tconst unmarkedSection = lines.slice(startLine, endLine + 1).join('\\n')\n\n\tconst preSection = lines.slice(0, startLine)\n\tconst markedSection = markSection(unmarkedSection, opts)\n\tconst postSection = lines.slice(endLine + 1)\n\n\tconst result = preSection.concat([markedSection]).concat(postSection).join('\\n')\n\treturn result\n}\n\nconst mark1d = (text, opts, linear) => {\n\tconst markedSection = markSection(text, opts, linear)\n\treturn markedSection\n}\n\nconst mark = (text, opts, linear) => {\n\treturn linear ? mark1d(text, opts, linear) : mark2d(text, opts)\n}\n\nconst validMarkersNumbers = opts => {\n\treturn typeof opts.start === 'number' &&\n\t\ttypeof opts.end === 'number'\n}\n\nconst validMarkersObject = opts => {\n\treturn typeof opts.start === 'object' &&\n\t\ttypeof opts.end === 'object' &&\n\t\ttypeof opts.start.line === 'number' &&\n\t\ttypeof opts.start.column === 'number' &&\n\t\ttypeof opts.end.line === 'number' &&\n\t\ttypeof opts.end.column === 'number'\n}\n\nconst ansiMark = (text, opts) => {\n\tif (validMarkersObject(opts)) {\n\t\treturn mark(text, opts)\n\t}\n\n\tif (validMarkersNumbers(opts)) {\n\t\topts.start = {line: 1, column: opts.start}\n\t\topts.end = {line: 1, column: opts.end}\n\t\tconst linear = true\n\t\treturn mark(text, opts, linear)\n\t}\n\n\tthrow new Error('Invalid marker definition.')\n}\n\nmodule.exports = ansiMark\n"]},"metadata":{},"sourceType":"script"}