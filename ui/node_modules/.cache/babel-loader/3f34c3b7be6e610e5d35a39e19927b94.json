{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getContractNode = exports.shimArtifacts = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:compilations:utils\");\n\nfunction shimArtifacts(artifacts, files) {\n  var shimmedCompilationId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"shimmedcompilation\";\n  var externalSolidity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  //note: always returns a one-element array (a single fictional compilation)\n  var contracts = [];\n  var sources = [];\n  var unreliableSourceOrder = false;\n\n  var _iterator = _createForOfIteratorHelper(artifacts),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var artifact = _step.value;\n      var contractName = artifact.contractName,\n          contract_name = artifact.contract_name,\n          bytecode = artifact.bytecode,\n          sourceMap = artifact.sourceMap,\n          deployedBytecode = artifact.deployedBytecode,\n          deployedSourceMap = artifact.deployedSourceMap,\n          immutableReferences = artifact.immutableReferences,\n          sourcePath = artifact.sourcePath,\n          source = artifact.source,\n          ast = artifact.ast,\n          abi = artifact.abi,\n          compiler = artifact.compiler;\n      contractName = contractName || contract_name; //dunno what's up w/ the type of contract_name, but it needs coercing\n\n      var sourceObject = {\n        sourcePath: sourcePath,\n        source: source,\n        ast: ast,\n        compiler: compiler\n      }; //ast needs to be coerced because schema doesn't quite match our types here...\n\n      var contractObject = {\n        contractName: contractName,\n        bytecode: bytecode,\n        sourceMap: sourceMap,\n        deployedBytecode: deployedBytecode,\n        deployedSourceMap: deployedSourceMap,\n        immutableReferences: immutableReferences,\n        abi: abi,\n        compiler: compiler\n      }; //if files was passed, trust that to determine the source index\n\n      if (files) {\n        var index = files.indexOf(sourcePath);\n        sources[index] = sourceObject;\n        sourceObject.id = index.toString(); //HACK\n\n        contractObject.primarySourceId = index.toString(); //note: we never set the unreliableSourceOrder flag in this branch;\n        //we just trust files.  If files is bad, then, uh, too bad.\n      } else {\n        //if files *wasn't* passed, attempt to determine it from the ast\n        //first: is this already there? only add it if it's not.\n        //(we determine this by sourcePath if present, and the actual source\n        //contents if not)\n        if (sources.every(function (existingSource) {\n          return existingSource.sourcePath !== sourcePath || !sourcePath && !existingSource.sourcePath && existingSource.source !== source;\n        })) {\n          var _index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n\n\n          if (!unreliableSourceOrder && _index !== undefined && !(_index in sources)) {\n            sources[_index] = sourceObject;\n            sourceObject.id = _index.toString(); //HACK\n\n            contractObject.primarySourceId = _index.toString();\n          } else {\n            //if we fail, set the unreliable source order flag\n            unreliableSourceOrder = true;\n          }\n\n          if (unreliableSourceOrder) {\n            //in case of unreliable source order, we'll ignore what indices\n            //things are *supposed* to have and just append things to the end\n            sourceObject.id = sources.length.toString(); //HACK\n\n            contractObject.primarySourceId = sources.length.toString();\n            sources.push(sourceObject); //these lines don't commute, obviously!\n          }\n        }\n      }\n\n      contracts.push(contractObject);\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var compiler;\n\n  if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    compiler = contracts[0].compiler;\n  }\n\n  return [{\n    id: shimmedCompilationId,\n    unreliableSourceOrder: unreliableSourceOrder,\n    sources: sources,\n    contracts: contracts,\n    compiler: compiler,\n    externalSolidity: externalSolidity\n  }];\n}\n\nexports.shimArtifacts = shimArtifacts;\n\nfunction sourceIndexForAst(ast) {\n  if (!ast) {\n    return undefined;\n  }\n\n  return parseInt(ast.src.split(\":\")[2]); //src is given as start:length:file.\n  //we want just the file.\n}\n\nfunction getContractNode(contract, compilation) {\n  var contractName = contract.contractName,\n      sourceMap = contract.sourceMap,\n      deployedSourceMap = contract.deployedSourceMap,\n      primarySourceId = contract.primarySourceId;\n  var unreliableSourceOrder = compilation.unreliableSourceOrder,\n      sources = compilation.sources;\n  var sourcesToCheck; //we will attempt to locate the primary source;\n  //if we can't find it, we'll just check every source in this\n  //compilation.\n\n  if (primarySourceId !== undefined) {\n    sourcesToCheck = [sources.find(function (source) {\n      return source && source.id === primarySourceId;\n    })];\n  } else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n    var sourceId = extractPrimarySource(deployedSourceMap || sourceMap);\n    sourcesToCheck = [sources[sourceId]];\n  } else {\n    //WARNING: if we end up in this case, we could get the wrong contract!\n    //(but we shouldn't end up here)\n    sourcesToCheck = sources;\n  }\n\n  return sourcesToCheck.reduce(function (foundNode, source) {\n    if (foundNode || !source) {\n      return foundNode;\n    }\n\n    if (!source.ast) {\n      return undefined;\n    }\n\n    return source.ast.nodes.find(function (node) {\n      return node.nodeType === \"ContractDefinition\" && node.name === contractName;\n    });\n  }, undefined);\n}\n\nexports.getContractNode = getContractNode;\n/*\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n * (this is something of a HACK)\n * NOTE: duplicated from debugger, sorry\n */\n\nfunction extractPrimarySource(sourceMap) {\n  return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);\n}","map":{"version":3,"sources":["../../../lib/compilations/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getContractNode = exports.shimArtifacts = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:compilations:utils\");\nfunction shimArtifacts(artifacts, files, shimmedCompilationId = \"shimmedcompilation\", externalSolidity = false) {\n    //note: always returns a one-element array (a single fictional compilation)\n    let contracts = [];\n    let sources = [];\n    let unreliableSourceOrder = false;\n    for (let artifact of artifacts) {\n        let { contractName, contract_name, bytecode, sourceMap, deployedBytecode, deployedSourceMap, immutableReferences, sourcePath, source, ast, abi, compiler } = artifact;\n        contractName = contractName || contract_name;\n        //dunno what's up w/ the type of contract_name, but it needs coercing\n        let sourceObject = {\n            sourcePath,\n            source,\n            ast: ast,\n            compiler\n        };\n        //ast needs to be coerced because schema doesn't quite match our types here...\n        let contractObject = {\n            contractName,\n            bytecode,\n            sourceMap,\n            deployedBytecode,\n            deployedSourceMap,\n            immutableReferences,\n            abi,\n            compiler\n        };\n        //if files was passed, trust that to determine the source index\n        if (files) {\n            let index = files.indexOf(sourcePath);\n            sources[index] = sourceObject;\n            sourceObject.id = index.toString(); //HACK\n            contractObject.primarySourceId = index.toString();\n            //note: we never set the unreliableSourceOrder flag in this branch;\n            //we just trust files.  If files is bad, then, uh, too bad.\n        }\n        else {\n            //if files *wasn't* passed, attempt to determine it from the ast\n            //first: is this already there? only add it if it's not.\n            //(we determine this by sourcePath if present, and the actual source\n            //contents if not)\n            if (sources.every(existingSource => existingSource.sourcePath !== sourcePath ||\n                (!sourcePath &&\n                    !existingSource.sourcePath &&\n                    existingSource.source !== source))) {\n                let index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n                if (!unreliableSourceOrder &&\n                    index !== undefined &&\n                    !(index in sources)) {\n                    sources[index] = sourceObject;\n                    sourceObject.id = index.toString(); //HACK\n                    contractObject.primarySourceId = index.toString();\n                }\n                else {\n                    //if we fail, set the unreliable source order flag\n                    unreliableSourceOrder = true;\n                }\n                if (unreliableSourceOrder) {\n                    //in case of unreliable source order, we'll ignore what indices\n                    //things are *supposed* to have and just append things to the end\n                    sourceObject.id = sources.length.toString(); //HACK\n                    contractObject.primarySourceId = sources.length.toString();\n                    sources.push(sourceObject); //these lines don't commute, obviously!\n                }\n            }\n        }\n        contracts.push(contractObject);\n    }\n    let compiler;\n    if (!unreliableSourceOrder && contracts.length > 0) {\n        //if things were actually compiled together, we should just be able\n        //to pick an arbitrary one\n        compiler = contracts[0].compiler;\n    }\n    return [\n        {\n            id: shimmedCompilationId,\n            unreliableSourceOrder,\n            sources,\n            contracts,\n            compiler,\n            externalSolidity\n        }\n    ];\n}\nexports.shimArtifacts = shimArtifacts;\nfunction sourceIndexForAst(ast) {\n    if (!ast) {\n        return undefined;\n    }\n    return parseInt(ast.src.split(\":\")[2]);\n    //src is given as start:length:file.\n    //we want just the file.\n}\nfunction getContractNode(contract, compilation) {\n    const { contractName, sourceMap, deployedSourceMap, primarySourceId } = contract;\n    const { unreliableSourceOrder, sources } = compilation;\n    let sourcesToCheck;\n    //we will attempt to locate the primary source;\n    //if we can't find it, we'll just check every source in this\n    //compilation.\n    if (primarySourceId !== undefined) {\n        sourcesToCheck = [\n            sources.find(source => source && source.id === primarySourceId)\n        ];\n    }\n    else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n        let sourceId = extractPrimarySource(deployedSourceMap || sourceMap);\n        sourcesToCheck = [sources[sourceId]];\n    }\n    else {\n        //WARNING: if we end up in this case, we could get the wrong contract!\n        //(but we shouldn't end up here)\n        sourcesToCheck = sources;\n    }\n    return sourcesToCheck.reduce((foundNode, source) => {\n        if (foundNode || !source) {\n            return foundNode;\n        }\n        if (!source.ast) {\n            return undefined;\n        }\n        return source.ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === contractName);\n    }, undefined);\n}\nexports.getContractNode = getContractNode;\n/*\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n * (this is something of a HACK)\n * NOTE: duplicated from debugger, sorry\n */\nfunction extractPrimarySource(sourceMap) {\n    return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}