{"ast":null,"code":"var debug = require(\"debug\")(\"provider:wrapper\"); // eslint-disable-line no-unused-vars\n\n\nvar ProviderError = require(\"./error\");\n\nmodule.exports = {\n  /*\n   * Web3.js Transport Wrapper\n   *\n   * Wraps an underlying web3 provider's RPC transport methods (send/sendAsync)\n   * for Truffle-specific purposes, mainly for logging / request verbosity.\n   */\n  wrap: function wrap(provider, options) {\n    /* wrapping should be idempotent */\n    if (provider._alreadyWrapped) return provider;\n    /* setup options defaults */\n\n    options = options || {}; // custom logger\n\n    options.logger = options.logger || console; // to see what web3 is sending and receiving.\n\n    options.verbose = options.verbose || options.verboseRpc || false;\n    /* create wrapper functions for before/after send */\n\n    var preHook = this.preHook(options);\n    var postHook = this.postHook(options);\n    var originalSend = provider.send.bind(provider);\n    /* overwrite method */\n\n    provider.send = this.send(originalSend, preHook, postHook);\n    /* mark as wrapped */\n\n    provider._alreadyWrapped = true;\n    return provider;\n  },\n\n  /*\n   * Transport Hook Generators\n   *\n   * Used to wrap underlying web3.js behavior before/after sending request\n   * payloads to the RPC.\n   *\n   * Transport hooks may be used to perform additional operations before/after\n   * sending, and/or to modify request/response data.\n   *\n   * Each generator accepts an `options` argument and uses it to construct\n   * and return a function.\n   *\n   * Returned functions accept relevant arguments and return potentially new\n   * versions of those arguments (for payload/result/error overrides)\n   */\n  // before send/sendAsync\n  preHook: function preHook(options) {\n    return function (payload) {\n      if (options.verbose) {\n        // for request payload debugging\n        options.logger.log(\"   > \" + JSON.stringify(payload, null, 2).split(\"\\n\").join(\"\\n   > \"));\n      }\n\n      return payload;\n    };\n  },\n  // after send/sendAsync\n  postHook: function postHook(options) {\n    return function (payload, error, result) {\n      // web3 websocket providers return false and web3 http providers\n      // return null when no error has occurred...kind of obnoxious\n      if (error) {\n        error = new ProviderError(error.message, options);\n        return [payload, error, result];\n      }\n\n      if (options.verbose) {\n        options.logger.log(\" <   \" + JSON.stringify(result, null, 2).split(\"\\n\").join(\"\\n <   \"));\n      }\n\n      return [payload, error, result];\n    };\n  },\n\n  /*\n   * Transport Method Generators\n   *\n   * Generate wrapped versions of `send`/`sendAsync`, given original method and\n   * transport hooks.\n   *\n   * Pre-condition: originals are bound correctly (`send.bind(provider)`)\n   *\n   * Return the wrapped function matching the original function's signature.\n   */\n  send: function send(originalSend, preHook, postHook) {\n    return function (payload, callback) {\n      payload = preHook(payload);\n      originalSend(payload, function (error, result) {\n        var modified = postHook(payload, error, result);\n        payload = modified[0];\n        error = modified[1];\n        result = modified[2];\n        callback(error, result);\n      });\n    };\n  }\n};","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/@truffle/provider/wrapper.js"],"names":["debug","require","ProviderError","module","exports","wrap","provider","options","_alreadyWrapped","logger","console","verbose","verboseRpc","preHook","postHook","originalSend","send","bind","payload","log","JSON","stringify","split","join","error","result","message","callback","modified"],"mappings":"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","sourcesContent":["var debug = require(\"debug\")(\"provider:wrapper\"); // eslint-disable-line no-unused-vars\nvar ProviderError = require(\"./error\");\n\nmodule.exports = {\n  /*\n   * Web3.js Transport Wrapper\n   *\n   * Wraps an underlying web3 provider's RPC transport methods (send/sendAsync)\n   * for Truffle-specific purposes, mainly for logging / request verbosity.\n   */\n  wrap: function (provider, options) {\n    /* wrapping should be idempotent */\n    if (provider._alreadyWrapped) return provider;\n\n    /* setup options defaults */\n    options = options || {};\n    // custom logger\n    options.logger = options.logger || console;\n    // to see what web3 is sending and receiving.\n    options.verbose = options.verbose || options.verboseRpc || false;\n\n    /* create wrapper functions for before/after send */\n    var preHook = this.preHook(options);\n    var postHook = this.postHook(options);\n\n    var originalSend = provider.send.bind(provider);\n\n    /* overwrite method */\n    provider.send = this.send(originalSend, preHook, postHook);\n\n    /* mark as wrapped */\n    provider._alreadyWrapped = true;\n\n    return provider;\n  },\n\n  /*\n   * Transport Hook Generators\n   *\n   * Used to wrap underlying web3.js behavior before/after sending request\n   * payloads to the RPC.\n   *\n   * Transport hooks may be used to perform additional operations before/after\n   * sending, and/or to modify request/response data.\n   *\n   * Each generator accepts an `options` argument and uses it to construct\n   * and return a function.\n   *\n   * Returned functions accept relevant arguments and return potentially new\n   * versions of those arguments (for payload/result/error overrides)\n   */\n\n  // before send/sendAsync\n  preHook: function (options) {\n    return function (payload) {\n      if (options.verbose) {\n        // for request payload debugging\n        options.logger.log(\n          \"   > \" + JSON.stringify(payload, null, 2).split(\"\\n\").join(\"\\n   > \")\n        );\n      }\n\n      return payload;\n    };\n  },\n\n  // after send/sendAsync\n  postHook: function (options) {\n    return function (payload, error, result) {\n      // web3 websocket providers return false and web3 http providers\n      // return null when no error has occurred...kind of obnoxious\n      if (error) {\n        error = new ProviderError(error.message, options);\n        return [payload, error, result];\n      }\n\n      if (options.verbose) {\n        options.logger.log(\n          \" <   \" + JSON.stringify(result, null, 2).split(\"\\n\").join(\"\\n <   \")\n        );\n      }\n\n      return [payload, error, result];\n    };\n  },\n\n  /*\n   * Transport Method Generators\n   *\n   * Generate wrapped versions of `send`/`sendAsync`, given original method and\n   * transport hooks.\n   *\n   * Pre-condition: originals are bound correctly (`send.bind(provider)`)\n   *\n   * Return the wrapped function matching the original function's signature.\n   */\n  send: function (originalSend, preHook, postHook) {\n    return function (payload, callback) {\n      payload = preHook(payload);\n\n      originalSend(payload, function (error, result) {\n        var modified = postHook(payload, error, result);\n        payload = modified[0];\n        error = modified[1];\n        result = modified[2];\n\n        callback(error, result);\n      });\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}