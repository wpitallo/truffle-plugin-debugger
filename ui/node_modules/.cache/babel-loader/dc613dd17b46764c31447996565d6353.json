{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar stream = require('stream');\n\nvar BinaryParseStream = require('../vendor/binary-parse-stream');\n\nvar Tagged = require('./tagged');\n\nvar Simple = require('./simple');\n\nvar utils = require('./utils');\n\nvar bignumber = require('bignumber.js').BigNumber;\n\nvar NoFilter = require('nofilter');\n\nvar constants = require('./constants'); // Do not fix this if you want to support node v4\n\n\nvar MT = constants.MT;\nvar NUMBYTES = constants.NUMBYTES;\nvar SIMPLE = constants.SIMPLE;\nvar SYMS = constants.SYMS;\nvar BI = utils.bigIntize(constants.BI);\nvar BN = constants.BN;\nvar COUNT = Symbol('count');\nvar PENDING_KEY = Symbol('pending_key');\nvar MAJOR = Symbol('major type');\nvar ERROR = Symbol('error');\nvar NOT_FOUND = Symbol('not found');\n\nfunction parentArray(parent, typ, count) {\n  var a = [];\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\n\nfunction parentBufferStream(parent, typ) {\n  var b = new NoFilter();\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n/**\n * @param {Buffer} v\n * @private\n */\n\n\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v);\n}\n/**\n * @param {BigInt} v\n * @private\n */\n\n\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BI.MINUS_ONE - utils.bufferToBigInt(v);\n}\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\n\n\nvar Decoder = /*#__PURE__*/function (_BinaryParseStream) {\n  _inherits(Decoder, _BinaryParseStream);\n\n  var _super = _createSuper(Decoder);\n\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  function Decoder(options) {\n    var _this;\n\n    _classCallCheck(this, Decoder);\n\n    options = options || {};\n    var tags = options.tags;\n    delete options.tags;\n    var max_depth = options.max_depth != null ? options.max_depth : -1;\n    delete options.max_depth;\n    var bigI = utils.hasBigInt ? !!options.bigint : false;\n    delete options.bigint;\n    _this = _super.call(this, options);\n    _this.running = true;\n    _this.max_depth = max_depth;\n    _this.tags = tags;\n\n    if (bigI) {\n      if (_this.tags == null) {\n        _this.tags = {};\n      }\n\n      if (_this.tags[2] == null) {\n        _this.tags[2] = _tag_2;\n      }\n\n      if (_this.tags[3] == null) {\n        _this.tags[3] = _tag_3;\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n\n\n  _createClass(Decoder, [{\n    key: \"close\",\n    value:\n    /**\n     * Stop processing\n     */\n    function close() {\n      this.running = false;\n      this.__fresh = true;\n    }\n  }, {\n    key: \"_parse\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function _parse() {\n      var parent, depth, val, octet, mt, ai, parent_major, parent_length, numbytes, buf, hasParent, again, pm, allstrings, i, len, _i, _len, _i2, _len2, t, old;\n\n      return _regeneratorRuntime.wrap(function _parse$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              parent = null;\n              depth = 0;\n              val = null;\n\n            case 3:\n              if (!true) {\n                _context.next = 151;\n                break;\n              }\n\n              if (!(this.max_depth >= 0 && depth > this.max_depth)) {\n                _context.next = 6;\n                break;\n              }\n\n              throw new Error('Maximum depth ' + this.max_depth + ' exceeded');\n\n            case 6:\n              _context.next = 8;\n              return 1;\n\n            case 8:\n              octet = _context.sent[0];\n\n              if (this.running) {\n                _context.next = 11;\n                break;\n              }\n\n              throw new Error('Unexpected data: 0x' + octet.toString(16));\n\n            case 11:\n              mt = octet >> 5;\n              ai = octet & 0x1f;\n              parent_major = parent != null ? parent[MAJOR] : undefined;\n              parent_length = parent != null ? parent.length : undefined;\n              _context.t0 = ai;\n              _context.next = _context.t0 === NUMBYTES.ONE ? 18 : _context.t0 === NUMBYTES.TWO ? 23 : _context.t0 === NUMBYTES.FOUR ? 23 : _context.t0 === NUMBYTES.EIGHT ? 23 : _context.t0 === 28 ? 30 : _context.t0 === 29 ? 30 : _context.t0 === 30 ? 30 : _context.t0 === NUMBYTES.INDEFINITE ? 32 : 38;\n              break;\n\n            case 18:\n              this.emit('more-bytes', mt, 1, parent_major, parent_length);\n              _context.next = 21;\n              return 1;\n\n            case 21:\n              val = _context.sent[0];\n              return _context.abrupt(\"break\", 39);\n\n            case 23:\n              numbytes = 1 << ai - 24;\n              this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n              _context.next = 27;\n              return numbytes;\n\n            case 27:\n              buf = _context.sent;\n              val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);\n              return _context.abrupt(\"break\", 39);\n\n            case 30:\n              this.running = false;\n              throw new Error('Additional info not implemented: ' + ai);\n\n            case 32:\n              _context.t1 = mt;\n              _context.next = _context.t1 === MT.POS_INT ? 35 : _context.t1 === MT.NEG_INT ? 35 : _context.t1 === MT.TAG ? 35 : 36;\n              break;\n\n            case 35:\n              throw new Error(\"Invalid indefinite encoding for MT \".concat(mt));\n\n            case 36:\n              val = -1;\n              return _context.abrupt(\"break\", 39);\n\n            case 38:\n              val = ai;\n\n            case 39:\n              _context.t2 = mt;\n              _context.next = _context.t2 === MT.POS_INT ? 42 : _context.t2 === MT.NEG_INT ? 43 : _context.t2 === MT.BYTE_STRING ? 45 : _context.t2 === MT.UTF8_STRING ? 45 : _context.t2 === MT.ARRAY ? 61 : _context.t2 === MT.MAP ? 61 : _context.t2 === MT.TAG ? 75 : _context.t2 === MT.SIMPLE_FLOAT ? 80 : 88;\n              break;\n\n            case 42:\n              return _context.abrupt(\"break\", 88);\n\n            case 43:\n              if (val === Number.MAX_SAFE_INTEGER) {\n                val = BN.NEG_MAX;\n              } else if (val instanceof bignumber) {\n                val = BN.MINUS_ONE.minus(val);\n              } else {\n                val = -1 - val;\n              }\n\n              return _context.abrupt(\"break\", 88);\n\n            case 45:\n              _context.t3 = val;\n              _context.next = _context.t3 === 0 ? 48 : _context.t3 === -1 ? 51 : 55;\n              break;\n\n            case 48:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = mt === MT.BYTE_STRING ? Buffer.allocUnsafe(0) : '';\n              return _context.abrupt(\"break\", 60);\n\n            case 51:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              return _context.abrupt(\"continue\", 3);\n\n            case 55:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              _context.next = 58;\n              return val;\n\n            case 58:\n              val = _context.sent;\n\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              }\n\n            case 60:\n              return _context.abrupt(\"break\", 88);\n\n            case 61:\n              _context.t4 = val;\n              _context.next = _context.t4 === 0 ? 64 : _context.t4 === -1 ? 66 : 70;\n              break;\n\n            case 64:\n              val = mt === MT.MAP ? {} : [];\n              return _context.abrupt(\"break\", 74);\n\n            case 66:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              return _context.abrupt(\"continue\", 3);\n\n            case 70:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              return _context.abrupt(\"continue\", 3);\n\n            case 74:\n              return _context.abrupt(\"break\", 88);\n\n            case 75:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, 1);\n              parent.push(val);\n              depth++;\n              return _context.abrupt(\"continue\", 3);\n\n            case 80:\n              if (!(typeof val === 'number')) {\n                _context.next = 87;\n                break;\n              }\n\n              if (!(ai === NUMBYTES.ONE && val < 32)) {\n                _context.next = 83;\n                break;\n              }\n\n              throw new Error(\"Invalid two-byte encoding of simple value \".concat(val));\n\n            case 83:\n              hasParent = parent != null;\n              val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);\n              _context.next = 88;\n              break;\n\n            case 87:\n              val = utils.parseCBORfloat(val);\n\n            case 88:\n              this.emit('value', val, parent_major, parent_length, ai);\n              again = false;\n\n            case 90:\n              if (!(parent != null)) {\n                _context.next = 147;\n                break;\n              }\n\n              _context.t5 = false;\n              _context.next = _context.t5 === (val !== SYMS.BREAK) ? 94 : _context.t5 === !Array.isArray(parent) ? 96 : _context.t5 === !(parent instanceof NoFilter) ? 98 : 103;\n              break;\n\n            case 94:\n              parent[COUNT] = 1;\n              return _context.abrupt(\"break\", 103);\n\n            case 96:\n              parent.push(val);\n              return _context.abrupt(\"break\", 103);\n\n            case 98:\n              pm = parent[MAJOR];\n\n              if (!(pm != null && pm !== mt)) {\n                _context.next = 102;\n                break;\n              }\n\n              this.running = false;\n              throw new Error('Invalid major type in indefinite encoding');\n\n            case 102:\n              parent.write(val);\n\n            case 103:\n              if (!(--parent[COUNT] !== 0)) {\n                _context.next = 106;\n                break;\n              }\n\n              again = true;\n              return _context.abrupt(\"break\", 147);\n\n            case 106:\n              --depth;\n              delete parent[COUNT];\n\n              if (!Array.isArray(parent)) {\n                _context.next = 132;\n                break;\n              }\n\n              _context.t6 = parent[MAJOR];\n              _context.next = _context.t6 === MT.ARRAY ? 112 : _context.t6 === MT.MAP ? 114 : _context.t6 === MT.TAG ? 127 : 130;\n              break;\n\n            case 112:\n              val = parent;\n              return _context.abrupt(\"break\", 130);\n\n            case 114:\n              allstrings = true;\n\n              if (!(parent.length % 2 !== 0)) {\n                _context.next = 117;\n                break;\n              }\n\n              throw new Error('Invalid map length: ' + parent.length);\n\n            case 117:\n              i = 0, len = parent.length;\n\n            case 118:\n              if (!(i < len)) {\n                _context.next = 125;\n                break;\n              }\n\n              if (!(typeof parent[i] !== 'string')) {\n                _context.next = 122;\n                break;\n              }\n\n              allstrings = false;\n              return _context.abrupt(\"break\", 125);\n\n            case 122:\n              i += 2;\n              _context.next = 118;\n              break;\n\n            case 125:\n              if (allstrings) {\n                val = {};\n\n                for (_i = 0, _len = parent.length; _i < _len; _i += 2) {\n                  val[parent[_i]] = parent[_i + 1];\n                }\n              } else {\n                val = new Map();\n\n                for (_i2 = 0, _len2 = parent.length; _i2 < _len2; _i2 += 2) {\n                  val.set(parent[_i2], parent[_i2 + 1]);\n                }\n              }\n\n              return _context.abrupt(\"break\", 130);\n\n            case 127:\n              t = new Tagged(parent[0], parent[1]);\n              val = t.convert(this.tags);\n              return _context.abrupt(\"break\", 130);\n\n            case 130:\n              _context.next = 140;\n              break;\n\n            case 132:\n              if (!(parent instanceof NoFilter)) {\n                _context.next = 140;\n                break;\n              }\n\n              _context.t7 = parent[MAJOR];\n              _context.next = _context.t7 === MT.BYTE_STRING ? 136 : _context.t7 === MT.UTF8_STRING ? 138 : 140;\n              break;\n\n            case 136:\n              val = parent.slice();\n              return _context.abrupt(\"break\", 140);\n\n            case 138:\n              val = parent.toString('utf-8');\n              return _context.abrupt(\"break\", 140);\n\n            case 140:\n              this.emit('stop', parent[MAJOR]);\n              old = parent;\n              parent = parent[SYMS.PARENT];\n              delete old[SYMS.PARENT];\n              delete old[MAJOR];\n              _context.next = 90;\n              break;\n\n            case 147:\n              if (again) {\n                _context.next = 149;\n                break;\n              }\n\n              return _context.abrupt(\"return\", val);\n\n            case 149:\n              _context.next = 3;\n              break;\n\n            case 151:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _parse, this);\n    })\n  }], [{\n    key: \"nullcheck\",\n    value: function nullcheck(val) {\n      switch (val) {\n        case SYMS.NULL:\n          return null;\n\n        case SYMS.UNDEFINED:\n          return undefined;\n\n        case NOT_FOUND:\n          throw new Error('Value not found');\n\n        default:\n          return val;\n      }\n    }\n    /**\n     * @typedef DecodeOptions\n     * @property {string} [encoding='hex'] - The encoding of the input.\n     *   Ignored if input is a Buffer.\n     */\n\n    /**\n     * Decode the first CBOR item in the input, synchronously.  This will throw an\n     * exception if the input is not valid CBOR.\n     *\n     * @static\n     * @param {string|Buffer|stream.Readable} input\n     * @param {DecodeOptions|string} [options] Options\n     * @returns {any} - the decoded value\n     */\n\n  }, {\n    key: \"decodeFirstSync\",\n    value: function decodeFirstSync(input, options) {\n      options = options || {\n        encoding: 'hex'\n      };\n      var opts = {};\n      var encod;\n\n      switch (typeof options) {\n        case 'string':\n          encod = options;\n          break;\n\n        case 'object':\n          opts = utils.extend({}, options);\n          encod = opts.encoding;\n          delete opts.encoding;\n          break;\n      }\n\n      var c = new Decoder(opts);\n      var s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input)); // for/of doesn't work when you need to call next() with a value\n      // generator created by parser will be \"done\" after each CBOR entity\n      // parser will yield numbers of bytes that it wants\n\n      var parser = c._parse();\n\n      var state = parser.next();\n\n      while (!state.done) {\n        var b = s.read(state.value);\n\n        if (b == null || b.length !== state.value) {\n          throw new Error('Insufficient data');\n        }\n\n        state = parser.next(b);\n      }\n\n      var val = Decoder.nullcheck(state.value);\n\n      if (s.length > 0) {\n        var nextByte = s.read(1);\n        s.unshift(nextByte);\n        var er = new Error('Unexpected data: 0x' + nextByte[0].toString(16));\n        er.value = val;\n        throw er;\n      }\n\n      return val;\n    }\n    /**\n     * Decode all of the CBOR items in the input into an array.  This will throw\n     * an exception if the input is not valid CBOR; a zero-length input will\n     * return an empty array.\n     *\n     * @static\n     * @param {string|Buffer|stream.Readable} input\n     * @param {DecodeOptions|string} [options] Options or encoding string\n     * @returns {Array} - Array of all found items\n     */\n\n  }, {\n    key: \"decodeAllSync\",\n    value: function decodeAllSync(input, options) {\n      options = options || {\n        encoding: 'hex'\n      };\n      var opts = {};\n      var encod;\n\n      switch (typeof options) {\n        case 'string':\n          encod = options;\n          break;\n\n        case 'object':\n          opts = utils.extend({}, options);\n          encod = opts.encoding;\n          delete opts.encoding;\n      }\n\n      var c = new Decoder(opts);\n      var s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));\n      var res = [];\n\n      while (s.length > 0) {\n        var parser = c._parse();\n\n        var state = parser.next();\n\n        while (!state.done) {\n          var b = s.read(state.value);\n\n          if (b == null || b.length !== state.value) {\n            throw new Error('Insufficient data');\n          }\n\n          state = parser.next(b);\n        }\n\n        res.push(Decoder.nullcheck(state.value));\n      }\n\n      return res;\n    }\n    /**\n     * @callback decodeCallback\n     * @param {Error} [error] - if one was generated\n     * @param {any} [value] - the decoded value\n     */\n\n    /**\n     * Decode the first CBOR item in the input.  This will error if there are more\n     * bytes left over at the end, and optionally if there were no valid CBOR\n     * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n     * if no data was found and the `required` option is false.\n     *\n     * @static\n     * @param {string|Buffer} input - the input to parse\n     * @param {DecodeOptions|decodeCallback|string} [options] - options\n     * @param {decodeCallback} [cb] callback\n     * @returns {Promise<any>} returned even if callback is specified\n     */\n\n  }, {\n    key: \"decodeFirst\",\n    value: function decodeFirst(input, options, cb) {\n      var opts = {};\n      var required = false;\n      var encod = 'hex';\n\n      switch (typeof options) {\n        case 'function':\n          cb = options;\n          encod = utils.guessEncoding(input);\n          break;\n\n        case 'string':\n          encod = options;\n          break;\n\n        case 'object':\n          opts = utils.extend({}, options);\n          encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n          delete opts.encoding;\n          required = opts.required != null ? opts.required : false;\n          delete opts.required;\n      }\n\n      var c = new Decoder(opts);\n      var v = NOT_FOUND;\n      var p = new Promise(function (resolve, reject) {\n        c.on('data', function (val) {\n          v = Decoder.nullcheck(val);\n          c.close();\n        });\n        c.once('error', function (er) {\n          if (v !== NOT_FOUND) {\n            er.value = v;\n          }\n\n          v = ERROR;\n          c.close();\n          return reject(er);\n        });\n        c.once('end', function () {\n          switch (v) {\n            case NOT_FOUND:\n              if (required) {\n                return reject(new Error('No CBOR found'));\n              } else {\n                return resolve(v);\n              }\n\n            case ERROR:\n              return void 0;\n\n            default:\n              return resolve(v);\n          }\n        });\n      });\n\n      if (typeof cb === 'function') {\n        p.then(function (v) {\n          return cb(null, v);\n        }, cb);\n      }\n\n      c.end(input, encod);\n      return p;\n    }\n    /**\n     * @callback decodeAllCallback\n     * @param {Error} error - if one was generated\n     * @param {Array} value - all of the decoded values, wrapped in an Array\n     */\n\n    /**\n     * Decode all of the CBOR items in the input.  This will error if there are\n     * more bytes left over at the end.\n     *\n     * @static\n     * @param {(string|Buffer)} input - the input to parse\n     * @param {(string|Object)} options - Decoding options.\n     *   If string, the input encoding.\n     * @param {decodeAllCallback} cb callback\n     * @returns {Promise<Array>} even if callback is specified\n     */\n\n  }, {\n    key: \"decodeAll\",\n    value: function decodeAll(input, options, cb) {\n      var opts = {};\n      var encod = 'hex';\n\n      switch (typeof options) {\n        case 'function':\n          cb = options;\n          encod = utils.guessEncoding(input);\n          break;\n\n        case 'string':\n          encod = options;\n          break;\n\n        case 'object':\n          opts = utils.extend({}, options);\n          encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n          delete opts.encoding;\n      }\n\n      var c = new Decoder(opts);\n      var vals = [];\n      c.on('data', function (val) {\n        return vals.push(Decoder.nullcheck(val));\n      });\n      var p = new Promise(function (resolve, reject) {\n        c.on('error', reject);\n        c.on('end', function () {\n          return resolve(vals);\n        });\n      });\n\n      if (typeof cb === 'function') {\n        p.then(function (v) {\n          return cb(null, v);\n        }, cb);\n      }\n\n      c.end(input, encod);\n      return p;\n    }\n  }]);\n\n  return Decoder;\n}(BinaryParseStream);\n\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/cbor/lib/decoder.js"],"names":["stream","require","BinaryParseStream","Tagged","Simple","utils","bignumber","BigNumber","NoFilter","constants","MT","NUMBYTES","SIMPLE","SYMS","BI","bigIntize","BN","COUNT","Symbol","PENDING_KEY","MAJOR","ERROR","NOT_FOUND","parentArray","parent","typ","count","a","PARENT","parentBufferStream","b","_tag_2","v","bufferToBigInt","_tag_3","MINUS_ONE","Decoder","options","tags","max_depth","bigI","hasBigInt","bigint","running","__fresh","depth","val","Error","octet","toString","mt","ai","parent_major","undefined","parent_length","length","ONE","TWO","FOUR","EIGHT","INDEFINITE","emit","numbytes","buf","SIMPLE_FLOAT","parseCBORint","POS_INT","NEG_INT","TAG","BYTE_STRING","UTF8_STRING","ARRAY","MAP","Number","MAX_SAFE_INTEGER","NEG_MAX","minus","Buffer","allocUnsafe","STREAM","utf8","push","hasParent","decode","parseCBORfloat","again","BREAK","Array","isArray","pm","write","allstrings","i","len","Map","set","t","convert","slice","old","NULL","UNDEFINED","input","encoding","opts","encod","extend","c","s","Readable","guessEncoding","parser","_parse","state","next","done","read","value","nullcheck","nextByte","unshift","er","res","cb","required","p","Promise","resolve","reject","on","close","once","then","end","vals","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst BinaryParseStream = require('../vendor/binary-parse-stream')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\nconst constants = require('./constants')\n// Do not fix this if you want to support node v4\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\nconst BI = utils.bigIntize(constants.BI)\nconst BN = constants.BN\nconst COUNT = Symbol('count')\nconst PENDING_KEY = Symbol('pending_key')\nconst MAJOR = Symbol('major type')\nconst ERROR = Symbol('error')\nconst NOT_FOUND = Symbol('not found')\n\nfunction parentArray(parent, typ, count) {\n  const a = []\n  a[COUNT] = count\n  a[SYMS.PARENT] = parent\n  a[MAJOR] = typ\n  return a\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter()\n  b[COUNT] = -1\n  b[SYMS.PARENT] = parent\n  b[MAJOR] = typ\n  return b\n}\n\n/**\n * @param {Buffer} v\n * @private\n */\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v)\n}\n\n/**\n * @param {BigInt} v\n * @private\n */\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BI.MINUS_ONE - utils.bufferToBigInt(v)\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\nclass Decoder extends BinaryParseStream {\n\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  constructor(options) {\n    options = options || {}\n    const tags = options.tags\n    delete options.tags\n    const max_depth = (options.max_depth != null) ? options.max_depth : -1\n    delete options.max_depth\n    const bigI = utils.hasBigInt ? (!!options.bigint) : false\n    delete options.bigint\n    super(options)\n\n    this.running = true\n    this.max_depth = max_depth\n    this.tags = tags\n    if (bigI) {\n      if (this.tags == null) {\n        this.tags = {}\n      }\n      if (this.tags[2] == null) {\n        this.tags[2] = _tag_2\n      }\n      if (this.tags[3] == null) {\n        this.tags[3] = _tag_3\n      }\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null\n      case SYMS.UNDEFINED:\n        return undefined\n      case NOT_FOUND:\n        throw new Error('Value not found')\n      default:\n        return val\n    }\n  }\n\n  /**\n   * @typedef DecodeOptions\n   * @property {string} [encoding='hex'] - The encoding of the input.\n   *   Ignored if input is a Buffer.\n   */\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw an\n   * exception if the input is not valid CBOR.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options\n   * @returns {any} - the decoded value\n   */\n  static decodeFirstSync(input, options) {\n    options = options || { encoding: 'hex' }\n    let opts = {}\n    let encod\n    switch (typeof options) {\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = opts.encoding\n        delete opts.encoding\n        break\n    }\n    const c = new Decoder(opts)\n    const s = (input instanceof stream.Readable) ? input : new NoFilter(\n      input,\n      encod != null ? encod : utils.guessEncoding(input))\n\n    // for/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse()\n    let state = parser.next()\n    while (!state.done) {\n      const b = s.read(state.value)\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data')\n      }\n      state = parser.next(b)\n    }\n    const val = Decoder.nullcheck(state.value)\n    if (s.length > 0) {\n      const nextByte = s.read(1)\n      s.unshift(nextByte)\n      const er = new Error(\n        'Unexpected data: 0x' + nextByte[0].toString(16))\n      er.value = val\n      throw er\n    }\n    return val\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options or encoding string\n   * @returns {Array} - Array of all found items\n   */\n  static decodeAllSync(input, options) {\n    options = options || { encoding: 'hex' }\n    let opts = {}\n    let encod\n    switch (typeof options) {\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = opts.encoding\n        delete opts.encoding\n    }\n    const c = new Decoder(opts)\n    const s = (input instanceof stream.Readable) ? input : new NoFilter(\n      input,\n      encod != null ? encod : utils.guessEncoding(input))\n    const res = []\n    while (s.length > 0) {\n      const parser = c._parse()\n      let state = parser.next()\n      while (!state.done) {\n        const b = s.read(state.value)\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data')\n        }\n        state = parser.next(b)\n      }\n      res.push(Decoder.nullcheck(state.value))\n    }\n    return res\n  }\n\n  /**\n   * @callback decodeCallback\n   * @param {Error} [error] - if one was generated\n   * @param {any} [value] - the decoded value\n   */\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are more\n   * bytes left over at the end, and optionally if there were no valid CBOR\n   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n   * if no data was found and the `required` option is false.\n   *\n   * @static\n   * @param {string|Buffer} input - the input to parse\n   * @param {DecodeOptions|decodeCallback|string} [options] - options\n   * @param {decodeCallback} [cb] callback\n   * @returns {Promise<any>} returned even if callback is specified\n   */\n  static decodeFirst(input, options, cb) {\n    let opts = {}\n    let required = false\n    let encod = 'hex'\n    switch (typeof options) {\n      case 'function':\n        cb = options\n        encod = utils.guessEncoding(input)\n        break\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n        required = (opts.required != null) ? opts.required : false\n        delete opts.required\n    }\n    const c = new Decoder(opts)\n    let v = NOT_FOUND\n    const p = new Promise((resolve, reject) => {\n      c.on('data', (val) => {\n        v = Decoder.nullcheck(val)\n        c.close()\n      })\n      c.once('error', (er) => {\n        if (v !== NOT_FOUND) {\n          er.value = v\n        }\n        v = ERROR\n        c.close()\n        return reject(er)\n      })\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'))\n            } else {\n              return resolve(v)\n            }\n          case ERROR:\n            return void 0\n          default:\n            return resolve(v)\n        }\n      })\n    })\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb)\n    }\n    c.end(input, encod)\n    return p\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error - if one was generated\n   * @param {Array} value - all of the decoded values, wrapped in an Array\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {(string|Buffer)} input - the input to parse\n   * @param {(string|Object)} options - Decoding options.\n   *   If string, the input encoding.\n   * @param {decodeAllCallback} cb callback\n   * @returns {Promise<Array>} even if callback is specified\n   */\n  static decodeAll(input, options, cb) {\n    let opts = {}\n    let encod = 'hex'\n    switch (typeof options) {\n      case 'function':\n        cb = options\n        encod = utils.guessEncoding(input)\n        break\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n    }\n    const c = new Decoder(opts)\n    const vals = []\n    c.on('data', (val) => {\n      return vals.push(Decoder.nullcheck(val))\n    })\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject)\n      c.on('end', () => resolve(vals))\n    })\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb)\n    }\n    c.end(input, encod)\n    return p\n  }\n\n  /**\n   * Stop processing\n   */\n  close() {\n    this.running = false\n    this.__fresh = true\n  }\n\n  *_parse() {\n    let parent = null\n    let depth = 0\n    let val = null\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error('Maximum depth ' + this.max_depth + ' exceeded')\n      }\n      const octet = (yield 1)[0]\n      if (!this.running) {\n        throw new Error('Unexpected data: 0x' + (octet.toString(16)))\n      }\n      const mt = octet >> 5\n      const ai = octet & 0x1f\n      const parent_major = (parent != null) ? parent[MAJOR] : undefined\n      const parent_length = (parent != null) ? parent.length : undefined\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length)\n          val = (yield 1)[0]\n          break\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          const numbytes = 1 << (ai - 24)\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)\n          const buf = yield numbytes\n          val = (mt === MT.SIMPLE_FLOAT) ? buf : utils.parseCBORint(ai, buf)\n          break\n        case 28:\n        case 29:\n        case 30:\n          this.running = false\n          throw new Error('Additional info not implemented: ' + ai)\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`)\n          }\n          val = -1\n          break\n        default:\n          val = ai\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // val already decoded\n          break\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BN.NEG_MAX\n          } else if (val instanceof bignumber) {\n            val = BN.MINUS_ONE.minus(val)\n          } else {\n            val = -1 - val\n          }\n          break\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = (mt === MT.BYTE_STRING) ? Buffer.allocUnsafe(0) : ''\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentBufferStream(parent, mt)\n              depth++\n              continue\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = yield val\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val)\n              }\n          }\n          break\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = (mt === MT.MAP) ? {} : []\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentArray(parent, mt, -1)\n              depth++\n              continue\n            default:\n              this.emit('start', mt, val, parent_major, parent_length)\n              parent = parentArray(parent, mt, val * (mt - 3))\n              depth++\n              continue\n          }\n          break\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length)\n          parent = parentArray(parent, mt, 1)\n          parent.push(val)\n          depth++\n          continue\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              )\n            }\n            const hasParent = (parent != null)\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0))\n          } else {\n            val = utils.parseCBORfloat(val)\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai)\n      let again = false\n      while (parent != null) {\n        switch (false) {\n          case val !== SYMS.BREAK:\n            parent[COUNT] = 1\n            break\n          case !Array.isArray(parent):\n            parent.push(val)\n            break\n          case !(parent instanceof NoFilter):\n            const pm = parent[MAJOR]\n            if ((pm != null) && (pm !== mt)) {\n              this.running = false\n              throw new Error('Invalid major type in indefinite encoding')\n            }\n            parent.write(val)\n        }\n        if ((--parent[COUNT]) !== 0) {\n          again = true\n          break\n        }\n        --depth\n        delete parent[COUNT]\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent\n              break\n            case MT.MAP:\n              let allstrings = true\n              if ((parent.length % 2) !== 0) {\n                throw new Error('Invalid map length: ' + parent.length)\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if (typeof parent[i] !== 'string') {\n                  allstrings = false\n                  break\n                }\n              }\n              if (allstrings) {\n                val = {}\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val[parent[i]] = parent[i + 1]\n                }\n              } else {\n                val = new Map\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val.set(parent[i], parent[i + 1])\n                }\n              }\n              break\n            case MT.TAG:\n              const t = new Tagged(parent[0], parent[1])\n              val = t.convert(this.tags)\n              break\n          }\n        } else if (parent instanceof NoFilter) {\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice()\n              break\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8')\n              break\n          }\n        }\n        this.emit('stop', parent[MAJOR])\n\n        const old = parent\n        parent = parent[SYMS.PARENT]\n        delete old[SYMS.PARENT]\n        delete old[MAJOR]\n      }\n      if (!again) {\n        return val\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND\nmodule.exports = Decoder\n"]},"metadata":{},"sourceType":"script"}