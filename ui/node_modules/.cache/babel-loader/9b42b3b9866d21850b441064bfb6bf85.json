{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar encoder = require('./encoder');\n\nvar decoder = require('./decoder');\n\nvar constants = require('./constants');\n\nvar MT = constants.MT;\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @class CborMap\n * @extends {Map}\n */\n\nvar CborMap = /*#__PURE__*/function (_Map) {\n  _inherits(CborMap, _Map);\n\n  var _super = _createSuper(CborMap);\n\n  /**\n   * Creates an instance of CborMap.\n   * @param {Iterable<any, any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  function CborMap(iterable) {\n    _classCallCheck(this, CborMap);\n\n    return _super.call(this, iterable);\n  }\n  /**\n   * @private\n   */\n\n\n  _createClass(CborMap, [{\n    key: \"get\",\n    value:\n    /**\n     * Retrieve a specified element.\n     *\n     * @param {any} key The key identifying the element to retrieve.\n     *   Can be any type, which will be serialized into CBOR and compared by\n     *   value.\n     * @returns {any} The element if it exists, or <code>undefined</code>.\n     */\n    function get(key) {\n      return _get(_getPrototypeOf(CborMap.prototype), \"get\", this).call(this, CborMap._encode(key));\n    }\n    /**\n     * Adds or updates an element with a specified key and value.\n     *\n     * @param {any} key The key identifying the element to store.\n     *   Can be any type, which will be serialized into CBOR and compared by\n     *   value.\n     * @param {any} val The element to store\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, val) {\n      return _get(_getPrototypeOf(CborMap.prototype), \"set\", this).call(this, CborMap._encode(key), val);\n    }\n    /**\n     * Removes the specified element.\n     *\n     * @param {any} key The key identifying the element to delete.\n     *   Can be any type, which will be serialized into CBOR and compared by\n     *   value.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      return _get(_getPrototypeOf(CborMap.prototype), \"delete\", this).call(this, CborMap._encode(key));\n    }\n    /**\n     * Does an element with the specified key exist?\n     *\n     * @param {any} key The key identifying the element to check.\n     *   Can be any type, which will be serialized into CBOR and compared by\n     *   value.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return _get(_getPrototypeOf(CborMap.prototype), \"has\", this).call(this, CborMap._encode(key));\n    }\n    /**\n     * Returns a new Iterator object that contains the keys for each element\n     * in the Map object in insertion order.  The keys are decoded into their\n     * original format.\n     *\n     * @returns {IterableIterator<any>}\n     */\n\n  }, {\n    key: \"keys\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function keys() {\n      var _iterator, _step, k;\n\n      return _regeneratorRuntime.wrap(function keys$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelper(_get(_getPrototypeOf(CborMap.prototype), \"keys\", this).call(this));\n              _context.prev = 1;\n\n              _iterator.s();\n\n            case 3:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 9;\n                break;\n              }\n\n              k = _step.value;\n              _context.next = 7;\n              return CborMap._decode(k);\n\n            case 7:\n              _context.next = 3;\n              break;\n\n            case 9:\n              _context.next = 14;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](1);\n\n              _iterator.e(_context.t0);\n\n            case 14:\n              _context.prev = 14;\n\n              _iterator.f();\n\n              return _context.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, keys, this, [[1, 11, 14, 17]]);\n    })\n    /**\n     * Returns a new Iterator object that contains the [key, value] pairs for\n     * each element in the Map object in insertion order.\n     *\n     * @returns {IterableIterator}\n     */\n\n  }, {\n    key: \"entries\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function entries() {\n      var _iterator2, _step2, kv;\n\n      return _regeneratorRuntime.wrap(function entries$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iterator2 = _createForOfIteratorHelper(_get(_getPrototypeOf(CborMap.prototype), \"entries\", this).call(this));\n              _context2.prev = 1;\n\n              _iterator2.s();\n\n            case 3:\n              if ((_step2 = _iterator2.n()).done) {\n                _context2.next = 9;\n                break;\n              }\n\n              kv = _step2.value;\n              _context2.next = 7;\n              return [CborMap._decode(kv[0]), kv[1]];\n\n            case 7:\n              _context2.next = 3;\n              break;\n\n            case 9:\n              _context2.next = 14;\n              break;\n\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](1);\n\n              _iterator2.e(_context2.t0);\n\n            case 14:\n              _context2.prev = 14;\n\n              _iterator2.f();\n\n              return _context2.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, entries, this, [[1, 11, 14, 17]]);\n    })\n    /**\n     * Returns a new Iterator object that contains the [key, value] pairs for\n     * each element in the Map object in insertion order.\n     *\n     * @returns {IterableIterator}\n     */\n\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this.entries();\n    }\n    /**\n     * Executes a provided function once per each key/value pair in the Map\n     * object, in insertion order.\n     *\n     * @param {function(any, any, Map): undefined} fun Function to execute for\n     *  each element, which takes a value, a key, and the Map being traversed.\n     * @param {any} thisArg Value to use as this when executing callback\n     */\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(fun, thisArg) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('Must be function');\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(_get(_getPrototypeOf(CborMap.prototype), \"entries\", this).call(this)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var kv = _step3.value;\n          fun.call(this, kv[1], CborMap._decode(kv[0]), this);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * Push the simple value onto the CBOR stream\n     *\n     * @param {Object} gen The generator to push onto\n     * @returns {boolean} true on success\n     */\n\n  }, {\n    key: \"encodeCBOR\",\n    value: function encodeCBOR(gen) {\n      if (!gen._pushInt(this.size, MT.MAP)) {\n        return false;\n      }\n\n      if (gen.canonical) {\n        var _entries = Array.from(_get(_getPrototypeOf(CborMap.prototype), \"entries\", this).call(this)).map(function (kv) {\n          return [Buffer.from(kv[0], 'base64'), kv[1]];\n        });\n\n        _entries.sort(function (a, b) {\n          return a[0].compare(b[0]);\n        });\n\n        var _iterator4 = _createForOfIteratorHelper(_entries),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var kv = _step4.value;\n\n            if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        var _iterator5 = _createForOfIteratorHelper(_get(_getPrototypeOf(CborMap.prototype), \"entries\", this).call(this)),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _kv = _step5.value;\n\n            if (!(gen.push(Buffer.from(_kv[0], 'base64')) && gen.pushAny(_kv[1]))) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n\n      return true;\n    }\n  }], [{\n    key: \"_encode\",\n    value: function _encode(key) {\n      return encoder.encodeCanonical(key).toString('base64');\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_decode\",\n    value: function _decode(key) {\n      return decoder.decodeFirstSync(key, 'base64');\n    }\n  }]);\n\n  return CborMap;\n}( /*#__PURE__*/_wrapNativeSuper(Map));\n\nmodule.exports = CborMap;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/cbor/lib/map.js"],"names":["encoder","require","decoder","constants","MT","CborMap","iterable","key","_encode","val","k","_decode","kv","Symbol","iterator","entries","fun","thisArg","TypeError","call","gen","_pushInt","size","MAP","canonical","Array","from","map","Buffer","sort","a","b","compare","push","pushAny","encodeCanonical","toString","decodeFirstSync","Map","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst encoder = require('./encoder')\nconst decoder = require('./decoder')\nconst constants = require('./constants')\nconst MT = constants.MT\n\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @class CborMap\n * @extends {Map}\n */\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   * @param {Iterable<any, any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable)\n  }\n\n  /**\n   * @private\n   */\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64')\n  }\n\n  /**\n   * @private\n   */\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64')\n  }\n\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n  get(key) {\n    return super.get(CborMap._encode(key))\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store\n   */\n  set(key, val) {\n    return super.set(CborMap._encode(key), val)\n  }\n\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean}\n   */\n  delete(key) {\n    return super.delete(CborMap._encode(key))\n  }\n\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean}\n   */\n  has(key) {\n    return super.has(CborMap._encode(key))\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @returns {IterableIterator<any>}\n   */\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k)\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator}\n   */\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]]\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map): undefined} fun Function to execute for\n   *  each element, which takes a value, a key, and the Map being traversed.\n   * @param {any} thisArg Value to use as this when executing callback\n   */\n  forEach(fun, thisArg) {\n    if (typeof(fun) !== 'function') {\n      throw new TypeError('Must be function')\n    }\n    for (const kv of super.entries()) {\n      fun.call(this, kv[1], CborMap._decode(kv[0]), this)\n    }\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   * @returns {boolean} true on success\n   */\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false\n    }\n    if (gen.canonical) {\n      const entries = Array.from(super.entries())\n        .map((kv) => [Buffer.from(kv[0], 'base64'), kv[1]])\n      entries.sort((a, b) => a[0].compare(b[0]))\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n}\n\nmodule.exports = CborMap\n"]},"metadata":{},"sourceType":"script"}