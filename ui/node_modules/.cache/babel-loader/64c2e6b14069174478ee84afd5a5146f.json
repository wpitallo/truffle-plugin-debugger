{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _defineProperty = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeContexts = exports.matchContext = exports.findContext = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:contexts:utils\");\n\nvar Evm = __importStar(require(\"../evm\"));\n\nvar lodash_escaperegexp_1 = __importDefault(require(\"lodash.escaperegexp\"));\n\nvar cbor = __importStar(require(\"cbor\"));\n\nfunction findContext(contexts, binary) {\n  var matchingContexts = Object.values(contexts).filter(function (context) {\n    return matchContext(context, binary);\n  }); //rather than just pick an arbitrary matching context, we're going\n  //to pick one that isn't a descendant of any of the others.\n  //(if there are multiple of *those*, then yeah it's arbitrary.)\n\n  var context = matchingContexts.find(function (descendant) {\n    return !matchingContexts.some(function (ancestor) {\n      return descendant.compilationId === ancestor.compilationId && descendant.linearizedBaseContracts && ancestor.contractId !== undefined && descendant.linearizedBaseContracts.slice(1).includes(ancestor.contractId);\n    } //we do slice one because everything is an an ancestor of itself; we only\n    //care about *proper* ancestors\n    );\n  });\n  return context || null;\n}\n\nexports.findContext = findContext;\n\nfunction matchContext(context, givenBinary) {\n  var binary = context.binary,\n      isConstructor = context.isConstructor;\n  var lengthDifference = givenBinary.length - binary.length; //first: if it's not a constructor, they'd better be equal in length.\n  //if it is a constructor, the given binary must be at least as long,\n  //and the difference must be a multiple of 64\n\n  if (!isConstructor && lengthDifference !== 0 || lengthDifference < 0 || lengthDifference % (2 * Evm.Utils.WORD_SIZE) !== 0) {\n    return false;\n  }\n\n  for (var i = 0; i < binary.length; i++) {\n    //note: using strings like arrays is kind of dangerous in general in JS,\n    //but everything here is ASCII so it's fine\n    //note that we need to compare case-insensitive, since Solidity will\n    //put addresses in checksum case in the compiled source\n    //(we don't actually need that second toLowerCase(), but whatever)\n    if (binary[i] !== \".\" && binary[i].toLowerCase() !== givenBinary[i].toLowerCase()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.matchContext = matchContext;\n\nfunction normalizeContexts(contexts) {\n  //unfortunately, due to our current link references format, we can't\n  //really use the binary from the artifact directly -- neither for purposes\n  //of matching, nor for purposes of decoding internal functions.  So, we\n  //need to perform this normalization step on our contexts before using\n  //them.  Once we have truffle-db, this step should largely go away.\n  debug(\"normalizing contexts\"); //first, let's clone the input\n  //(let's do a 2-deep clone because we'll be altering binary)\n\n  var newContexts = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(contexts).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        contextHash = _ref2[0],\n        context = _ref2[1];\n\n    return _defineProperty({}, contextHash, Object.assign({}, context));\n  }))));\n  debug(\"contexts cloned\"); //next, we get all the library names and sort them descending by length.\n  //We're going to want to go in descending order of length so that we\n  //don't run into problems when one name is a substring of another.\n  //For simplicity, we'll exclude names of length <38, because we can\n  //handle these with our more general check for link references at the end\n\n  var fillerLength = 2 * Evm.Utils.ADDRESS_SIZE;\n  var names = Object.values(newContexts).filter(function (context) {\n    return context.contractKind === \"library\";\n  }).map(function (context) {\n    return context.contractName;\n  }).filter(function (name) {\n    return name.length >= fillerLength - 3;\n  }) //the -3 is for 2 leading underscores and 1 trailing\n  .sort(function (name1, name2) {\n    return name2.length - name1.length;\n  });\n  debug(\"names sorted\"); //now, we need to turn all these names into regular expressions, because,\n  //unfortunately, str.replace() will only replace all if you use a /g regexp;\n  //note that because names may contain '$', we need to escape them\n  //(also we prepend \"__\" because that's the placeholder format)\n\n  var regexps = names.map(function (name) {\n    return new RegExp(lodash_escaperegexp_1.default(\"__\" + name), \"g\");\n  });\n  debug(\"regexps prepared\"); //having done so, we can do the replace for these names!\n\n  var replacement = \".\".repeat(fillerLength);\n\n  var _iterator = _createForOfIteratorHelper(regexps),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var regexp = _step.value;\n\n      for (var _i6 = 0, _Object$values6 = Object.values(newContexts); _i6 < _Object$values6.length; _i6++) {\n        var _context4 = _Object$values6[_i6];\n        _context4.binary = _context4.binary.replace(regexp, replacement);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  debug(\"long replacements complete\"); //now we can do a generic replace that will catch all names of length\n  //<40, while also catching the Solidity compiler's link reference format\n  //as well as Truffle's.  Hooray!\n\n  var genericRegexp = new RegExp(\"_.{\" + (fillerLength - 2) + \"}_\", \"g\"); //we're constructing the regexp /_.{38}_/g, but I didn't want to use a\n  //literal 38 :P\n\n  for (var _i = 0, _Object$values = Object.values(newContexts); _i < _Object$values.length; _i++) {\n    var context = _Object$values[_i];\n    context.binary = context.binary.replace(genericRegexp, replacement);\n  }\n\n  debug(\"short replacements complete\"); //now we must handle the delegatecall guard -- libraries' deployedBytecode will include\n  //0s in place of their own address instead of a link reference at the\n  //beginning, so we need to account for that too\n\n  var pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n  for (var _i2 = 0, _Object$values2 = Object.values(newContexts); _i2 < _Object$values2.length; _i2++) {\n    var _context = _Object$values2[_i2];\n\n    if (_context.contractKind === \"library\" && !_context.isConstructor) {\n      _context.binary = _context.binary.replace(\"0x\" + pushAddressInstruction + \"00\".repeat(Evm.Utils.ADDRESS_SIZE), \"0x\" + pushAddressInstruction + replacement);\n    }\n  }\n\n  debug(\"extra library replacements complete\"); //now let's handle immutable references\n  //(these are much nicer than link references due to not having to deal with the old format)\n\n  for (var _i3 = 0, _Object$values3 = Object.values(newContexts); _i3 < _Object$values3.length; _i3++) {\n    var _context2 = _Object$values3[_i3];\n\n    if (_context2.immutableReferences) {\n      for (var _i4 = 0, _Object$values4 = Object.values(_context2.immutableReferences); _i4 < _Object$values4.length; _i4++) {\n        var variable = _Object$values4[_i4];\n\n        var _iterator2 = _createForOfIteratorHelper(variable),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _step2.value,\n                start = _step2$value.start,\n                length = _step2$value.length;\n            //Goddammit TS\n            var lowerStringIndex = 2 + 2 * start;\n            var upperStringIndex = 2 + 2 * (start + length);\n            _context2.binary = _context2.binary.slice(0, lowerStringIndex) + \"..\".repeat(length) + _context2.binary.slice(upperStringIndex);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }\n\n  debug(\"immutables complete\"); //one last step: where there's CBOR with a metadata hash, we'll allow the\n  //CBOR to vary, aside from the length (note: ideally here we would *only*\n  //dot-out the metadata hash part of the CBOR, but, well, it's not worth the\n  //trouble to detect that; doing that could potentially get pretty involved)\n  //note that if the code isn't Solidity, that's fine -- we just won't get\n  //valid CBOR and will not end up adding to our list of regular expressions\n\n  var externalCborInfo = Object.values(newContexts).map(function (context) {\n    return extractCborInfo(context.binary);\n  }).filter(function (cborSegment) {\n    return cborSegment !== null && isCborWithHash(cborSegment.cbor);\n  });\n  var cborRegexps = externalCborInfo.map(function (cborInfo) {\n    return {\n      input: new RegExp(cborInfo.cborSegment, \"g\"),\n      output: \"..\".repeat(cborInfo.cborLength) + cborInfo.cborLengthHex\n    };\n  }); //HACK: we will replace *every* occurrence of *every* external CBOR occurring\n  //in *every* context, in order to cover created contracts (including if there\n  //are multiple or recursive ones)\n\n  for (var _i5 = 0, _Object$values5 = Object.values(newContexts); _i5 < _Object$values5.length; _i5++) {\n    var _context3 = _Object$values5[_i5];\n\n    var _iterator3 = _createForOfIteratorHelper(cborRegexps),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _step3.value,\n            input = _step3$value.input,\n            output = _step3$value.output;\n        _context3.binary = _context3.binary.replace(input, output);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  debug(\"external wildcards complete\"); //finally, return this mess!\n\n  return newContexts;\n}\n\nexports.normalizeContexts = normalizeContexts;\n\nfunction extractCborInfo(binary) {\n  debug(\"extracting cbor segement of %s\", binary);\n  var lastTwoBytes = binary.slice(2).slice(-2 * 2); //2 bytes * 2 for hex\n  //the slice(2) there may seem unnecessary; it's to handle the possibility that the contract\n  //has less than two bytes in its bytecode (that won't happen with Solidity, but let's be\n  //certain)\n\n  if (lastTwoBytes.length < 2 * 2) {\n    return null; //don't try to handle this case!\n  }\n\n  var cborLength = parseInt(lastTwoBytes, 16);\n  var cborEnd = binary.length - 2 * 2;\n  var cborStart = cborEnd - cborLength * 2; //sanity check\n\n  if (cborStart < 2) {\n    //\"0x\"\n    return null; //don't try to handle this case!\n  }\n\n  var cbor = binary.slice(cborStart, cborEnd);\n  return {\n    cborStart: cborStart,\n    cborLength: cborLength,\n    cborEnd: cborEnd,\n    cborLengthHex: lastTwoBytes,\n    cbor: cbor,\n    cborSegment: cbor + lastTwoBytes\n  };\n}\n\nfunction isCborWithHash(encoded) {\n  debug(\"checking cbor, encoed: %s\", encoded);\n  var decoded;\n\n  try {\n    //note this *will* throw if there's data left over,\n    //which is what we want it to do\n    decoded = cbor.decodeFirstSync(encoded);\n  } catch (_a) {\n    debug(\"invalid cbor!\");\n    return false;\n  }\n\n  debug(\"decoded: %O\", decoded);\n\n  if (typeof decoded !== \"object\") {\n    return false;\n  } //borc sometimes returns maps and sometimes objects,\n  //so let's make things consistent by converting to a map\n\n\n  if (!(decoded instanceof Map)) {\n    decoded = new Map(Object.entries(decoded));\n  }\n\n  var hashKeys = [\"bzzr0\", \"bzzr1\", \"ipfs\"];\n  return hashKeys.some(function (key) {\n    return decoded.has(key);\n  });\n}","map":{"version":3,"sources":["../../../lib/contexts/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeContexts = exports.matchContext = exports.findContext = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:contexts:utils\");\nconst Evm = __importStar(require(\"../evm\"));\nconst lodash_escaperegexp_1 = __importDefault(require(\"lodash.escaperegexp\"));\nconst cbor = __importStar(require(\"cbor\"));\nfunction findContext(contexts, binary) {\n    const matchingContexts = Object.values(contexts).filter(context => matchContext(context, binary));\n    //rather than just pick an arbitrary matching context, we're going\n    //to pick one that isn't a descendant of any of the others.\n    //(if there are multiple of *those*, then yeah it's arbitrary.)\n    const context = matchingContexts.find(descendant => !matchingContexts.some(ancestor => descendant.compilationId === ancestor.compilationId &&\n        descendant.linearizedBaseContracts &&\n        ancestor.contractId !== undefined &&\n        descendant.linearizedBaseContracts\n            .slice(1)\n            .includes(ancestor.contractId)\n    //we do slice one because everything is an an ancestor of itself; we only\n    //care about *proper* ancestors\n    ));\n    return context || null;\n}\nexports.findContext = findContext;\nfunction matchContext(context, givenBinary) {\n    let { binary, isConstructor } = context;\n    let lengthDifference = givenBinary.length - binary.length;\n    //first: if it's not a constructor, they'd better be equal in length.\n    //if it is a constructor, the given binary must be at least as long,\n    //and the difference must be a multiple of 64\n    if ((!isConstructor && lengthDifference !== 0) ||\n        lengthDifference < 0 ||\n        lengthDifference % (2 * Evm.Utils.WORD_SIZE) !== 0) {\n        return false;\n    }\n    for (let i = 0; i < binary.length; i++) {\n        //note: using strings like arrays is kind of dangerous in general in JS,\n        //but everything here is ASCII so it's fine\n        //note that we need to compare case-insensitive, since Solidity will\n        //put addresses in checksum case in the compiled source\n        //(we don't actually need that second toLowerCase(), but whatever)\n        if (binary[i] !== \".\" &&\n            binary[i].toLowerCase() !== givenBinary[i].toLowerCase()) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.matchContext = matchContext;\nfunction normalizeContexts(contexts) {\n    //unfortunately, due to our current link references format, we can't\n    //really use the binary from the artifact directly -- neither for purposes\n    //of matching, nor for purposes of decoding internal functions.  So, we\n    //need to perform this normalization step on our contexts before using\n    //them.  Once we have truffle-db, this step should largely go away.\n    debug(\"normalizing contexts\");\n    //first, let's clone the input\n    //(let's do a 2-deep clone because we'll be altering binary)\n    let newContexts = Object.assign({}, ...Object.entries(contexts).map(([contextHash, context]) => ({\n        [contextHash]: Object.assign({}, context)\n    })));\n    debug(\"contexts cloned\");\n    //next, we get all the library names and sort them descending by length.\n    //We're going to want to go in descending order of length so that we\n    //don't run into problems when one name is a substring of another.\n    //For simplicity, we'll exclude names of length <38, because we can\n    //handle these with our more general check for link references at the end\n    const fillerLength = 2 * Evm.Utils.ADDRESS_SIZE;\n    let names = Object.values(newContexts)\n        .filter(context => context.contractKind === \"library\")\n        .map(context => context.contractName)\n        .filter(name => name.length >= fillerLength - 3)\n        //the -3 is for 2 leading underscores and 1 trailing\n        .sort((name1, name2) => name2.length - name1.length);\n    debug(\"names sorted\");\n    //now, we need to turn all these names into regular expressions, because,\n    //unfortunately, str.replace() will only replace all if you use a /g regexp;\n    //note that because names may contain '$', we need to escape them\n    //(also we prepend \"__\" because that's the placeholder format)\n    let regexps = names.map(name => new RegExp(lodash_escaperegexp_1.default(\"__\" + name), \"g\"));\n    debug(\"regexps prepared\");\n    //having done so, we can do the replace for these names!\n    const replacement = \".\".repeat(fillerLength);\n    for (let regexp of regexps) {\n        for (let context of Object.values(newContexts)) {\n            context.binary = context.binary.replace(regexp, replacement);\n        }\n    }\n    debug(\"long replacements complete\");\n    //now we can do a generic replace that will catch all names of length\n    //<40, while also catching the Solidity compiler's link reference format\n    //as well as Truffle's.  Hooray!\n    const genericRegexp = new RegExp(\"_.{\" + (fillerLength - 2) + \"}_\", \"g\");\n    //we're constructing the regexp /_.{38}_/g, but I didn't want to use a\n    //literal 38 :P\n    for (let context of Object.values(newContexts)) {\n        context.binary = context.binary.replace(genericRegexp, replacement);\n    }\n    debug(\"short replacements complete\");\n    //now we must handle the delegatecall guard -- libraries' deployedBytecode will include\n    //0s in place of their own address instead of a link reference at the\n    //beginning, so we need to account for that too\n    const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n    for (let context of Object.values(newContexts)) {\n        if (context.contractKind === \"library\" && !context.isConstructor) {\n            context.binary = context.binary.replace(\"0x\" + pushAddressInstruction + \"00\".repeat(Evm.Utils.ADDRESS_SIZE), \"0x\" + pushAddressInstruction + replacement);\n        }\n    }\n    debug(\"extra library replacements complete\");\n    //now let's handle immutable references\n    //(these are much nicer than link references due to not having to deal with the old format)\n    for (let context of Object.values(newContexts)) {\n        if (context.immutableReferences) {\n            for (let variable of Object.values(context.immutableReferences)) {\n                for (let { start, length } of (variable)) {\n                    //Goddammit TS\n                    let lowerStringIndex = 2 + 2 * start;\n                    let upperStringIndex = 2 + 2 * (start + length);\n                    context.binary =\n                        context.binary.slice(0, lowerStringIndex) +\n                            \"..\".repeat(length) +\n                            context.binary.slice(upperStringIndex);\n                }\n            }\n        }\n    }\n    debug(\"immutables complete\");\n    //one last step: where there's CBOR with a metadata hash, we'll allow the\n    //CBOR to vary, aside from the length (note: ideally here we would *only*\n    //dot-out the metadata hash part of the CBOR, but, well, it's not worth the\n    //trouble to detect that; doing that could potentially get pretty involved)\n    //note that if the code isn't Solidity, that's fine -- we just won't get\n    //valid CBOR and will not end up adding to our list of regular expressions\n    const externalCborInfo = Object.values(newContexts)\n        .map(context => extractCborInfo(context.binary))\n        .filter(cborSegment => cborSegment !== null && isCborWithHash(cborSegment.cbor));\n    const cborRegexps = externalCborInfo.map(cborInfo => ({\n        input: new RegExp(cborInfo.cborSegment, \"g\"),\n        output: \"..\".repeat(cborInfo.cborLength) + cborInfo.cborLengthHex\n    }));\n    //HACK: we will replace *every* occurrence of *every* external CBOR occurring\n    //in *every* context, in order to cover created contracts (including if there\n    //are multiple or recursive ones)\n    for (let context of Object.values(newContexts)) {\n        for (let { input, output } of cborRegexps) {\n            context.binary = context.binary.replace(input, output);\n        }\n    }\n    debug(\"external wildcards complete\");\n    //finally, return this mess!\n    return newContexts;\n}\nexports.normalizeContexts = normalizeContexts;\nfunction extractCborInfo(binary) {\n    debug(\"extracting cbor segement of %s\", binary);\n    const lastTwoBytes = binary.slice(2).slice(-2 * 2); //2 bytes * 2 for hex\n    //the slice(2) there may seem unnecessary; it's to handle the possibility that the contract\n    //has less than two bytes in its bytecode (that won't happen with Solidity, but let's be\n    //certain)\n    if (lastTwoBytes.length < 2 * 2) {\n        return null; //don't try to handle this case!\n    }\n    const cborLength = parseInt(lastTwoBytes, 16);\n    const cborEnd = binary.length - 2 * 2;\n    const cborStart = cborEnd - cborLength * 2;\n    //sanity check\n    if (cborStart < 2) {\n        //\"0x\"\n        return null; //don't try to handle this case!\n    }\n    const cbor = binary.slice(cborStart, cborEnd);\n    return {\n        cborStart,\n        cborLength,\n        cborEnd,\n        cborLengthHex: lastTwoBytes,\n        cbor,\n        cborSegment: cbor + lastTwoBytes\n    };\n}\nfunction isCborWithHash(encoded) {\n    debug(\"checking cbor, encoed: %s\", encoded);\n    let decoded;\n    try {\n        //note this *will* throw if there's data left over,\n        //which is what we want it to do\n        decoded = cbor.decodeFirstSync(encoded);\n    }\n    catch (_a) {\n        debug(\"invalid cbor!\");\n        return false;\n    }\n    debug(\"decoded: %O\", decoded);\n    if (typeof decoded !== \"object\") {\n        return false;\n    }\n    //borc sometimes returns maps and sometimes objects,\n    //so let's make things consistent by converting to a map\n    if (!(decoded instanceof Map)) {\n        decoded = new Map(Object.entries(decoded));\n    }\n    const hashKeys = [\"bzzr0\", \"bzzr1\", \"ipfs\"];\n    return hashKeys.some(key => decoded.has(key));\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}