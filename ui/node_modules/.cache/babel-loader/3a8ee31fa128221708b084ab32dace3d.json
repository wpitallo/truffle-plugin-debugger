{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeBasic),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeContract),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(decodeContractAndContext),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(decodeExternalFunction);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPaddingLeft = exports.decodeInternalFunction = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:basic:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Contexts = __importStar(require(\"../../contexts\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar errors_1 = require(\"../../errors\");\n\nvar allocate_1 = require(\"../allocate\");\n\nfunction decodeBasic(dataType, pointer, info) {\n  var options,\n      state,\n      strict,\n      paddingMode,\n      bytes,\n      rawBytes,\n      error,\n      numeric,\n      _error,\n      _error2,\n      _error3,\n      _error4,\n      _error5,\n      fullType,\n      contractValueInfo,\n      coercedDataType,\n      _error6,\n      _error7,\n      address,\n      selector,\n      deployedPc,\n      constructorPc,\n      _numeric,\n      _fullType,\n      _error8,\n      numOptions,\n      numBytes,\n      paddingType,\n      _error9,\n      name,\n      _error10,\n      _error11,\n      asBN,\n      rawAsBN,\n      asBig,\n      rawAsBig,\n      _error12,\n      _asBN,\n      _rawAsBN,\n      _asBig,\n      _rawAsBig,\n      _args = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeBasic$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n          state = info.state;\n          strict = options.strictAbiMode; //if this is undefined it'll still be falsy so it's OK\n\n          paddingMode = options.paddingMode || \"default\";\n          _context.prev = 4;\n          return _context.delegateYield(read_1.default(pointer, state), \"t0\", 6);\n\n        case 6:\n          bytes = _context.t0;\n          _context.next = 13;\n          break;\n\n        case 9:\n          _context.prev = 9;\n          _context.t1 = _context[\"catch\"](4);\n          debug(\"segfault, pointer %o, state: %O\", pointer, state);\n          return _context.abrupt(\"return\", errors_1.handleDecodingError(dataType, _context.t1, strict));\n\n        case 13:\n          rawBytes = bytes;\n          debug(\"type %O\", dataType);\n          debug(\"pointer %o\", pointer);\n          _context.t2 = dataType.typeClass;\n          _context.next = _context.t2 === \"bool\" ? 19 : _context.t2 === \"uint\" ? 38 : _context.t2 === \"int\" ? 45 : _context.t2 === \"address\" ? 52 : _context.t2 === \"contract\" ? 59 : _context.t2 === \"bytes\" ? 69 : _context.t2 === \"function\" ? 77 : _context.t2 === \"enum\" ? 101 : _context.t2 === \"fixed\" ? 127 : _context.t2 === \"ufixed\" ? 138 : 149;\n          break;\n\n        case 19:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 24;\n            break;\n          }\n\n          error = {\n            kind: \"BoolPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 23;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(error);\n\n        case 23:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: error\n          });\n\n        case 24:\n          bytes = removePadding(bytes, dataType, paddingMode); //note: the use of the BN is a little silly here,\n          //but, kind of stuck with it for now\n\n          numeric = Conversion.toBN(bytes);\n\n          if (!numeric.eqn(0)) {\n            _context.next = 30;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: false\n            }\n          });\n\n        case 30:\n          if (!numeric.eqn(1)) {\n            _context.next = 34;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          });\n\n        case 34:\n          _error = {\n            kind: \"BoolOutOfRangeError\",\n            rawAsBN: numeric\n          };\n\n          if (!strict) {\n            _context.next = 37;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error);\n\n        case 37:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error\n          });\n\n        case 38:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 43;\n            break;\n          }\n\n          _error2 = {\n            kind: \"UintPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 42;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error2);\n\n        case 42:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error2\n          });\n\n        case 43:\n          //now, truncate to appropriate length\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBN: Conversion.toBN(bytes),\n              rawAsBN: Conversion.toBN(rawBytes)\n            }\n          });\n\n        case 45:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 50;\n            break;\n          }\n\n          _error3 = {\n            kind: \"IntPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 49;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error3);\n\n        case 49:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error3\n          });\n\n        case 50:\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBN: Conversion.toSignedBN(bytes),\n              rawAsBN: Conversion.toSignedBN(rawBytes)\n            }\n          });\n\n        case 52:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 57;\n            break;\n          }\n\n          _error4 = {\n            kind: \"AddressPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 56;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error4);\n\n        case 56:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error4\n          });\n\n        case 57:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asAddress: Evm.Utils.toAddress(bytes),\n              rawAsHex: Conversion.toHexString(rawBytes)\n            }\n          });\n\n        case 59:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 64;\n            break;\n          }\n\n          _error5 = {\n            kind: \"ContractPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 63;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error5);\n\n        case 63:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error5\n          });\n\n        case 64:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n          return _context.delegateYield(decodeContract(bytes, info), \"t3\", 67);\n\n        case 67:\n          contractValueInfo = _context.t3;\n          return _context.abrupt(\"return\", {\n            type: fullType,\n            kind: \"value\",\n            value: contractValueInfo\n          });\n\n        case 69:\n          //NOTE: we assume this is a *static* bytestring,\n          //because this is decodeBasic! dynamic ones should\n          //go to decodeBytes!\n          coercedDataType = dataType; //first, check padding (if needed)\n\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 75;\n            break;\n          }\n\n          _error6 = {\n            kind: \"BytesPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 74;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error6);\n\n        case 74:\n          return _context.abrupt(\"return\", {\n            type: coercedDataType,\n            kind: \"error\",\n            error: _error6\n          });\n\n        case 75:\n          //now, truncate to appropriate length\n          bytes = removePadding(bytes, dataType, paddingMode);\n          return _context.abrupt(\"return\", {\n            type: coercedDataType,\n            kind: \"value\",\n            value: {\n              asHex: Conversion.toHexString(bytes),\n              rawAsHex: Conversion.toHexString(rawBytes)\n            }\n          });\n\n        case 77:\n          _context.t4 = dataType.visibility;\n          _context.next = _context.t4 === \"external\" ? 80 : _context.t4 === \"internal\" ? 92 : 100;\n          break;\n\n        case 80:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 85;\n            break;\n          }\n\n          _error7 = {\n            kind: \"FunctionExternalNonStackPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 84;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error7);\n\n        case 84:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error7\n          });\n\n        case 85:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n          selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n          _context.t5 = dataType;\n          return _context.delegateYield(decodeExternalFunction(address, selector, info), \"t6\", 90);\n\n        case 90:\n          _context.t7 = _context.t6;\n          return _context.abrupt(\"return\", {\n            type: _context.t5,\n            kind: \"value\",\n            value: _context.t7\n          });\n\n        case 92:\n          if (!strict) {\n            _context.next = 94;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError({\n            kind: \"InternalFunctionInABIError\"\n          });\n\n        case 94:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 96;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"FunctionInternalPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            }\n          });\n\n        case 96:\n          bytes = removePadding(bytes, dataType, paddingMode);\n          deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n          constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n          return _context.abrupt(\"return\", decodeInternalFunction(dataType, deployedPc, constructorPc, info));\n\n        case 100:\n          return _context.abrupt(\"break\", 149);\n\n        case 101:\n          _numeric = Conversion.toBN(bytes);\n          _fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n          if (_fullType.options) {\n            _context.next = 108;\n            break;\n          }\n\n          _error8 = {\n            kind: \"EnumNotFoundDecodingError\",\n            type: _fullType,\n            rawAsBN: _numeric\n          };\n\n          if (!(strict || options.allowRetry)) {\n            _context.next = 107;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error8, true);\n\n        case 107:\n          return _context.abrupt(\"return\", {\n            type: _fullType,\n            kind: \"error\",\n            error: _error8\n          });\n\n        case 108:\n          //note: I'm doing the padding checks a little more manually on this one\n          //so that we can have the right type of error\n          numOptions = _fullType.options.length;\n          numBytes = Math.ceil(Math.log2(numOptions) / 8);\n          paddingType = getPaddingType(dataType, paddingMode);\n\n          if (checkPaddingDirect(bytes, numBytes, paddingType)) {\n            _context.next = 116;\n            break;\n          }\n\n          _error9 = {\n            kind: \"EnumPaddingError\",\n            type: _fullType,\n            paddingType: paddingType,\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 115;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error9);\n\n        case 115:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error9\n          });\n\n        case 116:\n          bytes = removePaddingDirect(bytes, numBytes, paddingType);\n          _numeric = Conversion.toBN(bytes); //alter numeric!\n\n          if (!_numeric.ltn(numOptions)) {\n            _context.next = 123;\n            break;\n          }\n\n          name = _fullType.options[_numeric.toNumber()]; //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n          //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n          //an enum with that many options in the first place, we have bigger problems!\n\n          return _context.abrupt(\"return\", {\n            type: _fullType,\n            kind: \"value\",\n            value: {\n              name: name,\n              numericAsBN: _numeric\n            }\n          });\n\n        case 123:\n          _error10 = {\n            kind: \"EnumOutOfRangeError\",\n            type: _fullType,\n            rawAsBN: _numeric\n          };\n\n          if (!strict) {\n            _context.next = 126;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error10);\n\n        case 126:\n          return _context.abrupt(\"return\", {\n            type: _fullType,\n            kind: \"error\",\n            error: _error10\n          });\n\n        case 127:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 132;\n            break;\n          }\n\n          _error11 = {\n            kind: \"FixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 131;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error11);\n\n        case 131:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error11\n          });\n\n        case 132:\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          asBN = Conversion.toSignedBN(bytes);\n          rawAsBN = Conversion.toSignedBN(rawBytes);\n          asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n          rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig: asBig,\n              rawAsBig: rawAsBig\n            }\n          });\n\n        case 138:\n          if (checkPadding(bytes, dataType, paddingMode)) {\n            _context.next = 143;\n            break;\n          }\n\n          _error12 = {\n            kind: \"UfixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (!strict) {\n            _context.next = 142;\n            break;\n          }\n\n          throw new errors_1.StopDecodingError(_error12);\n\n        case 142:\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _error12\n          });\n\n        case 143:\n          //now, truncate to appropriate length (keeping the bytes on the right)\n          bytes = removePadding(bytes, dataType, paddingMode);\n          _asBN = Conversion.toBN(bytes);\n          _rawAsBN = Conversion.toBN(rawBytes);\n          _asBig = Conversion.shiftBigDown(Conversion.toBig(_asBN), dataType.places);\n          _rawAsBig = Conversion.shiftBigDown(Conversion.toBig(_rawAsBN), dataType.places);\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBig: _asBig,\n              rawAsBig: _rawAsBig\n            }\n          });\n\n        case 149:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[4, 9]]);\n}\n\nexports.decodeBasic = decodeBasic; //NOTE that this function returns a ContractValueInfo, not a ContractResult\n\nfunction decodeContract(addressBytes, info) {\n  return _regeneratorRuntime.wrap(function decodeContract$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          return _context2.delegateYield(decodeContractAndContext(addressBytes, info), \"t0\", 1);\n\n        case 1:\n          return _context2.abrupt(\"return\", _context2.t0.contractInfo);\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nexports.decodeContract = decodeContract;\n\nfunction decodeContractAndContext(addressBytes, info) {\n  var address, rawAddress, codeBytes, code, context;\n  return _regeneratorRuntime.wrap(function decodeContractAndContext$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          address = Evm.Utils.toAddress(addressBytes);\n          rawAddress = Conversion.toHexString(addressBytes);\n          _context3.next = 4;\n          return {\n            type: \"code\",\n            address: address\n          };\n\n        case 4:\n          codeBytes = _context3.sent;\n          code = Conversion.toHexString(codeBytes);\n          context = Contexts.Utils.findContext(info.contexts, code);\n\n          if (!(context !== null)) {\n            _context3.next = 11;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            context: context,\n            contractInfo: {\n              kind: \"known\",\n              address: address,\n              rawAddress: rawAddress,\n              class: Contexts.Import.contextToType(context)\n            }\n          });\n\n        case 11:\n          return _context3.abrupt(\"return\", {\n            context: context,\n            contractInfo: {\n              kind: \"unknown\",\n              address: address,\n              rawAddress: rawAddress\n            }\n          });\n\n        case 12:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n} //note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\n\n\nfunction decodeExternalFunction(addressBytes, selectorBytes, info) {\n  var _yield$decodeContract, contract, context, selector, abiEntry;\n\n  return _regeneratorRuntime.wrap(function decodeExternalFunction$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.delegateYield(decodeContractAndContext(addressBytes, info), \"t0\", 1);\n\n        case 1:\n          _yield$decodeContract = _context4.t0;\n          contract = _yield$decodeContract.contractInfo;\n          context = _yield$decodeContract.context;\n          selector = Conversion.toHexString(selectorBytes);\n\n          if (!(contract.kind === \"unknown\")) {\n            _context4.next = 7;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", {\n            kind: \"unknown\",\n            contract: contract,\n            selector: selector\n          });\n\n        case 7:\n          abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n\n          if (!(abiEntry === undefined)) {\n            _context4.next = 10;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", {\n            kind: \"invalid\",\n            contract: contract,\n            selector: selector\n          });\n\n        case 10:\n          return _context4.abrupt(\"return\", {\n            kind: \"known\",\n            contract: contract,\n            selector: selector,\n            abi: abiEntry\n          });\n\n        case 11:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n}\n\nexports.decodeExternalFunction = decodeExternalFunction; //this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\n//also note, I haven't put the same sort of error-handling in this one since it's only intended to run with full info (for now, anyway)\n\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info) {\n  var deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n  var constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n  var context = Contexts.Import.contextToType(info.currentContext); //before anything else: do we even have an internal functions table?\n  //if not, we'll just return the info we have without really attemting to decode\n\n  if (!info.internalFunctionsTable) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"unknown\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //also before we continue: is the PC zero? if so let's just return that\n\n\n  if (deployedPc === 0 && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //another check: is only the deployed PC zero?\n\n\n  if (deployedPc === 0 && constructorPc !== 0) {\n    return {\n      type: dataType,\n      kind: \"error\",\n      error: {\n        kind: \"MalformedInternalFunctionError\",\n        context: context,\n        deployedProgramCounter: 0,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //one last pre-check: is this a deployed-format pointer in a constructor?\n\n\n  if (info.currentContext.isConstructor && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"error\",\n      error: {\n        kind: \"DeployedFunctionInConstructorError\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: 0\n      }\n    };\n  } //otherwise, we get our function\n\n\n  var pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n  var functionEntry = info.internalFunctionsTable[pc];\n\n  if (!functionEntry) {\n    //if it's not zero and there's no entry... error!\n    return {\n      type: dataType,\n      kind: \"error\",\n      error: {\n        kind: \"NoSuchInternalFunctionError\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n\n  if (functionEntry.isDesignatedInvalid) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context: context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n\n  var name = functionEntry.name;\n  var mutability = functionEntry.mutability;\n  var definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null\n\n  var id = Evm.Import.makeInternalFunctionId(functionEntry);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"function\",\n      context: context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc,\n      name: name,\n      id: id,\n      definedIn: definedIn,\n      mutability: mutability\n    }\n  };\n}\n\nexports.decodeInternalFunction = decodeInternalFunction;\n\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  var length = allocate_1.byteLength(dataType, userDefinedTypes);\n  var paddingType = getPaddingType(dataType, paddingMode);\n\n  if (paddingMode === \"permissive\") {\n    switch (dataType.typeClass) {\n      case \"bool\":\n      case \"enum\":\n      case \"function\":\n        //these three types are checked even in permissive mode\n        return checkPaddingDirect(bytes, length, paddingType);\n\n      default:\n        return true;\n    }\n  } else {\n    return checkPaddingDirect(bytes, length, paddingType);\n  }\n}\n\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  var length = allocate_1.byteLength(dataType, userDefinedTypes);\n  var paddingType = getPaddingType(dataType, paddingMode);\n  return removePaddingDirect(bytes, length, paddingType);\n}\n\nfunction removePaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n    case \"signed\":\n      return bytes.slice(-length);\n\n    case \"right\":\n      return bytes.slice(0, length);\n  }\n}\n\nfunction checkPaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n      return checkPaddingLeft(bytes, length);\n\n    case \"right\":\n      return checkPaddingRight(bytes, length);\n\n    case \"signed\":\n      return checkPaddingSigned(bytes, length);\n  }\n}\n\nfunction getPaddingType(dataType, paddingMode) {\n  switch (paddingMode) {\n    case \"right\":\n      return \"right\";\n\n    case \"default\":\n    case \"permissive\":\n      return defaultPaddingType(dataType);\n\n    case \"zero\":\n      var defaultType = defaultPaddingType(dataType);\n      return defaultType === \"signed\" ? \"left\" : defaultType;\n  }\n}\n\nfunction defaultPaddingType(dataType) {\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      return \"right\";\n\n    case \"int\":\n    case \"fixed\":\n      return \"signed\";\n\n    case \"function\":\n      if (dataType.visibility === \"external\") {\n        return \"right\";\n      }\n\n    //otherwise, fall through to default\n\n    default:\n      return \"left\";\n  }\n}\n\nfunction checkPaddingRight(bytes, length) {\n  var padding = bytes.slice(length); //cut off the first length bytes\n\n  return padding.every(function (paddingByte) {\n    return paddingByte === 0;\n  });\n} //exporting this one for use in stack.ts\n\n\nfunction checkPaddingLeft(bytes, length) {\n  var padding = bytes.slice(0, -length); //cut off the last length bytes\n\n  return padding.every(function (paddingByte) {\n    return paddingByte === 0;\n  });\n}\n\nexports.checkPaddingLeft = checkPaddingLeft;\n\nfunction checkPaddingSigned(bytes, length) {\n  var padding = bytes.slice(0, -length); //padding is all but the last length bytes\n\n  var value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n\n  var signByte = value[0] & 0x80 ? 0xff : 0x00;\n  return padding.every(function (paddingByte) {\n    return paddingByte === signByte;\n  });\n}","map":{"version":3,"sources":["../../../../lib/basic/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkPaddingLeft = exports.decodeInternalFunction = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:basic:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Contexts = __importStar(require(\"../../contexts\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nconst allocate_1 = require(\"../allocate\");\nfunction* decodeBasic(dataType, pointer, info, options = {}) {\n    const { state } = info;\n    const { strictAbiMode: strict } = options; //if this is undefined it'll still be falsy so it's OK\n    const paddingMode = options.paddingMode || \"default\";\n    let bytes;\n    let rawBytes;\n    try {\n        bytes = yield* read_1.default(pointer, state);\n    }\n    catch (error) {\n        debug(\"segfault, pointer %o, state: %O\", pointer, state);\n        return errors_1.handleDecodingError(dataType, error, strict);\n    }\n    rawBytes = bytes;\n    debug(\"type %O\", dataType);\n    debug(\"pointer %o\", pointer);\n    switch (dataType.typeClass) {\n        case \"bool\": {\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"BoolPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            //note: the use of the BN is a little silly here,\n            //but, kind of stuck with it for now\n            const numeric = Conversion.toBN(bytes);\n            if (numeric.eqn(0)) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    value: { asBoolean: false }\n                };\n            }\n            else if (numeric.eqn(1)) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    value: { asBoolean: true }\n                };\n            }\n            else {\n                let error = {\n                    kind: \"BoolOutOfRangeError\",\n                    rawAsBN: numeric\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n        }\n        case \"uint\":\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"UintPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBN: Conversion.toBN(bytes),\n                    rawAsBN: Conversion.toBN(rawBytes)\n                }\n            };\n        case \"int\":\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"IntPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length (keeping the bytes on the right)\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBN: Conversion.toSignedBN(bytes),\n                    rawAsBN: Conversion.toSignedBN(rawBytes)\n                }\n            };\n        case \"address\":\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"AddressPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asAddress: Evm.Utils.toAddress(bytes),\n                    rawAsHex: Conversion.toHexString(rawBytes)\n                }\n            };\n        case \"contract\":\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"ContractPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));\n            const contractValueInfo = yield* decodeContract(bytes, info);\n            return {\n                type: fullType,\n                kind: \"value\",\n                value: contractValueInfo\n            };\n        case \"bytes\":\n            //NOTE: we assume this is a *static* bytestring,\n            //because this is decodeBasic! dynamic ones should\n            //go to decodeBytes!\n            let coercedDataType = dataType;\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"BytesPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: coercedDataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: coercedDataType,\n                kind: \"value\",\n                value: {\n                    asHex: Conversion.toHexString(bytes),\n                    rawAsHex: Conversion.toHexString(rawBytes)\n                }\n            };\n        case \"function\":\n            switch (dataType.visibility) {\n                case \"external\":\n                    if (!checkPadding(bytes, dataType, paddingMode)) {\n                        let error = {\n                            kind: \"FunctionExternalNonStackPaddingError\",\n                            paddingType: getPaddingType(dataType, paddingMode),\n                            raw: Conversion.toHexString(bytes)\n                        };\n                        if (strict) {\n                            throw new errors_1.StopDecodingError(error);\n                        }\n                        return {\n                            type: dataType,\n                            kind: \"error\",\n                            error\n                        };\n                    }\n                    bytes = removePadding(bytes, dataType, paddingMode);\n                    const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n                    const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n                    return {\n                        type: dataType,\n                        kind: \"value\",\n                        value: yield* decodeExternalFunction(address, selector, info)\n                    };\n                case \"internal\":\n                    if (strict) {\n                        //internal functions don't go in the ABI!\n                        //this should never happen, but just to be sure...\n                        throw new errors_1.StopDecodingError({\n                            kind: \"InternalFunctionInABIError\"\n                        });\n                    }\n                    if (!checkPadding(bytes, dataType, paddingMode)) {\n                        return {\n                            type: dataType,\n                            kind: \"error\",\n                            error: {\n                                kind: \"FunctionInternalPaddingError\",\n                                paddingType: getPaddingType(dataType, paddingMode),\n                                raw: Conversion.toHexString(bytes)\n                            }\n                        };\n                    }\n                    bytes = removePadding(bytes, dataType, paddingMode);\n                    const deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n                    const constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n                    return decodeInternalFunction(dataType, deployedPc, constructorPc, info);\n            }\n            break; //to satisfy TypeScript\n        case \"enum\": {\n            let numeric = Conversion.toBN(bytes);\n            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));\n            if (!fullType.options) {\n                let error = {\n                    kind: \"EnumNotFoundDecodingError\",\n                    type: fullType,\n                    rawAsBN: numeric\n                };\n                if (strict || options.allowRetry) {\n                    throw new errors_1.StopDecodingError(error, true);\n                    //note that we allow a retry if we couldn't locate the enum type!\n                }\n                return {\n                    type: fullType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //note: I'm doing the padding checks a little more manually on this one\n            //so that we can have the right type of error\n            const numOptions = fullType.options.length;\n            const numBytes = Math.ceil(Math.log2(numOptions) / 8);\n            const paddingType = getPaddingType(dataType, paddingMode);\n            if (!checkPaddingDirect(bytes, numBytes, paddingType)) {\n                let error = {\n                    kind: \"EnumPaddingError\",\n                    type: fullType,\n                    paddingType,\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePaddingDirect(bytes, numBytes, paddingType);\n            numeric = Conversion.toBN(bytes); //alter numeric!\n            if (numeric.ltn(numOptions)) {\n                const name = fullType.options[numeric.toNumber()];\n                //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n                //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n                //an enum with that many options in the first place, we have bigger problems!\n                return {\n                    type: fullType,\n                    kind: \"value\",\n                    value: {\n                        name,\n                        numericAsBN: numeric\n                    }\n                };\n            }\n            else {\n                let error = {\n                    kind: \"EnumOutOfRangeError\",\n                    type: fullType,\n                    rawAsBN: numeric\n                };\n                if (strict) {\n                    //note:\n                    //if the enum is merely out of range rather than out of the ABI range,\n                    //we do NOT throw an error here!  instead we simply return an error value,\n                    //which we normally avoid doing in strict mode.  (the error will be caught\n                    //later at the re-encoding step instead.)  why?  because we might be running\n                    //in ABI mode, so we may need to abify this \"value\" rather than just throwing\n                    //it out.\n                    throw new errors_1.StopDecodingError(error);\n                    //note that we do NOT allow a retry here!\n                    //if we *can* find the enum type but the value is out of range,\n                    //we *know* that it is invalid!\n                }\n                return {\n                    type: fullType,\n                    kind: \"error\",\n                    error\n                };\n            }\n        }\n        case \"fixed\": {\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"FixedPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length (keeping the bytes on the right)\n            bytes = removePadding(bytes, dataType, paddingMode);\n            let asBN = Conversion.toSignedBN(bytes);\n            let rawAsBN = Conversion.toSignedBN(rawBytes);\n            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBig,\n                    rawAsBig\n                }\n            };\n        }\n        case \"ufixed\": {\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"UfixedPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length (keeping the bytes on the right)\n            bytes = removePadding(bytes, dataType, paddingMode);\n            let asBN = Conversion.toBN(bytes);\n            let rawAsBN = Conversion.toBN(rawBytes);\n            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBig,\n                    rawAsBig\n                }\n            };\n        }\n    }\n}\nexports.decodeBasic = decodeBasic;\n//NOTE that this function returns a ContractValueInfo, not a ContractResult\nfunction* decodeContract(addressBytes, info) {\n    return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;\n}\nexports.decodeContract = decodeContract;\nfunction* decodeContractAndContext(addressBytes, info) {\n    let address = Evm.Utils.toAddress(addressBytes);\n    let rawAddress = Conversion.toHexString(addressBytes);\n    let codeBytes = yield {\n        type: \"code\",\n        address\n    };\n    let code = Conversion.toHexString(codeBytes);\n    let context = Contexts.Utils.findContext(info.contexts, code);\n    if (context !== null) {\n        return {\n            context,\n            contractInfo: {\n                kind: \"known\",\n                address,\n                rawAddress,\n                class: Contexts.Import.contextToType(context)\n            }\n        };\n    }\n    else {\n        return {\n            context,\n            contractInfo: {\n                kind: \"unknown\",\n                address,\n                rawAddress\n            }\n        };\n    }\n}\n//note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\nfunction* decodeExternalFunction(addressBytes, selectorBytes, info) {\n    let { contractInfo: contract, context } = yield* decodeContractAndContext(addressBytes, info);\n    let selector = Conversion.toHexString(selectorBytes);\n    if (contract.kind === \"unknown\") {\n        return {\n            kind: \"unknown\",\n            contract,\n            selector\n        };\n    }\n    let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n    if (abiEntry === undefined) {\n        return {\n            kind: \"invalid\",\n            contract,\n            selector\n        };\n    }\n    return {\n        kind: \"known\",\n        contract,\n        selector,\n        abi: abiEntry\n    };\n}\nexports.decodeExternalFunction = decodeExternalFunction;\n//this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\n//also note, I haven't put the same sort of error-handling in this one since it's only intended to run with full info (for now, anyway)\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info) {\n    let deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n    let constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n    let context = Contexts.Import.contextToType(info.currentContext);\n    //before anything else: do we even have an internal functions table?\n    //if not, we'll just return the info we have without really attemting to decode\n    if (!info.internalFunctionsTable) {\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                kind: \"unknown\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    //also before we continue: is the PC zero? if so let's just return that\n    if (deployedPc === 0 && constructorPc === 0) {\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                kind: \"exception\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    //another check: is only the deployed PC zero?\n    if (deployedPc === 0 && constructorPc !== 0) {\n        return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n                kind: \"MalformedInternalFunctionError\",\n                context,\n                deployedProgramCounter: 0,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    //one last pre-check: is this a deployed-format pointer in a constructor?\n    if (info.currentContext.isConstructor && constructorPc === 0) {\n        return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n                kind: \"DeployedFunctionInConstructorError\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: 0\n            }\n        };\n    }\n    //otherwise, we get our function\n    let pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n    let functionEntry = info.internalFunctionsTable[pc];\n    if (!functionEntry) {\n        //if it's not zero and there's no entry... error!\n        return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n                kind: \"NoSuchInternalFunctionError\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    if (functionEntry.isDesignatedInvalid) {\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                kind: \"exception\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    let name = functionEntry.name;\n    let mutability = functionEntry.mutability;\n    let definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null\n    let id = Evm.Import.makeInternalFunctionId(functionEntry);\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            kind: \"function\",\n            context,\n            deployedProgramCounter: deployedPc,\n            constructorProgramCounter: constructorPc,\n            name,\n            id,\n            definedIn,\n            mutability\n        }\n    };\n}\nexports.decodeInternalFunction = decodeInternalFunction;\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n    const length = allocate_1.byteLength(dataType, userDefinedTypes);\n    let paddingType = getPaddingType(dataType, paddingMode);\n    if (paddingMode === \"permissive\") {\n        switch (dataType.typeClass) {\n            case \"bool\":\n            case \"enum\":\n            case \"function\":\n                //these three types are checked even in permissive mode\n                return checkPaddingDirect(bytes, length, paddingType);\n            default:\n                return true;\n        }\n    }\n    else {\n        return checkPaddingDirect(bytes, length, paddingType);\n    }\n}\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n    const length = allocate_1.byteLength(dataType, userDefinedTypes);\n    const paddingType = getPaddingType(dataType, paddingMode);\n    return removePaddingDirect(bytes, length, paddingType);\n}\nfunction removePaddingDirect(bytes, length, paddingType) {\n    switch (paddingType) {\n        case \"left\":\n        case \"signed\":\n            return bytes.slice(-length);\n        case \"right\":\n            return bytes.slice(0, length);\n    }\n}\nfunction checkPaddingDirect(bytes, length, paddingType) {\n    switch (paddingType) {\n        case \"left\":\n            return checkPaddingLeft(bytes, length);\n        case \"right\":\n            return checkPaddingRight(bytes, length);\n        case \"signed\":\n            return checkPaddingSigned(bytes, length);\n    }\n}\nfunction getPaddingType(dataType, paddingMode) {\n    switch (paddingMode) {\n        case \"right\":\n            return \"right\";\n        case \"default\":\n        case \"permissive\":\n            return defaultPaddingType(dataType);\n        case \"zero\":\n            let defaultType = defaultPaddingType(dataType);\n            return defaultType === \"signed\" ? \"left\" : defaultType;\n    }\n}\nfunction defaultPaddingType(dataType) {\n    switch (dataType.typeClass) {\n        case \"bytes\":\n            return \"right\";\n        case \"int\":\n        case \"fixed\":\n            return \"signed\";\n        case \"function\":\n            if (dataType.visibility === \"external\") {\n                return \"right\";\n            }\n        //otherwise, fall through to default\n        default:\n            return \"left\";\n    }\n}\nfunction checkPaddingRight(bytes, length) {\n    let padding = bytes.slice(length); //cut off the first length bytes\n    return padding.every(paddingByte => paddingByte === 0);\n}\n//exporting this one for use in stack.ts\nfunction checkPaddingLeft(bytes, length) {\n    let padding = bytes.slice(0, -length); //cut off the last length bytes\n    return padding.every(paddingByte => paddingByte === 0);\n}\nexports.checkPaddingLeft = checkPaddingLeft;\nfunction checkPaddingSigned(bytes, length) {\n    let padding = bytes.slice(0, -length); //padding is all but the last length bytes\n    let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n    let signByte = value[0] & 0x80 ? 0xff : 0x00;\n    return padding.every(paddingByte => paddingByte === signByte);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}