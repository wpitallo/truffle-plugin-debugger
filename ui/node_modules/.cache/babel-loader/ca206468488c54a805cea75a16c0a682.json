{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeTupleAbi = exports.encodeAbi = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:abi-data:encode\");\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar allocate_1 = require(\"../allocate\");\n\nvar lodash_sum_1 = __importDefault(require(\"lodash.sum\")); //UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n\n/**\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeAbi(input, allocations) {\n  //errors can't be encoded\n  if (input.kind === \"error\") {\n    return undefined;\n  }\n\n  var bytes; //TypeScript can at least infer in the rest of this that we're looking\n  //at a value, not an error!  But that's hardly enough...\n\n  switch (input.type.typeClass) {\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n      //none of these can go in the ABI\n      return undefined;\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return Basic.Encode.encodeBasic(input);\n\n        case \"dynamic\":\n          bytes = Bytes.Encode.encodeBytes(input);\n          return padAndPrependLength(bytes);\n      }\n\n    case \"string\":\n      bytes = Bytes.Encode.encodeBytes(input);\n      return padAndPrependLength(bytes);\n\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          case \"internal\":\n            return undefined;\n          //internal functions can't go in the ABI!\n          //Yes, technically we could defer to encodeBasic here, but,\n          //c'mon, that's not how the function's supposed to be used\n\n          case \"external\":\n            return Basic.Encode.encodeBasic(input);\n        }\n      }\n    //now for the serious cases\n\n    case \"array\":\n      {\n        var coercedInput = input;\n\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        var staticEncoding = encodeTupleAbi(coercedInput.value, allocations);\n\n        switch (input.type.kind) {\n          case \"static\":\n            return staticEncoding;\n\n          case \"dynamic\":\n            var encoded = new Uint8Array(Evm.Utils.WORD_SIZE + staticEncoding.length); //leave room for length\n\n            encoded.set(staticEncoding, Evm.Utils.WORD_SIZE); //again, leave room for length beforehand\n\n            var lengthBytes = Conversion.toBytes(coercedInput.value.length, Evm.Utils.WORD_SIZE);\n            encoded.set(lengthBytes); //and now we set the length\n\n            return encoded;\n        }\n      }\n\n    case \"struct\":\n      {\n        var _coercedInput = input;\n\n        if (_coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        return encodeTupleAbi(_coercedInput.value.map(function (_ref) {\n          var value = _ref.value;\n          return value;\n        }), allocations);\n      }\n\n    case \"tuple\":\n      //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n      //(That may not be apparent from this one line, but it's true)\n      //I'm writing it this way anyway for simplicity, to avoid rewriting the encoder\n      //However it may be worth revisiting this in the future if performance turns out to be a problem\n      return encodeTupleAbi(input.value.map(function (_ref2) {\n        var value = _ref2.value;\n        return value;\n      }), allocations);\n\n    default:\n      return Basic.Encode.encodeBasic(input);\n  }\n}\n\nexports.encodeAbi = encodeAbi;\n/**\n * @Category Encoding (low-level)\n */\n\nfunction padAndPrependLength(bytes) {\n  var length = bytes.length;\n  var paddedLength = Evm.Utils.WORD_SIZE * Math.ceil(length / Evm.Utils.WORD_SIZE);\n  var encoded = new Uint8Array(Evm.Utils.WORD_SIZE + paddedLength);\n  encoded.set(bytes, Evm.Utils.WORD_SIZE); //start 32 in to leave room for the length beforehand\n\n  var lengthBytes = Conversion.toBytes(length, Evm.Utils.WORD_SIZE);\n  encoded.set(lengthBytes); //and now we set the length\n\n  return encoded;\n}\n/**\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeTupleAbi(tuple, allocations) {\n  var elementEncodings = tuple.map(function (element) {\n    return encodeAbi(element, allocations);\n  });\n\n  if (elementEncodings.some(function (element) {\n    return element === undefined;\n  })) {\n    return undefined;\n  }\n\n  var elementSizeInfo = tuple.map(function (element) {\n    return allocate_1.abiSizeInfo(element.type, allocations);\n  }); //heads and tails here are as discussed in the ABI docs;\n  //for a static type the head is the encoding and the tail is empty,\n  //for a dynamic type the head is the pointer and the tail is the encoding\n\n  var heads = [];\n  var tails = []; //but first, we need to figure out where the first tail will start,\n  //by adding up the sizes of all the heads (we can easily do this in\n  //advance via elementSizeInfo, without needing to know the particular\n  //values of the heads)\n\n  var startOfNextTail = lodash_sum_1.default(elementSizeInfo.map(function (elementInfo) {\n    return elementInfo.size;\n  }));\n\n  for (var i = 0; i < tuple.length; i++) {\n    var head = void 0;\n    var tail = void 0;\n\n    if (!elementSizeInfo[i].dynamic) {\n      //static case\n      head = elementEncodings[i];\n      tail = new Uint8Array(); //empty array\n    } else {\n      //dynamic case\n      head = Conversion.toBytes(startOfNextTail, Evm.Utils.WORD_SIZE);\n      tail = elementEncodings[i];\n    }\n\n    heads.push(head);\n    tails.push(tail);\n    startOfNextTail += tail.length;\n  } //finally, we need to concatenate everything together!\n  //since we're dealing with Uint8Arrays, we have to do this manually\n\n\n  var totalSize = startOfNextTail;\n  var encoded = new Uint8Array(totalSize);\n  var position = 0;\n\n  for (var _i = 0, _heads = heads; _i < _heads.length; _i++) {\n    var _head = _heads[_i];\n    encoded.set(_head, position);\n    position += _head.length;\n  }\n\n  for (var _i2 = 0, _tails = tails; _i2 < _tails.length; _i2++) {\n    var _tail = _tails[_i2];\n    encoded.set(_tail, position);\n    position += _tail.length;\n  }\n\n  return encoded;\n}\n\nexports.encodeTupleAbi = encodeTupleAbi;","map":{"version":3,"sources":["../../../../lib/abi-data/encode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeTupleAbi = exports.encodeAbi = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abi-data:encode\");\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst lodash_sum_1 = __importDefault(require(\"lodash.sum\"));\n//UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n/**\n * @Category Encoding (low-level)\n */\nfunction encodeAbi(input, allocations) {\n    //errors can't be encoded\n    if (input.kind === \"error\") {\n        return undefined;\n    }\n    let bytes;\n    //TypeScript can at least infer in the rest of this that we're looking\n    //at a value, not an error!  But that's hardly enough...\n    switch (input.type.typeClass) {\n        case \"mapping\":\n        case \"magic\":\n        case \"type\":\n            //none of these can go in the ABI\n            return undefined;\n        case \"bytes\":\n            switch (input.type.kind) {\n                case \"static\":\n                    return Basic.Encode.encodeBasic(input);\n                case \"dynamic\":\n                    bytes = Bytes.Encode.encodeBytes((input));\n                    return padAndPrependLength(bytes);\n            }\n        case \"string\":\n            bytes = Bytes.Encode.encodeBytes(input);\n            return padAndPrependLength(bytes);\n        case \"function\": {\n            switch (input.type.visibility) {\n                case \"internal\":\n                    return undefined; //internal functions can't go in the ABI!\n                //Yes, technically we could defer to encodeBasic here, but,\n                //c'mon, that's not how the function's supposed to be used\n                case \"external\":\n                    return Basic.Encode.encodeBasic(input);\n            }\n        }\n        //now for the serious cases\n        case \"array\": {\n            let coercedInput = (input);\n            if (coercedInput.reference !== undefined) {\n                return undefined; //circular values can't be encoded\n            }\n            let staticEncoding = encodeTupleAbi(coercedInput.value, allocations);\n            switch (input.type.kind) {\n                case \"static\":\n                    return staticEncoding;\n                case \"dynamic\":\n                    let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + staticEncoding.length); //leave room for length\n                    encoded.set(staticEncoding, Evm.Utils.WORD_SIZE); //again, leave room for length beforehand\n                    let lengthBytes = Conversion.toBytes(coercedInput.value.length, Evm.Utils.WORD_SIZE);\n                    encoded.set(lengthBytes); //and now we set the length\n                    return encoded;\n            }\n        }\n        case \"struct\": {\n            let coercedInput = (input);\n            if (coercedInput.reference !== undefined) {\n                return undefined; //circular values can't be encoded\n            }\n            return encodeTupleAbi(coercedInput.value.map(({ value }) => value), allocations);\n        }\n        case \"tuple\":\n            //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n            //(That may not be apparent from this one line, but it's true)\n            //I'm writing it this way anyway for simplicity, to avoid rewriting the encoder\n            //However it may be worth revisiting this in the future if performance turns out to be a problem\n            return encodeTupleAbi(input.value.map(({ value }) => value), allocations);\n        default:\n            return Basic.Encode.encodeBasic(input);\n    }\n}\nexports.encodeAbi = encodeAbi;\n/**\n * @Category Encoding (low-level)\n */\nfunction padAndPrependLength(bytes) {\n    let length = bytes.length;\n    let paddedLength = Evm.Utils.WORD_SIZE * Math.ceil(length / Evm.Utils.WORD_SIZE);\n    let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + paddedLength);\n    encoded.set(bytes, Evm.Utils.WORD_SIZE); //start 32 in to leave room for the length beforehand\n    let lengthBytes = Conversion.toBytes(length, Evm.Utils.WORD_SIZE);\n    encoded.set(lengthBytes); //and now we set the length\n    return encoded;\n}\n/**\n * @Category Encoding (low-level)\n */\nfunction encodeTupleAbi(tuple, allocations) {\n    let elementEncodings = tuple.map(element => encodeAbi(element, allocations));\n    if (elementEncodings.some(element => element === undefined)) {\n        return undefined;\n    }\n    let elementSizeInfo = tuple.map(element => allocate_1.abiSizeInfo(element.type, allocations));\n    //heads and tails here are as discussed in the ABI docs;\n    //for a static type the head is the encoding and the tail is empty,\n    //for a dynamic type the head is the pointer and the tail is the encoding\n    let heads = [];\n    let tails = [];\n    //but first, we need to figure out where the first tail will start,\n    //by adding up the sizes of all the heads (we can easily do this in\n    //advance via elementSizeInfo, without needing to know the particular\n    //values of the heads)\n    let startOfNextTail = lodash_sum_1.default(elementSizeInfo.map(elementInfo => elementInfo.size));\n    for (let i = 0; i < tuple.length; i++) {\n        let head;\n        let tail;\n        if (!elementSizeInfo[i].dynamic) {\n            //static case\n            head = elementEncodings[i];\n            tail = new Uint8Array(); //empty array\n        }\n        else {\n            //dynamic case\n            head = Conversion.toBytes(startOfNextTail, Evm.Utils.WORD_SIZE);\n            tail = elementEncodings[i];\n        }\n        heads.push(head);\n        tails.push(tail);\n        startOfNextTail += tail.length;\n    }\n    //finally, we need to concatenate everything together!\n    //since we're dealing with Uint8Arrays, we have to do this manually\n    let totalSize = startOfNextTail;\n    let encoded = new Uint8Array(totalSize);\n    let position = 0;\n    for (let head of heads) {\n        encoded.set(head, position);\n        position += head.length;\n    }\n    for (let tail of tails) {\n        encoded.set(tail, position);\n        position += tail.length;\n    }\n    return encoded;\n}\nexports.encodeTupleAbi = encodeTupleAbi;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}