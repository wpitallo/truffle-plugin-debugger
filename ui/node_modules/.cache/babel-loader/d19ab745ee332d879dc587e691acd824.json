{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEventAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:abi-data:allocate\");\n\nvar Import = __importStar(require(\"../import\"));\n\nvar AbiDataUtils = __importStar(require(\"../utils\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar Common = __importStar(require(\"../../common\"));\n\nvar Ast = __importStar(require(\"../../ast\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\n\nexports.FallbackOutputAllocation = {\n  kind: \"returnmessage\",\n  selector: new Uint8Array(),\n  allocationMode: \"full\"\n};\n\nfunction getAbiAllocations(userDefinedTypes) {\n  var allocations = {};\n\n  for (var _i = 0, _Object$values = Object.values(userDefinedTypes); _i < _Object$values.length; _i++) {\n    var dataType = _Object$values[_i];\n\n    if (dataType.typeClass === \"struct\") {\n      try {\n        allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n      } catch (_) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n        //note: a better way of handling this would probably be to *mark* it\n        //as failed rather than throwing an exception as that would lead to less\n        //recomputation, but this is simpler and I don't think the recomputation\n        //should really be a problem\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getAbiAllocations = getAbiAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n} //note: we will still allocate circular structs, even though they're not allowed in the abi, because it's\n//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)\n\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {\n  var start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var dynamic = false; //note that we will mutate the start argument also!\n  //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  var allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n\n  var memberAllocations = [];\n\n  var _iterator = _createForOfIteratorHelper(members),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var member = _step.value;\n      var length = void 0;\n      var dynamicMember = void 0;\n\n      var _abiSizeAndAllocate = abiSizeAndAllocate(member.type, userDefinedTypes, allocations);\n\n      length = _abiSizeAndAllocate.size;\n      dynamicMember = _abiSizeAndAllocate.dynamic;\n      allocations = _abiSizeAndAllocate.allocations;\n\n      //vomit on illegal types in calldata -- note the short-circuit!\n      if (length === undefined) {\n        allocations[parentId] = null;\n        return allocations;\n      }\n\n      var pointer = {\n        location: \"abi\",\n        start: start,\n        length: length\n      };\n      memberAllocations.push({\n        name: member.name,\n        type: member.type,\n        pointer: pointer\n      });\n      start += length;\n      dynamic = dynamic || dynamicMember;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    length: dynamic ? Evm.Utils.WORD_SIZE : start,\n    dynamic: dynamic\n  };\n  return allocations;\n} //first return value is the actual size.\n//second return value is whether the type is dynamic\n//both will be undefined if type is a mapping or internal function\n//third return value is resulting allocations, INCLUDING the ones passed in\n\n\nfunction abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n  switch (dataType.typeClass) {\n    case \"bool\":\n    case \"address\":\n    case \"contract\":\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n    case \"enum\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: false,\n        allocations: existingAllocations\n      };\n\n    case \"string\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: true,\n        allocations: existingAllocations\n      };\n\n    case \"bytes\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: dataType.kind === \"dynamic\",\n        allocations: existingAllocations\n      };\n\n    case \"mapping\":\n      return {\n        allocations: existingAllocations\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            size: Evm.Utils.WORD_SIZE,\n            dynamic: false,\n            allocations: existingAllocations\n          };\n\n        case \"internal\":\n          return {\n            allocations: existingAllocations\n          };\n      }\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: Evm.Utils.WORD_SIZE,\n              dynamic: true,\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            if (dataType.length.isZero()) {\n              //arrays of length 0 are static regardless of base type\n              return {\n                size: 0,\n                dynamic: false,\n                allocations: existingAllocations\n              };\n            }\n\n            var _abiSizeAndAllocate2 = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations),\n                baseSize = _abiSizeAndAllocate2.size,\n                dynamic = _abiSizeAndAllocate2.dynamic,\n                allocations = _abiSizeAndAllocate2.allocations;\n\n            return {\n              //WARNING!  The use of toNumber() here may throw an exception!\n              //I'm judging this OK since if you have arrays that large we have bigger problems :P\n              size: dataType.length.toNumber() * baseSize,\n              dynamic: dynamic,\n              allocations: allocations\n            };\n        }\n      }\n\n    case \"struct\":\n      {\n        var _allocations = existingAllocations;\n        var allocation = _allocations[dataType.id];\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          var storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          _allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = _allocations[storedType.id];\n        } //having found our allocation, if it's not null, we can just look up its size and dynamicity\n\n\n        if (allocation !== null) {\n          return {\n            size: allocation.length,\n            dynamic: allocation.dynamic,\n            allocations: _allocations\n          };\n        } //if it is null, this type doesn't go in the abi\n        else {\n            return {\n              allocations: _allocations\n            };\n          }\n      }\n\n    case \"tuple\":\n      {\n        //Warning! Yucky wasteful recomputation here!\n        var size = 0;\n        var _dynamic = false; //note that we don't just invoke allocateStruct here!\n        //why not? because it has no ID to store the result in!\n        //and we can't use a fake like -1 because there might be a recursive call to it,\n        //and then the results would overwrite each other\n        //I mean, we could do some hashing thing or something, but I think it's easier to just\n        //copy the logic in this one case (sorry)\n\n        var _iterator2 = _createForOfIteratorHelper(dataType.memberTypes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var member = _step2.value;\n\n            var _abiSizeAndAllocate3 = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations),\n                memberSize = _abiSizeAndAllocate3.size,\n                memberDynamic = _abiSizeAndAllocate3.dynamic;\n\n            size += memberSize;\n            _dynamic = _dynamic || memberDynamic;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return {\n          size: size,\n          dynamic: _dynamic,\n          allocations: existingAllocations\n        };\n      }\n  }\n} //assumes you've already done allocation! don't use if you haven't!\n\n/**\n * @protected\n */\n\n\nfunction abiSizeInfo(dataType, allocations) {\n  var _abiSizeAndAllocate4 = abiSizeAndAllocate(dataType, null, allocations),\n      size = _abiSizeAndAllocate4.size,\n      dynamic = _abiSizeAndAllocate4.dynamic; //the above line should work fine... as long as allocation is already done!\n  //the middle argument, userDefinedTypes, is only needed during allocation\n  //again, this function is only for use if allocation is done, so it's safe to pass null here\n\n\n  return {\n    size: size,\n    dynamic: dynamic\n  };\n}\n\nexports.abiSizeInfo = abiSizeInfo; //allocates an external call\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n//NOTE: returns undefined if attempting to allocate a constructor but we don't have the\n//bytecode for the constructor\n\nfunction allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {\n  //first: determine the corresponding function node\n  //(simultaneously: determine the offset)\n  var node = undefined;\n  var inputParametersFull;\n  var outputParametersFull;\n  var inputParametersAbi;\n  var outputParametersAbi;\n  var offset; //refers to INPUT offset; output offset is always 0\n\n  switch (abiEntry.type) {\n    case \"constructor\":\n      if (!constructorContext) {\n        return undefined;\n      }\n\n      var rawLength = constructorContext.binary.length;\n      offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n      //for a constructor, we only want to search the particular contract\n\n      if (contractNode) {\n        node = contractNode.nodes.find(function (functionNode) {\n          return AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a function node, but then it will\n          //return false (well, unless it's a getter node!)\n          abiEntry, functionNode, referenceDeclarations);\n        });\n      } //if we can't find it, we'll handle this below\n\n\n      break;\n\n    case \"function\":\n      offset = Evm.Utils.SELECTOR_SIZE; //search through base contracts, from most derived (left) to most base (right)\n\n      if (contractNode) {\n        var linearizedBaseContracts = contractNode.linearizedBaseContracts;\n        debug(\"linearized: %O\", linearizedBaseContracts);\n        node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, function (functionNode) {\n          return AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations);\n        }, contractNode).node; //may be undefined!  that's OK!\n      }\n\n      break;\n  } //now: get the parameters (both full-mode & ABI)\n\n\n  if (node) {\n    switch (node.nodeType) {\n      case \"FunctionDefinition\":\n        //normal case\n        inputParametersFull = node.parameters.parameters;\n        outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!\n\n        break;\n\n      case \"VariableDeclaration\":\n        //getter case\n        var _Ast$Utils$getterPara = Ast.Utils.getterParameters(node, referenceDeclarations);\n\n        inputParametersFull = _Ast$Utils$getterPara.inputs;\n        outputParametersFull = _Ast$Utils$getterPara.outputs;\n        break;\n    }\n  } else {\n    inputParametersFull = undefined;\n    outputParametersFull = undefined;\n  }\n\n  inputParametersAbi = abiEntry.inputs;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputParametersAbi = abiEntry.outputs;\n      break;\n\n    case \"constructor\":\n      //we just leave this empty for constructors\n      outputParametersAbi = [];\n      break;\n  } //now: do the allocation!\n\n\n  var _allocateDataArgument = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset),\n      abiAllocationInput = _allocateDataArgument.allocation,\n      inputMode = _allocateDataArgument.mode;\n\n  var _allocateDataArgument2 = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler //note no offset\n  ),\n      abiAllocationOutput = _allocateDataArgument2.allocation,\n      outputMode = _allocateDataArgument2.mode; //finally: transform the allocation appropriately\n\n\n  var inputArgumentsAllocation = abiAllocationInput.members.map(function (member) {\n    return Object.assign(Object.assign({}, member), {\n      pointer: {\n        location: \"calldata\",\n        start: member.pointer.start,\n        length: member.pointer.length\n      }\n    });\n  });\n  var outputArgumentsAllocation = abiAllocationOutput.members.map(function (member) {\n    return Object.assign(Object.assign({}, member), {\n      pointer: {\n        location: \"returndata\",\n        start: member.pointer.start,\n        length: member.pointer.length\n      }\n    });\n  });\n  var inputsAllocation = {\n    abi: abiEntry,\n    offset: offset,\n    arguments: inputArgumentsAllocation,\n    allocationMode: inputMode\n  };\n  var outputsAllocation;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputsAllocation = {\n        selector: new Uint8Array(),\n        arguments: outputArgumentsAllocation,\n        allocationMode: outputMode,\n        kind: \"return\"\n      };\n      break;\n\n    case \"constructor\":\n      outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);\n      break;\n  }\n\n  return {\n    input: inputsAllocation,\n    output: outputsAllocation\n  };\n} //note: allocateEvent doesn't use this because it needs additional\n//handling for indexed parameters (maybe these can be unified in\n//the future though?)\n\n\nfunction allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  var offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var allocationMode = fullModeParameters ? \"full\" : \"abi\"; //can degrade\n\n  var parameterTypes;\n  var abiAllocation;\n\n  if (allocationMode === \"full\") {\n    var id = \"-1\"; //fake ID that doesn't matter\n\n    parameterTypes = fullModeParameters.map(function (parameter) {\n      return {\n        name: parameter.name,\n        type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!\n\n      };\n    });\n    debug(\"parameterTypes: %O\", parameterTypes); //now: perform the allocation!\n\n    try {\n      abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n    } catch (_a) {\n      //if something goes wrong, switch to ABI mdoe\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    //this is the ABI case.  we end up here EITHER\n    //if node doesn't exist, OR if something went wrong\n    //during allocation\n    var _id = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiParameters.map(function (parameter) {\n      return {\n        name: parameter.name,\n        type: Import.abiParameterToType(parameter)\n      };\n    });\n    abiAllocation = allocateMembers(_id, parameterTypes, userDefinedTypes, abiAllocations, offset)[_id];\n  }\n\n  return {\n    allocation: abiAllocation,\n    mode: allocationMode\n  };\n} //allocates an event\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n\n\nfunction allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  var parameterTypes;\n  var id; //first: determine the corresponding event node\n  //search through base contracts, from most derived (right) to most base (left)\n\n  var node = undefined;\n  var definedIn = undefined;\n  var allocationMode = \"full\"; //degrade to abi as needed\n\n  debug(\"allocating ABI: %O\", abiEntry);\n\n  if (contractNode) {\n    //first: check same contract for the event\n    node = contractNode.nodes.find(function (eventNode) {\n      return AbiDataUtils.definitionMatchesAbi( //note this needn't actually be an event node, but then it will\n      //return false\n      abiEntry, eventNode, referenceDeclarations);\n    }); //if we found the node, great!  If not...\n\n    if (!node) {\n      debug(\"didn't find node in base contract...\"); //let's search for the node among the base contracts.\n      //but if we find it...\n      //[note: the following code is overcomplicated; it was used\n      //when we were trying to get the actual node, it's overcomplicated\n      //now that we're just determining its presence.  oh well]\n\n      var linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n      linearizedBaseContractsMinusSelf.shift(); //remove self\n\n      debug(\"checking contracts: %o\", linearizedBaseContractsMinusSelf);\n      node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, function (eventNode) {\n        return AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a event node, but then it will return false\n        abiEntry, eventNode, referenceDeclarations);\n      } //don't pass deriveContractNode here, we're not checking the contract itself\n      ).node; //may be undefined! that's OK!\n\n      if (node) {\n        //...if we find the node in an ancestor, we\n        //deliberately *don't* allocate!  instead such cases\n        //will be handled during a later combination step\n        debug(\"bailing out for later handling!\");\n        debug(\"ABI: %O\", abiEntry);\n        return undefined;\n      }\n    }\n  } //otherwise, leave node undefined\n\n\n  if (node) {\n    debug(\"found node\"); //if we found the node, let's also turn it into a type\n\n    definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler); //can skip reference declarations argument here\n  } else {\n    //if no node, have to fall back into ABI mode\n    debug(\"falling back to ABI because no node\");\n    allocationMode = \"abi\";\n  } //now: construct the list of parameter types, attaching indexedness info\n  //and overall position (for later reconstruction)\n\n\n  var indexed;\n  var nonIndexed;\n  var abiAllocation; //the untransformed allocation for the non-indexed parameters\n\n  if (allocationMode === \"full\") {\n    var _id2 = node.id.toString();\n\n    var parameters = node.parameters.parameters;\n    parameterTypes = parameters.map(function (definition) {\n      return {\n        //note: if node is defined, compiler had better be defined, too!\n        type: Ast.Import.definitionToType(definition, compilationId, compiler),\n        name: definition.name,\n        indexed: definition.indexed\n      };\n    }); //now: split the list of parameters into indexed and non-indexed\n\n    var _lodash_partition_1$d = lodash_partition_1.default(parameterTypes, function (parameter) {\n      return parameter.indexed;\n    });\n\n    var _lodash_partition_1$d2 = _slicedToArray(_lodash_partition_1$d, 2);\n\n    indexed = _lodash_partition_1$d2[0];\n    nonIndexed = _lodash_partition_1$d2[1];\n\n    try {\n      //now: perform the allocation for the non-indexed parameters!\n      abiAllocation = allocateMembers(_id2, nonIndexed, userDefinedTypes, abiAllocations)[_id2]; //note the implicit conversion from EventParameterInfo to NameTypePair\n    } catch (_a) {\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    id = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiEntry.inputs.map(function (abiParameter) {\n      return {\n        type: Import.abiParameterToType(abiParameter),\n        name: abiParameter.name,\n        indexed: abiParameter.indexed\n      };\n    }); //now: split the list of parameters into indexed and non-indexed\n\n    var _lodash_partition_1$d3 = lodash_partition_1.default(parameterTypes, function (parameter) {\n      return parameter.indexed;\n    });\n\n    var _lodash_partition_1$d4 = _slicedToArray(_lodash_partition_1$d3, 2);\n\n    indexed = _lodash_partition_1$d4[0];\n    nonIndexed = _lodash_partition_1$d4[1];\n    //now: perform the allocation for the non-indexed parameters!\n    abiAllocation = allocateMembers(id, nonIndexed, userDefinedTypes, abiAllocations)[id]; //note the implicit conversion from EventParameterInfo to NameTypePair\n  } //now: transform the result appropriately\n\n\n  var nonIndexedArgumentsAllocation = abiAllocation.members.map(function (member) {\n    return Object.assign(Object.assign({}, member), {\n      pointer: {\n        location: \"eventdata\",\n        start: member.pointer.start,\n        length: member.pointer.length\n      }\n    });\n  }); //now: allocate the indexed parameters\n\n  var startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0\n\n  var indexedArgumentsAllocation = indexed.map(function (_ref, position) {\n    var type = _ref.type,\n        name = _ref.name;\n    return {\n      type: type,\n      name: name,\n      pointer: {\n        location: \"eventtopic\",\n        topic: startingTopic + position\n      }\n    };\n  }); //finally: weave these back together\n\n  var argumentsAllocation = [];\n\n  var _iterator3 = _createForOfIteratorHelper(parameterTypes),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var parameter = _step3.value;\n      var arrayToGrabFrom = parameter.indexed ? indexedArgumentsAllocation : nonIndexedArgumentsAllocation;\n      argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n    } //...and return\n\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return {\n    abi: abiEntry,\n    contextHash: undefined,\n    definedIn: definedIn,\n    arguments: argumentsAllocation,\n    allocationMode: allocationMode,\n    anonymous: abiEntry.anonymous\n  };\n}\n\nfunction getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  var allocations = {\n    constructorAllocation: undefined,\n    //(if it doesn't then it will remain as default)\n    functionAllocations: {}\n  };\n\n  if (!abi) {\n    //if no ABI, can't do much!\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    return allocations;\n  }\n\n  var _iterator4 = _createForOfIteratorHelper(abi),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var abiEntry = _step4.value;\n\n      if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) || AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {\n        //the first of these conditions is a hack workaround for a Solidity bug.\n        //the second of these is because... seriously? we're not handling these\n        //(at least not for now!) (these only exist prior to Solidity 0.5.6,\n        //thankfully)\n        continue;\n      }\n\n      switch (abiEntry.type) {\n        case \"constructor\":\n          allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n          debug(\"constructor alloc: %O\", allocations.constructorAllocation);\n          break;\n\n        case \"function\":\n          allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n          break;\n\n        default:\n          //skip over fallback and event\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  if (!allocations.constructorAllocation) {\n    //set a default constructor allocation if we haven't allocated one yet\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    debug(\"default constructor alloc: %O\", allocations.constructorAllocation);\n  }\n\n  return allocations;\n}\n\nfunction defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {\n  if (!constructorContext) {\n    return undefined;\n  }\n\n  var rawLength = constructorContext.binary.length;\n  var offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n\n  var input = {\n    offset: offset,\n    abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,\n    arguments: [],\n    allocationMode: \"full\"\n  };\n  var output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, \"full\"); //assume full, degrade as necessary\n\n  return {\n    input: input,\n    output: output\n  };\n} //note: context should be deployed context!\n\n\nfunction constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {\n  if (!context) {\n    //just return a default abi mode result\n    return {\n      selector: new Uint8Array(),\n      allocationMode: \"abi\",\n      kind: \"bytecode\",\n      delegatecallGuard: false\n    };\n  }\n\n  var immutableReferences = context.immutableReferences,\n      compilationId = context.compilationId,\n      compiler = context.compiler,\n      contractKind = context.contractKind,\n      binary = context.binary;\n  var immutables;\n\n  if (allocationMode === \"full\" && immutableReferences) {\n    if (contractNode) {\n      debug(\"allocating immutables\");\n      immutables = [];\n\n      var _loop = function _loop() {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n            id = _Object$entries$_i[0],\n            references = _Object$entries$_i[1];\n\n        if (references.length === 0) {\n          return \"continue\"; //don't allocate immutables that don't exist\n        }\n\n        var astId = parseInt(id); //get the corresponding variable node; potentially fail\n\n        var _findNodeAndContract = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, function (node) {\n          return node.id === astId;\n        }, contractNode),\n            definition = _findNodeAndContract.node,\n            definedIn = _findNodeAndContract.contract;\n\n        if (!definition || definition.nodeType !== \"VariableDeclaration\") {\n          debug(\"didn't find definition for %d!\", astId);\n          allocationMode = \"abi\";\n          immutables = undefined;\n          return \"break\";\n        }\n\n        var definedInClass = Ast.Import.definitionToStoredType(definedIn, compilationId, compiler); //can skip reference declarations argument here\n\n        var dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n        immutables.push({\n          name: definition.name,\n          definedIn: definedInClass,\n          type: dataType,\n          pointer: {\n            location: \"returndata\",\n            start: references[0].start,\n            length: references[0].length\n          }\n        });\n      };\n\n      for (var _i2 = 0, _Object$entries = Object.entries(immutableReferences); _i2 < _Object$entries.length; _i2++) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n        if (_ret === \"break\") break;\n      }\n    } else if (Object.entries(immutableReferences).length > 0) {\n      //if there are immutables, but no contract mode, go to abi mode\n      debug(\"immutables but no node!\");\n      allocationMode = \"abi\";\n    }\n  } else {\n    debug(\"no immutables\");\n  } //now, is there a delegatecall guard?\n\n\n  var delegatecallGuard = false;\n\n  if (contractKind === \"library\") {\n    //note: I am relying on this being present!\n    //(also this part is a bit HACKy)\n    var pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n    var delegateCallGuardString = \"0x\" + pushAddressInstruction + \"..\".repeat(Evm.Utils.ADDRESS_SIZE);\n\n    if (binary.startsWith(delegateCallGuardString)) {\n      delegatecallGuard = true;\n    }\n  }\n\n  return {\n    selector: new Uint8Array(),\n    allocationMode: allocationMode,\n    kind: \"bytecode\",\n    immutables: immutables,\n    delegatecallGuard: delegatecallGuard\n  };\n}\n\nfunction getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  var allocations = {\n    constructorAllocations: {},\n    functionAllocations: {}\n  };\n\n  var _iterator5 = _createForOfIteratorHelper(contracts),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var contract = _step5.value;\n      var contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n\n      if (contract.constructorContext) {\n        allocations.constructorAllocations[contract.constructorContext.context] = contractAllocations.constructorAllocation;\n      }\n\n      if (contract.deployedContext) {\n        allocations.functionAllocations[contract.deployedContext.context] = contractAllocations.functionAllocations; //set this up under both constructor *and* deployed! this is to handle\n        //constructor returndata decoding\n\n        allocations.constructorAllocations[contract.deployedContext.context] = contractAllocations.constructorAllocation;\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return allocations;\n}\n\nexports.getCalldataAllocations = getCalldataAllocations;\n\nfunction getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  return abi.filter(function (abiEntry) {\n    return abiEntry.type === \"event\";\n  }).filter(function (abiEntry) {\n    return !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry);\n  }) //hack workaround\n  .map(function (abiEntry) {\n    return {\n      selector: AbiDataUtils.abiSelector(abiEntry),\n      anonymous: abiEntry.anonymous,\n      topics: AbiDataUtils.topicsCount(abiEntry),\n      allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)\n    };\n  }); //note we do *not* filter out undefined allocations; we need these as placeholders\n} //note: constructor context is ignored by this function; no need to pass it in\n//WARNING: this function is full of hacks... sorry\n\n\nfunction getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  //first: do allocations for individual contracts\n  var individualAllocations = {};\n  var groupedAllocations = {};\n  var allocations = {};\n\n  var _iterator6 = _createForOfIteratorHelper(contracts),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _step6$value = _step6.value,\n          abi = _step6$value.abi,\n          deployedContext = _step6$value.deployedContext,\n          contractNode = _step6$value.contractNode,\n          compilationId = _step6$value.compilationId,\n          compiler = _step6$value.compiler;\n\n      if (!deployedContext && !contractNode) {\n        //we'll need *one* of these two at least\n        continue;\n      }\n\n      var contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);\n      var key = makeContractKey(deployedContext, contractNode ? contractNode.id : undefined, compilationId);\n\n      if (individualAllocations[key] === undefined) {\n        individualAllocations[key] = {};\n      }\n\n      var _iterator9 = _createForOfIteratorHelper(contractAllocations),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var allocationTemporary = _step9.value;\n          //we'll use selector *even for anonymous* here, because it's just\n          //for determining what overrides what at this point\n          individualAllocations[key][allocationTemporary.selector] = {\n            context: deployedContext,\n            contractNode: contractNode,\n            allocationTemporary: allocationTemporary,\n            compilationId: compilationId\n          };\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    } //now: put things together for inheritance\n    //note how we always put things in order from most derived to most base\n\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  for (var contextOrId in individualAllocations) {\n    groupedAllocations[contextOrId] = {};\n\n    var _loop2 = function _loop2(selector) {\n      var _individualAllocation = individualAllocations[contextOrId][selector],\n          context = _individualAllocation.context,\n          contractNode = _individualAllocation.contractNode,\n          allocationTemporary = _individualAllocation.allocationTemporary,\n          compilationId = _individualAllocation.compilationId;\n      debug(\"allocationTemporary: %O\", allocationTemporary);\n      var allocationsTemporary = allocationTemporary.allocation ? [allocationTemporary] : []; //filter out undefined allocations\n      //first, copy from individual allocations\n\n      groupedAllocations[contextOrId][selector] = {\n        context: context,\n        contractNode: contractNode,\n        allocationsTemporary: allocationsTemporary\n      }; //if no contract node, that's all.  if there is...\n\n      if (contractNode) {\n        //...we have to do inheritance processing\n        debug(\"contract Id: %d\", contractNode.id);\n        debug(\"base contracts: %o\", contractNode.linearizedBaseContracts);\n        var linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n        linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors\n\n        var _iterator7 = _createForOfIteratorHelper(linearizedBaseContractsMinusSelf),\n            _step7;\n\n        try {\n          var _loop3 = function _loop3() {\n            var baseId = _step7.value;\n            debug(\"checking baseId: %d\", baseId);\n            var baseNode = referenceDeclarations[compilationId][baseId];\n\n            if (!baseNode || baseNode.nodeType !== \"ContractDefinition\") {\n              debug(\"failed to find node for baseId: %d\", baseId);\n              return \"break\"; //not a continue!\n              //if we can't find the base node, it's better to stop the loop,\n              //rather than continue to potentially erroneous things\n            } //note: we're not actually going to *use* the baseNode here.\n            //we're just checking for whether we can *find* it\n            //why? because if we couldn't find it, that means that events defined in\n            //base contracts *weren't* skipped earlier, and so we shouldn't now add them in\n\n\n            var baseContractInfo = contracts.find(function (contractAllocationInfo) {\n              return contractAllocationInfo.compilationId === compilationId && contractAllocationInfo.contractNode && contractAllocationInfo.contractNode.id === baseId;\n            });\n\n            if (!baseContractInfo) {\n              //similar to above... this failure case can happen when there are\n              //two contracts with the same name and you attempt to use the\n              //artifacts; say you have contracts A, B, and B', where A inherits\n              //from B, and B and B' have the same name, and B' is the one that\n              //gets the artifact; B will end up in reference declarations and so\n              //get found above, but it won't appear in contracts, causing the\n              //problem here.  Unfortunately I don't know any great way to handle this,\n              //so, uh, we treat it as a failure same as above.\n              debug(\"failed to find contract info for baseId: %d\", baseId);\n              return \"break\";\n            }\n\n            var baseContext = baseContractInfo.deployedContext;\n            var baseKey = makeContractKey(baseContext, baseId, compilationId);\n\n            if (individualAllocations[baseKey][selector] !== undefined) {\n              var baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;\n              debug(\"(probably) pushing inherited alloc from baseId: %d\", baseId);\n\n              if (baseAllocation.allocation) {\n                //don't push undefined!\n                groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);\n              }\n            }\n          };\n\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _ret2 = _loop3();\n\n            if (_ret2 === \"break\") break;\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n    };\n\n    for (var selector in individualAllocations[contextOrId]) {\n      _loop2(selector);\n    }\n  } //finally: transform into final form & return,\n  //filtering out things w/o a context\n\n\n  for (var contractKey in groupedAllocations) {\n    if (!hasContext(contractKey)) {\n      continue; //(this filters out ones that had no context and therefore were\n      //given by ID; we needed these at the previous stage but from\n      //here on they're irrelevant)\n    }\n\n    var contextHash = contextHashForKey(contractKey);\n\n    for (var _selector in groupedAllocations[contextHash]) {\n      var _groupedAllocations$c = groupedAllocations[contextHash][_selector],\n          allocationsTemporary = _groupedAllocations$c.allocationsTemporary,\n          context = _groupedAllocations$c.context;\n\n      var _iterator8 = _createForOfIteratorHelper(allocationsTemporary),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _step8.value,\n              anonymous = _step8$value.anonymous,\n              topics = _step8$value.topics,\n              allocation = _step8$value.allocation;\n          var contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK\n\n          if (contractKind !== \"library\") {\n            contractKind = \"contract\"; //round off interfaces to being contracts for our purposes :P\n          }\n\n          allocation = Object.assign(Object.assign({}, allocation), {\n            contextHash: contextHash\n          }); //the allocation's context hash at this point depends on where it was defined, but\n          //that's not what we want going in the final allocation table!\n\n          if (allocations[topics] === undefined) {\n            allocations[topics] = {\n              bySelector: {},\n              anonymous: {\n                contract: {},\n                library: {}\n              }\n            };\n          }\n\n          if (!anonymous) {\n            if (allocations[topics].bySelector[_selector] === undefined) {\n              allocations[topics].bySelector[_selector] = {\n                contract: {},\n                library: {}\n              };\n            }\n\n            if (allocations[topics].bySelector[_selector][contractKind][contextHash] === undefined) {\n              allocations[topics].bySelector[_selector][contractKind][contextHash] = [];\n            }\n\n            allocations[topics].bySelector[_selector][contractKind][contextHash].push(allocation);\n          } else {\n            if (allocations[topics].anonymous[contractKind][contextHash] === undefined) {\n              allocations[topics].anonymous[contractKind][contextHash] = [];\n            }\n\n            allocations[topics].anonymous[contractKind][contextHash].push(allocation);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getEventAllocations = getEventAllocations; //if derivedContractNode is passed, we check that before referenceDeclarations\n\nfunction findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {\n  var searchResult = linearizedBaseContracts.reduce(function (foundNodeAndContract, baseContractId) {\n    if (foundNodeAndContract !== undefined) {\n      return foundNodeAndContract; //once we've found something, we don't need to keep looking\n    }\n\n    debug(\"searching contract %d\", baseContractId);\n    var baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision\n    : referenceDeclarations[baseContractId];\n\n    if (baseContractNode === undefined || baseContractNode.nodeType !== \"ContractDefinition\") {\n      debug(\"bad contract node!\");\n      return null; //return null rather than undefined so that this will propagate through\n      //(i.e. by returning null here we give up the search)\n      //(we don't want to continue due to possibility of grabbing the wrong override)\n    }\n\n    var node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!\n\n    if (node) {\n      debug(\"found node: %o\", node);\n      return {\n        node: node,\n        contract: baseContractNode\n      };\n    } else {\n      return undefined;\n    }\n  }, undefined //start with no node found\n  );\n  return searchResult || {\n    node: undefined,\n    contract: undefined\n  };\n}\n\nfunction makeContractKey(context, id, compilationId) {\n  return context ? context.context : id + \":\" + compilationId; //HACK!\n}\n\nfunction hasContext(key) {\n  return key.startsWith(\"0x\"); //HACK!\n}\n\nfunction contextHashForKey(key) {\n  return hasContext(key) ? key //HACK!\n  : undefined;\n}","map":{"version":3,"sources":["../../../../lib/abi-data/allocate/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getEventAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abi-data:allocate\");\nconst Import = __importStar(require(\"../import\"));\nconst AbiDataUtils = __importStar(require(\"../utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst Common = __importStar(require(\"../../common\"));\nconst Ast = __importStar(require(\"../../ast\"));\nconst Format = __importStar(require(\"../../format\"));\nconst lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\nexports.FallbackOutputAllocation = {\n    kind: \"returnmessage\",\n    selector: new Uint8Array(),\n    allocationMode: \"full\"\n};\nfunction getAbiAllocations(userDefinedTypes) {\n    let allocations = {};\n    for (const dataType of Object.values(userDefinedTypes)) {\n        if (dataType.typeClass === \"struct\") {\n            try {\n                allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n            }\n            catch (_) {\n                //if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n                //note: a better way of handling this would probably be to *mark* it\n                //as failed rather than throwing an exception as that would lead to less\n                //recomputation, but this is simpler and I don't think the recomputation\n                //should really be a problem\n            }\n        }\n    }\n    return allocations;\n}\nexports.getAbiAllocations = getAbiAllocations;\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n    //NOTE: dataType here should be a *stored* type!\n    //it is up to the caller to take care of this\n    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n}\n//note: we will still allocate circular structs, even though they're not allowed in the abi, because it's\n//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, start = 0) {\n    let dynamic = false;\n    //note that we will mutate the start argument also!\n    //don't allocate things that have already been allocated\n    if (parentId in existingAllocations) {\n        return existingAllocations;\n    }\n    let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n    let memberAllocations = [];\n    for (const member of members) {\n        let length;\n        let dynamicMember;\n        ({ size: length, dynamic: dynamicMember, allocations } = abiSizeAndAllocate(member.type, userDefinedTypes, allocations));\n        //vomit on illegal types in calldata -- note the short-circuit!\n        if (length === undefined) {\n            allocations[parentId] = null;\n            return allocations;\n        }\n        let pointer = {\n            location: \"abi\",\n            start,\n            length\n        };\n        memberAllocations.push({\n            name: member.name,\n            type: member.type,\n            pointer\n        });\n        start += length;\n        dynamic = dynamic || dynamicMember;\n    }\n    allocations[parentId] = {\n        members: memberAllocations,\n        length: dynamic ? Evm.Utils.WORD_SIZE : start,\n        dynamic\n    };\n    return allocations;\n}\n//first return value is the actual size.\n//second return value is whether the type is dynamic\n//both will be undefined if type is a mapping or internal function\n//third return value is resulting allocations, INCLUDING the ones passed in\nfunction abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n    switch (dataType.typeClass) {\n        case \"bool\":\n        case \"address\":\n        case \"contract\":\n        case \"int\":\n        case \"uint\":\n        case \"fixed\":\n        case \"ufixed\":\n        case \"enum\":\n            return {\n                size: Evm.Utils.WORD_SIZE,\n                dynamic: false,\n                allocations: existingAllocations\n            };\n        case \"string\":\n            return {\n                size: Evm.Utils.WORD_SIZE,\n                dynamic: true,\n                allocations: existingAllocations\n            };\n        case \"bytes\":\n            return {\n                size: Evm.Utils.WORD_SIZE,\n                dynamic: dataType.kind === \"dynamic\",\n                allocations: existingAllocations\n            };\n        case \"mapping\":\n            return {\n                allocations: existingAllocations\n            };\n        case \"function\":\n            switch (dataType.visibility) {\n                case \"external\":\n                    return {\n                        size: Evm.Utils.WORD_SIZE,\n                        dynamic: false,\n                        allocations: existingAllocations\n                    };\n                case \"internal\":\n                    return {\n                        allocations: existingAllocations\n                    };\n            }\n        case \"array\": {\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    return {\n                        size: Evm.Utils.WORD_SIZE,\n                        dynamic: true,\n                        allocations: existingAllocations\n                    };\n                case \"static\":\n                    if (dataType.length.isZero()) {\n                        //arrays of length 0 are static regardless of base type\n                        return {\n                            size: 0,\n                            dynamic: false,\n                            allocations: existingAllocations\n                        };\n                    }\n                    const { size: baseSize, dynamic, allocations } = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n                    return {\n                        //WARNING!  The use of toNumber() here may throw an exception!\n                        //I'm judging this OK since if you have arrays that large we have bigger problems :P\n                        size: dataType.length.toNumber() * baseSize,\n                        dynamic,\n                        allocations\n                    };\n            }\n        }\n        case \"struct\": {\n            let allocations = existingAllocations;\n            let allocation = allocations[dataType.id];\n            if (allocation === undefined) {\n                //if we don't find an allocation, we'll have to do the allocation ourselves\n                const storedType = (userDefinedTypes[dataType.id]);\n                if (!storedType) {\n                    throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n                }\n                allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n                allocation = allocations[storedType.id];\n            }\n            //having found our allocation, if it's not null, we can just look up its size and dynamicity\n            if (allocation !== null) {\n                return {\n                    size: allocation.length,\n                    dynamic: allocation.dynamic,\n                    allocations\n                };\n            }\n            //if it is null, this type doesn't go in the abi\n            else {\n                return {\n                    allocations\n                };\n            }\n        }\n        case \"tuple\": {\n            //Warning! Yucky wasteful recomputation here!\n            let size = 0;\n            let dynamic = false;\n            //note that we don't just invoke allocateStruct here!\n            //why not? because it has no ID to store the result in!\n            //and we can't use a fake like -1 because there might be a recursive call to it,\n            //and then the results would overwrite each other\n            //I mean, we could do some hashing thing or something, but I think it's easier to just\n            //copy the logic in this one case (sorry)\n            for (let member of dataType.memberTypes) {\n                let { size: memberSize, dynamic: memberDynamic } = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations);\n                size += memberSize;\n                dynamic = dynamic || memberDynamic;\n            }\n            return { size, dynamic, allocations: existingAllocations };\n        }\n    }\n}\n//assumes you've already done allocation! don't use if you haven't!\n/**\n * @protected\n */\nfunction abiSizeInfo(dataType, allocations) {\n    let { size, dynamic } = abiSizeAndAllocate(dataType, null, allocations);\n    //the above line should work fine... as long as allocation is already done!\n    //the middle argument, userDefinedTypes, is only needed during allocation\n    //again, this function is only for use if allocation is done, so it's safe to pass null here\n    return { size, dynamic };\n}\nexports.abiSizeInfo = abiSizeInfo;\n//allocates an external call\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n//NOTE: returns undefined if attempting to allocate a constructor but we don't have the\n//bytecode for the constructor\nfunction allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {\n    //first: determine the corresponding function node\n    //(simultaneously: determine the offset)\n    let node = undefined;\n    let inputParametersFull;\n    let outputParametersFull;\n    let inputParametersAbi;\n    let outputParametersAbi;\n    let offset; //refers to INPUT offset; output offset is always 0\n    switch (abiEntry.type) {\n        case \"constructor\":\n            if (!constructorContext) {\n                return undefined;\n            }\n            let rawLength = constructorContext.binary.length;\n            offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n            //for a constructor, we only want to search the particular contract\n            if (contractNode) {\n                node = contractNode.nodes.find(functionNode => AbiDataUtils.definitionMatchesAbi(\n                //note this needn't actually be a function node, but then it will\n                //return false (well, unless it's a getter node!)\n                abiEntry, functionNode, referenceDeclarations));\n            }\n            //if we can't find it, we'll handle this below\n            break;\n        case \"function\":\n            offset = Evm.Utils.SELECTOR_SIZE;\n            //search through base contracts, from most derived (left) to most base (right)\n            if (contractNode) {\n                const linearizedBaseContracts = contractNode.linearizedBaseContracts;\n                debug(\"linearized: %O\", linearizedBaseContracts);\n                node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, functionNode => AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations), contractNode).node; //may be undefined!  that's OK!\n            }\n            break;\n    }\n    //now: get the parameters (both full-mode & ABI)\n    if (node) {\n        switch (node.nodeType) {\n            case \"FunctionDefinition\":\n                //normal case\n                inputParametersFull = node.parameters.parameters;\n                outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!\n                break;\n            case \"VariableDeclaration\":\n                //getter case\n                ({\n                    inputs: inputParametersFull,\n                    outputs: outputParametersFull\n                } = Ast.Utils.getterParameters(node, referenceDeclarations));\n                break;\n        }\n    }\n    else {\n        inputParametersFull = undefined;\n        outputParametersFull = undefined;\n    }\n    inputParametersAbi = abiEntry.inputs;\n    switch (abiEntry.type) {\n        case \"function\":\n            outputParametersAbi = abiEntry.outputs;\n            break;\n        case \"constructor\":\n            //we just leave this empty for constructors\n            outputParametersAbi = [];\n            break;\n    }\n    //now: do the allocation!\n    let { allocation: abiAllocationInput, mode: inputMode } = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset);\n    let { allocation: abiAllocationOutput, mode: outputMode } = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler\n    //note no offset\n    );\n    //finally: transform the allocation appropriately\n    let inputArgumentsAllocation = abiAllocationInput.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {\n            location: \"calldata\",\n            start: member.pointer.start,\n            length: member.pointer.length\n        } })));\n    let outputArgumentsAllocation = abiAllocationOutput.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {\n            location: \"returndata\",\n            start: member.pointer.start,\n            length: member.pointer.length\n        } })));\n    let inputsAllocation = {\n        abi: abiEntry,\n        offset,\n        arguments: inputArgumentsAllocation,\n        allocationMode: inputMode\n    };\n    let outputsAllocation;\n    switch (abiEntry.type) {\n        case \"function\":\n            outputsAllocation = {\n                selector: new Uint8Array(),\n                arguments: outputArgumentsAllocation,\n                allocationMode: outputMode,\n                kind: \"return\"\n            };\n            break;\n        case \"constructor\":\n            outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);\n            break;\n    }\n    return { input: inputsAllocation, output: outputsAllocation };\n}\n//note: allocateEvent doesn't use this because it needs additional\n//handling for indexed parameters (maybe these can be unified in\n//the future though?)\nfunction allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler, offset = 0) {\n    let allocationMode = fullModeParameters ? \"full\" : \"abi\"; //can degrade\n    let parameterTypes;\n    let abiAllocation;\n    if (allocationMode === \"full\") {\n        let id = \"-1\"; //fake ID that doesn't matter\n        parameterTypes = fullModeParameters.map(parameter => ({\n            name: parameter.name,\n            type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!\n        }));\n        debug(\"parameterTypes: %O\", parameterTypes);\n        //now: perform the allocation!\n        try {\n            abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n        }\n        catch (_a) {\n            //if something goes wrong, switch to ABI mdoe\n            allocationMode = \"abi\";\n        }\n    }\n    if (allocationMode === \"abi\") {\n        //THIS IS DELIBERATELY NOT AN ELSE\n        //this is the ABI case.  we end up here EITHER\n        //if node doesn't exist, OR if something went wrong\n        //during allocation\n        let id = \"-1\"; //fake irrelevant ID\n        parameterTypes = abiParameters.map(parameter => ({\n            name: parameter.name,\n            type: Import.abiParameterToType(parameter)\n        }));\n        abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n    }\n    return { allocation: abiAllocation, mode: allocationMode };\n}\n//allocates an event\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\nfunction allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n    let parameterTypes;\n    let id;\n    //first: determine the corresponding event node\n    //search through base contracts, from most derived (right) to most base (left)\n    let node = undefined;\n    let definedIn = undefined;\n    let allocationMode = \"full\"; //degrade to abi as needed\n    debug(\"allocating ABI: %O\", abiEntry);\n    if (contractNode) {\n        //first: check same contract for the event\n        node = contractNode.nodes.find(eventNode => AbiDataUtils.definitionMatchesAbi(\n        //note this needn't actually be an event node, but then it will\n        //return false\n        abiEntry, eventNode, referenceDeclarations));\n        //if we found the node, great!  If not...\n        if (!node) {\n            debug(\"didn't find node in base contract...\");\n            //let's search for the node among the base contracts.\n            //but if we find it...\n            //[note: the following code is overcomplicated; it was used\n            //when we were trying to get the actual node, it's overcomplicated\n            //now that we're just determining its presence.  oh well]\n            let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n            linearizedBaseContractsMinusSelf.shift(); //remove self\n            debug(\"checking contracts: %o\", linearizedBaseContractsMinusSelf);\n            node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, eventNode => AbiDataUtils.definitionMatchesAbi(\n            //note this needn't actually be a event node, but then it will return false\n            abiEntry, eventNode, referenceDeclarations)\n            //don't pass deriveContractNode here, we're not checking the contract itself\n            ).node; //may be undefined! that's OK!\n            if (node) {\n                //...if we find the node in an ancestor, we\n                //deliberately *don't* allocate!  instead such cases\n                //will be handled during a later combination step\n                debug(\"bailing out for later handling!\");\n                debug(\"ABI: %O\", abiEntry);\n                return undefined;\n            }\n        }\n    }\n    //otherwise, leave node undefined\n    if (node) {\n        debug(\"found node\");\n        //if we found the node, let's also turn it into a type\n        definedIn = (Ast.Import.definitionToStoredType(contractNode, compilationId, compiler)); //can skip reference declarations argument here\n    }\n    else {\n        //if no node, have to fall back into ABI mode\n        debug(\"falling back to ABI because no node\");\n        allocationMode = \"abi\";\n    }\n    //now: construct the list of parameter types, attaching indexedness info\n    //and overall position (for later reconstruction)\n    let indexed;\n    let nonIndexed;\n    let abiAllocation; //the untransformed allocation for the non-indexed parameters\n    if (allocationMode === \"full\") {\n        let id = node.id.toString();\n        let parameters = node.parameters.parameters;\n        parameterTypes = parameters.map(definition => ({\n            //note: if node is defined, compiler had better be defined, too!\n            type: Ast.Import.definitionToType(definition, compilationId, compiler),\n            name: definition.name,\n            indexed: definition.indexed\n        }));\n        //now: split the list of parameters into indexed and non-indexed\n        [indexed, nonIndexed] = lodash_partition_1.default(parameterTypes, (parameter) => parameter.indexed);\n        try {\n            //now: perform the allocation for the non-indexed parameters!\n            abiAllocation = allocateMembers(id, nonIndexed, userDefinedTypes, abiAllocations)[id]; //note the implicit conversion from EventParameterInfo to NameTypePair\n        }\n        catch (_a) {\n            allocationMode = \"abi\";\n        }\n    }\n    if (allocationMode === \"abi\") {\n        //THIS IS DELIBERATELY NOT AN ELSE\n        id = \"-1\"; //fake irrelevant ID\n        parameterTypes = abiEntry.inputs.map(abiParameter => ({\n            type: Import.abiParameterToType(abiParameter),\n            name: abiParameter.name,\n            indexed: abiParameter.indexed\n        }));\n        //now: split the list of parameters into indexed and non-indexed\n        [indexed, nonIndexed] = lodash_partition_1.default(parameterTypes, (parameter) => parameter.indexed);\n        //now: perform the allocation for the non-indexed parameters!\n        abiAllocation = allocateMembers(id, nonIndexed, userDefinedTypes, abiAllocations)[id]; //note the implicit conversion from EventParameterInfo to NameTypePair\n    }\n    //now: transform the result appropriately\n    const nonIndexedArgumentsAllocation = abiAllocation.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {\n            location: \"eventdata\",\n            start: member.pointer.start,\n            length: member.pointer.length\n        } })));\n    //now: allocate the indexed parameters\n    const startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0\n    const indexedArgumentsAllocation = indexed.map(({ type, name }, position) => ({\n        type,\n        name,\n        pointer: {\n            location: \"eventtopic\",\n            topic: startingTopic + position\n        }\n    }));\n    //finally: weave these back together\n    let argumentsAllocation = [];\n    for (let parameter of parameterTypes) {\n        let arrayToGrabFrom = parameter.indexed\n            ? indexedArgumentsAllocation\n            : nonIndexedArgumentsAllocation;\n        argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n    }\n    //...and return\n    return {\n        abi: abiEntry,\n        contextHash: undefined,\n        definedIn,\n        arguments: argumentsAllocation,\n        allocationMode,\n        anonymous: abiEntry.anonymous\n    };\n}\nfunction getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n    let allocations = {\n        constructorAllocation: undefined,\n        //(if it doesn't then it will remain as default)\n        functionAllocations: {}\n    };\n    if (!abi) {\n        //if no ABI, can't do much!\n        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n        return allocations;\n    }\n    for (let abiEntry of abi) {\n        if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) ||\n            AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {\n            //the first of these conditions is a hack workaround for a Solidity bug.\n            //the second of these is because... seriously? we're not handling these\n            //(at least not for now!) (these only exist prior to Solidity 0.5.6,\n            //thankfully)\n            continue;\n        }\n        switch (abiEntry.type) {\n            case \"constructor\":\n                allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n                debug(\"constructor alloc: %O\", allocations.constructorAllocation);\n                break;\n            case \"function\":\n                allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n                break;\n            default:\n                //skip over fallback and event\n                break;\n        }\n    }\n    if (!allocations.constructorAllocation) {\n        //set a default constructor allocation if we haven't allocated one yet\n        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n        debug(\"default constructor alloc: %O\", allocations.constructorAllocation);\n    }\n    return allocations;\n}\nfunction defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {\n    if (!constructorContext) {\n        return undefined;\n    }\n    const rawLength = constructorContext.binary.length;\n    const offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n    const input = {\n        offset,\n        abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,\n        arguments: [],\n        allocationMode: \"full\"\n    };\n    const output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, \"full\"); //assume full, degrade as necessary\n    return { input, output };\n}\n//note: context should be deployed context!\nfunction constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {\n    if (!context) {\n        //just return a default abi mode result\n        return {\n            selector: new Uint8Array(),\n            allocationMode: \"abi\",\n            kind: \"bytecode\",\n            delegatecallGuard: false\n        };\n    }\n    const { immutableReferences, compilationId, compiler, contractKind, binary } = context;\n    let immutables;\n    if (allocationMode === \"full\" && immutableReferences) {\n        if (contractNode) {\n            debug(\"allocating immutables\");\n            immutables = [];\n            for (const [id, references] of Object.entries(immutableReferences)) {\n                if (references.length === 0) {\n                    continue; //don't allocate immutables that don't exist\n                }\n                const astId = parseInt(id);\n                //get the corresponding variable node; potentially fail\n                const { node: definition, contract: definedIn } = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, node => node.id === astId, contractNode);\n                if (!definition || definition.nodeType !== \"VariableDeclaration\") {\n                    debug(\"didn't find definition for %d!\", astId);\n                    allocationMode = \"abi\";\n                    immutables = undefined;\n                    break;\n                }\n                const definedInClass = (Ast.Import.definitionToStoredType(definedIn, compilationId, compiler)); //can skip reference declarations argument here\n                const dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n                immutables.push({\n                    name: definition.name,\n                    definedIn: definedInClass,\n                    type: dataType,\n                    pointer: {\n                        location: \"returndata\",\n                        start: references[0].start,\n                        length: references[0].length\n                    }\n                });\n            }\n        }\n        else if (Object.entries(immutableReferences).length > 0) {\n            //if there are immutables, but no contract mode, go to abi mode\n            debug(\"immutables but no node!\");\n            allocationMode = \"abi\";\n        }\n    }\n    else {\n        debug(\"no immutables\");\n    }\n    //now, is there a delegatecall guard?\n    let delegatecallGuard = false;\n    if (contractKind === \"library\") {\n        //note: I am relying on this being present!\n        //(also this part is a bit HACKy)\n        const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n        const delegateCallGuardString = \"0x\" + pushAddressInstruction + \"..\".repeat(Evm.Utils.ADDRESS_SIZE);\n        if (binary.startsWith(delegateCallGuardString)) {\n            delegatecallGuard = true;\n        }\n    }\n    return {\n        selector: new Uint8Array(),\n        allocationMode,\n        kind: \"bytecode\",\n        immutables,\n        delegatecallGuard\n    };\n}\nfunction getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n    let allocations = {\n        constructorAllocations: {},\n        functionAllocations: {}\n    };\n    for (let contract of contracts) {\n        const contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n        if (contract.constructorContext) {\n            allocations.constructorAllocations[contract.constructorContext.context] =\n                contractAllocations.constructorAllocation;\n        }\n        if (contract.deployedContext) {\n            allocations.functionAllocations[contract.deployedContext.context] =\n                contractAllocations.functionAllocations;\n            //set this up under both constructor *and* deployed! this is to handle\n            //constructor returndata decoding\n            allocations.constructorAllocations[contract.deployedContext.context] =\n                contractAllocations.constructorAllocation;\n        }\n    }\n    return allocations;\n}\nexports.getCalldataAllocations = getCalldataAllocations;\nfunction getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n    return abi\n        .filter((abiEntry) => abiEntry.type === \"event\")\n        .filter((abiEntry) => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n        .map((abiEntry) => ({\n        selector: AbiDataUtils.abiSelector(abiEntry),\n        anonymous: abiEntry.anonymous,\n        topics: AbiDataUtils.topicsCount(abiEntry),\n        allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)\n    }));\n    //note we do *not* filter out undefined allocations; we need these as placeholders\n}\n//note: constructor context is ignored by this function; no need to pass it in\n//WARNING: this function is full of hacks... sorry\nfunction getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n    //first: do allocations for individual contracts\n    let individualAllocations = {};\n    let groupedAllocations = {};\n    let allocations = {};\n    for (let { abi, deployedContext, contractNode, compilationId, compiler } of contracts) {\n        if (!deployedContext && !contractNode) {\n            //we'll need *one* of these two at least\n            continue;\n        }\n        let contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);\n        let key = makeContractKey(deployedContext, contractNode ? contractNode.id : undefined, compilationId);\n        if (individualAllocations[key] === undefined) {\n            individualAllocations[key] = {};\n        }\n        for (let allocationTemporary of contractAllocations) {\n            //we'll use selector *even for anonymous* here, because it's just\n            //for determining what overrides what at this point\n            individualAllocations[key][allocationTemporary.selector] = {\n                context: deployedContext,\n                contractNode,\n                allocationTemporary,\n                compilationId\n            };\n        }\n    }\n    //now: put things together for inheritance\n    //note how we always put things in order from most derived to most base\n    for (let contextOrId in individualAllocations) {\n        groupedAllocations[contextOrId] = {};\n        for (let selector in individualAllocations[contextOrId]) {\n            let { context, contractNode, allocationTemporary, compilationId } = individualAllocations[contextOrId][selector];\n            debug(\"allocationTemporary: %O\", allocationTemporary);\n            let allocationsTemporary = allocationTemporary.allocation\n                ? [allocationTemporary]\n                : []; //filter out undefined allocations\n            //first, copy from individual allocations\n            groupedAllocations[contextOrId][selector] = {\n                context,\n                contractNode,\n                allocationsTemporary\n            };\n            //if no contract node, that's all.  if there is...\n            if (contractNode) {\n                //...we have to do inheritance processing\n                debug(\"contract Id: %d\", contractNode.id);\n                debug(\"base contracts: %o\", contractNode.linearizedBaseContracts);\n                let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n                linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors\n                for (let baseId of linearizedBaseContractsMinusSelf) {\n                    debug(\"checking baseId: %d\", baseId);\n                    let baseNode = referenceDeclarations[compilationId][baseId];\n                    if (!baseNode || baseNode.nodeType !== \"ContractDefinition\") {\n                        debug(\"failed to find node for baseId: %d\", baseId);\n                        break; //not a continue!\n                        //if we can't find the base node, it's better to stop the loop,\n                        //rather than continue to potentially erroneous things\n                    }\n                    //note: we're not actually going to *use* the baseNode here.\n                    //we're just checking for whether we can *find* it\n                    //why? because if we couldn't find it, that means that events defined in\n                    //base contracts *weren't* skipped earlier, and so we shouldn't now add them in\n                    let baseContractInfo = contracts.find(contractAllocationInfo => contractAllocationInfo.compilationId === compilationId &&\n                        contractAllocationInfo.contractNode &&\n                        contractAllocationInfo.contractNode.id === baseId);\n                    if (!baseContractInfo) {\n                        //similar to above... this failure case can happen when there are\n                        //two contracts with the same name and you attempt to use the\n                        //artifacts; say you have contracts A, B, and B', where A inherits\n                        //from B, and B and B' have the same name, and B' is the one that\n                        //gets the artifact; B will end up in reference declarations and so\n                        //get found above, but it won't appear in contracts, causing the\n                        //problem here.  Unfortunately I don't know any great way to handle this,\n                        //so, uh, we treat it as a failure same as above.\n                        debug(\"failed to find contract info for baseId: %d\", baseId);\n                        break;\n                    }\n                    let baseContext = baseContractInfo.deployedContext;\n                    let baseKey = makeContractKey(baseContext, baseId, compilationId);\n                    if (individualAllocations[baseKey][selector] !== undefined) {\n                        let baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;\n                        debug(\"(probably) pushing inherited alloc from baseId: %d\", baseId);\n                        if (baseAllocation.allocation) {\n                            //don't push undefined!\n                            groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //finally: transform into final form & return,\n    //filtering out things w/o a context\n    for (let contractKey in groupedAllocations) {\n        if (!hasContext(contractKey)) {\n            continue;\n            //(this filters out ones that had no context and therefore were\n            //given by ID; we needed these at the previous stage but from\n            //here on they're irrelevant)\n        }\n        let contextHash = contextHashForKey(contractKey);\n        for (let selector in groupedAllocations[contextHash]) {\n            let { allocationsTemporary, context } = groupedAllocations[contextHash][selector];\n            for (let { anonymous, topics, allocation } of allocationsTemporary) {\n                let contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK\n                if (contractKind !== \"library\") {\n                    contractKind = \"contract\"; //round off interfaces to being contracts for our purposes :P\n                }\n                allocation = Object.assign(Object.assign({}, allocation), { contextHash }); //the allocation's context hash at this point depends on where it was defined, but\n                //that's not what we want going in the final allocation table!\n                if (allocations[topics] === undefined) {\n                    allocations[topics] = {\n                        bySelector: {},\n                        anonymous: { contract: {}, library: {} }\n                    };\n                }\n                if (!anonymous) {\n                    if (allocations[topics].bySelector[selector] === undefined) {\n                        allocations[topics].bySelector[selector] = {\n                            contract: {},\n                            library: {}\n                        };\n                    }\n                    if (allocations[topics].bySelector[selector][contractKind][contextHash] === undefined) {\n                        allocations[topics].bySelector[selector][contractKind][contextHash] = [];\n                    }\n                    allocations[topics].bySelector[selector][contractKind][contextHash].push(allocation);\n                }\n                else {\n                    if (allocations[topics].anonymous[contractKind][contextHash] ===\n                        undefined) {\n                        allocations[topics].anonymous[contractKind][contextHash] = [];\n                    }\n                    allocations[topics].anonymous[contractKind][contextHash].push(allocation);\n                }\n            }\n        }\n    }\n    return allocations;\n}\nexports.getEventAllocations = getEventAllocations;\n//if derivedContractNode is passed, we check that before referenceDeclarations\nfunction findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {\n    const searchResult = linearizedBaseContracts.reduce((foundNodeAndContract, baseContractId) => {\n        if (foundNodeAndContract !== undefined) {\n            return foundNodeAndContract; //once we've found something, we don't need to keep looking\n        }\n        debug(\"searching contract %d\", baseContractId);\n        let baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id\n            ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision\n            : referenceDeclarations[baseContractId];\n        if (baseContractNode === undefined ||\n            baseContractNode.nodeType !== \"ContractDefinition\") {\n            debug(\"bad contract node!\");\n            return null; //return null rather than undefined so that this will propagate through\n            //(i.e. by returning null here we give up the search)\n            //(we don't want to continue due to possibility of grabbing the wrong override)\n        }\n        const node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!\n        if (node) {\n            debug(\"found node: %o\", node);\n            return {\n                node,\n                contract: baseContractNode\n            };\n        }\n        else {\n            return undefined;\n        }\n    }, undefined //start with no node found\n    );\n    return searchResult || { node: undefined, contract: undefined };\n}\nfunction makeContractKey(context, id, compilationId) {\n    return context ? context.context : id + \":\" + compilationId; //HACK!\n}\nfunction hasContext(key) {\n    return key.startsWith(\"0x\"); //HACK!\n}\nfunction contextHashForKey(key) {\n    return hasContext(key)\n        ? key //HACK!\n        : undefined;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}