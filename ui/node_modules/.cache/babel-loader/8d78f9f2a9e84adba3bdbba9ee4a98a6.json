{"ast":null,"code":"// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n// binary-parse-stream is now unmaintained, so I'm going to rewrite it as\n// more modern JS so I can get tsc to help check types.\n'use strict';\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Stream = require('stream');\n\nvar NoFilter = require('nofilter');\n\nvar TransformStream = Stream.Transform;\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @class BinaryParseStream\n * @extends {TransformStream}\n */\n\nvar BinaryParseStream = /*#__PURE__*/function (_TransformStream) {\n  _inherits(BinaryParseStream, _TransformStream);\n\n  var _super = _createSuper(BinaryParseStream);\n\n  function BinaryParseStream(options) {\n    var _this;\n\n    _classCallCheck(this, BinaryParseStream);\n\n    _this = _super.call(this, options); // doesn't work to pass these in as opts, for some reason\n\n    _this['_writableState'].objectMode = false;\n    _this['_readableState'].objectMode = true;\n    _this.bs = new NoFilter();\n\n    _this.__restart();\n\n    return _this;\n  }\n\n  _createClass(BinaryParseStream, [{\n    key: \"_transform\",\n    value: function _transform(fresh, encoding, cb) {\n      this.bs.write(fresh);\n\n      while (this.bs.length >= this.__needed) {\n        var ret = void 0;\n        var chunk = this.__needed === null ? undefined : this.bs.read(this.__needed);\n\n        try {\n          ret = this.__parser.next(chunk);\n        } catch (e) {\n          return cb(e);\n        }\n\n        if (this.__needed) {\n          this.__fresh = false;\n        }\n\n        if (!ret.done) {\n          this.__needed = ret.value || 0;\n        } else {\n          this.push(ret.value);\n\n          this.__restart();\n        }\n      }\n\n      return cb();\n    }\n    /**\n     * @abstract\n     */\n\n    /* istanbul ignore next */\n\n  }, {\n    key: \"_parse\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _parse() {\n      return _regeneratorRuntime.wrap(function _parse$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              throw new Error('Must be implemented in subclass');\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _parse);\n    })\n  }, {\n    key: \"__restart\",\n    value: function __restart() {\n      this.__needed = null;\n      this.__parser = this._parse();\n      this.__fresh = true;\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(cb) {\n      cb(this.__fresh ? null : new Error('unexpected end of input'));\n    }\n  }]);\n\n  return BinaryParseStream;\n}(TransformStream);\n\nmodule.exports = BinaryParseStream;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/cbor/vendor/binary-parse-stream/index.js"],"names":["Stream","require","NoFilter","TransformStream","Transform","BinaryParseStream","options","objectMode","bs","__restart","fresh","encoding","cb","write","length","__needed","ret","chunk","undefined","read","__parser","next","e","__fresh","done","value","push","Error","_parse","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;AACA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAME,eAAe,GAAGH,MAAM,CAACI,SAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACMC,iB;;;;;AACJ,6BAAYC,OAAZ,EAAqB;AAAA;;AAAA;;AACnB,8BAAMA,OAAN,EADmB,CAEnB;;AACA,UAAK,gBAAL,EAAuBC,UAAvB,GAAoC,KAApC;AACA,UAAK,gBAAL,EAAuBA,UAAvB,GAAoC,IAApC;AAEA,UAAKC,EAAL,GAAU,IAAIN,QAAJ,EAAV;;AACA,UAAKO,SAAL;;AAPmB;AAQpB;;;;WAED,oBAAWC,KAAX,EAAkBC,QAAlB,EAA4BC,EAA5B,EAAgC;AAC9B,WAAKJ,EAAL,CAAQK,KAAR,CAAcH,KAAd;;AAEA,aAAO,KAAKF,EAAL,CAAQM,MAAR,IAAkB,KAAKC,QAA9B,EAAwC;AACtC,YAAIC,GAAG,SAAP;AACA,YAAMC,KAAK,GAAI,KAAKF,QAAL,KAAkB,IAAnB,GACZG,SADY,GACA,KAAKV,EAAL,CAAQW,IAAR,CAAa,KAAKJ,QAAlB,CADd;;AAGA,YAAI;AACFC,UAAAA,GAAG,GAAG,KAAKI,QAAL,CAAcC,IAAd,CAAmBJ,KAAnB,CAAN;AACD,SAFD,CAEE,OAAOK,CAAP,EAAU;AACV,iBAAOV,EAAE,CAACU,CAAD,CAAT;AACD;;AAED,YAAI,KAAKP,QAAT,EAAmB;AACjB,eAAKQ,OAAL,GAAe,KAAf;AACD;;AAED,YAAI,CAACP,GAAG,CAACQ,IAAT,EAAe;AACb,eAAKT,QAAL,GAAgBC,GAAG,CAACS,KAAJ,IAAa,CAA7B;AACD,SAFD,MAEO;AACL,eAAKC,IAAL,CAAUV,GAAG,CAACS,KAAd;;AACA,eAAKhB,SAAL;AACD;AACF;;AAED,aAAOG,EAAE,EAAT;AACD;AAED;AACF;AACA;;AACE;;;;;;6BACA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACQ,IAAIe,KAAJ,CAAU,iCAAV,CADR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,K;;;WAIA,qBAAY;AACV,WAAKZ,QAAL,GAAgB,IAAhB;AACA,WAAKK,QAAL,GAAgB,KAAKQ,MAAL,EAAhB;AACA,WAAKL,OAAL,GAAe,IAAf;AACD;;;WAED,gBAAOX,EAAP,EAAW;AACTA,MAAAA,EAAE,CAAC,KAAKW,OAAL,GAAe,IAAf,GAAsB,IAAII,KAAJ,CAAU,yBAAV,CAAvB,CAAF;AACD;;;;EAxD6BxB,e;;AA2DhC0B,MAAM,CAACC,OAAP,GAAiBzB,iBAAjB","sourcesContent":["// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n\n// binary-parse-stream is now unmaintained, so I'm going to rewrite it as\n// more modern JS so I can get tsc to help check types.\n\n'use strict'\nconst Stream = require('stream')\nconst NoFilter = require('nofilter')\nconst TransformStream = Stream.Transform\n\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @class BinaryParseStream\n * @extends {TransformStream}\n */\nclass BinaryParseStream extends TransformStream {\n  constructor(options) {\n    super(options)\n    // doesn't work to pass these in as opts, for some reason\n    this['_writableState'].objectMode = false\n    this['_readableState'].objectMode = true\n\n    this.bs = new NoFilter()\n    this.__restart()\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.bs.write(fresh)\n\n    while (this.bs.length >= this.__needed) {\n      let ret\n      const chunk = (this.__needed === null) ?\n        undefined : this.bs.read(this.__needed)\n\n      try {\n        ret = this.__parser.next(chunk)\n      } catch (e) {\n        return cb(e)\n      }\n  \n      if (this.__needed) {\n        this.__fresh = false\n      }\n\n      if (!ret.done) {\n        this.__needed = ret.value || 0\n      } else {\n        this.push(ret.value)\n        this.__restart()\n      }\n    }\n  \n    return cb()\n  }\n\n  /**\n   * @abstract\n   */\n  /* istanbul ignore next */\n  *_parse() {\n    throw new Error('Must be implemented in subclass')\n  }\n\n  __restart() {\n    this.__needed = null\n    this.__parser = this._parse()\n    this.__fresh = true\n  }\n\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'))\n  }\n}\n\nmodule.exports = BinaryParseStream\n"]},"metadata":{},"sourceType":"script"}