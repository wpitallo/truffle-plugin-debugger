{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readStackLiteral = exports.readStack = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:stack:read\");\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar errors_1 = require(\"../../errors\");\n\nfunction readStack(pointer, state) {\n  var from = pointer.from,\n      to = pointer.to;\n  var stack = state.stack;\n\n  if (from < 0 || to >= stack.length) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorStack\",\n      from: from,\n      to: to\n    });\n  } //unforunately, Uint8Arrays don't support concat; if they did the rest of\n  //this would be one line.  Or similarly if they worked with lodash's flatten,\n  //but they don't support that either.  But neither of those are the case, so\n  //we'll have to concatenate a bit more manually.\n\n\n  var words = stack.slice(from, to + 1);\n  var result = new Uint8Array(words.length * Evm.Utils.WORD_SIZE); //shouldn't we total up the lengths? yeah, but each one should have a\n  //length of 32, so unless somehting's gone wrong we can just multiply\n\n  for (var index = 0; index < words.length; index++) {\n    result.set(words[index], index * Evm.Utils.WORD_SIZE);\n  }\n\n  return result;\n}\n\nexports.readStack = readStack;\n\nfunction readStackLiteral(pointer) {\n  return pointer.literal;\n}\n\nexports.readStackLiteral = readStackLiteral;","map":{"version":3,"sources":["../../../../lib/stack/read/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,kBAAZ,CAAd;;AAEA,IAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAEA,SAAgB,SAAhB,CACE,OADF,EAEE,KAFF,EAEqB;AAAA,MAEb,IAFa,GAEA,OAFA,CAEb,IAFa;AAAA,MAEP,EAFO,GAEA,OAFA,CAEP,EAFO;AAAA,MAGb,KAHa,GAGH,KAHG,CAGb,KAHa;;AAInB,MAAI,IAAI,GAAG,CAAP,IAAY,EAAE,IAAI,KAAK,CAAC,MAA5B,EAAoC;AAClC,UAAM,IAAI,QAAA,CAAA,aAAJ,CAAkB;AACtB,MAAA,IAAI,EAAE,gBADgB;AAEtB,MAAA,IAAI,EAAJ,IAFsB;AAGtB,MAAA,EAAE,EAAF;AAHsB,KAAlB,CAAN;AAKD,GAVkB,CAWnB;AACA;AACA;AACA;;;AACA,MAAI,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,IAAZ,EAAkB,EAAE,GAAG,CAAvB,CAAZ;AACA,MAAI,MAAM,GAAG,IAAI,UAAJ,CAAe,KAAK,CAAC,MAAN,GAAe,GAAG,CAAC,KAAJ,CAAU,SAAxC,CAAb,CAhBmB,CAiBnB;AACA;;AACA,OAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,KAAK,CAAC,MAAlC,EAA0C,KAAK,EAA/C,EAAmD;AACjD,IAAA,MAAM,CAAC,GAAP,CAAW,KAAK,CAAC,KAAD,CAAhB,EAAyB,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,SAA3C;AACD;;AACD,SAAO,MAAP;AACD;;AAzBD,OAAA,CAAA,SAAA,GAAA,SAAA;;AA2BA,SAAgB,gBAAhB,CACE,OADF,EACsC;AAEpC,SAAO,OAAO,CAAC,OAAf;AACD;;AAJD,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readStackLiteral = exports.readStack = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:stack:read\");\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction readStack(pointer, state) {\n    let { from, to } = pointer;\n    let { stack } = state;\n    if (from < 0 || to >= stack.length) {\n        throw new errors_1.DecodingError({\n            kind: \"ReadErrorStack\",\n            from,\n            to\n        });\n    }\n    //unforunately, Uint8Arrays don't support concat; if they did the rest of\n    //this would be one line.  Or similarly if they worked with lodash's flatten,\n    //but they don't support that either.  But neither of those are the case, so\n    //we'll have to concatenate a bit more manually.\n    let words = stack.slice(from, to + 1);\n    let result = new Uint8Array(words.length * Evm.Utils.WORD_SIZE);\n    //shouldn't we total up the lengths? yeah, but each one should have a\n    //length of 32, so unless somehting's gone wrong we can just multiply\n    for (let index = 0; index < words.length; index++) {\n        result.set(words[index], index * Evm.Utils.WORD_SIZE);\n    }\n    return result;\n}\nexports.readStack = readStack;\nfunction readStackLiteral(pointer) {\n    return pointer.literal;\n}\nexports.readStackLiteral = readStackLiteral;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}