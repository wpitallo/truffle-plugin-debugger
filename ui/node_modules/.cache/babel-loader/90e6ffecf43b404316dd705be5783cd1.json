{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:format:types\");\n\nfunction isUserDefinedType(anyType) {\n  var userDefinedTypes = [\"contract\", \"enum\", \"struct\"];\n  return userDefinedTypes.includes(anyType.typeClass);\n}\n\nfunction isReferenceType(anyType) {\n  var alwaysReferenceTypes = [\"array\", \"mapping\", \"struct\", \"string\"];\n\n  if (alwaysReferenceTypes.includes(anyType.typeClass)) {\n    return true;\n  } else if (anyType.typeClass === \"bytes\") {\n    return anyType.kind === \"dynamic\";\n  } else {\n    return false;\n  }\n}\n\nexports.isReferenceType = isReferenceType; //one could define a counterpart function that stripped all unnecessary information\n//from the type object, but at the moment I see no need for that\n\nfunction fullType(basicType, userDefinedTypes) {\n  if (!isUserDefinedType(basicType)) {\n    return basicType;\n  }\n\n  var id = basicType.id;\n  var storedType = userDefinedTypes[id];\n\n  if (!storedType) {\n    return basicType;\n  }\n\n  var returnType = Object.assign(Object.assign({}, basicType), storedType);\n\n  if (isReferenceType(basicType) && basicType.location !== undefined) {\n    returnType = specifyLocation(returnType, basicType.location);\n  }\n\n  return returnType;\n}\n\nexports.fullType = fullType; //the location argument here always forces, so passing undefined *will* force undefined\n\nfunction specifyLocation(dataType, location) {\n  if (isReferenceType(dataType)) {\n    switch (dataType.typeClass) {\n      case \"string\":\n      case \"bytes\":\n        return Object.assign(Object.assign({}, dataType), {\n          location: location\n        });\n\n      case \"array\":\n        return Object.assign(Object.assign({}, dataType), {\n          location: location,\n          baseType: specifyLocation(dataType.baseType, location)\n        });\n\n      case \"mapping\":\n        var newLocation = location === \"storage\" ? \"storage\" : undefined;\n        return Object.assign(Object.assign({}, dataType), {\n          location: newLocation,\n          valueType: specifyLocation(dataType.valueType, newLocation)\n        });\n\n      case \"struct\":\n        var returnType = Object.assign(Object.assign({}, dataType), {\n          location: location\n        });\n\n        if (returnType.memberTypes) {\n          returnType.memberTypes = returnType.memberTypes.map(function (_ref) {\n            var memberName = _ref.name,\n                memberType = _ref.type;\n            return {\n              name: memberName,\n              type: specifyLocation(memberType, location)\n            };\n          });\n        }\n\n        return returnType;\n    }\n  } else {\n    return dataType;\n  }\n}\n\nexports.specifyLocation = specifyLocation; //NOTE: the following two functions might not be exactly right for weird internal stuff,\n//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things\n//are pointers or not??  we don't track that so we can't recreate that)\n//But what can you do.\n\nfunction typeString(dataType) {\n  var baseString = typeStringWithoutLocation(dataType);\n\n  if (isReferenceType(dataType) && dataType.location) {\n    return baseString + \" \" + dataType.location;\n  } else {\n    return baseString;\n  }\n}\n\nexports.typeString = typeString;\n\nfunction typeStringWithoutLocation(dataType) {\n  switch (dataType.typeClass) {\n    case \"uint\":\n      return dataType.typeHint || \"uint\".concat(dataType.bits);\n\n    case \"int\":\n      return dataType.typeHint || \"int\".concat(dataType.bits);\n\n    case \"bool\":\n      return dataType.typeHint || \"bool\";\n\n    case \"bytes\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return \"bytes\";\n\n        case \"static\":\n          return \"bytes\".concat(dataType.length);\n      }\n\n    case \"address\":\n      switch (dataType.kind) {\n        case \"general\":\n          return dataType.typeHint || \"address\";\n        //I guess?\n\n        case \"specific\":\n          return dataType.payable ? \"address payable\" : \"address\";\n      }\n\n    case \"string\":\n      return dataType.typeHint || \"string\";\n\n    case \"fixed\":\n      return dataType.typeHint || \"fixed\".concat(dataType.bits, \"x\").concat(dataType.places);\n\n    case \"ufixed\":\n      return dataType.typeHint || \"ufixed\".concat(dataType.bits, \"x\").concat(dataType.places);\n\n    case \"array\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return \"\".concat(typeStringWithoutLocation(dataType.baseType), \"[]\");\n\n        case \"static\":\n          return \"\".concat(typeStringWithoutLocation(dataType.baseType), \"[\").concat(dataType.length, \"]\");\n      }\n\n    case \"mapping\":\n      return \"mapping(\".concat(typeStringWithoutLocation(dataType.keyType), \" => \").concat(typeStringWithoutLocation(dataType.valueType), \")\");\n\n    case \"struct\":\n    case \"enum\":\n      //combining these cases for simplicity\n      switch (dataType.kind) {\n        case \"local\":\n          return \"\".concat(dataType.typeClass, \" \").concat(dataType.definingContractName, \".\").concat(dataType.typeName);\n\n        case \"global\":\n          return \"\".concat(dataType.typeClass, \" \").concat(dataType.typeName);\n      }\n\n    case \"tuple\":\n      return dataType.typeHint || \"tuple(\" + dataType.memberTypes.map(function (memberType) {\n        return typeString(memberType.type);\n      }).join(\",\") + \")\";\n    //note that we do include location and do not put spaces\n\n    case \"contract\":\n      return dataType.contractKind + \" \" + dataType.typeName;\n\n    case \"magic\":\n      //no, this is not transposed!\n      var variableNames = {\n        message: \"msg\",\n        transaction: \"tx\",\n        block: \"block\"\n      };\n      return variableNames[dataType.variable];\n\n    case \"type\":\n      return \"type(\".concat(typeString(dataType.type), \")\");\n\n    case \"function\":\n      var visibilityString;\n\n      switch (dataType.visibility) {\n        case \"external\":\n          if (dataType.kind === \"general\") {\n            if (dataType.typeHint) {\n              return dataType.typeHint;\n            } else {\n              return \"function external\"; //I guess???\n            }\n          }\n\n          visibilityString = \" external\"; //note the deliberate space!\n\n          break;\n\n        case \"internal\":\n          visibilityString = \"\";\n          break;\n      }\n\n      var mutabilityString = dataType.mutability === \"nonpayable\" ? \"\" : \" \" + dataType.mutability; //again, note the deliberate space\n\n      var inputList = dataType.inputParameterTypes.map(typeString).join(\",\"); //note that we do include location, and do not put spaces\n\n      var outputList = dataType.outputParameterTypes.map(typeString).join(\",\");\n      var inputString = \"function(\".concat(inputList, \")\");\n      var outputString = outputList === \"\" ? \"\" : \" returns (\".concat(outputList, \")\"); //again, note the deliberate space\n\n      return inputString + mutabilityString + visibilityString + outputString;\n  }\n}\n\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\n\nfunction isContractDefinedType(anyType) {\n  var contractDefinedTypes = [\"enum\", \"struct\"];\n  return contractDefinedTypes.includes(anyType.typeClass);\n}\n\nexports.isContractDefinedType = isContractDefinedType;","map":{"version":3,"sources":["../../../lib/format/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:format:types\");\nfunction isUserDefinedType(anyType) {\n    const userDefinedTypes = [\"contract\", \"enum\", \"struct\"];\n    return userDefinedTypes.includes(anyType.typeClass);\n}\nfunction isReferenceType(anyType) {\n    const alwaysReferenceTypes = [\"array\", \"mapping\", \"struct\", \"string\"];\n    if (alwaysReferenceTypes.includes(anyType.typeClass)) {\n        return true;\n    }\n    else if (anyType.typeClass === \"bytes\") {\n        return anyType.kind === \"dynamic\";\n    }\n    else {\n        return false;\n    }\n}\nexports.isReferenceType = isReferenceType;\n//one could define a counterpart function that stripped all unnecessary information\n//from the type object, but at the moment I see no need for that\nfunction fullType(basicType, userDefinedTypes) {\n    if (!isUserDefinedType(basicType)) {\n        return basicType;\n    }\n    let id = basicType.id;\n    let storedType = userDefinedTypes[id];\n    if (!storedType) {\n        return basicType;\n    }\n    let returnType = Object.assign(Object.assign({}, basicType), storedType);\n    if (isReferenceType(basicType) && basicType.location !== undefined) {\n        returnType = specifyLocation(returnType, basicType.location);\n    }\n    return returnType;\n}\nexports.fullType = fullType;\n//the location argument here always forces, so passing undefined *will* force undefined\nfunction specifyLocation(dataType, location) {\n    if (isReferenceType(dataType)) {\n        switch (dataType.typeClass) {\n            case \"string\":\n            case \"bytes\":\n                return Object.assign(Object.assign({}, dataType), { location });\n            case \"array\":\n                return Object.assign(Object.assign({}, dataType), { location, baseType: specifyLocation(dataType.baseType, location) });\n            case \"mapping\":\n                let newLocation = location === \"storage\" ? \"storage\" : undefined;\n                return Object.assign(Object.assign({}, dataType), { location: newLocation, valueType: specifyLocation(dataType.valueType, newLocation) });\n            case \"struct\":\n                let returnType = Object.assign(Object.assign({}, dataType), { location });\n                if (returnType.memberTypes) {\n                    returnType.memberTypes = returnType.memberTypes.map(({ name: memberName, type: memberType }) => ({\n                        name: memberName,\n                        type: specifyLocation(memberType, location)\n                    }));\n                }\n                return returnType;\n        }\n    }\n    else {\n        return dataType;\n    }\n}\nexports.specifyLocation = specifyLocation;\n//NOTE: the following two functions might not be exactly right for weird internal stuff,\n//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things\n//are pointers or not??  we don't track that so we can't recreate that)\n//But what can you do.\nfunction typeString(dataType) {\n    let baseString = typeStringWithoutLocation(dataType);\n    if (isReferenceType(dataType) && dataType.location) {\n        return baseString + \" \" + dataType.location;\n    }\n    else {\n        return baseString;\n    }\n}\nexports.typeString = typeString;\nfunction typeStringWithoutLocation(dataType) {\n    switch (dataType.typeClass) {\n        case \"uint\":\n            return dataType.typeHint || `uint${dataType.bits}`;\n        case \"int\":\n            return dataType.typeHint || `int${dataType.bits}`;\n        case \"bool\":\n            return dataType.typeHint || \"bool\";\n        case \"bytes\":\n            if (dataType.typeHint) {\n                return dataType.typeHint;\n            }\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    return \"bytes\";\n                case \"static\":\n                    return `bytes${dataType.length}`;\n            }\n        case \"address\":\n            switch (dataType.kind) {\n                case \"general\":\n                    return dataType.typeHint || \"address\"; //I guess?\n                case \"specific\":\n                    return dataType.payable ? \"address payable\" : \"address\";\n            }\n        case \"string\":\n            return dataType.typeHint || \"string\";\n        case \"fixed\":\n            return dataType.typeHint || `fixed${dataType.bits}x${dataType.places}`;\n        case \"ufixed\":\n            return dataType.typeHint || `ufixed${dataType.bits}x${dataType.places}`;\n        case \"array\":\n            if (dataType.typeHint) {\n                return dataType.typeHint;\n            }\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    return `${typeStringWithoutLocation(dataType.baseType)}[]`;\n                case \"static\":\n                    return `${typeStringWithoutLocation(dataType.baseType)}[${dataType.length}]`;\n            }\n        case \"mapping\":\n            return `mapping(${typeStringWithoutLocation(dataType.keyType)} => ${typeStringWithoutLocation(dataType.valueType)})`;\n        case \"struct\":\n        case \"enum\":\n            //combining these cases for simplicity\n            switch (dataType.kind) {\n                case \"local\":\n                    return `${dataType.typeClass} ${dataType.definingContractName}.${dataType.typeName}`;\n                case \"global\":\n                    return `${dataType.typeClass} ${dataType.typeName}`;\n            }\n        case \"tuple\":\n            return (dataType.typeHint ||\n                \"tuple(\" +\n                    dataType.memberTypes\n                        .map(memberType => typeString(memberType.type))\n                        .join(\",\") +\n                    \")\"); //note that we do include location and do not put spaces\n        case \"contract\":\n            return dataType.contractKind + \" \" + dataType.typeName;\n        case \"magic\":\n            //no, this is not transposed!\n            const variableNames = {\n                message: \"msg\",\n                transaction: \"tx\",\n                block: \"block\"\n            };\n            return variableNames[dataType.variable];\n        case \"type\":\n            return `type(${typeString(dataType.type)})`;\n        case \"function\":\n            let visibilityString;\n            switch (dataType.visibility) {\n                case \"external\":\n                    if (dataType.kind === \"general\") {\n                        if (dataType.typeHint) {\n                            return dataType.typeHint;\n                        }\n                        else {\n                            return \"function external\"; //I guess???\n                        }\n                    }\n                    visibilityString = \" external\"; //note the deliberate space!\n                    break;\n                case \"internal\":\n                    visibilityString = \"\";\n                    break;\n            }\n            let mutabilityString = dataType.mutability === \"nonpayable\" ? \"\" : \" \" + dataType.mutability; //again, note the deliberate space\n            let inputList = dataType.inputParameterTypes.map(typeString).join(\",\"); //note that we do include location, and do not put spaces\n            let outputList = dataType.outputParameterTypes.map(typeString).join(\",\");\n            let inputString = `function(${inputList})`;\n            let outputString = outputList === \"\" ? \"\" : ` returns (${outputList})`; //again, note the deliberate space\n            return inputString + mutabilityString + visibilityString + outputString;\n    }\n}\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\nfunction isContractDefinedType(anyType) {\n    const contractDefinedTypes = [\"enum\", \"struct\"];\n    return contractDefinedTypes.includes(anyType.typeClass);\n}\nexports.isContractDefinedType = isContractDefinedType;\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}