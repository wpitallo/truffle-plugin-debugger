{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(decodeMemory),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(decodeMemoryReferenceByAddress);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:memory:decode\");\n\nvar read_1 = __importDefault(require(\"../../read\"));\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Format = __importStar(require(\"../../format\"));\n\nvar Basic = __importStar(require(\"../../basic\"));\n\nvar Bytes = __importStar(require(\"../../bytes\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nfunction decodeMemory(dataType, pointer, info) {\n  var options,\n      _args = arguments;\n  return _regeneratorRuntime.wrap(function decodeMemory$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n\n          if (!Format.Types.isReferenceType(dataType)) {\n            _context.next = 10;\n            break;\n          }\n\n          if (!(dataType.typeClass === \"mapping\")) {\n            _context.next = 6;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: []\n          });\n\n        case 6:\n          return _context.delegateYield(decodeMemoryReferenceByAddress(dataType, pointer, info, options), \"t0\", 7);\n\n        case 7:\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 8:\n          _context.next = 12;\n          break;\n\n        case 10:\n          return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, options), \"t1\", 11);\n\n        case 11:\n          return _context.abrupt(\"return\", _context.t1);\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.decodeMemory = decodeMemory;\n\nfunction decodeMemoryReferenceByAddress(dataType, pointer, info) {\n  var options,\n      state,\n      memoryVisited,\n      rawValue,\n      startPositionAsBN,\n      startPosition,\n      objectPosition,\n      rawLength,\n      lengthAsBN,\n      length,\n      seenPreviously,\n      childPointer,\n      memoryNowVisited,\n      baseType,\n      decodedChildren,\n      index,\n      allocations,\n      userDefinedTypes,\n      typeId,\n      structAllocation,\n      _memoryNowVisited,\n      decodedMembers,\n      _index,\n      memberAllocation,\n      memberPointer,\n      _childPointer,\n      memberName,\n      memberType,\n      _args2 = arguments;\n\n  return _regeneratorRuntime.wrap(function decodeMemoryReferenceByAddress$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};\n          state = info.state;\n          memoryVisited = options.memoryVisited || [];\n          debug(\"pointer %o\", pointer);\n          _context2.prev = 4;\n          return _context2.delegateYield(read_1.default(pointer, state), \"t0\", 6);\n\n        case 6:\n          rawValue = _context2.t0;\n          _context2.next = 12;\n          break;\n\n        case 9:\n          _context2.prev = 9;\n          _context2.t1 = _context2[\"catch\"](4);\n          return _context2.abrupt(\"return\", {\n            //dunno why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t1.error\n          });\n\n        case 12:\n          startPositionAsBN = Conversion.toBN(rawValue);\n          _context2.prev = 13;\n          startPosition = startPositionAsBN.toNumber();\n          _context2.next = 20;\n          break;\n\n        case 17:\n          _context2.prev = 17;\n          _context2.t2 = _context2[\"catch\"](13);\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlargePointersNotImplementedError\",\n              pointerAsBN: startPositionAsBN\n            }\n          });\n\n        case 20:\n          //startPosition may get modified later, so let's save the current\n          //value for circularity detection purposes\n          objectPosition = startPosition;\n          _context2.t3 = dataType.typeClass;\n          _context2.next = _context2.t3 === \"bytes\" ? 24 : _context2.t3 === \"string\" ? 24 : _context2.t3 === \"array\" ? 43 : _context2.t3 === \"struct\" ? 80 : 108;\n          break;\n\n        case 24:\n          _context2.prev = 24;\n          return _context2.delegateYield(read_1.default({\n            location: \"memory\",\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t4\", 26);\n\n        case 26:\n          rawLength = _context2.t4;\n          _context2.next = 32;\n          break;\n\n        case 29:\n          _context2.prev = 29;\n          _context2.t5 = _context2[\"catch\"](24);\n          return _context2.abrupt(\"return\", {\n            //dunno why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t5.error\n          });\n\n        case 32:\n          lengthAsBN = Conversion.toBN(rawLength);\n          _context2.prev = 33;\n          length = lengthAsBN.toNumber();\n          _context2.next = 40;\n          break;\n\n        case 37:\n          _context2.prev = 37;\n          _context2.t6 = _context2[\"catch\"](33);\n          return _context2.abrupt(\"return\", {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 40:\n          childPointer = {\n            location: \"memory\",\n            start: startPosition + Evm.Utils.WORD_SIZE,\n            length: length\n          };\n          return _context2.delegateYield(Bytes.Decode.decodeBytes(dataType, childPointer, info), \"t7\", 42);\n\n        case 42:\n          return _context2.abrupt(\"return\", _context2.t7);\n\n        case 43:\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n\n          if (!(seenPreviously !== -1)) {\n            _context2.next = 46;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          });\n\n        case 46:\n          if (!(dataType.kind === \"dynamic\")) {\n            _context2.next = 59;\n            break;\n          }\n\n          _context2.prev = 47;\n          return _context2.delegateYield(read_1.default({\n            location: \"memory\",\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state), \"t8\", 49);\n\n        case 49:\n          rawLength = _context2.t8;\n          _context2.next = 55;\n          break;\n\n        case 52:\n          _context2.prev = 52;\n          _context2.t9 = _context2[\"catch\"](47);\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: _context2.t9.error\n          });\n\n        case 55:\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n\n          _context2.next = 60;\n          break;\n\n        case 59:\n          lengthAsBN = dataType.length;\n\n        case 60:\n          _context2.prev = 60;\n          length = lengthAsBN.toNumber();\n          _context2.next = 67;\n          break;\n\n        case 64:\n          _context2.prev = 64;\n          _context2.t10 = _context2[\"catch\"](60);\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN: lengthAsBN\n            }\n          });\n\n        case 67:\n          memoryNowVisited = [objectPosition].concat(_toConsumableArray(memoryVisited));\n          baseType = dataType.baseType;\n          decodedChildren = [];\n          index = 0;\n\n        case 71:\n          if (!(index < length)) {\n            _context2.next = 79;\n            break;\n          }\n\n          _context2.t11 = decodedChildren;\n          return _context2.delegateYield(decodeMemory(baseType, {\n            location: \"memory\",\n            start: startPosition + index * Evm.Utils.WORD_SIZE,\n            length: Evm.Utils.WORD_SIZE\n          }, info, {\n            memoryVisited: memoryNowVisited\n          }), \"t12\", 74);\n\n        case 74:\n          _context2.t13 = _context2.t12;\n\n          _context2.t11.push.call(_context2.t11, _context2.t13);\n\n        case 76:\n          index++;\n          _context2.next = 71;\n          break;\n\n        case 79:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedChildren\n          });\n\n        case 80:\n          //first: circularity check!\n          seenPreviously = memoryVisited.indexOf(objectPosition);\n\n          if (!(seenPreviously !== -1)) {\n            _context2.next = 83;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          });\n\n        case 83:\n          //otherwise, decode as normal\n          allocations = info.allocations.memory, userDefinedTypes = info.userDefinedTypes;\n          typeId = dataType.id;\n          structAllocation = allocations[typeId];\n\n          if (structAllocation) {\n            _context2.next = 88;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          });\n\n        case 88:\n          debug(\"structAllocation %O\", structAllocation);\n          _memoryNowVisited = [objectPosition].concat(_toConsumableArray(memoryVisited));\n          decodedMembers = [];\n          _index = 0;\n\n        case 92:\n          if (!(_index < structAllocation.members.length)) {\n            _context2.next = 107;\n            break;\n          }\n\n          memberAllocation = structAllocation.members[_index];\n          memberPointer = memberAllocation.pointer;\n          _childPointer = {\n            location: \"memory\",\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length //always equals WORD_SIZE or 0\n\n          };\n          memberName = memberAllocation.name;\n          memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n          _context2.t14 = decodedMembers;\n          _context2.t15 = memberName;\n          return _context2.delegateYield(decodeMemory(memberType, _childPointer, info, {\n            memoryVisited: _memoryNowVisited\n          }), \"t16\", 101);\n\n        case 101:\n          _context2.t17 = _context2.t16;\n          _context2.t18 = {\n            name: _context2.t15,\n            value: _context2.t17\n          };\n\n          _context2.t14.push.call(_context2.t14, _context2.t18);\n\n        case 104:\n          _index++;\n          _context2.next = 92;\n          break;\n\n        case 107:\n          return _context2.abrupt(\"return\", {\n            type: dataType,\n            kind: \"value\",\n            value: decodedMembers\n          });\n\n        case 108:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[4, 9], [13, 17], [24, 29], [33, 37], [47, 52], [60, 64]]);\n}\n\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;","map":{"version":3,"sources":["../../../../lib/memory/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:memory:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Evm = __importStar(require(\"../../evm\"));\nfunction* decodeMemory(dataType, pointer, info, options = {}) {\n    if (Format.Types.isReferenceType(dataType)) {\n        if (dataType.typeClass === \"mapping\") {\n            //special case: a mapping in memory is always empty\n            //(this is here and not in decodeMemoryReferenceByAddress\n            //since no addresses are involved, and it's not worth\n            //making into its own function)\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: []\n            };\n        }\n        else {\n            return yield* decodeMemoryReferenceByAddress(dataType, pointer, info, options);\n        }\n    }\n    else {\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n}\nexports.decodeMemory = decodeMemory;\nfunction* decodeMemoryReferenceByAddress(dataType, pointer, info, options = {}) {\n    const { state } = info;\n    const memoryVisited = options.memoryVisited || [];\n    debug(\"pointer %o\", pointer);\n    let rawValue;\n    try {\n        rawValue = yield* read_1.default(pointer, state);\n    }\n    catch (error) {\n        return {\n            //dunno why TS is failing here\n            type: dataType,\n            kind: \"error\",\n            error: error.error\n        };\n    }\n    let startPositionAsBN = Conversion.toBN(rawValue);\n    let startPosition;\n    try {\n        startPosition = startPositionAsBN.toNumber();\n    }\n    catch (_) {\n        return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n                kind: \"OverlargePointersNotImplementedError\",\n                pointerAsBN: startPositionAsBN\n            }\n        };\n    }\n    //startPosition may get modified later, so let's save the current\n    //value for circularity detection purposes\n    const objectPosition = startPosition;\n    let rawLength;\n    let lengthAsBN;\n    let length;\n    let seenPreviously;\n    switch (dataType.typeClass) {\n        case \"bytes\":\n        case \"string\":\n            //initial word contains length\n            try {\n                rawLength = yield* read_1.default({\n                    location: \"memory\",\n                    start: startPosition,\n                    length: Evm.Utils.WORD_SIZE\n                }, state);\n            }\n            catch (error) {\n                return {\n                    //dunno why TS is failing here\n                    type: dataType,\n                    kind: \"error\",\n                    error: error.error\n                };\n            }\n            lengthAsBN = Conversion.toBN(rawLength);\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_) {\n                return {\n                    //again with the TS failures...\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            let childPointer = {\n                location: \"memory\",\n                start: startPosition + Evm.Utils.WORD_SIZE,\n                length\n            };\n            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info);\n        case \"array\": {\n            //first: circularity check!\n            seenPreviously = memoryVisited.indexOf(objectPosition);\n            if (seenPreviously !== -1) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    reference: seenPreviously + 1,\n                    value: [] //will be fixed later by the tie function\n                };\n            }\n            //otherwise, decode as normal\n            if (dataType.kind === \"dynamic\") {\n                //initial word contains array length\n                try {\n                    rawLength = yield* read_1.default({\n                        location: \"memory\",\n                        start: startPosition,\n                        length: Evm.Utils.WORD_SIZE\n                    }, state);\n                }\n                catch (error) {\n                    return {\n                        type: dataType,\n                        kind: \"error\",\n                        error: error.error\n                    };\n                }\n                lengthAsBN = Conversion.toBN(rawLength);\n                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n                //to next word, as first word was used for length\n            }\n            else {\n                lengthAsBN = dataType.length;\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            let memoryNowVisited = [objectPosition, ...memoryVisited];\n            let baseType = dataType.baseType;\n            let decodedChildren = [];\n            for (let index = 0; index < length; index++) {\n                decodedChildren.push(yield* decodeMemory(baseType, {\n                    location: \"memory\",\n                    start: startPosition + index * Evm.Utils.WORD_SIZE,\n                    length: Evm.Utils.WORD_SIZE\n                }, info, { memoryVisited: memoryNowVisited }));\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        }\n        case \"struct\": {\n            //first: circularity check!\n            seenPreviously = memoryVisited.indexOf(objectPosition);\n            if (seenPreviously !== -1) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    reference: seenPreviously + 1,\n                    value: [] //will be fixed later by the tie function\n                };\n            }\n            //otherwise, decode as normal\n            const { allocations: { memory: allocations }, userDefinedTypes } = info;\n            const typeId = dataType.id;\n            const structAllocation = allocations[typeId];\n            if (!structAllocation) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"UserDefinedTypeNotFoundError\",\n                        type: dataType\n                    }\n                };\n            }\n            debug(\"structAllocation %O\", structAllocation);\n            let memoryNowVisited = [objectPosition, ...memoryVisited];\n            let decodedMembers = [];\n            for (let index = 0; index < structAllocation.members.length; index++) {\n                const memberAllocation = structAllocation.members[index];\n                const memberPointer = memberAllocation.pointer;\n                const childPointer = {\n                    location: \"memory\",\n                    start: startPosition + memberPointer.start,\n                    length: memberPointer.length //always equals WORD_SIZE or 0\n                };\n                let memberName = memberAllocation.name;\n                let memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n                decodedMembers.push({\n                    name: memberName,\n                    value: yield* decodeMemory(memberType, childPointer, info, {\n                        memoryVisited: memoryNowVisited\n                    })\n                });\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedMembers\n            };\n        }\n    }\n}\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}