{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuorumDefinition = void 0;\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar abi_coder_1 = require(\"ethers/utils/abi-coder\");\n\nexports.QuorumDefinition = {\n  initNetworkType: function initNetworkType(web3) {\n    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // duck punch some of web3's output formatters\n              overrides.getBlock(web3);\n              overrides.getTransaction(web3);\n              overrides.getTransactionReceipt(web3);\n              overrides.decodeParameters(web3);\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n  }\n};\nvar overrides = {\n  // The ts-ignores are ignoring the checks that are\n  // saying that web3.eth.getBlock is a function and doesn't\n  // have a `method` property, which it does\n  getBlock: function getBlock(web3) {\n    // @ts-ignore\n    var _oldBlockFormatter = web3.eth.getBlock.method.outputFormatter; // @ts-ignore\n\n    web3.eth.getBlock.method.outputFormatter = function (block) {\n      var _oldTimestamp = block.timestamp;\n      var _oldGasLimit = block.gasLimit;\n      var _oldGasUsed = block.gasUsed; // Quorum uses nanoseconds instead of seconds in timestamp\n\n      var timestamp = new bn_js_1.default(block.timestamp.slice(2), 16);\n      timestamp = timestamp.div(new bn_js_1.default(10).pow(new bn_js_1.default(9)));\n      block.timestamp = \"0x\" + timestamp.toString(16); // Since we're overwriting the gasLimit/Used later,\n      // it doesn't matter what it is before the call\n      // The same applies to the timestamp, but I reduced\n      // the precision since there was an accurate representation\n      // We do this because Quorum can have large block/transaction\n      // gas limits\n\n      block.gasLimit = \"0x0\";\n      block.gasUsed = \"0x0\"; // @ts-ignore\n\n      var result = _oldBlockFormatter.call(web3.eth.getBlock.method, block); // Perhaps there is a better method of doing this,\n      // but the raw hexstrings work for the time being\n\n\n      result.timestamp = _oldTimestamp;\n      result.gasLimit = _oldGasLimit;\n      result.gasUsed = _oldGasUsed;\n      return result;\n    };\n  },\n  getTransaction: function getTransaction(web3) {\n    var _oldTransactionFormatter = // @ts-ignore\n    web3.eth.getTransaction.method.outputFormatter; // @ts-ignore\n\n    web3.eth.getTransaction.method.outputFormatter = function (tx) {\n      var _oldGas = tx.gas;\n      tx.gas = \"0x0\";\n\n      var result = _oldTransactionFormatter.call( // @ts-ignore\n      web3.eth.getTransaction.method, tx); // Perhaps there is a better method of doing this,\n      // but the raw hexstrings work for the time being\n\n\n      result.gas = _oldGas;\n      return result;\n    };\n  },\n  getTransactionReceipt: function getTransactionReceipt(web3) {\n    var _oldTransactionReceiptFormatter = // @ts-ignore\n    web3.eth.getTransactionReceipt.method.outputFormatter; // @ts-ignore\n\n    web3.eth.getTransactionReceipt.method.outputFormatter = function (receipt) {\n      var _oldGasUsed = receipt.gasUsed;\n      receipt.gasUsed = \"0x0\";\n\n      var result = _oldTransactionReceiptFormatter.call( // @ts-ignore\n      web3.eth.getTransactionReceipt.method, receipt); // Perhaps there is a better method of doing this,\n      // but the raw hexstrings work for the time being\n\n\n      result.gasUsed = _oldGasUsed;\n      return result;\n    };\n  },\n  // The primary difference between this decodeParameters function and web3's\n  // is that the 'Out of Gas?' zero/null bytes guard has been removed and any\n  // falsy bytes are interpreted as a zero value.\n  decodeParameters: function decodeParameters(web3) {\n    var _oldDecodeParameters = web3.eth.abi.decodeParameters;\n    var ethersAbiCoder = new abi_coder_1.AbiCoder(function (type, value) {\n      if (type.match(/^u?int/) && !Array.isArray(value) && (typeof value !== \"object\" || value.constructor.name !== \"BN\")) {\n        return value.toString();\n      }\n\n      return value;\n    }); // result method\n\n    function Result() {}\n\n    web3.eth.abi.decodeParameters = function (outputs, bytes) {\n      // if bytes is falsy, we'll pass 64 '0' bits to the ethers.js decoder.\n      // the decoder will decode the 64 '0' bits as a 0 value.\n      if (!bytes) bytes = \"0\".repeat(64);\n      var res = ethersAbiCoder.decode( //@ts-ignore 'mapTypes' not existing on type 'ABI'\n      web3.eth.abi.mapTypes(outputs), \"0x\".concat(bytes.replace(/0x/i, \"\"))); //@ts-ignore complaint regarding Result method\n\n      var returnValue = new Result();\n      returnValue.__length__ = 0;\n      outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = decodedValue === \"0x\" ? null : decodedValue;\n        returnValue[i] = decodedValue; // @ts-ignore object not having name key\n\n        if (typeof output === \"object\" && output.name) {\n          // @ts-ignore object not having name key\n          returnValue[output.name] = decodedValue;\n        }\n\n        returnValue.__length__++;\n      });\n      return returnValue;\n    };\n  }\n};","map":{"version":3,"sources":["../../../lib/shim/overloads/quorum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QuorumDefinition = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst abi_coder_1 = require(\"ethers/utils/abi-coder\");\nexports.QuorumDefinition = {\n    initNetworkType(web3) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // duck punch some of web3's output formatters\n            overrides.getBlock(web3);\n            overrides.getTransaction(web3);\n            overrides.getTransactionReceipt(web3);\n            overrides.decodeParameters(web3);\n        });\n    }\n};\nconst overrides = {\n    // The ts-ignores are ignoring the checks that are\n    // saying that web3.eth.getBlock is a function and doesn't\n    // have a `method` property, which it does\n    getBlock: (web3) => {\n        // @ts-ignore\n        const _oldBlockFormatter = web3.eth.getBlock.method.outputFormatter;\n        // @ts-ignore\n        web3.eth.getBlock.method.outputFormatter = (block) => {\n            const _oldTimestamp = block.timestamp;\n            const _oldGasLimit = block.gasLimit;\n            const _oldGasUsed = block.gasUsed;\n            // Quorum uses nanoseconds instead of seconds in timestamp\n            let timestamp = new bn_js_1.default(block.timestamp.slice(2), 16);\n            timestamp = timestamp.div(new bn_js_1.default(10).pow(new bn_js_1.default(9)));\n            block.timestamp = \"0x\" + timestamp.toString(16);\n            // Since we're overwriting the gasLimit/Used later,\n            // it doesn't matter what it is before the call\n            // The same applies to the timestamp, but I reduced\n            // the precision since there was an accurate representation\n            // We do this because Quorum can have large block/transaction\n            // gas limits\n            block.gasLimit = \"0x0\";\n            block.gasUsed = \"0x0\";\n            // @ts-ignore\n            let result = _oldBlockFormatter.call(web3.eth.getBlock.method, block);\n            // Perhaps there is a better method of doing this,\n            // but the raw hexstrings work for the time being\n            result.timestamp = _oldTimestamp;\n            result.gasLimit = _oldGasLimit;\n            result.gasUsed = _oldGasUsed;\n            return result;\n        };\n    },\n    getTransaction: (web3) => {\n        const _oldTransactionFormatter = \n        // @ts-ignore\n        web3.eth.getTransaction.method.outputFormatter;\n        // @ts-ignore\n        web3.eth.getTransaction.method.outputFormatter = (tx) => {\n            const _oldGas = tx.gas;\n            tx.gas = \"0x0\";\n            let result = _oldTransactionFormatter.call(\n            // @ts-ignore\n            web3.eth.getTransaction.method, tx);\n            // Perhaps there is a better method of doing this,\n            // but the raw hexstrings work for the time being\n            result.gas = _oldGas;\n            return result;\n        };\n    },\n    getTransactionReceipt: (web3) => {\n        const _oldTransactionReceiptFormatter = \n        // @ts-ignore\n        web3.eth.getTransactionReceipt.method.outputFormatter;\n        // @ts-ignore\n        web3.eth.getTransactionReceipt.method.outputFormatter = (receipt) => {\n            const _oldGasUsed = receipt.gasUsed;\n            receipt.gasUsed = \"0x0\";\n            let result = _oldTransactionReceiptFormatter.call(\n            // @ts-ignore\n            web3.eth.getTransactionReceipt.method, receipt);\n            // Perhaps there is a better method of doing this,\n            // but the raw hexstrings work for the time being\n            result.gasUsed = _oldGasUsed;\n            return result;\n        };\n    },\n    // The primary difference between this decodeParameters function and web3's\n    // is that the 'Out of Gas?' zero/null bytes guard has been removed and any\n    // falsy bytes are interpreted as a zero value.\n    decodeParameters: (web3) => {\n        const _oldDecodeParameters = web3.eth.abi.decodeParameters;\n        const ethersAbiCoder = new abi_coder_1.AbiCoder((type, value) => {\n            if (type.match(/^u?int/) &&\n                !Array.isArray(value) &&\n                (typeof value !== \"object\" || value.constructor.name !== \"BN\")) {\n                return value.toString();\n            }\n            return value;\n        });\n        // result method\n        function Result() { }\n        web3.eth.abi.decodeParameters = (outputs, bytes) => {\n            // if bytes is falsy, we'll pass 64 '0' bits to the ethers.js decoder.\n            // the decoder will decode the 64 '0' bits as a 0 value.\n            if (!bytes)\n                bytes = \"0\".repeat(64);\n            const res = ethersAbiCoder.decode(\n            //@ts-ignore 'mapTypes' not existing on type 'ABI'\n            web3.eth.abi.mapTypes(outputs), `0x${bytes.replace(/0x/i, \"\")}`);\n            //@ts-ignore complaint regarding Result method\n            const returnValue = new Result();\n            returnValue.__length__ = 0;\n            outputs.forEach((output, i) => {\n                let decodedValue = res[returnValue.__length__];\n                decodedValue = decodedValue === \"0x\" ? null : decodedValue;\n                returnValue[i] = decodedValue;\n                // @ts-ignore object not having name key\n                if (typeof output === \"object\" && output.name) {\n                    // @ts-ignore object not having name key\n                    returnValue[output.name] = decodedValue;\n                }\n                returnValue.__length__++;\n            });\n            return returnValue;\n        };\n    }\n};\n//# sourceMappingURL=quorum.js.map"]},"metadata":{},"sourceType":"script"}