{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar bignumber = require('bignumber.js').BigNumber;\n\nvar constants = require('./constants');\n\nvar NUMBYTES = constants.NUMBYTES;\nvar SHIFT32 = constants.SHIFT32;\nvar MAX_SAFE_HIGH = 0x1fffff;\nexports.hasBigInt = typeof BigInt === 'function';\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n */\n\nvar TD = typeof TextDecoder === 'function' ? TextDecoder : util.TextDecoder;\n/* istanbul ignore else */\n\nif (TD) {\n  // node 11+, browsers : node 8.3+\n  var td = new TD('utf8', {\n    fatal: true,\n    ignoreBOM: true\n  });\n\n  exports.utf8 = function (buf) {\n    return td.decode(buf);\n  };\n\n  exports.utf8.checksUTF8 = true;\n} else {\n  // TODO: polyfill a slow one or wait for node6 to die\n  exports.utf8 = function (buf) {\n    return buf.toString('utf8');\n  };\n\n  exports.utf8.checksUTF8 = false;\n}\n\nexports.parseCBORint = function (ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0);\n\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0);\n\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0);\n\n    case NUMBYTES.EIGHT:\n      var f = buf.readUInt32BE(0);\n      var g = buf.readUInt32BE(4);\n\n      if (f > MAX_SAFE_HIGH) {\n        return new bignumber(f).times(SHIFT32).plus(g);\n      } else {\n        return f * SHIFT32 + g;\n      }\n\n    default:\n      throw new Error('Invalid additional info for int: ' + ai);\n  }\n};\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n  var u32 = Buffer.allocUnsafe(4);\n  u32.writeFloatBE(half, 0);\n  var u = u32.readUInt32BE(0); // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n\n  if ((u & 0x1FFF) !== 0) {\n    return false;\n  } //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n\n  var s16 = u >> 16 & 0x8000; // top bit is sign\n\n  var exp = u >> 23 & 0xff; // then 5 bits of exponent\n\n  var mant = u & 0x7fffff; //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if (exp >= 113 && exp <= 142) {\n    s16 += (exp - 112 << 10) + (mant >> 13);\n  } else if (exp >= 103 && exp < 113) {\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n    if (mant & (1 << 126 - exp) - 1) {\n      return false;\n    }\n\n    s16 += mant + 0x800000 >> 126 - exp;\n  } else {\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n    // hildjj: Infinity already handled\n    //   } else\n    //     goto float32;           /* loss of range */\n    return false;\n  } //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n\n\n  buf.writeUInt16BE(s16);\n  return true;\n};\n\nexports.parseHalf = function parseHalf(buf) {\n  var sign = buf[0] & 0x80 ? -1 : 1;\n  var exp = (buf[0] & 0x7C) >> 2;\n  var mant = (buf[0] & 0x03) << 8 | buf[1];\n\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant;\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308);\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant);\n  }\n};\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf);\n\n    case 4:\n      return buf.readFloatBE(0);\n\n    case 8:\n      return buf.readDoubleBE(0);\n\n    default:\n      throw new Error('Invalid float size: ' + buf.length);\n  }\n};\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex');\n};\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '');\n  var start = 0;\n  var end = s.length % 8 || 8;\n  var chunks = [];\n\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2));\n    start = end;\n    end += 8;\n  }\n\n  return Buffer.from(chunks);\n};\n\nexports.extend = function extend() {\n  var old = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var len = arguments.length <= 1 ? 0 : arguments.length - 1;\n\n  for (var j = 0; j < len; j++) {\n    var a = j + 1 < 1 || arguments.length <= j + 1 ? undefined : arguments[j + 1];\n\n    for (var k in a) {\n      var v = a[k];\n      old[k] = v;\n    }\n  }\n\n  return old;\n};\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if (a == null && b == null) {\n    return true;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  }\n\n  return a.length === b.length && a.every(function (elem, i) {\n    return elem === b[i];\n  });\n};\n\nexports.bufferEqual = function bufferEqual(a, b) {\n  if (a == null && b == null) {\n    return true;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (!(Buffer.isBuffer(a) && Buffer.isBuffer(b) && a.length === b.length)) {\n    return false;\n  }\n\n  var len = a.length;\n  var ret = true;\n  var i;\n  var j;\n\n  for (i = j = 0; j < len; i = ++j) {\n    var byte = a[i];\n    ret = ret && b[i] === byte;\n  }\n\n  return !!ret;\n};\n\nexports.bufferToBignumber = function bufferToBignumber(buf) {\n  return new bignumber(buf.toString('hex'), 16);\n};\n\nexports.toBigInt = function toBigInt(num) {\n  if (!exports.hasBigInt) {\n    return Number(num); // lossy.  Better than nothing?\n  }\n\n  return BigInt(num);\n};\n\nexports.bigIntize = function bigIntize(obj) {\n  var ret = {};\n\n  for (var k in obj) {\n    // stupid node 6\n    ret[k] = exports.toBigInt(obj[k]);\n  }\n\n  return ret;\n};\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return exports.toBigInt('0x' + buf.toString('hex'));\n};\n\nexports.guessEncoding = function guessEncoding(input) {\n  if (typeof input == 'string') {\n    return 'hex';\n  } else if (Buffer.isBuffer(input)) {\n    return undefined;\n  }\n\n  throw new Error('Unknown input type');\n};","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/cbor/lib/utils.js"],"names":["util","require","bignumber","BigNumber","constants","NUMBYTES","SHIFT32","MAX_SAFE_HIGH","exports","hasBigInt","BigInt","TD","TextDecoder","td","fatal","ignoreBOM","utf8","buf","decode","checksUTF8","toString","parseCBORint","ai","ONE","readUInt8","TWO","readUInt16BE","FOUR","readUInt32BE","EIGHT","f","g","times","plus","Error","writeHalf","half","u32","Buffer","allocUnsafe","writeFloatBE","u","s16","exp","mant","writeUInt16BE","parseHalf","sign","Math","pow","parseCBORfloat","length","readFloatBE","readDoubleBE","hex","s","from","replace","bin","start","end","chunks","push","parseInt","slice","extend","old","len","j","a","k","v","arrayEqual","b","every","elem","i","bufferEqual","isBuffer","ret","byte","bufferToBignumber","toBigInt","num","Number","bigIntize","obj","bufferToBigInt","guessEncoding","input","undefined"],"mappings":"AAAA;;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,cAAD,CAAP,CAAwBE,SAA1C;;AAEA,IAAMC,SAAS,GAAGH,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAMI,QAAQ,GAAGD,SAAS,CAACC,QAA3B;AACA,IAAMC,OAAO,GAAGF,SAAS,CAACE,OAA1B;AACA,IAAMC,aAAa,GAAG,QAAtB;AAEAC,OAAO,CAACC,SAAR,GAAqB,OAAOC,MAAP,KAAkB,UAAvC;AAEA;AACA;AACA;AACA;;AACA,IAAMC,EAAE,GAAI,OAAOC,WAAP,KAAuB,UAAxB,GAAsCA,WAAtC,GAAoDZ,IAAI,CAACY,WAApE;AACA;;AACA,IAAID,EAAJ,EAAQ;AACN;AACA,MAAME,EAAE,GAAG,IAAIF,EAAJ,CAAO,MAAP,EAAe;AAACG,IAAAA,KAAK,EAAE,IAAR;AAAcC,IAAAA,SAAS,EAAE;AAAzB,GAAf,CAAX;;AACAP,EAAAA,OAAO,CAACQ,IAAR,GAAe,UAACC,GAAD;AAAA,WAASJ,EAAE,CAACK,MAAH,CAAUD,GAAV,CAAT;AAAA,GAAf;;AACAT,EAAAA,OAAO,CAACQ,IAAR,CAAaG,UAAb,GAA0B,IAA1B;AACD,CALD,MAKO;AACL;AACAX,EAAAA,OAAO,CAACQ,IAAR,GAAe,UAACC,GAAD;AAAA,WAASA,GAAG,CAACG,QAAJ,CAAa,MAAb,CAAT;AAAA,GAAf;;AACAZ,EAAAA,OAAO,CAACQ,IAAR,CAAaG,UAAb,GAA0B,KAA1B;AACD;;AAEDX,OAAO,CAACa,YAAR,GAAuB,UAASC,EAAT,EAAaL,GAAb,EAAkB;AACvC,UAAQK,EAAR;AACE,SAAKjB,QAAQ,CAACkB,GAAd;AACE,aAAON,GAAG,CAACO,SAAJ,CAAc,CAAd,CAAP;;AACF,SAAKnB,QAAQ,CAACoB,GAAd;AACE,aAAOR,GAAG,CAACS,YAAJ,CAAiB,CAAjB,CAAP;;AACF,SAAKrB,QAAQ,CAACsB,IAAd;AACE,aAAOV,GAAG,CAACW,YAAJ,CAAiB,CAAjB,CAAP;;AACF,SAAKvB,QAAQ,CAACwB,KAAd;AACE,UAAMC,CAAC,GAAGb,GAAG,CAACW,YAAJ,CAAiB,CAAjB,CAAV;AACA,UAAMG,CAAC,GAAGd,GAAG,CAACW,YAAJ,CAAiB,CAAjB,CAAV;;AACA,UAAIE,CAAC,GAAGvB,aAAR,EAAuB;AACrB,eAAO,IAAIL,SAAJ,CAAc4B,CAAd,EAAiBE,KAAjB,CAAuB1B,OAAvB,EAAgC2B,IAAhC,CAAqCF,CAArC,CAAP;AACD,OAFD,MAEO;AACL,eAAQD,CAAC,GAAGxB,OAAL,GAAgByB,CAAvB;AACD;;AACH;AACE,YAAM,IAAIG,KAAJ,CAAU,sCAAsCZ,EAAhD,CAAN;AAhBJ;AAkBD,CAnBD;;AAqBAd,OAAO,CAAC2B,SAAR,GAAoB,SAASA,SAAT,CAAmBlB,GAAnB,EAAwBmB,IAAxB,EAA8B;AAChD;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMC,GAAG,GAAGC,MAAM,CAACC,WAAP,CAAmB,CAAnB,CAAZ;AACAF,EAAAA,GAAG,CAACG,YAAJ,CAAiBJ,IAAjB,EAAuB,CAAvB;AACA,MAAMK,CAAC,GAAGJ,GAAG,CAACT,YAAJ,CAAiB,CAAjB,CAAV,CAhBgD,CAkBhD;AAEA;AACA;AACA;;AACA,MAAI,CAACa,CAAC,GAAG,MAAL,MAAiB,CAArB,EAAwB;AACtB,WAAO,KAAP;AACD,GAzB+C,CA2BhD;AACA;AACA;;;AAEA,MAAIC,GAAG,GAAID,CAAC,IAAI,EAAN,GAAY,MAAtB,CA/BgD,CA+BnB;;AAC7B,MAAME,GAAG,GAAIF,CAAC,IAAI,EAAN,GAAY,IAAxB,CAhCgD,CAgCnB;;AAC7B,MAAMG,IAAI,GAAGH,CAAC,GAAG,QAAjB,CAjCgD,CAmChD;AACA;AAEA;AAEA;AACA;;AAEA,MAAKE,GAAG,IAAI,GAAR,IAAiBA,GAAG,IAAI,GAA5B,EAAkC;AAChCD,IAAAA,GAAG,IAAI,CAAEC,GAAG,GAAG,GAAP,IAAe,EAAhB,KAAuBC,IAAI,IAAI,EAA/B,CAAP;AACD,GAFD,MAEO,IAAKD,GAAG,IAAI,GAAR,IAAiBA,GAAG,GAAG,GAA3B,EAAiC;AACtC;AACA;AACA;AACA;AAEA,QAAIC,IAAI,GAAI,CAAC,KAAM,MAAMD,GAAb,IAAqB,CAAjC,EAAqC;AACnC,aAAO,KAAP;AACD;;AACDD,IAAAA,GAAG,IAAME,IAAI,GAAG,QAAR,IAAsB,MAAMD,GAApC;AACD,GAVM,MAUA;AACP;AACA;AAEE;AAEA;AACA;AAEA,WAAO,KAAP;AACD,GAjE+C,CAmEhD;AACA;AACA;;;AACA1B,EAAAA,GAAG,CAAC4B,aAAJ,CAAkBH,GAAlB;AACA,SAAO,IAAP;AACD,CAxED;;AA0EAlC,OAAO,CAACsC,SAAR,GAAoB,SAASA,SAAT,CAAmB7B,GAAnB,EAAwB;AAC1C,MAAM8B,IAAI,GAAG9B,GAAG,CAAC,CAAD,CAAH,GAAS,IAAT,GAAgB,CAAC,CAAjB,GAAqB,CAAlC;AACA,MAAM0B,GAAG,GAAG,CAAC1B,GAAG,CAAC,CAAD,CAAH,GAAS,IAAV,KAAmB,CAA/B;AACA,MAAM2B,IAAI,GAAI,CAAC3B,GAAG,CAAC,CAAD,CAAH,GAAS,IAAV,KAAmB,CAApB,GAAyBA,GAAG,CAAC,CAAD,CAAzC;;AACA,MAAI,CAAC0B,GAAL,EAAU;AACR,WAAOI,IAAI,GAAG,qBAAP,GAA+BH,IAAtC;AACD,GAFD,MAEO,IAAID,GAAG,KAAK,IAAZ,EAAkB;AACvB,WAAOI,IAAI,IAAIH,IAAI,GAAG,IAAI,CAAP,GAAW,KAAnB,CAAX;AACD,GAFM,MAEA;AACL,WAAOG,IAAI,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYN,GAAG,GAAG,EAAlB,CAAP,IAAgC,OAAOC,IAAvC,CAAP;AACD;AACF,CAXD;;AAaApC,OAAO,CAAC0C,cAAR,GAAyB,SAASA,cAAT,CAAwBjC,GAAxB,EAA6B;AACpD,UAAQA,GAAG,CAACkC,MAAZ;AACE,SAAK,CAAL;AACE,aAAO3C,OAAO,CAACsC,SAAR,CAAkB7B,GAAlB,CAAP;;AACF,SAAK,CAAL;AACE,aAAOA,GAAG,CAACmC,WAAJ,CAAgB,CAAhB,CAAP;;AACF,SAAK,CAAL;AACE,aAAOnC,GAAG,CAACoC,YAAJ,CAAiB,CAAjB,CAAP;;AACF;AACE,YAAM,IAAInB,KAAJ,CAAU,yBAAyBjB,GAAG,CAACkC,MAAvC,CAAN;AARJ;AAUD,CAXD;;AAaA3C,OAAO,CAAC8C,GAAR,GAAc,SAASA,GAAT,CAAaC,CAAb,EAAgB;AAC5B,SAAOjB,MAAM,CAACkB,IAAP,CAAYD,CAAC,CAACE,OAAF,CAAU,KAAV,EAAiB,EAAjB,CAAZ,EAAkC,KAAlC,CAAP;AACD,CAFD;;AAIAjD,OAAO,CAACkD,GAAR,GAAc,SAASA,GAAT,CAAaH,CAAb,EAAgB;AAC5BA,EAAAA,CAAC,GAAGA,CAAC,CAACE,OAAF,CAAU,KAAV,EAAiB,EAAjB,CAAJ;AACA,MAAIE,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAG,GAAIL,CAAC,CAACJ,MAAF,GAAW,CAAZ,IAAkB,CAA5B;AACA,MAAMU,MAAM,GAAG,EAAf;;AACA,SAAOD,GAAG,IAAIL,CAAC,CAACJ,MAAhB,EAAwB;AACtBU,IAAAA,MAAM,CAACC,IAAP,CAAYC,QAAQ,CAACR,CAAC,CAACS,KAAF,CAAQL,KAAR,EAAeC,GAAf,CAAD,EAAsB,CAAtB,CAApB;AACAD,IAAAA,KAAK,GAAGC,GAAR;AACAA,IAAAA,GAAG,IAAI,CAAP;AACD;;AACD,SAAOtB,MAAM,CAACkB,IAAP,CAAYK,MAAZ,CAAP;AACD,CAXD;;AAaArD,OAAO,CAACyD,MAAR,GAAiB,SAASA,MAAT,GAAiC;AAAA,MAAjBC,GAAiB,uEAAb,EAAa;AAChD,MAAMC,GAAG,mDAAT;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAApB,EAAyBC,CAAC,EAA1B,EAA8B;AAC5B,QAAMC,CAAC,GAAQD,CAAR,gCAAQA,CAAR,6BAAQA,CAAR,KAAP;;AACA,SAAK,IAAME,CAAX,IAAgBD,CAAhB,EAAmB;AACjB,UAAME,CAAC,GAAGF,CAAC,CAACC,CAAD,CAAX;AACAJ,MAAAA,GAAG,CAACI,CAAD,CAAH,GAASC,CAAT;AACD;AACF;;AACD,SAAOL,GAAP;AACD,CAVD;;AAYA1D,OAAO,CAACgE,UAAR,GAAqB,SAASA,UAAT,CAAoBH,CAApB,EAAuBI,CAAvB,EAA0B;AAC7C,MAAKJ,CAAC,IAAI,IAAN,IAAgBI,CAAC,IAAI,IAAzB,EAAgC;AAC9B,WAAO,IAAP;AACD;;AACD,MAAKJ,CAAC,IAAI,IAAN,IAAgBI,CAAC,IAAI,IAAzB,EAAgC;AAC9B,WAAO,KAAP;AACD;;AACD,SAAQJ,CAAC,CAAClB,MAAF,KAAasB,CAAC,CAACtB,MAAhB,IAA2BkB,CAAC,CAACK,KAAF,CAAQ,UAACC,IAAD,EAAOC,CAAP;AAAA,WAAaD,IAAI,KAAKF,CAAC,CAACG,CAAD,CAAvB;AAAA,GAAR,CAAlC;AACD,CARD;;AAUApE,OAAO,CAACqE,WAAR,GAAsB,SAASA,WAAT,CAAqBR,CAArB,EAAwBI,CAAxB,EAA2B;AAC/C,MAAKJ,CAAC,IAAI,IAAN,IAAgBI,CAAC,IAAI,IAAzB,EAAgC;AAC9B,WAAO,IAAP;AACD;;AACD,MAAKJ,CAAC,IAAI,IAAN,IAAgBI,CAAC,IAAI,IAAzB,EAAgC;AAC9B,WAAO,KAAP;AACD;;AACD,MAAI,EAAEnC,MAAM,CAACwC,QAAP,CAAgBT,CAAhB,KAAsB/B,MAAM,CAACwC,QAAP,CAAgBL,CAAhB,CAAtB,IAA6CJ,CAAC,CAAClB,MAAF,KAAasB,CAAC,CAACtB,MAA9D,CAAJ,EAA4E;AAC1E,WAAO,KAAP;AACD;;AACD,MAAMgB,GAAG,GAAGE,CAAC,CAAClB,MAAd;AACA,MAAI4B,GAAG,GAAG,IAAV;AACA,MAAIH,CAAJ;AACA,MAAIR,CAAJ;;AACA,OAAKQ,CAAC,GAAGR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAApB,EAAyBS,CAAC,GAAG,EAAER,CAA/B,EAAkC;AAChC,QAAMY,IAAI,GAAGX,CAAC,CAACO,CAAD,CAAd;AACAG,IAAAA,GAAG,GAAGA,GAAG,IAAKN,CAAC,CAACG,CAAD,CAAD,KAASI,IAAvB;AACD;;AACD,SAAO,CAAC,CAACD,GAAT;AACD,CAnBD;;AAqBAvE,OAAO,CAACyE,iBAAR,GAA4B,SAASA,iBAAT,CAA2BhE,GAA3B,EAAgC;AAC1D,SAAO,IAAIf,SAAJ,CAAce,GAAG,CAACG,QAAJ,CAAa,KAAb,CAAd,EAAmC,EAAnC,CAAP;AACD,CAFD;;AAIAZ,OAAO,CAAC0E,QAAR,GAAmB,SAASA,QAAT,CAAkBC,GAAlB,EAAuB;AACxC,MAAI,CAAC3E,OAAO,CAACC,SAAb,EAAwB;AACtB,WAAO2E,MAAM,CAACD,GAAD,CAAb,CADsB,CACH;AACpB;;AACD,SAAOzE,MAAM,CAACyE,GAAD,CAAb;AACD,CALD;;AAOA3E,OAAO,CAAC6E,SAAR,GAAoB,SAASA,SAAT,CAAmBC,GAAnB,EAAwB;AAC1C,MAAMP,GAAG,GAAG,EAAZ;;AACA,OAAK,IAAMT,CAAX,IAAgBgB,GAAhB,EAAqB;AAAE;AACrBP,IAAAA,GAAG,CAACT,CAAD,CAAH,GAAS9D,OAAO,CAAC0E,QAAR,CAAiBI,GAAG,CAAChB,CAAD,CAApB,CAAT;AACD;;AACD,SAAOS,GAAP;AACD,CAND;;AAQAvE,OAAO,CAAC+E,cAAR,GAAyB,SAASA,cAAT,CAAwBtE,GAAxB,EAA6B;AACpD,SAAOT,OAAO,CAAC0E,QAAR,CAAiB,OAAOjE,GAAG,CAACG,QAAJ,CAAa,KAAb,CAAxB,CAAP;AACD,CAFD;;AAIAZ,OAAO,CAACgF,aAAR,GAAwB,SAASA,aAAT,CAAuBC,KAAvB,EAA8B;AACpD,MAAI,OAAOA,KAAP,IAAgB,QAApB,EAA8B;AAC5B,WAAO,KAAP;AACD,GAFD,MAEO,IAAInD,MAAM,CAACwC,QAAP,CAAgBW,KAAhB,CAAJ,EAA4B;AACjC,WAAOC,SAAP;AACD;;AACD,QAAM,IAAIxD,KAAJ,CAAU,oBAAV,CAAN;AACD,CAPD","sourcesContent":["'use strict'\n\nconst util = require('util')\nconst bignumber = require('bignumber.js').BigNumber\n\nconst constants = require('./constants')\nconst NUMBYTES = constants.NUMBYTES\nconst SHIFT32 = constants.SHIFT32\nconst MAX_SAFE_HIGH = 0x1fffff\n\nexports.hasBigInt = (typeof BigInt === 'function')\n\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n */\nconst TD = (typeof TextDecoder === 'function') ? TextDecoder : util.TextDecoder\n/* istanbul ignore else */\nif (TD) {\n  // node 11+, browsers : node 8.3+\n  const td = new TD('utf8', {fatal: true, ignoreBOM: true})\n  exports.utf8 = (buf) => td.decode(buf)\n  exports.utf8.checksUTF8 = true\n} else {\n  // TODO: polyfill a slow one or wait for node6 to die\n  exports.utf8 = (buf) => buf.toString('utf8') \n  exports.utf8.checksUTF8 = false  \n}\n\nexports.parseCBORint = function(ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0)\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0)\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0)\n    case NUMBYTES.EIGHT:\n      const f = buf.readUInt32BE(0)\n      const g = buf.readUInt32BE(4)\n      if (f > MAX_SAFE_HIGH) {\n        return new bignumber(f).times(SHIFT32).plus(g)\n      } else {\n        return (f * SHIFT32) + g\n      }\n    default:\n      throw new Error('Invalid additional info for int: ' + ai)\n  }\n}\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  let s16 = (u >> 16) & 0x8000 // top bit is sign\n  const exp = (u >> 23) & 0xff // then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n  } else if ((exp >= 103) && (exp < 113)) {\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n  } else {\n  //   } else if (exp == 255 && mant == 0) { /* Inf */\n  //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n\n    return false\n  }\n\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16)\n  return true\n}\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1\n  const exp = (buf[0] & 0x7C) >> 2\n  const mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308)\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant)\n  }\n}\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf)\n    case 4:\n      return buf.readFloatBE(0)\n    case 8:\n      return buf.readDoubleBE(0)\n    default:\n      throw new Error('Invalid float size: ' + buf.length)\n  }\n}\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex')\n}\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '')\n  let start = 0\n  let end = (s.length % 8) || 8\n  const chunks = []\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2))\n    start = end\n    end += 8\n  }\n  return Buffer.from(chunks)\n}\n\nexports.extend = function extend(old={}, ...adds) {\n  const len = adds.length\n  for (let j = 0; j < len; j++) {\n    const a = adds[j]\n    for (const k in a) {\n      const v = a[k]\n      old[k] = v\n    }\n  }\n  return old\n}\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true\n  }\n  if ((a == null) || (b == null)) {\n    return false\n  }\n  return (a.length === b.length) && a.every((elem, i) => elem === b[i])\n}\n\nexports.bufferEqual = function bufferEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true\n  }\n  if ((a == null) || (b == null)) {\n    return false\n  }\n  if (!(Buffer.isBuffer(a) && Buffer.isBuffer(b) && (a.length === b.length))) {\n    return false\n  }\n  const len = a.length\n  let ret = true\n  let i\n  let j\n  for (i = j = 0; j < len; i = ++j) {\n    const byte = a[i]\n    ret = ret && (b[i] === byte)\n  }\n  return !!ret\n}\n\nexports.bufferToBignumber = function bufferToBignumber(buf) {\n  return new bignumber(buf.toString('hex'), 16)\n}\n\nexports.toBigInt = function toBigInt(num) {\n  if (!exports.hasBigInt) {\n    return Number(num) // lossy.  Better than nothing?\n  }\n  return BigInt(num)\n}\n\nexports.bigIntize = function bigIntize(obj) {\n  const ret = {}\n  for (const k in obj) { // stupid node 6\n    ret[k] = exports.toBigInt(obj[k])\n  }\n  return ret\n}\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return exports.toBigInt('0x' + buf.toString('hex'))\n}\n\nexports.guessEncoding = function guessEncoding(input) {\n  if (typeof input == 'string') {\n    return 'hex'\n  } else if (Buffer.isBuffer(input)) {\n    return undefined\n  }\n  throw new Error('Unknown input type')\n}\n\n"]},"metadata":{},"sourceType":"script"}