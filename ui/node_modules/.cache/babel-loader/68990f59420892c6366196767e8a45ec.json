{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(readSlot),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(readStorage);\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readStorage = exports.readSlot = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:storage:read\");\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Utils = __importStar(require(\"../utils\"));\n\nvar Evm = __importStar(require(\"../../evm\"));\n\nvar errors_1 = require(\"../../errors\");\n\nfunction readSlot(storage, slot) {\n  var address, hexAddress, word;\n  return _regeneratorRuntime.wrap(function readSlot$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          address = Utils.slotAddress(slot); // debug(\"reading slot: %o\", Conversion.toHexString(address));\n\n          hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);\n          word = storage[hexAddress]; //if we can't find the word in the map, we place a request to the invoker to supply it\n          //(contract-decoder will look it up from the blockchain, while the debugger will just\n          //say 0)\n\n          if (!(word === undefined)) {\n            _context.next = 7;\n            break;\n          }\n\n          _context.next = 6;\n          return {\n            type: \"storage\",\n            slot: address\n          };\n\n        case 6:\n          word = _context.sent;\n\n        case 7:\n          return _context.abrupt(\"return\", word);\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nexports.readSlot = readSlot;\n\nfunction readStorage(pointer, state) {\n  var storage, range, from, to, length, totalWordsAsBN, totalWords, data, i, offset, word;\n  return _regeneratorRuntime.wrap(function readStorage$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          storage = state.storage;\n          range = pointer.range;\n          debug(\"readRange %o\", range);\n          from = range.from, to = range.to, length = range.length;\n          from = {\n            slot: from.slot,\n            index: from.index || 0\n          };\n\n          if (length !== undefined) {\n            to = {\n              slot: {\n                path: from.slot.path || undefined,\n                offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))\n              },\n              index: (from.index + length - 1) % Evm.Utils.WORD_SIZE\n            };\n          }\n\n          debug(\"normalized readRange %o\", {\n            from: from,\n            to: to\n          });\n          totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);\n          _context2.prev = 8;\n          totalWords = totalWordsAsBN.toNumber();\n          _context2.next = 15;\n          break;\n\n        case 12:\n          _context2.prev = 12;\n          _context2.t0 = _context2[\"catch\"](8);\n          throw new errors_1.DecodingError({\n            kind: \"ReadErrorStorage\",\n            range: range\n          });\n\n        case 15:\n          data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);\n          i = 0;\n\n        case 17:\n          if (!(i < totalWords)) {\n            _context2.next = 25;\n            break;\n          }\n\n          offset = from.slot.offset.addn(i);\n          return _context2.delegateYield(readSlot(storage, Object.assign(Object.assign({}, from.slot), {\n            offset: offset\n          })), \"t1\", 20);\n\n        case 20:\n          word = _context2.t1;\n\n          if (typeof word !== \"undefined\") {\n            data.set(word, i * Evm.Utils.WORD_SIZE);\n          }\n\n        case 22:\n          i++;\n          _context2.next = 17;\n          break;\n\n        case 25:\n          debug(\"words %o\", data);\n          data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);\n          debug(\"data: %o\", data);\n          return _context2.abrupt(\"return\", data);\n\n        case 29:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[8, 12]]);\n}\n\nexports.readStorage = readStorage;","map":{"version":3,"sources":["../../../../lib/storage/read/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readStorage = exports.readSlot = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:storage:read\");\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* readSlot(storage, slot) {\n    const address = Utils.slotAddress(slot);\n    // debug(\"reading slot: %o\", Conversion.toHexString(address));\n    const hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);\n    let word = storage[hexAddress];\n    //if we can't find the word in the map, we place a request to the invoker to supply it\n    //(contract-decoder will look it up from the blockchain, while the debugger will just\n    //say 0)\n    if (word === undefined) {\n        word = yield {\n            type: \"storage\",\n            slot: address\n        };\n    }\n    return word;\n}\nexports.readSlot = readSlot;\nfunction* readStorage(pointer, state) {\n    const { storage } = state;\n    const { range } = pointer;\n    debug(\"readRange %o\", range);\n    let { from, to, length } = range;\n    from = {\n        slot: from.slot,\n        index: from.index || 0\n    };\n    if (length !== undefined) {\n        to = {\n            slot: {\n                path: from.slot.path || undefined,\n                offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))\n            },\n            index: (from.index + length - 1) % Evm.Utils.WORD_SIZE\n        };\n    }\n    debug(\"normalized readRange %o\", { from, to });\n    let totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);\n    let totalWords;\n    try {\n        totalWords = totalWordsAsBN.toNumber();\n    }\n    catch (_) {\n        throw new errors_1.DecodingError({\n            kind: \"ReadErrorStorage\",\n            range\n        });\n    }\n    let data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);\n    for (let i = 0; i < totalWords; i++) {\n        let offset = from.slot.offset.addn(i);\n        const word = yield* readSlot(storage, Object.assign(Object.assign({}, from.slot), { offset }));\n        if (typeof word !== \"undefined\") {\n            data.set(word, i * Evm.Utils.WORD_SIZE);\n        }\n    }\n    debug(\"words %o\", data);\n    data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);\n    debug(\"data: %o\", data);\n    return data;\n}\nexports.readStorage = readStorage;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}