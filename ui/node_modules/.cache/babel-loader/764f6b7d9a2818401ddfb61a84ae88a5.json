{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getterParameters = exports.definitionToAbi = exports.isContractPayable = exports.mutability = exports.functionKind = exports.parameters = exports.valueDefinition = exports.keyDefinition = exports.baseDefinition = exports.rationalValue = exports.regularizeTypeIdentifier = exports.spliceLocation = exports.isSimpleConstant = exports.stackSize = exports.contractKind = exports.referenceType = exports.isReference = exports.isEnum = exports.isMapping = exports.isStruct = exports.staticLengthAsString = exports.staticLength = exports.isDynamicArray = exports.isArray = exports.decimalPlaces = exports.specifiedSize = exports.visibility = exports.typeId = exports.typeClassLongForm = exports.typeClass = exports.typeStringWithoutLocation = exports.typeString = exports.typeIdentifier = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:ast:utils\");\n\nvar Common = __importStar(require(\"../common\"));\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\n/** @category Definition Reading */\n\n\nfunction typeIdentifier(definition) {\n  return definition.typeDescriptions.typeIdentifier;\n}\n\nexports.typeIdentifier = typeIdentifier;\n/** @category Definition Reading */\n\nfunction typeString(definition) {\n  return definition.typeDescriptions.typeString;\n}\n\nexports.typeString = typeString;\n/**\n * Returns the type string, but with location (if any) stripped off the end\n * @category Definition Reading\n */\n\nfunction typeStringWithoutLocation(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    //for handling Yul variables\n    return \"bytes32\";\n  }\n\n  return typeString(definition).replace(/ (storage|memory|calldata)( slice)?$/, \"\");\n}\n\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\n/**\n * returns basic type class for a variable definition node\n * e.g.:\n *  `t_uint256` becomes `uint`\n *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`\n * @category Definition Reading\n */\n\nfunction typeClass(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    //for handling Yul variables\n    return \"bytes\";\n  }\n\n  return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];\n}\n\nexports.typeClass = typeClass;\n/**\n * similar to typeClass, but includes any numeric qualifiers\n * e.g.:\n * `t_uint256` becomes `uint256`\n * @category Definition Reading\n */\n\nfunction typeClassLongForm(definition) {\n  return typeIdentifier(definition).match(/t_([^$_]+)/)[1];\n}\n\nexports.typeClassLongForm = typeClassLongForm;\n/**\n * for user-defined types -- structs, enums, contracts\n * often you can get these from referencedDeclaration, but not\n * always\n * @category Definition Reading\n */\n\nfunction typeId(definition) {\n  debug(\"definition %O\", definition);\n  return parseInt(typeIdentifier(definition).match(/\\$(\\d+)(_(storage|memory|calldata)(_ptr(_slice)?)?)?$/)[1]);\n}\n\nexports.typeId = typeId;\n/**\n * For function types; returns internal or external\n * (not for use on other types! will cause an error!)\n * should only return \"internal\" or \"external\"\n * @category Definition Reading\n */\n\nfunction visibility(definition) {\n  return definition.typeName ? definition.typeName.visibility : definition.visibility;\n}\n\nexports.visibility = visibility;\n/**\n * e.g. uint48 -> 6\n * @return size in bytes for explicit type size, or `null` if not stated\n * @category Definition Reading\n */\n\nfunction specifiedSize(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    return 32; //for handling Yul variables\n  }\n\n  var specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);\n\n  if (!specified) {\n    return null;\n  }\n\n  var num = parseInt(specified[1]);\n\n  switch (typeClass(definition)) {\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n      return num / 8;\n\n    case \"bytes\":\n      return num;\n\n    default:\n      debug(\"Unknown type for size specification: %s\", typeIdentifier(definition));\n  }\n}\n\nexports.specifiedSize = specifiedSize;\n/**\n * for fixed-point types, obviously\n * @category Definition Reading\n */\n\nfunction decimalPlaces(definition) {\n  return parseInt(typeIdentifier(definition).match(/t_[a-z]+[0-9]+x([0-9]+)/)[1]);\n}\n\nexports.decimalPlaces = decimalPlaces;\n/** @category Definition Reading */\n\nfunction isArray(definition) {\n  return typeIdentifier(definition).match(/^t_array/) != null;\n}\n\nexports.isArray = isArray;\n/** @category Definition Reading */\n\nfunction isDynamicArray(definition) {\n  return isArray(definition) && //NOTE: we do this by parsing the type identifier, rather than by just\n  //checking the length field, because we might be using this on a faked-up\n  //definition\n  typeIdentifier(definition).match(/\\$dyn_(storage|memory|calldata)(_ptr(_slice)?)?$/) != null;\n}\n\nexports.isDynamicArray = isDynamicArray;\n/**\n * length of a statically sized array -- please only use for arrays\n * already verified to be static!\n * @category Definition Reading\n */\n\nfunction staticLength(definition) {\n  //NOTE: we do this by parsing the type identifier, rather than by just\n  //checking the length field, because we might be using this on a faked-up\n  //definition\n  return parseInt(staticLengthAsString(definition));\n}\n\nexports.staticLength = staticLength;\n/**\n * see staticLength for explanation\n * @category Definition Reading\n */\n\nfunction staticLengthAsString(definition) {\n  return typeIdentifier(definition).match(/\\$(\\d+)_(storage|memory|calldata)(_ptr(_slice)?)?$/)[1];\n}\n\nexports.staticLengthAsString = staticLengthAsString;\n/** @category Definition Reading */\n\nfunction isStruct(definition) {\n  return typeIdentifier(definition).match(/^t_struct/) != null;\n}\n\nexports.isStruct = isStruct;\n/** @category Definition Reading */\n\nfunction isMapping(definition) {\n  return typeIdentifier(definition).match(/^t_mapping/) != null;\n}\n\nexports.isMapping = isMapping;\n/** @category Definition Reading */\n\nfunction isEnum(definition) {\n  return typeIdentifier(definition).match(/^t_enum/) != null;\n}\n\nexports.isEnum = isEnum;\n/** @category Definition Reading */\n\nfunction isReference(definition) {\n  return typeIdentifier(definition).match(/_(memory|storage|calldata)(_ptr(_slice)?)?$/) != null;\n}\n\nexports.isReference = isReference;\n/**\n * note: only use this on things already verified to be references\n * @category Definition Reading\n */\n\nfunction referenceType(definition) {\n  return typeIdentifier(definition).match(/_([^_]+)(_ptr(_slice)?)?$/)[1];\n}\n\nexports.referenceType = referenceType;\n/**\n * only for contract types, obviously! will yield nonsense otherwise!\n * @category Definition Reading\n */\n\nfunction contractKind(definition) {\n  return typeString(definition).split(\" \")[0];\n}\n\nexports.contractKind = contractKind;\n/**\n * stack size, in words, of a given type\n * @category Definition Reading\n */\n\nfunction stackSize(definition) {\n  if (typeClass(definition) === \"function\" && visibility(definition) === \"external\") {\n    return 2;\n  }\n\n  if (isReference(definition) && referenceType(definition) === \"calldata\") {\n    if (typeClass(definition) === \"string\" || typeClass(definition) === \"bytes\") {\n      return 2;\n    }\n\n    if (isDynamicArray(definition)) {\n      return 2;\n    }\n  }\n\n  return 1;\n}\n\nexports.stackSize = stackSize;\n/** @category Definition Reading */\n\nfunction isSimpleConstant(definition) {\n  var types = [\"stringliteral\", \"rational\"];\n  return types.includes(typeClass(definition));\n}\n\nexports.isSimpleConstant = isSimpleConstant;\n/**\n * definition: a storage reference definition\n * location: the location you want it to refer to instead\n * @category Definition Reading\n */\n\nfunction spliceLocation(definition, location) {\n  debug(\"definition %O\", definition);\n  return Object.assign(Object.assign({}, definition), {\n    typeDescriptions: Object.assign(Object.assign({}, definition.typeDescriptions), {\n      typeIdentifier: definition.typeDescriptions.typeIdentifier.replace(/_(storage|memory|calldata)(?=((_slice)?_ptr)?$)/, \"_\" + location)\n    })\n  });\n}\n\nexports.spliceLocation = spliceLocation;\n/**\n * adds \"_ptr\" on to the end of type identifiers that might need it; note that\n * this operates on identifiers, not definitions\n * @category Definition Reading\n */\n\nfunction regularizeTypeIdentifier(identifier) {\n  return identifier.replace(/(_(storage|memory|calldata))((_slice)?_ptr)?$/, \"$1_ptr\" //this used to use lookbehind for clarity, but Firefox...\n  //(see: https://github.com/trufflesuite/truffle/issues/3068 )\n  );\n}\n\nexports.regularizeTypeIdentifier = regularizeTypeIdentifier;\n/**\n * extract the actual numerical value from a node of type rational.\n * currently assumes result will be integer (currently returns BN)\n * @category Definition Reading\n */\n\nfunction rationalValue(definition) {\n  var identifier = typeIdentifier(definition);\n  var absoluteValue = identifier.match(/_(\\d+)_by_1$/)[1];\n  var isNegative = identifier.match(/_minus_/) != null;\n  return isNegative ? new bn_js_1.default(absoluteValue).neg() : new bn_js_1.default(absoluteValue);\n}\n\nexports.rationalValue = rationalValue;\n/** @category Definition Reading */\n\nfunction baseDefinition(definition) {\n  if (definition.typeName && definition.typeName.baseType) {\n    return definition.typeName.baseType;\n  }\n\n  if (definition.baseType) {\n    return definition.baseType;\n  } //otherwise, we'll have to spoof it up ourselves\n\n\n  var baseIdentifier = typeIdentifier(definition).match(/^t_array\\$_(.*)_\\$/)[1]; //greedy match to extract everything from first to last dollar sign\n  // HACK - internal types for memory or storage also seem to be pointers\n\n  baseIdentifier = regularizeTypeIdentifier(baseIdentifier); // another HACK - we get away with it because we're only using that one property\n\n  var result = lodash_clonedeep_1.default(definition);\n  result.typeDescriptions.typeIdentifier = baseIdentifier;\n  return result; //WARNING -- these hacks do *not* correctly handle all cases!\n  //they do, however, handle the cases we currently need.\n}\n\nexports.baseDefinition = baseDefinition;\n/**\n * for use for mappings and arrays only!\n * for arrays, fakes up a uint definition\n * @category Definition Reading\n */\n\nfunction keyDefinition(definition, scopes) {\n  var result;\n\n  switch (typeClass(definition)) {\n    case \"mapping\":\n      //first: is there a key type already there? if so just use that\n      if (definition.keyType) {\n        return definition.keyType;\n      }\n\n      if (definition.typeName && definition.typeName.keyType) {\n        return definition.typeName.keyType;\n      } //otherwise: is there a referencedDeclaration? if so try using that\n\n\n      var baseDeclarationId = definition.referencedDeclaration;\n      debug(\"baseDeclarationId %d\", baseDeclarationId); //if there's a referencedDeclaration, we'll use that\n\n      if (baseDeclarationId !== undefined) {\n        var baseDeclaration = scopes[baseDeclarationId].definition;\n        return baseDeclaration.keyType || baseDeclaration.typeName.keyType;\n      } //otherwise, we'll need to perform some hackery, similarly to in baseDefinition;\n      //we'll have to spoof it up ourselves\n\n\n      var keyIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_(.*?)_\\$_/)[1]; //use *non*-greedy match; note that if the key type could include\n      //the sequence \"_$_\", this could cause a problem, but they can't; the only\n      //valid key types that include dollar signs at all are user-defined types,\n      //which contain both \"$_\" and \"_$\" but never \"_$_\".\n      // HACK - internal types for memory or storage also seem to be pointers\n\n      keyIdentifier = regularizeTypeIdentifier(keyIdentifier);\n      var keyString = typeString(definition).match(/mapping\\((.*?) => .*\\)( storage)?$/)[1]; //use *non*-greedy match; note that if the key type could include\n      //\"=>\", this could cause a problem, but mappings are not allowed as key\n      //types, so this can't come up\n      // another HACK - we get away with it because we're only using that one property\n\n      result = lodash_clonedeep_1.default(definition);\n      result.typeDescriptions = {\n        typeIdentifier: keyIdentifier,\n        typeString: keyString\n      };\n      return result;\n\n    case \"array\":\n      //HACK -- again we should get away with it because for a uint256 we don't\n      //really need to inspect the other properties\n      result = lodash_clonedeep_1.default(definition);\n      result.typeDescriptions = {\n        typeIdentifier: \"t_uint256\",\n        typeString: \"uint256\"\n      };\n      return result;\n\n    default:\n      debug(\"unrecognized index access!\");\n  }\n}\n\nexports.keyDefinition = keyDefinition;\n/**\n * for use for mappings only!\n * @category Definition Reading\n */\n\nfunction valueDefinition(definition, scopes) {\n  var result; //first: is there a value type already there? if so just use that\n\n  if (definition.valueType) {\n    return definition.valueType;\n  }\n\n  if (definition.typeName && definition.typeName.valueType) {\n    return definition.typeName.valueType;\n  } //otherwise: is there a referencedDeclaration? if so try using that\n\n\n  var baseDeclarationId = definition.referencedDeclaration;\n  debug(\"baseDeclarationId %d\", baseDeclarationId); //if there's a referencedDeclaration, we'll use that\n\n  if (baseDeclarationId !== undefined) {\n    var baseDeclaration = scopes[baseDeclarationId].definition;\n    return baseDeclaration.valueType || baseDeclaration.typeName.valueType;\n  } //otherwise, we'll need to perform some hackery, similarly to in keyDefinition;\n  //we'll have to spoof it up ourselves\n\n\n  var valueIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_.*?_\\$_(.*)_\\$/)[1]; //use *non*-greedy match on the key; note that if the key type could include\n  //the sequence \"_$_\", this could cause a problem, but they can't; the only\n  //valid key types that include dollar signs at all are user-defined types,\n  //which contain both \"$_\" and \"_$\" but never \"_$_\".\n  // HACK - internal types for memory or storage also seem to be pointers\n\n  valueIdentifier = regularizeTypeIdentifier(valueIdentifier);\n  var valueString = typeString(definition).match(/mapping\\(.*? => (.*)\\)( storage)?$/)[1]; //use *non*-greedy match; note that if the key type could include\n  //\"=>\", this could cause a problem, but mappings are not allowed as key\n  //types, so this can't come up\n  // another HACK - we get away with it because we're only using that one property\n\n  result = lodash_clonedeep_1.default(definition);\n  result.typeDescriptions = {\n    typeIdentifier: valueIdentifier,\n    typeString: valueString\n  };\n  return result;\n}\n\nexports.valueDefinition = valueDefinition;\n/**\n * returns input parameters, then output parameters\n * NOTE: ONLY FOR VARIABLE DECLARATIONS OF FUNCTION TYPE\n * NOT FOR FUNCTION DEFINITIONS\n * @category Definition Reading\n */\n\nfunction parameters(definition) {\n  var typeObject = definition.typeName || definition;\n\n  if (typeObject.parameterTypes && typeObject.returnParameterTypes) {\n    return [typeObject.parameterTypes.parameters, typeObject.returnParameterTypes.parameters];\n  } else {\n    return undefined;\n  }\n}\n\nexports.parameters = parameters;\n/**\n * compatibility function, since pre-0.5.0 functions don't have node.kind\n * returns undefined if you don't put in a function node\n * @category Definition Reading\n */\n\nfunction functionKind(node) {\n  if (node.nodeType !== \"FunctionDefinition\") {\n    return undefined;\n  }\n\n  if (node.kind !== undefined) {\n    //if we're dealing with 0.5.x, we can just read node.kind\n    return node.kind;\n  } //otherwise, we need this little shim\n\n\n  if (node.isConstructor) {\n    return \"constructor\";\n  }\n\n  return node.name === \"\" ? \"fallback\" : \"function\";\n}\n\nexports.functionKind = functionKind;\n/**\n * similar compatibility function for mutability for pre-0.4.16 versions\n * returns undefined if you don't give it a FunctionDefinition or\n * VariableDeclaration\n * @category Definition Reading\n */\n\nfunction mutability(node) {\n  node = node.typeName || node;\n\n  if (node.nodeType !== \"FunctionDefinition\" && node.nodeType !== \"FunctionTypeName\") {\n    return undefined;\n  }\n\n  if (node.stateMutability !== undefined) {\n    //if we're dealing with 0.4.16 or later, we can just read node.stateMutability\n    return node.stateMutability;\n  } //otherwise, we need this little shim\n\n\n  if (node.payable) {\n    return \"payable\";\n  }\n\n  if (node.constant) {\n    //yes, it means \"view\" even if you're looking at a variable declaration!\n    //old Solidity was weird!\n    return \"view\";\n  }\n\n  return \"nonpayable\";\n}\n\nexports.mutability = mutability;\n/**\n * takes a contract definition and asks, does it have a payable fallback\n * function?\n * @category Definition Reading\n */\n\nfunction isContractPayable(definition) {\n  return definition.nodes.some(function (node) {\n    return node.nodeType === \"FunctionDefinition\" && (functionKind(node) === \"fallback\" || functionKind(node) === \"receive\") && mutability(node) === \"payable\";\n  });\n}\n\nexports.isContractPayable = isContractPayable;\n/**\n * the main function. just does some dispatch.\n * returns undefined on bad input\n */\n\nfunction definitionToAbi(node, referenceDeclarations) {\n  switch (node.nodeType) {\n    case \"FunctionDefinition\":\n      if (node.visibility === \"public\" || node.visibility === \"external\") {\n        return functionDefinitionToAbi(node, referenceDeclarations);\n      } else {\n        return undefined;\n      }\n\n    case \"EventDefinition\":\n      return eventDefinitionToAbi(node, referenceDeclarations);\n\n    case \"VariableDeclaration\":\n      if (node.visibility === \"public\") {\n        return getterDefinitionToAbi(node, referenceDeclarations);\n      } else {\n        return undefined;\n      }\n\n    default:\n      return undefined;\n  }\n}\n\nexports.definitionToAbi = definitionToAbi; //note: not for FunctionTypeNames or VariableDeclarations\n\nfunction functionDefinitionToAbi(node, referenceDeclarations) {\n  var kind = functionKind(node);\n  var stateMutability = mutability(node);\n  var payable = stateMutability === \"payable\";\n  var inputs;\n\n  switch (kind) {\n    case \"function\":\n      var name = node.name;\n      var outputs = parametersToAbi(node.returnParameters.parameters, referenceDeclarations);\n      inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n      return {\n        type: \"function\",\n        name: name,\n        inputs: inputs,\n        outputs: outputs,\n        stateMutability: stateMutability\n      };\n\n    case \"constructor\":\n      inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations); //note: need to coerce because of mutability restrictions\n\n      return {\n        type: \"constructor\",\n        inputs: inputs,\n        stateMutability: stateMutability,\n        payable: payable\n      };\n\n    case \"fallback\":\n      //note: need to coerce because of mutability restrictions\n      return {\n        type: \"fallback\",\n        stateMutability: stateMutability,\n        payable: payable\n      };\n\n    case \"receive\":\n      //note: need to coerce because of mutability restrictions\n      return {\n        type: \"receive\",\n        stateMutability: stateMutability,\n        payable: payable\n      };\n  }\n}\n\nfunction eventDefinitionToAbi(node, referenceDeclarations) {\n  var inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n  var name = node.name;\n  var anonymous = node.anonymous;\n  return {\n    type: \"event\",\n    inputs: inputs,\n    name: name,\n    anonymous: anonymous\n  };\n}\n\nfunction parametersToAbi(nodes, referenceDeclarations) {\n  return nodes.map(function (node) {\n    return parameterToAbi(node, referenceDeclarations);\n  });\n} //NOTE: This function is only for types that could potentially go in the ABI!\n//(otherwise it could, say, loop infinitely)\n//currently it will only ever be called on those because it's only called from\n//definitionToAbi, which filters out any definitions that are not for\n//this that *actually* go in the ABI\n//if you want to expand it to handle those (by throwing an exception, say),\n//you'll need to give it a way to detect circularities\n\n\nfunction parameterToAbi(node, referenceDeclarations) {\n  var name = node.name; //may be the empty string... or even undefined for a base type\n\n  var components;\n  var internalType = typeStringWithoutLocation(node); //is this an array? if so use separate logic\n\n  if (typeClass(node) === \"array\") {\n    var baseType = node.typeName ? node.typeName.baseType : node.baseType;\n    var baseAbi = parameterToAbi(baseType, referenceDeclarations);\n    var arraySuffix = isDynamicArray(node) ? \"[]\" : \"[\".concat(staticLength(node), \"]\");\n    var _parameter = {\n      name: name,\n      type: baseAbi.type + arraySuffix,\n      components: baseAbi.components,\n      internalType: internalType\n    };\n\n    if (\"indexed\" in node) {\n      return Object.assign(Object.assign({}, _parameter), {\n        indexed: node.indexed\n      });\n    } else {\n      return _parameter;\n    }\n  }\n\n  var abiTypeString = toAbiType(node, referenceDeclarations); //otherwise... is it a struct? if so we need to populate components\n\n  if (typeClass(node) === \"struct\") {\n    var id = typeId(node);\n    var referenceDeclaration = referenceDeclarations[id];\n\n    if (referenceDeclaration === undefined) {\n      var typeToDisplay = typeString(node);\n      throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n    }\n\n    components = parametersToAbi(referenceDeclaration.members, referenceDeclarations);\n  }\n\n  var parameter = {\n    name: name,\n    type: abiTypeString,\n    components: components,\n    internalType: internalType\n  };\n\n  if (\"indexed\" in node) {\n    return Object.assign(Object.assign({}, parameter), {\n      indexed: node.indexed\n    });\n  } else {\n    return parameter;\n  }\n} //note: this is only meant for non-array types that can go in the ABI\n//it returns how that type is notated in the ABI -- just the string,\n//to be clear, not components of tuples\n//again, NOT FOR ARRAYS\n\n\nfunction toAbiType(node, referenceDeclarations) {\n  var basicType = typeClassLongForm(node); //get that whole first segment!\n\n  switch (basicType) {\n    case \"contract\":\n      return \"address\";\n\n    case \"struct\":\n      return \"tuple\";\n    //the more detailed checking will be handled elsewhere\n\n    case \"enum\":\n      var referenceId = typeId(node);\n      var referenceDeclaration = referenceDeclarations[referenceId];\n\n      if (referenceDeclaration === undefined) {\n        var typeToDisplay = typeString(node);\n        throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);\n      }\n\n      var numOptions = referenceDeclaration.members.length;\n      var bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n      return \"uint\".concat(bits);\n\n    default:\n      return basicType;\n    //note that: int/uint/fixed/ufixed/bytes will have their size and such left on;\n    //address will have \"payable\" left off;\n    //external functions will be reduced to \"function\" (and internal functions shouldn't\n    //be passed in!)\n    //(mappings shouldn't be passed in either obviously)\n    //(nor arrays :P )\n  }\n}\n\nfunction getterDefinitionToAbi(node, referenceDeclarations) {\n  debug(\"getter node: %O\", node);\n  var name = node.name;\n\n  var _getterParameters = getterParameters(node, referenceDeclarations),\n      inputs = _getterParameters.inputs,\n      outputs = _getterParameters.outputs;\n\n  var inputsAbi = parametersToAbi(inputs, referenceDeclarations);\n  var outputsAbi = parametersToAbi(outputs, referenceDeclarations);\n  return {\n    type: \"function\",\n    name: name,\n    inputs: inputsAbi,\n    outputs: outputsAbi,\n    stateMutability: \"view\"\n  };\n} //how getter parameters work:\n//INPUT:\n//types other than arrays and mappings take no input.\n//array getters take uint256 input. mapping getters take input of their key type.\n//if arrays, mappings, stacked, then takes multiple inputs, in order from outside\n//to in.\n//These parameters are unnamed.\n//OUTPUT:\n//if base type (beneath mappings & arrays) is not a struct, returns that.\n//(This return parameter has no name -- it is *not* named for the variable!)\n//if it is a struct, returns multiple outputs, one for each member of the struct,\n//*except* arrays and mappings.  (And they have names, the names of the members.)\n//important note: inner structs within a struct are just returned, not\n//partially destructured like the outermost struct!  Yes, this is confusing.\n\n\nfunction getterParameters(node, referenceDeclarations) {\n  var baseNode = node.typeName || node;\n  var inputs = [];\n\n  while (typeClass(baseNode) === \"array\" || typeClass(baseNode) === \"mapping\") {\n    var keyNode = keyDefinition(baseNode); //note: if baseNode is an array, this spoofs up a uint256 definition\n\n    inputs.push(Object.assign(Object.assign({}, keyNode), {\n      name: \"\"\n    })); //again, getter input params have no name\n\n    switch (typeClass(baseNode)) {\n      case \"array\":\n        baseNode = baseNode.baseType;\n        break;\n\n      case \"mapping\":\n        baseNode = baseNode.valueType;\n        break;\n    }\n  } //at this point, baseNode should hold the base type\n  //now we face the question: is it a struct?\n\n\n  if (typeClass(baseNode) === \"struct\") {\n    var id = typeId(baseNode);\n    var referenceDeclaration = referenceDeclarations[id];\n\n    if (referenceDeclaration === undefined) {\n      var typeToDisplay = typeString(baseNode);\n      throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n    }\n\n    var outputs = referenceDeclaration.members.filter(function (member) {\n      return typeClass(member) !== \"array\" && typeClass(member) !== \"mapping\";\n    });\n    return {\n      inputs: inputs,\n      outputs: outputs\n    }; //no need to wash name!\n  } else {\n    //only one output; it's just the base node, with its name washed\n    return {\n      inputs: inputs,\n      outputs: [Object.assign(Object.assign({}, baseNode), {\n        name: \"\"\n      })]\n    };\n  }\n}\n\nexports.getterParameters = getterParameters;","map":{"version":3,"sources":["../../../lib/ast/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getterParameters = exports.definitionToAbi = exports.isContractPayable = exports.mutability = exports.functionKind = exports.parameters = exports.valueDefinition = exports.keyDefinition = exports.baseDefinition = exports.rationalValue = exports.regularizeTypeIdentifier = exports.spliceLocation = exports.isSimpleConstant = exports.stackSize = exports.contractKind = exports.referenceType = exports.isReference = exports.isEnum = exports.isMapping = exports.isStruct = exports.staticLengthAsString = exports.staticLength = exports.isDynamicArray = exports.isArray = exports.decimalPlaces = exports.specifiedSize = exports.visibility = exports.typeId = exports.typeClassLongForm = exports.typeClass = exports.typeStringWithoutLocation = exports.typeString = exports.typeIdentifier = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:ast:utils\");\nconst Common = __importStar(require(\"../common\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\n/** @category Definition Reading */\nfunction typeIdentifier(definition) {\n    return definition.typeDescriptions.typeIdentifier;\n}\nexports.typeIdentifier = typeIdentifier;\n/** @category Definition Reading */\nfunction typeString(definition) {\n    return definition.typeDescriptions.typeString;\n}\nexports.typeString = typeString;\n/**\n * Returns the type string, but with location (if any) stripped off the end\n * @category Definition Reading\n */\nfunction typeStringWithoutLocation(definition) {\n    if (definition.nodeType === \"YulTypedName\") {\n        //for handling Yul variables\n        return \"bytes32\";\n    }\n    return typeString(definition).replace(/ (storage|memory|calldata)( slice)?$/, \"\");\n}\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\n/**\n * returns basic type class for a variable definition node\n * e.g.:\n *  `t_uint256` becomes `uint`\n *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`\n * @category Definition Reading\n */\nfunction typeClass(definition) {\n    if (definition.nodeType === \"YulTypedName\") {\n        //for handling Yul variables\n        return \"bytes\";\n    }\n    return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];\n}\nexports.typeClass = typeClass;\n/**\n * similar to typeClass, but includes any numeric qualifiers\n * e.g.:\n * `t_uint256` becomes `uint256`\n * @category Definition Reading\n */\nfunction typeClassLongForm(definition) {\n    return typeIdentifier(definition).match(/t_([^$_]+)/)[1];\n}\nexports.typeClassLongForm = typeClassLongForm;\n/**\n * for user-defined types -- structs, enums, contracts\n * often you can get these from referencedDeclaration, but not\n * always\n * @category Definition Reading\n */\nfunction typeId(definition) {\n    debug(\"definition %O\", definition);\n    return parseInt(typeIdentifier(definition).match(/\\$(\\d+)(_(storage|memory|calldata)(_ptr(_slice)?)?)?$/)[1]);\n}\nexports.typeId = typeId;\n/**\n * For function types; returns internal or external\n * (not for use on other types! will cause an error!)\n * should only return \"internal\" or \"external\"\n * @category Definition Reading\n */\nfunction visibility(definition) {\n    return ((definition.typeName\n        ? definition.typeName.visibility\n        : definition.visibility));\n}\nexports.visibility = visibility;\n/**\n * e.g. uint48 -> 6\n * @return size in bytes for explicit type size, or `null` if not stated\n * @category Definition Reading\n */\nfunction specifiedSize(definition) {\n    if (definition.nodeType === \"YulTypedName\") {\n        return 32; //for handling Yul variables\n    }\n    let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);\n    if (!specified) {\n        return null;\n    }\n    let num = parseInt(specified[1]);\n    switch (typeClass(definition)) {\n        case \"int\":\n        case \"uint\":\n        case \"fixed\":\n        case \"ufixed\":\n            return num / 8;\n        case \"bytes\":\n            return num;\n        default:\n            debug(\"Unknown type for size specification: %s\", typeIdentifier(definition));\n    }\n}\nexports.specifiedSize = specifiedSize;\n/**\n * for fixed-point types, obviously\n * @category Definition Reading\n */\nfunction decimalPlaces(definition) {\n    return parseInt(typeIdentifier(definition).match(/t_[a-z]+[0-9]+x([0-9]+)/)[1]);\n}\nexports.decimalPlaces = decimalPlaces;\n/** @category Definition Reading */\nfunction isArray(definition) {\n    return typeIdentifier(definition).match(/^t_array/) != null;\n}\nexports.isArray = isArray;\n/** @category Definition Reading */\nfunction isDynamicArray(definition) {\n    return (isArray(definition) &&\n        //NOTE: we do this by parsing the type identifier, rather than by just\n        //checking the length field, because we might be using this on a faked-up\n        //definition\n        typeIdentifier(definition).match(/\\$dyn_(storage|memory|calldata)(_ptr(_slice)?)?$/) != null);\n}\nexports.isDynamicArray = isDynamicArray;\n/**\n * length of a statically sized array -- please only use for arrays\n * already verified to be static!\n * @category Definition Reading\n */\nfunction staticLength(definition) {\n    //NOTE: we do this by parsing the type identifier, rather than by just\n    //checking the length field, because we might be using this on a faked-up\n    //definition\n    return parseInt(staticLengthAsString(definition));\n}\nexports.staticLength = staticLength;\n/**\n * see staticLength for explanation\n * @category Definition Reading\n */\nfunction staticLengthAsString(definition) {\n    return typeIdentifier(definition).match(/\\$(\\d+)_(storage|memory|calldata)(_ptr(_slice)?)?$/)[1];\n}\nexports.staticLengthAsString = staticLengthAsString;\n/** @category Definition Reading */\nfunction isStruct(definition) {\n    return typeIdentifier(definition).match(/^t_struct/) != null;\n}\nexports.isStruct = isStruct;\n/** @category Definition Reading */\nfunction isMapping(definition) {\n    return typeIdentifier(definition).match(/^t_mapping/) != null;\n}\nexports.isMapping = isMapping;\n/** @category Definition Reading */\nfunction isEnum(definition) {\n    return typeIdentifier(definition).match(/^t_enum/) != null;\n}\nexports.isEnum = isEnum;\n/** @category Definition Reading */\nfunction isReference(definition) {\n    return (typeIdentifier(definition).match(/_(memory|storage|calldata)(_ptr(_slice)?)?$/) != null);\n}\nexports.isReference = isReference;\n/**\n * note: only use this on things already verified to be references\n * @category Definition Reading\n */\nfunction referenceType(definition) {\n    return typeIdentifier(definition).match(/_([^_]+)(_ptr(_slice)?)?$/)[1];\n}\nexports.referenceType = referenceType;\n/**\n * only for contract types, obviously! will yield nonsense otherwise!\n * @category Definition Reading\n */\nfunction contractKind(definition) {\n    return typeString(definition).split(\" \")[0];\n}\nexports.contractKind = contractKind;\n/**\n * stack size, in words, of a given type\n * @category Definition Reading\n */\nfunction stackSize(definition) {\n    if (typeClass(definition) === \"function\" &&\n        visibility(definition) === \"external\") {\n        return 2;\n    }\n    if (isReference(definition) && referenceType(definition) === \"calldata\") {\n        if (typeClass(definition) === \"string\" ||\n            typeClass(definition) === \"bytes\") {\n            return 2;\n        }\n        if (isDynamicArray(definition)) {\n            return 2;\n        }\n    }\n    return 1;\n}\nexports.stackSize = stackSize;\n/** @category Definition Reading */\nfunction isSimpleConstant(definition) {\n    const types = [\"stringliteral\", \"rational\"];\n    return types.includes(typeClass(definition));\n}\nexports.isSimpleConstant = isSimpleConstant;\n/**\n * definition: a storage reference definition\n * location: the location you want it to refer to instead\n * @category Definition Reading\n */\nfunction spliceLocation(definition, location) {\n    debug(\"definition %O\", definition);\n    return Object.assign(Object.assign({}, definition), { typeDescriptions: Object.assign(Object.assign({}, definition.typeDescriptions), { typeIdentifier: definition.typeDescriptions.typeIdentifier.replace(/_(storage|memory|calldata)(?=((_slice)?_ptr)?$)/, \"_\" + location) }) });\n}\nexports.spliceLocation = spliceLocation;\n/**\n * adds \"_ptr\" on to the end of type identifiers that might need it; note that\n * this operates on identifiers, not definitions\n * @category Definition Reading\n */\nfunction regularizeTypeIdentifier(identifier) {\n    return identifier.replace(/(_(storage|memory|calldata))((_slice)?_ptr)?$/, \"$1_ptr\" //this used to use lookbehind for clarity, but Firefox...\n    //(see: https://github.com/trufflesuite/truffle/issues/3068 )\n    );\n}\nexports.regularizeTypeIdentifier = regularizeTypeIdentifier;\n/**\n * extract the actual numerical value from a node of type rational.\n * currently assumes result will be integer (currently returns BN)\n * @category Definition Reading\n */\nfunction rationalValue(definition) {\n    let identifier = typeIdentifier(definition);\n    let absoluteValue = identifier.match(/_(\\d+)_by_1$/)[1];\n    let isNegative = identifier.match(/_minus_/) != null;\n    return isNegative ? new bn_js_1.default(absoluteValue).neg() : new bn_js_1.default(absoluteValue);\n}\nexports.rationalValue = rationalValue;\n/** @category Definition Reading */\nfunction baseDefinition(definition) {\n    if (definition.typeName && definition.typeName.baseType) {\n        return definition.typeName.baseType;\n    }\n    if (definition.baseType) {\n        return definition.baseType;\n    }\n    //otherwise, we'll have to spoof it up ourselves\n    let baseIdentifier = typeIdentifier(definition).match(/^t_array\\$_(.*)_\\$/)[1];\n    //greedy match to extract everything from first to last dollar sign\n    // HACK - internal types for memory or storage also seem to be pointers\n    baseIdentifier = regularizeTypeIdentifier(baseIdentifier);\n    // another HACK - we get away with it because we're only using that one property\n    let result = lodash_clonedeep_1.default(definition);\n    result.typeDescriptions.typeIdentifier = baseIdentifier;\n    return result;\n    //WARNING -- these hacks do *not* correctly handle all cases!\n    //they do, however, handle the cases we currently need.\n}\nexports.baseDefinition = baseDefinition;\n/**\n * for use for mappings and arrays only!\n * for arrays, fakes up a uint definition\n * @category Definition Reading\n */\nfunction keyDefinition(definition, scopes) {\n    let result;\n    switch (typeClass(definition)) {\n        case \"mapping\":\n            //first: is there a key type already there? if so just use that\n            if (definition.keyType) {\n                return definition.keyType;\n            }\n            if (definition.typeName && definition.typeName.keyType) {\n                return definition.typeName.keyType;\n            }\n            //otherwise: is there a referencedDeclaration? if so try using that\n            let baseDeclarationId = definition.referencedDeclaration;\n            debug(\"baseDeclarationId %d\", baseDeclarationId);\n            //if there's a referencedDeclaration, we'll use that\n            if (baseDeclarationId !== undefined) {\n                let baseDeclaration = scopes[baseDeclarationId].definition;\n                return baseDeclaration.keyType || baseDeclaration.typeName.keyType;\n            }\n            //otherwise, we'll need to perform some hackery, similarly to in baseDefinition;\n            //we'll have to spoof it up ourselves\n            let keyIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_(.*?)_\\$_/)[1];\n            //use *non*-greedy match; note that if the key type could include\n            //the sequence \"_$_\", this could cause a problem, but they can't; the only\n            //valid key types that include dollar signs at all are user-defined types,\n            //which contain both \"$_\" and \"_$\" but never \"_$_\".\n            // HACK - internal types for memory or storage also seem to be pointers\n            keyIdentifier = regularizeTypeIdentifier(keyIdentifier);\n            let keyString = typeString(definition).match(/mapping\\((.*?) => .*\\)( storage)?$/)[1];\n            //use *non*-greedy match; note that if the key type could include\n            //\"=>\", this could cause a problem, but mappings are not allowed as key\n            //types, so this can't come up\n            // another HACK - we get away with it because we're only using that one property\n            result = lodash_clonedeep_1.default(definition);\n            result.typeDescriptions = {\n                typeIdentifier: keyIdentifier,\n                typeString: keyString\n            };\n            return result;\n        case \"array\":\n            //HACK -- again we should get away with it because for a uint256 we don't\n            //really need to inspect the other properties\n            result = lodash_clonedeep_1.default(definition);\n            result.typeDescriptions = {\n                typeIdentifier: \"t_uint256\",\n                typeString: \"uint256\"\n            };\n            return result;\n        default:\n            debug(\"unrecognized index access!\");\n    }\n}\nexports.keyDefinition = keyDefinition;\n/**\n * for use for mappings only!\n * @category Definition Reading\n */\nfunction valueDefinition(definition, scopes) {\n    let result;\n    //first: is there a value type already there? if so just use that\n    if (definition.valueType) {\n        return definition.valueType;\n    }\n    if (definition.typeName && definition.typeName.valueType) {\n        return definition.typeName.valueType;\n    }\n    //otherwise: is there a referencedDeclaration? if so try using that\n    let baseDeclarationId = definition.referencedDeclaration;\n    debug(\"baseDeclarationId %d\", baseDeclarationId);\n    //if there's a referencedDeclaration, we'll use that\n    if (baseDeclarationId !== undefined) {\n        let baseDeclaration = scopes[baseDeclarationId].definition;\n        return baseDeclaration.valueType || baseDeclaration.typeName.valueType;\n    }\n    //otherwise, we'll need to perform some hackery, similarly to in keyDefinition;\n    //we'll have to spoof it up ourselves\n    let valueIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_.*?_\\$_(.*)_\\$/)[1];\n    //use *non*-greedy match on the key; note that if the key type could include\n    //the sequence \"_$_\", this could cause a problem, but they can't; the only\n    //valid key types that include dollar signs at all are user-defined types,\n    //which contain both \"$_\" and \"_$\" but never \"_$_\".\n    // HACK - internal types for memory or storage also seem to be pointers\n    valueIdentifier = regularizeTypeIdentifier(valueIdentifier);\n    let valueString = typeString(definition).match(/mapping\\(.*? => (.*)\\)( storage)?$/)[1];\n    //use *non*-greedy match; note that if the key type could include\n    //\"=>\", this could cause a problem, but mappings are not allowed as key\n    //types, so this can't come up\n    // another HACK - we get away with it because we're only using that one property\n    result = lodash_clonedeep_1.default(definition);\n    result.typeDescriptions = {\n        typeIdentifier: valueIdentifier,\n        typeString: valueString\n    };\n    return result;\n}\nexports.valueDefinition = valueDefinition;\n/**\n * returns input parameters, then output parameters\n * NOTE: ONLY FOR VARIABLE DECLARATIONS OF FUNCTION TYPE\n * NOT FOR FUNCTION DEFINITIONS\n * @category Definition Reading\n */\nfunction parameters(definition) {\n    let typeObject = definition.typeName || definition;\n    if (typeObject.parameterTypes && typeObject.returnParameterTypes) {\n        return [\n            typeObject.parameterTypes.parameters,\n            typeObject.returnParameterTypes.parameters\n        ];\n    }\n    else {\n        return undefined;\n    }\n}\nexports.parameters = parameters;\n/**\n * compatibility function, since pre-0.5.0 functions don't have node.kind\n * returns undefined if you don't put in a function node\n * @category Definition Reading\n */\nfunction functionKind(node) {\n    if (node.nodeType !== \"FunctionDefinition\") {\n        return undefined;\n    }\n    if (node.kind !== undefined) {\n        //if we're dealing with 0.5.x, we can just read node.kind\n        return node.kind;\n    }\n    //otherwise, we need this little shim\n    if (node.isConstructor) {\n        return \"constructor\";\n    }\n    return node.name === \"\" ? \"fallback\" : \"function\";\n}\nexports.functionKind = functionKind;\n/**\n * similar compatibility function for mutability for pre-0.4.16 versions\n * returns undefined if you don't give it a FunctionDefinition or\n * VariableDeclaration\n * @category Definition Reading\n */\nfunction mutability(node) {\n    node = node.typeName || node;\n    if (node.nodeType !== \"FunctionDefinition\" &&\n        node.nodeType !== \"FunctionTypeName\") {\n        return undefined;\n    }\n    if (node.stateMutability !== undefined) {\n        //if we're dealing with 0.4.16 or later, we can just read node.stateMutability\n        return node.stateMutability;\n    }\n    //otherwise, we need this little shim\n    if (node.payable) {\n        return \"payable\";\n    }\n    if (node.constant) {\n        //yes, it means \"view\" even if you're looking at a variable declaration!\n        //old Solidity was weird!\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\nexports.mutability = mutability;\n/**\n * takes a contract definition and asks, does it have a payable fallback\n * function?\n * @category Definition Reading\n */\nfunction isContractPayable(definition) {\n    return definition.nodes.some(node => node.nodeType === \"FunctionDefinition\" &&\n        (functionKind(node) === \"fallback\" || functionKind(node) === \"receive\") &&\n        mutability(node) === \"payable\");\n}\nexports.isContractPayable = isContractPayable;\n/**\n * the main function. just does some dispatch.\n * returns undefined on bad input\n */\nfunction definitionToAbi(node, referenceDeclarations) {\n    switch (node.nodeType) {\n        case \"FunctionDefinition\":\n            if (node.visibility === \"public\" || node.visibility === \"external\") {\n                return functionDefinitionToAbi(node, referenceDeclarations);\n            }\n            else {\n                return undefined;\n            }\n        case \"EventDefinition\":\n            return eventDefinitionToAbi(node, referenceDeclarations);\n        case \"VariableDeclaration\":\n            if (node.visibility === \"public\") {\n                return getterDefinitionToAbi(node, referenceDeclarations);\n            }\n            else {\n                return undefined;\n            }\n        default:\n            return undefined;\n    }\n}\nexports.definitionToAbi = definitionToAbi;\n//note: not for FunctionTypeNames or VariableDeclarations\nfunction functionDefinitionToAbi(node, referenceDeclarations) {\n    let kind = functionKind(node);\n    let stateMutability = mutability(node);\n    let payable = stateMutability === \"payable\";\n    let inputs;\n    switch (kind) {\n        case \"function\":\n            let name = node.name;\n            let outputs = parametersToAbi(node.returnParameters.parameters, referenceDeclarations);\n            inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n            return {\n                type: \"function\",\n                name,\n                inputs,\n                outputs,\n                stateMutability\n            };\n        case \"constructor\":\n            inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n            //note: need to coerce because of mutability restrictions\n            return {\n                type: \"constructor\",\n                inputs,\n                stateMutability,\n                payable\n            };\n        case \"fallback\":\n            //note: need to coerce because of mutability restrictions\n            return {\n                type: \"fallback\",\n                stateMutability,\n                payable\n            };\n        case \"receive\":\n            //note: need to coerce because of mutability restrictions\n            return {\n                type: \"receive\",\n                stateMutability,\n                payable\n            };\n    }\n}\nfunction eventDefinitionToAbi(node, referenceDeclarations) {\n    let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n    let name = node.name;\n    let anonymous = node.anonymous;\n    return {\n        type: \"event\",\n        inputs,\n        name,\n        anonymous\n    };\n}\nfunction parametersToAbi(nodes, referenceDeclarations) {\n    return nodes.map(node => parameterToAbi(node, referenceDeclarations));\n}\n//NOTE: This function is only for types that could potentially go in the ABI!\n//(otherwise it could, say, loop infinitely)\n//currently it will only ever be called on those because it's only called from\n//definitionToAbi, which filters out any definitions that are not for\n//this that *actually* go in the ABI\n//if you want to expand it to handle those (by throwing an exception, say),\n//you'll need to give it a way to detect circularities\nfunction parameterToAbi(node, referenceDeclarations) {\n    let name = node.name; //may be the empty string... or even undefined for a base type\n    let components;\n    let internalType = typeStringWithoutLocation(node);\n    //is this an array? if so use separate logic\n    if (typeClass(node) === \"array\") {\n        let baseType = node.typeName ? node.typeName.baseType : node.baseType;\n        let baseAbi = parameterToAbi(baseType, referenceDeclarations);\n        let arraySuffix = isDynamicArray(node) ? `[]` : `[${staticLength(node)}]`;\n        const parameter = {\n            name,\n            type: baseAbi.type + arraySuffix,\n            components: baseAbi.components,\n            internalType\n        };\n        if (\"indexed\" in node) {\n            return Object.assign(Object.assign({}, parameter), { indexed: node.indexed });\n        }\n        else {\n            return parameter;\n        }\n    }\n    let abiTypeString = toAbiType(node, referenceDeclarations);\n    //otherwise... is it a struct? if so we need to populate components\n    if (typeClass(node) === \"struct\") {\n        let id = typeId(node);\n        let referenceDeclaration = referenceDeclarations[id];\n        if (referenceDeclaration === undefined) {\n            let typeToDisplay = typeString(node);\n            throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n        }\n        components = parametersToAbi(referenceDeclaration.members, referenceDeclarations);\n    }\n    const parameter = {\n        name,\n        type: abiTypeString,\n        components,\n        internalType\n    };\n    if (\"indexed\" in node) {\n        return Object.assign(Object.assign({}, parameter), { indexed: node.indexed });\n    }\n    else {\n        return parameter;\n    }\n}\n//note: this is only meant for non-array types that can go in the ABI\n//it returns how that type is notated in the ABI -- just the string,\n//to be clear, not components of tuples\n//again, NOT FOR ARRAYS\nfunction toAbiType(node, referenceDeclarations) {\n    let basicType = typeClassLongForm(node); //get that whole first segment!\n    switch (basicType) {\n        case \"contract\":\n            return \"address\";\n        case \"struct\":\n            return \"tuple\"; //the more detailed checking will be handled elsewhere\n        case \"enum\":\n            let referenceId = typeId(node);\n            let referenceDeclaration = referenceDeclarations[referenceId];\n            if (referenceDeclaration === undefined) {\n                let typeToDisplay = typeString(node);\n                throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);\n            }\n            let numOptions = referenceDeclaration.members.length;\n            let bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n            return `uint${bits}`;\n        default:\n            return basicType;\n        //note that: int/uint/fixed/ufixed/bytes will have their size and such left on;\n        //address will have \"payable\" left off;\n        //external functions will be reduced to \"function\" (and internal functions shouldn't\n        //be passed in!)\n        //(mappings shouldn't be passed in either obviously)\n        //(nor arrays :P )\n    }\n}\nfunction getterDefinitionToAbi(node, referenceDeclarations) {\n    debug(\"getter node: %O\", node);\n    let name = node.name;\n    let { inputs, outputs } = getterParameters(node, referenceDeclarations);\n    let inputsAbi = parametersToAbi(inputs, referenceDeclarations);\n    let outputsAbi = parametersToAbi(outputs, referenceDeclarations);\n    return {\n        type: \"function\",\n        name,\n        inputs: inputsAbi,\n        outputs: outputsAbi,\n        stateMutability: \"view\"\n    };\n}\n//how getter parameters work:\n//INPUT:\n//types other than arrays and mappings take no input.\n//array getters take uint256 input. mapping getters take input of their key type.\n//if arrays, mappings, stacked, then takes multiple inputs, in order from outside\n//to in.\n//These parameters are unnamed.\n//OUTPUT:\n//if base type (beneath mappings & arrays) is not a struct, returns that.\n//(This return parameter has no name -- it is *not* named for the variable!)\n//if it is a struct, returns multiple outputs, one for each member of the struct,\n//*except* arrays and mappings.  (And they have names, the names of the members.)\n//important note: inner structs within a struct are just returned, not\n//partially destructured like the outermost struct!  Yes, this is confusing.\nfunction getterParameters(node, referenceDeclarations) {\n    let baseNode = node.typeName || node;\n    let inputs = [];\n    while (typeClass(baseNode) === \"array\" || typeClass(baseNode) === \"mapping\") {\n        let keyNode = keyDefinition(baseNode); //note: if baseNode is an array, this spoofs up a uint256 definition\n        inputs.push(Object.assign(Object.assign({}, keyNode), { name: \"\" })); //again, getter input params have no name\n        switch (typeClass(baseNode)) {\n            case \"array\":\n                baseNode = baseNode.baseType;\n                break;\n            case \"mapping\":\n                baseNode = baseNode.valueType;\n                break;\n        }\n    }\n    //at this point, baseNode should hold the base type\n    //now we face the question: is it a struct?\n    if (typeClass(baseNode) === \"struct\") {\n        let id = typeId(baseNode);\n        let referenceDeclaration = referenceDeclarations[id];\n        if (referenceDeclaration === undefined) {\n            let typeToDisplay = typeString(baseNode);\n            throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n        }\n        let outputs = referenceDeclaration.members.filter(member => typeClass(member) !== \"array\" && typeClass(member) !== \"mapping\");\n        return { inputs, outputs }; //no need to wash name!\n    }\n    else {\n        //only one output; it's just the base node, with its name washed\n        return { inputs, outputs: [Object.assign(Object.assign({}, baseNode), { name: \"\" })] };\n    }\n}\nexports.getterParameters = getterParameters;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}