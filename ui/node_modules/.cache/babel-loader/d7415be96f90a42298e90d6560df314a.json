{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar stream = require('stream');\n\nvar url = require('url');\n\nvar bignumber = require('bignumber.js').BigNumber;\n\nvar NoFilter = require('nofilter');\n\nvar Tagged = require('./tagged');\n\nvar Simple = require('./simple');\n\nvar utils = require('./utils');\n\nvar constants = require('./constants');\n\nvar MT = constants.MT;\nvar NUMBYTES = constants.NUMBYTES;\nvar SHIFT32 = constants.SHIFT32;\nvar SYMS = constants.SYMS;\nvar TAG = constants.TAG;\nvar HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;\nvar FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;\nvar DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;\nvar TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;\nvar FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;\nvar UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;\nvar NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;\nvar BREAK = Buffer.from([0xff]);\nvar BI = utils.bigIntize(constants.BI);\nvar BN = constants.BN;\nvar BUF_NAN = Buffer.from('f97e00', 'hex');\nvar BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nvar BUF_INF_POS = Buffer.from('f97c00', 'hex');\nvar BUF_NEG_ZERO = Buffer.from('f98000', 'hex');\nvar LOOP_DETECT = Symbol('CBOR_LOOP_DETECT');\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends {stream.Transform}\n */\n\nvar Encoder = /*#__PURE__*/function (_stream$Transform) {\n  _inherits(Encoder, _stream$Transform);\n\n  var _super = _createSuper(Encoder);\n\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {Object} [options={}] - options for the encoder\n   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,\n   *   `function(Encoder)` for semantic types to be encoded.  Not needed\n   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.\n   * @param {boolean} [options.canonical=false] - should the output be\n   *   canonicalized\n   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops\n   *   be detected?  This will currently modify the encoded object graph\n   *   by adding a Symbol property to each object.  If this bothers you,\n   *   call `removeLoopDetectors` on the encoded object when done.  Do not\n   *   encode the same object twice on the same encoder, without calling\n   *   `removeLoopDetectors` in between.\n   * @param {(\"number\"|\"float\"|\"int\"|\"string\")} [options.dateType=\"number\"] -\n   *   how should dates be encoded?  \"number\" means float or int, if no\n   *   fractional seconds.\n   * @param {any} [options.encodeUndefined=undefined] - How should an \n   *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n   *   undefined.  If this is a buffer, use those bytes without re-encoding\n   *   them.  If this is a function, the function will be called (which is\n   *   a good time to throw an exception, if that's what you want), and the\n   *   return value will be used according to these rules.  Anything\n   *   else will be encoded as CBOR.\n   * @param {boolean} [options.disallowUndefinedKeys=false] - Should \"undefined\"\n   *   be disallowed as a key in a Map that is serialized?  If this is true,\n   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that\n   *   it is impossible to get a key of undefined in a normal JS object.\n   * @param {boolean} [options.collapseBigIntegers=false] - Should integers\n   *   that come in as BigNumber integers and ECMAscript bigint's be encoded\n   *   as normal CBOR integers if they fit, discarding type information?\n   */\n  function Encoder(options) {\n    var _this;\n\n    _classCallCheck(this, Encoder);\n\n    var opts = Object.assign({}, options, {\n      readableObjectMode: false,\n      writableObjectMode: true\n    });\n    _this = _super.call(this, opts);\n    _this.canonical = opts.canonical;\n    _this.encodeUndefined = opts.encodeUndefined;\n    _this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys;\n    _this.dateType = opts.dateType != null ? opts.dateType.toLowerCase() : 'number';\n    _this.collapseBigIntegers = !!opts.collapseBigIntegers; // new Symbol for each instance.  Note: means we can't re-use the same\n    // encoder and encoded object\n\n    if (typeof opts.detectLoops === 'symbol') {\n      _this.detectLoops = opts.detectLoops;\n    } else {\n      _this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null;\n    }\n\n    _this.semanticTypes = {\n      Array: _this._pushArray,\n      Date: _this._pushDate,\n      Buffer: _this._pushBuffer,\n      Map: _this._pushMap,\n      NoFilter: _this._pushNoFilter,\n      RegExp: _this._pushRegexp,\n      Set: _this._pushSet,\n      BigNumber: _this._pushBigNumber,\n      ArrayBuffer: _this._pushUint8Array,\n      Uint8ClampedArray: _this._pushUint8Array,\n      Uint8Array: _this._pushUint8Array,\n      Uint16Array: _this._pushArray,\n      Uint32Array: _this._pushArray,\n      Int8Array: _this._pushArray,\n      Int16Array: _this._pushArray,\n      Int32Array: _this._pushArray,\n      Float32Array: _this._pushFloat32Array,\n      Float64Array: _this._pushFloat64Array\n    }; // tsc doesn't know about old Url\n\n    if (url['Url']) {\n      _this.addSemanticType('Url', _this._pushUrl);\n    }\n\n    if (url['URL']) {\n      _this.addSemanticType('URL', _this._pushURL);\n    }\n\n    var addTypes = opts.genTypes || [];\n\n    for (var i = 0, len = addTypes.length; i < len; i += 2) {\n      _this.addSemanticType(addTypes[i], addTypes[i + 1]);\n    }\n\n    return _this;\n  }\n\n  _createClass(Encoder, [{\n    key: \"_transform\",\n    value: function _transform(fresh, encoding, cb) {\n      var ret = this.pushAny(fresh); // Old transformers might not return bool.  undefined !== false\n\n      return cb(ret === false ? new Error('Push Error') : undefined);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(cb) {\n      return cb();\n    }\n    /**\n     * @callback encodeFunction\n     * @param {Encoder} encoder - the encoder to serialize into.  Call \"write\"\n     *   on the encoder as needed.\n     * @return {bool} - true on success, else false\n     */\n\n    /**\n     * Add an encoding function to the list of supported semantic types.  This is\n     * useful for objects for which you can't add an encodeCBOR method\n     *\n     * @param {any} type\n     * @param {any} fun\n     * @returns {encodeFunction}\n     */\n\n  }, {\n    key: \"addSemanticType\",\n    value: function addSemanticType(type, fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function');\n      }\n\n      var typeName = typeof type === 'string' ? type : type.name;\n      var old = this.semanticTypes[typeName];\n      this.semanticTypes[typeName] = fun;\n      return old;\n    }\n  }, {\n    key: \"_pushUInt8\",\n    value: function _pushUInt8(val) {\n      var b = Buffer.allocUnsafe(1);\n      b.writeUInt8(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushUInt16BE\",\n    value: function _pushUInt16BE(val) {\n      var b = Buffer.allocUnsafe(2);\n      b.writeUInt16BE(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushUInt32BE\",\n    value: function _pushUInt32BE(val) {\n      var b = Buffer.allocUnsafe(4);\n      b.writeUInt32BE(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushFloatBE\",\n    value: function _pushFloatBE(val) {\n      var b = Buffer.allocUnsafe(4);\n      b.writeFloatBE(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushDoubleBE\",\n    value: function _pushDoubleBE(val) {\n      var b = Buffer.allocUnsafe(8);\n      b.writeDoubleBE(val, 0);\n      return this.push(b);\n    }\n  }, {\n    key: \"_pushNaN\",\n    value: function _pushNaN() {\n      return this.push(BUF_NAN);\n    }\n  }, {\n    key: \"_pushInfinity\",\n    value: function _pushInfinity(obj) {\n      var half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;\n      return this.push(half);\n    }\n  }, {\n    key: \"_pushFloat\",\n    value: function _pushFloat(obj) {\n      if (this.canonical) {\n        // TODO: is this enough slower to hide behind canonical?\n        // It's certainly enough of a hack (see utils.parseHalf)\n        // From section 3.9:\n        // If a protocol allows for IEEE floats, then additional canonicalization\n        // rules might need to be added.  One example rule might be to have all\n        // floats start as a 64-bit float, then do a test conversion to a 32-bit\n        // float; if the result is the same numeric value, use the shorter value\n        // and repeat the process with a test conversion to a 16-bit float.  (This\n        // rule selects 16-bit float for positive and negative Infinity as well.)\n        // which seems pretty much backwards to me.\n        var b2 = Buffer.allocUnsafe(2);\n\n        if (utils.writeHalf(b2, obj)) {\n          // I have convinced myself that there are no cases where writeHalf\n          // will return true but `utils.parseHalf(b2) !== obj)`\n          return this._pushUInt8(HALF) && this.push(b2);\n        }\n      }\n\n      if (Math.fround(obj) === obj) {\n        return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);\n      }\n\n      return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n    }\n  }, {\n    key: \"_pushInt\",\n    value: function _pushInt(obj, mt, orig) {\n      var m = mt << 5;\n\n      switch (false) {\n        case !(obj < 24):\n          return this._pushUInt8(m | obj);\n\n        case !(obj <= 0xff):\n          return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n\n        case !(obj <= 0xffff):\n          return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n\n        case !(obj <= 0xffffffff):\n          return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n\n        case !(obj <= Number.MAX_SAFE_INTEGER):\n          return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);\n\n        default:\n          if (mt === MT.NEG_INT) {\n            return this._pushFloat(orig);\n          } else {\n            return this._pushFloat(obj);\n          }\n\n      }\n    }\n  }, {\n    key: \"_pushIntNum\",\n    value: function _pushIntNum(obj) {\n      if (Object.is(obj, -0)) {\n        return this.push(BUF_NEG_ZERO);\n      }\n\n      if (obj < 0) {\n        return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n      } else {\n        return this._pushInt(obj, MT.POS_INT);\n      }\n    }\n  }, {\n    key: \"_pushNumber\",\n    value: function _pushNumber(obj) {\n      switch (false) {\n        case !isNaN(obj):\n          return this._pushNaN();\n\n        case isFinite(obj):\n          return this._pushInfinity(obj);\n\n        case Math.round(obj) !== obj:\n          return this._pushIntNum(obj);\n\n        default:\n          return this._pushFloat(obj);\n      }\n    }\n  }, {\n    key: \"_pushString\",\n    value: function _pushString(obj) {\n      var len = Buffer.byteLength(obj, 'utf8');\n      return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');\n    }\n  }, {\n    key: \"_pushBoolean\",\n    value: function _pushBoolean(obj) {\n      return this._pushUInt8(obj ? TRUE : FALSE);\n    }\n  }, {\n    key: \"_pushUndefined\",\n    value: function _pushUndefined(obj) {\n      switch (typeof this.encodeUndefined) {\n        case 'undefined':\n          return this._pushUInt8(UNDEFINED);\n\n        case 'function':\n          return this.pushAny(this.encodeUndefined.call(this, obj));\n\n        case 'object':\n          if (Buffer.isBuffer(this.encodeUndefined)) {\n            return this.push(this.encodeUndefined);\n          }\n\n      }\n\n      return this.pushAny(this.encodeUndefined);\n    }\n  }, {\n    key: \"_pushNull\",\n    value: function _pushNull(obj) {\n      return this._pushUInt8(NULL);\n    }\n  }, {\n    key: \"_pushArray\",\n    value: function _pushArray(gen, obj, opts) {\n      opts = Object.assign({\n        indefinite: false\n      }, opts);\n      var len = obj.length;\n\n      if (opts.indefinite) {\n        if (!gen._pushUInt8(MT.ARRAY << 5 | NUMBYTES.INDEFINITE)) {\n          return false;\n        }\n      } else if (!gen._pushInt(len, MT.ARRAY)) {\n        return false;\n      }\n\n      for (var j = 0; j < len; j++) {\n        if (!gen.pushAny(obj[j])) {\n          return false;\n        }\n      }\n\n      if (opts.indefinite) {\n        if (!gen.push(BREAK)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_pushTag\",\n    value: function _pushTag(tag) {\n      return this._pushInt(tag, MT.TAG);\n    }\n  }, {\n    key: \"_pushDate\",\n    value: function _pushDate(gen, obj) {\n      switch (gen.dateType) {\n        case 'string':\n          return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());\n\n        case 'int':\n        case 'integer':\n          return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj / 1000));\n\n        case 'float':\n          // force float\n          return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj / 1000);\n\n        case 'number':\n        default:\n          // if we happen to have an integral number of seconds,\n          // use integer.  Otherwise, use float.\n          return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj / 1000);\n      }\n    }\n  }, {\n    key: \"_pushBuffer\",\n    value: function _pushBuffer(gen, obj) {\n      return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n    }\n  }, {\n    key: \"_pushNoFilter\",\n    value: function _pushNoFilter(gen, obj) {\n      return gen._pushBuffer(gen, obj.slice());\n    }\n  }, {\n    key: \"_pushRegexp\",\n    value: function _pushRegexp(gen, obj) {\n      return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n    }\n  }, {\n    key: \"_pushSet\",\n    value: function _pushSet(gen, obj) {\n      if (!gen._pushInt(obj.size, MT.ARRAY)) {\n        return false;\n      }\n\n      var _iterator = _createForOfIteratorHelper(obj),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var x = _step.value;\n\n          if (!gen.pushAny(x)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_pushUrl\",\n    value: function _pushUrl(gen, obj) {\n      return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());\n    }\n  }, {\n    key: \"_pushURL\",\n    value: function _pushURL(gen, obj) {\n      return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());\n    }\n    /**\n     * @param {bignumber} obj\n     * @private\n     */\n\n  }, {\n    key: \"_pushBigint\",\n    value: function _pushBigint(obj) {\n      var m = MT.POS_INT;\n      var tag = TAG.POS_BIGINT;\n\n      if (obj.isNegative()) {\n        obj = obj.negated().minus(1);\n        m = MT.NEG_INT;\n        tag = TAG.NEG_BIGINT;\n      }\n\n      if (this.collapseBigIntegers && obj.lte(BN.MAXINT64)) {\n        //  special handiling for 64bits\n        if (obj.lte(BN.MAXINT32)) {\n          return this._pushInt(obj.toNumber(), m);\n        }\n\n        return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(obj.dividedToIntegerBy(BN.SHIFT32).toNumber()) && this._pushUInt32BE(obj.mod(BN.SHIFT32).toNumber());\n      }\n\n      var str = obj.toString(16);\n\n      if (str.length % 2) {\n        str = '0' + str;\n      }\n\n      var buf = Buffer.from(str, 'hex');\n      return this._pushTag(tag) && this._pushBuffer(this, buf);\n    }\n    /**\n     * @param {bigint} obj\n     * @private\n     */\n\n  }, {\n    key: \"_pushJSBigint\",\n    value: function _pushJSBigint(obj) {\n      var m = MT.POS_INT;\n      var tag = TAG.POS_BIGINT; // BigInt doesn't have -0\n\n      if (obj < 0) {\n        obj = -obj + BI.MINUS_ONE;\n        m = MT.NEG_INT;\n        tag = TAG.NEG_BIGINT;\n      }\n\n      if (this.collapseBigIntegers && obj <= BI.MAXINT64) {\n        //  special handiling for 64bits\n        if (obj <= 0xffffffff) {\n          return this._pushInt(Number(obj), m);\n        }\n\n        return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));\n      }\n\n      var str = obj.toString(16);\n\n      if (str.length % 2) {\n        str = '0' + str;\n      }\n\n      var buf = Buffer.from(str, 'hex');\n      return this._pushTag(tag) && this._pushBuffer(this, buf);\n    }\n  }, {\n    key: \"_pushBigNumber\",\n    value: function _pushBigNumber(gen, obj) {\n      if (obj.isNaN()) {\n        return gen._pushNaN();\n      }\n\n      if (!obj.isFinite()) {\n        return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);\n      }\n\n      if (obj.isInteger()) {\n        return gen._pushBigint(obj);\n      }\n\n      if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {\n        return false;\n      }\n\n      var dec = obj.decimalPlaces();\n      var slide = obj.shiftedBy(dec);\n\n      if (!gen._pushIntNum(-dec)) {\n        return false;\n      }\n\n      if (slide.abs().isLessThan(BN.MAXINT)) {\n        return gen._pushIntNum(slide.toNumber());\n      } else {\n        return gen._pushBigint(slide);\n      }\n    }\n  }, {\n    key: \"_pushMap\",\n    value: function _pushMap(gen, obj, opts) {\n      opts = Object.assign({\n        indefinite: false\n      }, opts);\n\n      if (opts.indefinite) {\n        if (!gen._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n          return false;\n        }\n      } else if (!gen._pushInt(obj.size, MT.MAP)) {\n        return false;\n      } // memoizing the cbor only helps in certain cases, and hurts in most\n      // others.  Just avoid it.\n\n\n      if (gen.canonical) {\n        // keep the key/value pairs together, so we don't have to do odd\n        // gets with object keys later\n        var entries = _toConsumableArray(obj.entries());\n\n        var enc = new Encoder(this); // TODO: fix genTypes\n\n        var bs = new NoFilter({\n          highWaterMark: this.readableHighWaterMark\n        });\n        enc.pipe(bs);\n        entries.sort(function (_ref, _ref2) {\n          var _ref3 = _slicedToArray(_ref, 1),\n              a = _ref3[0];\n\n          var _ref4 = _slicedToArray(_ref2, 1),\n              b = _ref4[0];\n\n          // a, b are the keys\n          enc.pushAny(a);\n          var a_cbor = bs.read();\n          enc.pushAny(b);\n          var b_cbor = bs.read();\n          return a_cbor.compare(b_cbor);\n        });\n\n        var _iterator2 = _createForOfIteratorHelper(entries),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n                k = _step2$value[0],\n                v = _step2$value[1];\n\n            if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n              throw new Error('Invalid Map key: undefined');\n            }\n\n            if (!(gen.pushAny(k) && gen.pushAny(v))) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        var _iterator3 = _createForOfIteratorHelper(obj),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _slicedToArray(_step3.value, 2),\n                _k = _step3$value[0],\n                _v = _step3$value[1];\n\n            if (gen.disallowUndefinedKeys && typeof _k === 'undefined') {\n              throw new Error('Invalid Map key: undefined');\n            }\n\n            if (!(gen.pushAny(_k) && gen.pushAny(_v))) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      if (opts.indefinite) {\n        if (!gen.push(BREAK)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_pushUint8Array\",\n    value: function _pushUint8Array(gen, obj) {\n      return gen._pushBuffer(gen, Buffer.from(obj));\n    }\n  }, {\n    key: \"_pushFloat32Array\",\n    value: function _pushFloat32Array(gen, obj) {\n      var len = obj.length;\n\n      if (!gen._pushInt(len, MT.ARRAY)) {\n        return false;\n      }\n\n      for (var j = 0; j < len; j++) {\n        if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_pushFloat64Array\",\n    value: function _pushFloat64Array(gen, obj) {\n      var len = obj.length;\n\n      if (!gen._pushInt(len, MT.ARRAY)) {\n        return false;\n      }\n\n      for (var j = 0; j < len; j++) {\n        if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Remove all of the loop detector additions to the given object.\n     *\n     * @param {Object} obj - object to clean\n     * @returns {bool} - true when the object was cleaned, else false\n     */\n\n  }, {\n    key: \"removeLoopDetectors\",\n    value: function removeLoopDetectors(obj) {\n      if (!this.detectLoops) {\n        return false;\n      }\n\n      return Encoder.removeLoopDetectors(obj, this.detectLoops);\n    }\n    /**\n     * Remove all of the loop detector additions to the given object.\n     * The static version is easier to call when you don't have a full\n     * encoder instance available; it uses a good heuristic to figure\n     * out the loop detector symbol.\n     *\n     * @param {Object} obj - object to clean\n     * @param {Symbol} [detector=null] - the symbol to clean, or null\n     *   to use the first detected symbol\n     * @returns {bool} - true when the object was cleaned, else false\n     */\n\n  }, {\n    key: \"_pushObject\",\n    value: function _pushObject(obj, opts) {\n      if (!obj) {\n        return this._pushNull(obj);\n      }\n\n      opts = Object.assign({\n        indefinite: false,\n        skipTypes: false\n      }, opts);\n\n      if (!opts.indefinite) {\n        // this will only happen the first time through for indefinite encoding\n        if (this.detectLoops) {\n          if (obj[LOOP_DETECT] === this.detectLoops) {\n            throw new Error('Loop detected while CBOR encoding');\n          } else {\n            obj[LOOP_DETECT] = this.detectLoops;\n          }\n        }\n      }\n\n      if (!opts.skipTypes) {\n        var f = obj.encodeCBOR;\n\n        if (typeof f === 'function') {\n          return f.call(obj, this);\n        }\n\n        var converter = this.semanticTypes[obj.constructor.name];\n\n        if (converter) {\n          return converter.call(obj, this, obj);\n        }\n      }\n\n      var keys = Object.keys(obj).filter(function (k) {\n        return typeof obj[k] !== 'function';\n      });\n      var cbor_keys = {};\n\n      if (this.canonical) {\n        // note: this can't be a normal sort, because 'b' needs to sort before\n        // 'aa'\n        keys.sort(function (a, b) {\n          // Always strings, so don't bother to pass options.\n          // hold on to the cbor versions, since there's no need\n          // to encode more than once\n          var a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));\n          var b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));\n          return a_cbor.compare(b_cbor);\n        });\n      }\n\n      if (opts.indefinite) {\n        if (!this._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n          return false;\n        }\n      } else if (!this._pushInt(keys.length, MT.MAP)) {\n        return false;\n      }\n\n      var ck;\n\n      for (var j = 0, len2 = keys.length; j < len2; j++) {\n        var k = keys[j];\n\n        if (this.canonical && (ck = cbor_keys[k])) {\n          if (!this.push(ck)) {\n            // already a Buffer\n            return false;\n          }\n        } else {\n          if (!this._pushString(k)) {\n            return false;\n          }\n        }\n\n        if (!this.pushAny(obj[k])) {\n          return false;\n        }\n      }\n\n      if (opts.indefinite) {\n        if (!this.push(BREAK)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Push any supported type onto the encoded stream\n     *\n     * @param {any} obj\n     * @returns {boolean} true on success\n     */\n\n  }, {\n    key: \"pushAny\",\n    value: function pushAny(obj) {\n      switch (typeof obj) {\n        case 'number':\n          return this._pushNumber(obj);\n\n        case 'bigint':\n          return this._pushJSBigint(obj);\n\n        case 'string':\n          return this._pushString(obj);\n\n        case 'boolean':\n          return this._pushBoolean(obj);\n\n        case 'undefined':\n          return this._pushUndefined(obj);\n\n        case 'object':\n          return this._pushObject(obj);\n\n        case 'symbol':\n          switch (obj) {\n            case SYMS.NULL:\n              return this._pushNull(null);\n\n            case SYMS.UNDEFINED:\n              return this._pushUndefined(void 0);\n            // TODO: Add pluggable support for other symbols\n\n            default:\n              throw new Error('Unknown symbol: ' + obj.toString());\n          }\n\n        default:\n          throw new Error('Unknown type: ' + typeof obj + ', ' + (!!obj.toString ? obj.toString() : ''));\n      }\n    }\n    /* backwards-compat wrapper */\n\n  }, {\n    key: \"_pushAny\",\n    value: function _pushAny(obj) {\n      // TODO: write deprecation warning\n      return this.pushAny(obj);\n    }\n  }, {\n    key: \"_encodeAll\",\n    value: function _encodeAll(objs) {\n      var bs = new NoFilter({\n        highWaterMark: this.readableHighWaterMark\n      });\n      this.pipe(bs);\n\n      var _iterator4 = _createForOfIteratorHelper(objs),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var o = _step4.value;\n          this.pushAny(o);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.end();\n      return bs.read();\n    }\n    /**\n     * Encode the given object with indefinite length.  There are apparently\n     * some (IMO) broken implementations of poorly-specified protocols that\n     * REQUIRE indefinite-encoding.  Add this to an object or class as the\n     * `encodeCBOR` function to get indefinite encoding:\n     * @example\n     * const o = {\n     *   a: true,\n     *   encodeCBOR: cbor.Encoder.encodeIndefinite\n     * }\n     * const m = []\n     * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n     * cbor.encodeOne([o, m])\n     *\n     * @param {Encoder} - the encoder to use\n     * @param {String|Buffer|Array|Map|Object} [obj] - the object to encode.  If\n     *   null, use \"this\" instead.\n     * @param {Object} [opts=null] - Options for encoding\n     * @param {boolean} [opts.chunkSize=4096] - Number of characters or bytes\n     *  for each chunk, if obj is a string or Buffer\n     * @returns {boolean} - true on success\n     */\n\n  }], [{\n    key: \"removeLoopDetectors\",\n    value: function removeLoopDetectors(obj) {\n      var detector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (typeof obj !== 'object' || !obj) {\n        return false;\n      }\n\n      var dl = obj[LOOP_DETECT];\n\n      if (!dl) {\n        // ironically, use loop marking to detect loops on removal as well\n        return false;\n      }\n\n      if (detector == null) {\n        detector = dl;\n      } else {\n        if (detector !== dl) {\n          return false;\n        }\n      }\n\n      delete obj[LOOP_DETECT];\n\n      if (Array.isArray(obj)) {\n        var _iterator5 = _createForOfIteratorHelper(obj),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var i = _step5.value;\n            this.removeLoopDetectors(i, detector);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else {\n        for (var k in obj) {\n          this.removeLoopDetectors(obj[k], detector);\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"encodeIndefinite\",\n    value: function encodeIndefinite(gen, obj, opts) {\n      if (obj == null) {\n        if (this == null) {\n          throw new Error('No object to encode');\n        }\n\n        obj = this;\n      }\n\n      opts = Object.assign({\n        chunkSize: 4096\n      }, opts);\n      var ret = true;\n      var objType = typeof obj;\n\n      if (objType === 'string') {\n        // TODO: make sure not to split surrogate pairs at the edges of chunks,\n        // since such half-surrogates cannot be legally encoded as UTF-8.\n        ret = ret && gen._pushUInt8(MT.UTF8_STRING << 5 | NUMBYTES.INDEFINITE);\n        var offset = 0;\n\n        while (offset < obj.length) {\n          var endIndex = offset + opts.chunkSize;\n          ret = ret && gen._pushString(obj.slice(offset, endIndex));\n          offset = endIndex;\n        }\n\n        ret = ret && gen.push(BREAK);\n      } else if (Buffer.isBuffer(obj)) {\n        ret = ret && gen._pushUInt8(MT.BYTE_STRING << 5 | NUMBYTES.INDEFINITE);\n        var _offset = 0;\n\n        while (_offset < obj.length) {\n          var _endIndex = _offset + opts.chunkSize;\n\n          ret = ret && gen._pushBuffer(gen, obj.slice(_offset, _endIndex));\n          _offset = _endIndex;\n        }\n\n        ret = ret && gen.push(BREAK);\n      } else if (Array.isArray(obj)) {\n        ret = ret && gen._pushArray(gen, obj, {\n          indefinite: true\n        });\n      } else if (obj instanceof Map) {\n        ret = ret && gen._pushMap(gen, obj, {\n          indefinite: true\n        });\n      } else {\n        if (objType !== 'object') {\n          throw new Error('Invalid indefinite encoding');\n        }\n\n        ret = ret && gen._pushObject(obj, {\n          indefinite: true,\n          skipTypes: true\n        });\n      }\n\n      return ret;\n    }\n    /**\n     * Encode one or more JavaScript objects, and return a Buffer containing the\n     * CBOR bytes.\n     *\n     * @param {...any} objs - the objects to encode\n     * @returns {Buffer} - the encoded objects\n     */\n\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n        objs[_key] = arguments[_key];\n      }\n\n      return new Encoder()._encodeAll(objs);\n    }\n    /**\n     * Encode one or more JavaScript objects canonically (slower!), and return\n     * a Buffer containing the CBOR bytes.\n     *\n     * @param {...any} objs - the objects to encode\n     * @returns {Buffer} - the encoded objects\n     */\n\n  }, {\n    key: \"encodeCanonical\",\n    value: function encodeCanonical() {\n      for (var _len2 = arguments.length, objs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        objs[_key2] = arguments[_key2];\n      }\n\n      return new Encoder({\n        canonical: true\n      })._encodeAll(objs);\n    }\n    /**\n     * Encode one JavaScript object using the given options.\n     *\n     * @static\n     * @param {any} obj - the object to encode\n     * @param {Object?} options - passed to the Encoder constructor\n     * @returns {Buffer} - the encoded objects\n     */\n\n  }, {\n    key: \"encodeOne\",\n    value: function encodeOne(obj, options) {\n      return new Encoder(options)._encodeAll([obj]);\n    }\n    /**\n     * Encode one JavaScript object using the given options in a way that\n     * is more resilient to objects being larger than the highWaterMark\n     * number of bytes.  As with the other static encode functions, this \n     * will still use a large amount of memory.  Use a stream-based approach\n     * directly if you need to process large and complicated inputs.\n     *\n     * @param {any} obj - the object to encode\n     * @param {Object?} options - passed to the Encoder constructor\n     */\n\n  }, {\n    key: \"encodeAsync\",\n    value: function encodeAsync(obj, options) {\n      return new Promise(function (resolve, reject) {\n        var bufs = [];\n        var enc = new Encoder(options);\n        enc.on('data', function (buf) {\n          return bufs.push(buf);\n        });\n        enc.on('error', reject);\n        enc.on('finish', function () {\n          return resolve(Buffer.concat(bufs));\n        });\n        enc.pushAny(obj);\n        enc.end();\n      });\n    }\n  }]);\n\n  return Encoder;\n}(stream.Transform);\n\nmodule.exports = Encoder;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/cbor/lib/encoder.js"],"names":["stream","require","url","bignumber","BigNumber","NoFilter","Tagged","Simple","utils","constants","MT","NUMBYTES","SHIFT32","SYMS","TAG","HALF","SIMPLE_FLOAT","TWO","FLOAT","FOUR","DOUBLE","EIGHT","TRUE","SIMPLE","FALSE","UNDEFINED","NULL","BREAK","Buffer","from","BI","bigIntize","BN","BUF_NAN","BUF_INF_NEG","BUF_INF_POS","BUF_NEG_ZERO","LOOP_DETECT","Symbol","Encoder","options","opts","Object","assign","readableObjectMode","writableObjectMode","canonical","encodeUndefined","disallowUndefinedKeys","dateType","toLowerCase","collapseBigIntegers","detectLoops","semanticTypes","Array","_pushArray","Date","_pushDate","_pushBuffer","Map","_pushMap","_pushNoFilter","RegExp","_pushRegexp","Set","_pushSet","_pushBigNumber","ArrayBuffer","_pushUint8Array","Uint8ClampedArray","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","_pushFloat32Array","Float64Array","_pushFloat64Array","addSemanticType","_pushUrl","_pushURL","addTypes","genTypes","i","len","length","fresh","encoding","cb","ret","pushAny","Error","undefined","type","fun","TypeError","typeName","name","old","val","b","allocUnsafe","writeUInt8","push","writeUInt16BE","writeUInt32BE","writeFloatBE","writeDoubleBE","obj","half","b2","writeHalf","_pushUInt8","Math","fround","_pushFloatBE","_pushDoubleBE","mt","orig","m","ONE","_pushUInt16BE","_pushUInt32BE","Number","MAX_SAFE_INTEGER","floor","NEG_INT","_pushFloat","is","_pushInt","POS_INT","isNaN","_pushNaN","isFinite","_pushInfinity","round","_pushIntNum","byteLength","UTF8_STRING","call","isBuffer","gen","indefinite","ARRAY","INDEFINITE","j","tag","_pushTag","DATE_STRING","_pushString","toISOString","DATE_EPOCH","BYTE_STRING","slice","REGEXP","source","size","x","URI","format","toString","POS_BIGINT","isNegative","negated","minus","NEG_BIGINT","lte","MAXINT64","MAXINT32","toNumber","dividedToIntegerBy","mod","str","buf","MINUS_ONE","Infinity","isInteger","_pushBigint","DECIMAL_FRAC","dec","decimalPlaces","slide","shiftedBy","abs","isLessThan","MAXINT","MAP","entries","enc","bs","highWaterMark","readableHighWaterMark","pipe","sort","a","a_cbor","read","b_cbor","compare","k","v","removeLoopDetectors","_pushNull","skipTypes","f","encodeCBOR","converter","constructor","keys","filter","cbor_keys","encode","ck","len2","_pushNumber","_pushJSBigint","_pushBoolean","_pushUndefined","_pushObject","objs","o","end","detector","dl","isArray","chunkSize","objType","offset","endIndex","_encodeAll","Promise","resolve","reject","bufs","on","concat","Transform","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst url = require('url')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\n\nconst constants = require('./constants')\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SHIFT32 = constants.SHIFT32\nconst SYMS = constants.SYMS\nconst TAG = constants.TAG\nconst HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO\nconst FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR\nconst DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT\nconst TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE\nconst FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE\nconst UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED\nconst NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL\nconst BREAK = Buffer.from([0xff])\n\nconst BI = utils.bigIntize(constants.BI)\nconst BN = constants.BN\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex')\nconst LOOP_DETECT = Symbol('CBOR_LOOP_DETECT')\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends {stream.Transform}\n */\nclass Encoder extends stream.Transform {\n\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {Object} [options={}] - options for the encoder\n   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,\n   *   `function(Encoder)` for semantic types to be encoded.  Not needed\n   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.\n   * @param {boolean} [options.canonical=false] - should the output be\n   *   canonicalized\n   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops\n   *   be detected?  This will currently modify the encoded object graph\n   *   by adding a Symbol property to each object.  If this bothers you,\n   *   call `removeLoopDetectors` on the encoded object when done.  Do not\n   *   encode the same object twice on the same encoder, without calling\n   *   `removeLoopDetectors` in between.\n   * @param {(\"number\"|\"float\"|\"int\"|\"string\")} [options.dateType=\"number\"] -\n   *   how should dates be encoded?  \"number\" means float or int, if no\n   *   fractional seconds.\n   * @param {any} [options.encodeUndefined=undefined] - How should an \n   *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n   *   undefined.  If this is a buffer, use those bytes without re-encoding\n   *   them.  If this is a function, the function will be called (which is\n   *   a good time to throw an exception, if that's what you want), and the\n   *   return value will be used according to these rules.  Anything\n   *   else will be encoded as CBOR.\n   * @param {boolean} [options.disallowUndefinedKeys=false] - Should \"undefined\"\n   *   be disallowed as a key in a Map that is serialized?  If this is true,\n   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that\n   *   it is impossible to get a key of undefined in a normal JS object.\n   * @param {boolean} [options.collapseBigIntegers=false] - Should integers\n   *   that come in as BigNumber integers and ECMAscript bigint's be encoded\n   *   as normal CBOR integers if they fit, discarding type information?\n   */\n  constructor(options) {\n    const opts = Object.assign({}, options, {\n      readableObjectMode: false,\n      writableObjectMode: true\n    })\n    super(opts)\n\n    this.canonical = opts.canonical\n    this.encodeUndefined = opts.encodeUndefined\n    this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys\n    this.dateType = (opts.dateType != null) ?\n      opts.dateType.toLowerCase() : 'number'\n    this.collapseBigIntegers = !!opts.collapseBigIntegers\n\n    // new Symbol for each instance.  Note: means we can't re-use the same\n    // encoder and encoded object\n    if (typeof(opts.detectLoops) === 'symbol') {\n      this.detectLoops = opts.detectLoops\n    } else {\n      this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null\n    }\n\n    this.semanticTypes = {\n      Array: this._pushArray,\n      Date: this._pushDate,\n      Buffer: this._pushBuffer,\n      Map: this._pushMap,\n      NoFilter: this._pushNoFilter,\n      RegExp: this._pushRegexp,\n      Set: this._pushSet,\n      BigNumber: this._pushBigNumber,\n      ArrayBuffer: this._pushUint8Array,\n      Uint8ClampedArray: this._pushUint8Array,\n      Uint8Array: this._pushUint8Array,\n      Uint16Array: this._pushArray,\n      Uint32Array: this._pushArray,\n      Int8Array: this._pushArray,\n      Int16Array: this._pushArray,\n      Int32Array: this._pushArray,\n      Float32Array: this._pushFloat32Array,\n      Float64Array: this._pushFloat64Array\n    }\n\n    // tsc doesn't know about old Url\n    if (url['Url']) {\n      this.addSemanticType('Url', this._pushUrl)\n    }\n    if (url['URL']) {\n      this.addSemanticType('URL', this._pushURL)\n    }\n\n    const addTypes = opts.genTypes || []\n    for (let i = 0, len = addTypes.length; i < len; i += 2) {\n      this.addSemanticType(addTypes[i], addTypes[i + 1])\n    }\n  }\n\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh)\n    // Old transformers might not return bool.  undefined !== false\n    return cb((ret === false) ? new Error('Push Error') : undefined)\n  }\n\n  _flush(cb) {\n    return cb()\n  }\n\n  /**\n   * @callback encodeFunction\n   * @param {Encoder} encoder - the encoder to serialize into.  Call \"write\"\n   *   on the encoder as needed.\n   * @return {bool} - true on success, else false\n   */\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This is\n   * useful for objects for which you can't add an encodeCBOR method\n   *\n   * @param {any} type\n   * @param {any} fun\n   * @returns {encodeFunction}\n   */\n  addSemanticType(type, fun) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('fun must be of type function')\n    }\n    const typeName = (typeof type === 'string') ? type : type.name\n    const old = this.semanticTypes[typeName]\n    this.semanticTypes[typeName] = fun\n    return old\n  }\n\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1)\n    b.writeUInt8(val, 0)\n    return this.push(b)\n  }\n\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2)\n    b.writeUInt16BE(val, 0)\n    return this.push(b)\n  }\n\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeUInt32BE(val, 0)\n    return this.push(b)\n  }\n\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeFloatBE(val, 0)\n    return this.push(b)\n  }\n\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8)\n    b.writeDoubleBE(val, 0)\n    return this.push(b)\n  }\n\n  _pushNaN() {\n    return this.push(BUF_NAN)\n  }\n\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2)\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5\n    switch (false) {\n      case !(obj < 24):\n        return this._pushUInt8(m | obj)\n      case !(obj <= 0xff):\n        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n      case !(obj <= 0xffff):\n        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n      case !(obj <= 0xffffffff):\n        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n      case !(obj <= Number.MAX_SAFE_INTEGER):\n        return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n          this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n          this._pushUInt32BE(obj % SHIFT32)\n      default:\n        if (mt === MT.NEG_INT) {\n          return this._pushFloat(orig)\n        } else {\n          return this._pushFloat(obj)\n        }\n    }\n  }\n\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO)\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    } else {\n      return this._pushInt(obj, MT.POS_INT)\n    }\n  }\n\n  _pushNumber(obj) {\n    switch (false) {\n      case !isNaN(obj):\n        return this._pushNaN()\n      case isFinite(obj):\n        return this._pushInfinity(obj)\n      case Math.round(obj) !== obj:\n        return this._pushIntNum(obj)\n      default:\n        return this._pushFloat(obj)\n    }\n  }\n\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8')\n  }\n\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED)\n      case 'function':\n        return this.pushAny(this.encodeUndefined.call(this, obj))\n      case 'object':\n        if (Buffer.isBuffer(this.encodeUndefined)) {\n          return this.push(this.encodeUndefined)\n        }\n    }\n    return this.pushAny(this.encodeUndefined)\n  }\n\n  _pushNull(obj) {\n    return this._pushUInt8(NULL)\n  }\n\n  _pushArray(gen, obj, opts) {\n    opts = Object.assign({\n      indefinite: false\n    }, opts)\n    const len = obj.length\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString())\n      case 'int':\n      case 'integer':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj / 1000))\n      case 'float':\n        // force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj / 1000)\n      case 'number':\n      default:\n        // if we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj / 1000)\n    }\n  }\n\n  _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  _pushNoFilter(gen, obj) {\n    return gen._pushBuffer(gen, obj.slice())\n  }\n\n  _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  _pushSet(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushUrl(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())\n  }\n\n  _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString())\n  }\n\n  /**\n   * @param {bignumber} obj\n   * @private\n   */\n  _pushBigint(obj) {\n    let m = MT.POS_INT\n    let tag = TAG.POS_BIGINT\n\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1)\n      m = MT.NEG_INT\n      tag = TAG.NEG_BIGINT\n    }\n\n    if (this.collapseBigIntegers &&\n        obj.lte(BN.MAXINT64)) {\n      //  special handiling for 64bits\n      if (obj.lte(BN.MAXINT32)) {\n        return this._pushInt(obj.toNumber(), m)\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(obj.dividedToIntegerBy(BN.SHIFT32).toNumber()) &&\n        this._pushUInt32BE(obj.mod(BN.SHIFT32).toNumber())\n    }\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  /**\n   * @param {bigint} obj\n   * @private\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT\n    let tag = TAG.POS_BIGINT\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE\n      m = MT.NEG_INT\n      tag = TAG.NEG_BIGINT\n    }\n\n    if (this.collapseBigIntegers &&\n        (obj <= BI.MAXINT64)) {\n      //  special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m)\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&\n        this._pushUInt32BE(Number(obj % BI.SHIFT32))\n    }\n\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  _pushBigNumber(gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN()\n    }\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)\n    }\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj)\n    }\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&\n      gen._pushInt(2, MT.ARRAY))) {\n      return false\n    }\n\n    const dec = obj.decimalPlaces()\n    const slide = obj.shiftedBy(dec)\n    if (!gen._pushIntNum(-dec)) {\n      return false\n    }\n    if (slide.abs().isLessThan(BN.MAXINT)) {\n      return gen._pushIntNum(slide.toNumber())\n    } else {\n      return gen._pushBigint(slide)\n    }\n  }\n\n  _pushMap(gen, obj, opts) {\n    opts = Object.assign({\n      indefinite: false\n    }, opts)\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false\n    }\n    // memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const entries = [...obj.entries()]\n      const enc = new Encoder(this) // TODO: fix genTypes\n      const bs = new NoFilter({highWaterMark:this.readableHighWaterMark})\n      enc.pipe(bs)\n      entries.sort(([a], [b]) => {\n        // a, b are the keys\n        enc.pushAny(a)\n        const a_cbor = bs.read()\n        enc.pushAny(b)\n        const b_cbor = bs.read()\n        return a_cbor.compare(b_cbor)\n      })\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    } else {\n      for (const [k, v] of obj) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushUint8Array(gen, obj) {\n    return gen._pushBuffer(gen, Buffer.from(obj))\n  }\n\n  _pushFloat32Array(gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushFloat64Array(gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Remove all of the loop detector additions to the given object.\n   *\n   * @param {Object} obj - object to clean\n   * @returns {bool} - true when the object was cleaned, else false\n   */\n  removeLoopDetectors(obj) {\n    if (!this.detectLoops) {\n      return false\n    }\n    return Encoder.removeLoopDetectors(obj, this.detectLoops)\n  }\n\n  /**\n   * Remove all of the loop detector additions to the given object.\n   * The static version is easier to call when you don't have a full\n   * encoder instance available; it uses a good heuristic to figure\n   * out the loop detector symbol.\n   *\n   * @param {Object} obj - object to clean\n   * @param {Symbol} [detector=null] - the symbol to clean, or null\n   *   to use the first detected symbol\n   * @returns {bool} - true when the object was cleaned, else false\n   */\n  static removeLoopDetectors(obj, detector=null) {\n    if ((typeof(obj) !== 'object') || !obj) {\n      return false\n    }\n    const dl = obj[LOOP_DETECT]\n    if (!dl) {\n      // ironically, use loop marking to detect loops on removal as well\n      return false\n    }\n    if (detector == null) {\n      detector = dl\n    } else {\n      if (detector !== dl) {\n        return false\n      }\n    }\n    delete obj[LOOP_DETECT]\n    if (Array.isArray(obj)) {\n      for (const i of obj) {\n        this.removeLoopDetectors(i, detector)\n      }\n    } else {\n      for (const k in obj) {\n        this.removeLoopDetectors(obj[k], detector)\n      }\n    }\n    return true\n  }\n\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj)\n    }\n    opts = Object.assign({\n      indefinite: false,\n      skipTypes: false\n    }, opts)\n    if (!opts.indefinite) {\n      // this will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (obj[LOOP_DETECT] === this.detectLoops) {\n          throw new Error('Loop detected while CBOR encoding')\n        } else {\n          obj[LOOP_DETECT] = this.detectLoops\n        }\n      }\n    }\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR\n      if (typeof f === 'function') {\n        return f.call(obj, this)\n      }\n      const converter = this.semanticTypes[obj.constructor.name]\n      if (converter) {\n        return converter.call(obj, this, obj)\n      }\n    }\n    const keys = Object.keys(obj).filter(k => typeof obj[k] !== 'function')\n    const cbor_keys = {}\n    if (this.canonical) {\n      // note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))\n\n        return a_cbor.compare(b_cbor)\n      })\n    }\n    if (opts.indefinite) {\n      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false\n    }\n    let ck\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j]\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // already a Buffer\n          return false\n        }\n      } else {\n        if (!this._pushString(k)) {\n          return false\n        }\n      }\n      if (!this.pushAny(obj[k])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj)\n      case 'bigint':\n        return this._pushJSBigint(obj)\n      case 'string':\n        return this._pushString(obj)\n      case 'boolean':\n        return this._pushBoolean(obj)\n      case 'undefined':\n        return this._pushUndefined(obj)\n      case 'object':\n        return this._pushObject(obj)\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(void 0)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString())\n        }\n      default:\n        throw new Error(\n          'Unknown type: ' + typeof obj + ', ' +\n          (!!obj.toString ? obj.toString() : ''))\n    }\n  }\n\n  /* backwards-compat wrapper */\n  _pushAny(obj) {\n    // TODO: write deprecation warning\n    return this.pushAny(obj)\n  }\n\n  _encodeAll(objs) {\n    const bs = new NoFilter({ highWaterMark:this.readableHighWaterMark })\n    this.pipe(bs)\n    for (const o of objs) {\n      this.pushAny(o)\n    }\n    this.end()\n    return bs.read()\n  }\n\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  Add this to an object or class as the\n   * `encodeCBOR` function to get indefinite encoding:\n   * @example\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   *\n   * @param {Encoder} - the encoder to use\n   * @param {String|Buffer|Array|Map|Object} [obj] - the object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {Object} [opts=null] - Options for encoding\n   * @param {boolean} [opts.chunkSize=4096] - Number of characters or bytes\n   *  for each chunk, if obj is a string or Buffer\n   * @returns {boolean} - true on success\n   */\n  static encodeIndefinite(gen, obj, opts) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode')\n      }\n      obj = this\n    }\n    opts = Object.assign({\n      chunkSize: 4096\n    }, opts)\n\n    let ret = true\n    const objType = typeof obj\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < obj.length) {\n        const endIndex = offset + opts.chunkSize\n        ret = ret && gen._pushString(obj.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if (Buffer.isBuffer(obj)) {\n      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < obj.length) {\n        const endIndex = offset + opts.chunkSize\n        ret = ret && gen._pushBuffer(gen, obj.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if (Array.isArray(obj)) {\n      ret = ret && gen._pushArray(gen, obj, {\n        indefinite: true\n      })\n    } else if (obj instanceof Map) {\n      ret = ret && gen._pushMap(gen, obj, {\n        indefinite: true\n      })\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding')\n      }\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true\n      })\n    }\n    return ret\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs)\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({canonical: true})._encodeAll(objs)\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @static\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   * @returns {Buffer} - the encoded objects\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this \n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = []\n      const enc = new Encoder(options)\n      enc.on('data', buf => bufs.push(buf))\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n}\n\nmodule.exports = Encoder\n"]},"metadata":{},"sourceType":"script"}