{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBasic = void 0;\n\nvar Conversion = __importStar(require(\"../../conversion\"));\n\nvar Evm = __importStar(require(\"../../evm\")); //UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n\n/**\n * Handles encoding of basic types; yes the input type is broader than\n * it should be but it's hard to fix this without causing other problems,\n * sorry!\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeBasic(input) {\n  var bytes;\n\n  switch (input.type.typeClass) {\n    case \"uint\":\n    case \"int\":\n      return Conversion.toBytes(input.value.asBN, Evm.Utils.WORD_SIZE);\n\n    case \"enum\":\n      return Conversion.toBytes(input.value.numericAsBN, Evm.Utils.WORD_SIZE);\n\n    case \"bool\":\n      {\n        bytes = new Uint8Array(Evm.Utils.WORD_SIZE); //is initialized to zeroes\n\n        if (input.value.asBoolean) {\n          bytes[Evm.Utils.WORD_SIZE - 1] = 1;\n        }\n\n        return bytes;\n      }\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        //deliberately not handling dynamic case!\n        case \"static\":\n          bytes = Conversion.toBytes(input.value.asHex);\n          var padded = new Uint8Array(Evm.Utils.WORD_SIZE); //initialized to zeroes\n\n          padded.set(bytes);\n          return padded;\n      }\n\n    case \"address\":\n      return Conversion.toBytes(input.value.asAddress, Evm.Utils.WORD_SIZE);\n\n    case \"contract\":\n      return Conversion.toBytes(input.value.address, Evm.Utils.WORD_SIZE);\n\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          //for our purposes here, we will NOT count internal functions as a\n          //basic type!  so no handling of internal case\n          case \"external\":\n            var coercedInput = input;\n            var encoded = new Uint8Array(Evm.Utils.WORD_SIZE); //starts filled w/0s\n\n            var addressBytes = Conversion.toBytes(coercedInput.value.contract.address); //should already be correct length\n\n            var selectorBytes = Conversion.toBytes(coercedInput.value.selector); //should already be correct length\n\n            encoded.set(addressBytes);\n            encoded.set(selectorBytes, Evm.Utils.ADDRESS_SIZE); //set it after the address\n\n            return encoded;\n        }\n\n        break; //to satisfy TS\n      }\n\n    case \"fixed\":\n    case \"ufixed\":\n      var bigValue = input.value.asBig;\n      var shiftedValue = Conversion.shiftBigUp(bigValue, input.type.places);\n      return Conversion.toBytes(shiftedValue, Evm.Utils.WORD_SIZE);\n  }\n}\n\nexports.encodeBasic = encodeBasic;","map":{"version":3,"sources":["../../../../lib/basic/encode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeBasic = void 0;\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Evm = __importStar(require(\"../../evm\"));\n//UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n/**\n * Handles encoding of basic types; yes the input type is broader than\n * it should be but it's hard to fix this without causing other problems,\n * sorry!\n * @Category Encoding (low-level)\n */\nfunction encodeBasic(input) {\n    let bytes;\n    switch (input.type.typeClass) {\n        case \"uint\":\n        case \"int\":\n            return Conversion.toBytes(input.value.asBN, Evm.Utils.WORD_SIZE);\n        case \"enum\":\n            return Conversion.toBytes(input.value.numericAsBN, Evm.Utils.WORD_SIZE);\n        case \"bool\": {\n            bytes = new Uint8Array(Evm.Utils.WORD_SIZE); //is initialized to zeroes\n            if (input.value.asBoolean) {\n                bytes[Evm.Utils.WORD_SIZE - 1] = 1;\n            }\n            return bytes;\n        }\n        case \"bytes\":\n            switch (input.type.kind) {\n                //deliberately not handling dynamic case!\n                case \"static\":\n                    bytes = Conversion.toBytes(input.value.asHex);\n                    let padded = new Uint8Array(Evm.Utils.WORD_SIZE); //initialized to zeroes\n                    padded.set(bytes);\n                    return padded;\n            }\n        case \"address\":\n            return Conversion.toBytes(input.value.asAddress, Evm.Utils.WORD_SIZE);\n        case \"contract\":\n            return Conversion.toBytes(input.value.address, Evm.Utils.WORD_SIZE);\n        case \"function\": {\n            switch (input.type.visibility) {\n                //for our purposes here, we will NOT count internal functions as a\n                //basic type!  so no handling of internal case\n                case \"external\":\n                    let coercedInput = input;\n                    let encoded = new Uint8Array(Evm.Utils.WORD_SIZE); //starts filled w/0s\n                    let addressBytes = Conversion.toBytes(coercedInput.value.contract.address); //should already be correct length\n                    let selectorBytes = Conversion.toBytes(coercedInput.value.selector); //should already be correct length\n                    encoded.set(addressBytes);\n                    encoded.set(selectorBytes, Evm.Utils.ADDRESS_SIZE); //set it after the address\n                    return encoded;\n            }\n            break; //to satisfy TS\n        }\n        case \"fixed\":\n        case \"ufixed\":\n            let bigValue = (input).value.asBig;\n            let shiftedValue = Conversion.shiftBigUp(bigValue, input.type.places);\n            return Conversion.toBytes(shiftedValue, Evm.Utils.WORD_SIZE);\n    }\n}\nexports.encodeBasic = encodeBasic;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}