{"ast":null,"code":"var _slicedToArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar debug = require(\"debug\")(\"solidity-utils\");\n\nvar CodeUtils = require(\"@truffle/code-utils\");\n\nvar Codec = require(\"@truffle/codec\");\n\nvar jsonpointer = require(\"json-pointer\");\n\nvar IntervalTree = require(\"node-interval-tree\").default;\n\nvar SolidityUtils = {\n  getCharacterOffsetToLineAndColumnMapping: function getCharacterOffsetToLineAndColumnMapping(source) {\n    var mapping = [];\n    source = source.split(\"\");\n    var line = 0;\n    var column = 0;\n    source.forEach(function (character) {\n      if (character === \"\\n\") {\n        line += 1;\n        column = -1;\n        mapping.push({\n          line: line,\n          column: 0\n        });\n      } else {\n        mapping.push({\n          line: line,\n          column: column\n        });\n      }\n\n      column += 1;\n    });\n    return mapping;\n  },\n  getHumanReadableSourceMap: function getHumanReadableSourceMap(sourceMap) {\n    var instructions = sourceMap.split(\";\");\n    var processedInstruction = {}; //persists across instructions for when info doesn't change\n\n    var processedSourceMap = []; //JS doesn't have scan, so we'll do this scan manually\n\n    var _iterator = _createForOfIteratorHelper(instructions),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var instruction = _step.value;\n        var splitInstruction = instruction.split(\":\"); //note: if(splitInstruction[i]) checks both that there are\n        //at least that many fields, and that that particular field\n        //is nonempty\n\n        if (splitInstruction[0]) {\n          processedInstruction.start = parseInt(splitInstruction[0]);\n        }\n\n        if (splitInstruction[1]) {\n          processedInstruction.length = parseInt(splitInstruction[1]);\n        }\n\n        if (splitInstruction[2]) {\n          processedInstruction.file = parseInt(splitInstruction[2]);\n        }\n\n        if (splitInstruction[3]) {\n          processedInstruction.jump = splitInstruction[3];\n        }\n\n        if (splitInstruction[4]) {\n          processedInstruction.modifierDepth = parseInt(splitInstruction[4]);\n        } //we need to clone before pushing so that the array won't contain a\n        //bunch of copies of the same thing.  unfortunately, we don't have\n        //babel here, so we need to clone a bit manually.\n\n\n        var clonedProcessedInstruction = {\n          start: processedInstruction.start,\n          length: processedInstruction.length,\n          file: processedInstruction.file,\n          jump: processedInstruction.jump,\n          modifierDepth: processedInstruction.modifierDepth\n        };\n        processedSourceMap.push(clonedProcessedInstruction);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return processedSourceMap;\n  },\n  //sources: array of text sources (must be in order!)\n  //binary: raw binary to process.  should not have unresolved links.\n  //sourceMap: a processed source map as output by getHumanReadableSourceMap above\n  //we... attempt to muddle through.\n  getProcessedInstructionsForBinary: function getProcessedInstructionsForBinary(sources, binary, sourceMap) {\n    if (!sources || !binary) {\n      return [];\n    }\n\n    debug(\"sourceMap: %O\", sourceMap);\n    var numInstructions;\n\n    if (sourceMap) {\n      numInstructions = sourceMap.length;\n    } //because we might be dealing with a constructor with arguments, we do\n    //*not* remove metadata manually\n\n\n    var instructions = CodeUtils.parseCode(binary, numInstructions);\n\n    if (!sourceMap) {\n      // HACK\n      // Let's create a source map to use since none exists. This source\n      // map maps just as many ranges as there are instructions (or\n      // possibly more), and marks them all as being Solidity-internal and\n      // not jumps.\n      sourceMap = new Array(instructions.length);\n      sourceMap.fill({\n        start: 0,\n        length: 0,\n        file: -1,\n        jump: \"-\",\n        modifierDepth: \"0\"\n      });\n    }\n\n    var lineAndColumnMappings = sources.map(function (source) {\n      return SolidityUtils.getCharacterOffsetToLineAndColumnMapping(source || \"\");\n    });\n    var primaryFile;\n\n    if (sourceMap[0]) {\n      primaryFile = sourceMap[0].file;\n    }\n\n    debug(\"primaryFile %o\", primaryFile);\n    return instructions.map(function (instruction, index) {\n      // lookup source map by index and add `index` property to\n      // instruction\n      //\n      var instructionSourceMap = sourceMap[index] || {};\n      instruction.index = index; //should be fine to modify this\n\n      return {\n        instruction: instruction,\n        instructionSourceMap: instructionSourceMap\n      };\n    }).map(function (_ref) {\n      var instruction = _ref.instruction,\n          instructionSourceMap = _ref.instructionSourceMap;\n      instruction.jump = instructionSourceMap.jump;\n      var _instructionSourceMap = instructionSourceMap.start;\n      instruction.start = _instructionSourceMap === void 0 ? 0 : _instructionSourceMap;\n      var _instructionSourceMap2 = instructionSourceMap.length;\n      instruction.length = _instructionSourceMap2 === void 0 ? 0 : _instructionSourceMap2;\n      var _instructionSourceMap3 = instructionSourceMap.file;\n      instruction.file = _instructionSourceMap3 === void 0 ? primaryFile : _instructionSourceMap3;\n      var _instructionSourceMap4 = instructionSourceMap.modifierDepth;\n      instruction.modifierDepth = _instructionSourceMap4 === void 0 ? 0 : _instructionSourceMap4;\n\n      if (instruction.start === -1 && instruction.length === -1) {\n        instruction.start = 0;\n        instruction.length = 0;\n      }\n\n      var lineAndColumnMapping = lineAndColumnMappings[instruction.file] || {};\n      instruction.range = {\n        start: lineAndColumnMapping[instruction.start] || {\n          line: null,\n          column: null\n        },\n        end: lineAndColumnMapping[instruction.start + instruction.length] || {\n          line: null,\n          column: null\n        }\n      };\n      return instruction;\n    });\n  },\n  //instructions: as output by the function above\n  //asts: array of abstract syntax trees for the sources. must be in order!\n  //overlapFunctions: an array of functions -- each one corresponding to the AST of the same index --\n  //that, given a start index and a length, will search for all nodes in that AST overlapping the\n  //given range, and will return an array of objects with fields node and pointer; node should\n  //be the corresponding node, and pointer a jsonpointer to it (from the AST root)\n  //compilationId: what it says.  the function will work fine without it.\n  getFunctionsByProgramCounter: function getFunctionsByProgramCounter(instructions, asts, overlapFunctions, compilationId) {\n    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(instructions.filter(function (instruction) {\n      return instruction.name === \"JUMPDEST\";\n    }).map(function (instruction) {\n      debug(\"instruction %O\", instruction);\n      var sourceIndex = instruction.file; //first off, a special case: if the file is -1, check for designated\n      //invalid and if it's not that give up\n      //(designated invalid gets file -1 in some Solidity versions)\n\n      if (sourceIndex === -1) {\n        //yeah, this is copypasted from below\n        var nextInstruction = instructions[instruction.index + 1] || {};\n\n        if (nextInstruction.name === \"INVALID\") {\n          //designated invalid, include it\n          return _defineProperty({}, instruction.pc, {\n            isDesignatedInvalid: true\n          });\n        } else {\n          //not designated invalid, filter it out\n          return {};\n        }\n      } //now we proceed with the normal case\n\n\n      var findOverlappingRange = overlapFunctions[sourceIndex];\n      var ast = asts[sourceIndex];\n\n      if (!ast) {\n        //if we can't get the ast... filter it out I guess\n        return {};\n      }\n\n      var range = SolidityUtils.getSourceRange(instruction);\n\n      var _SolidityUtils$findRa = SolidityUtils.findRange(findOverlappingRange, range.start, range.length),\n          node = _SolidityUtils$findRa.node,\n          pointer = _SolidityUtils$findRa.pointer;\n\n      if (!pointer) {\n        node = ast;\n      }\n\n      if (!node || node.nodeType !== \"FunctionDefinition\") {\n        //filter out JUMPDESTs that aren't function definitions...\n        //except for the designated invalid function\n        var _nextInstruction = instructions[instruction.index + 1] || {};\n\n        if (_nextInstruction.name === \"INVALID\") {\n          //designated invalid, include it\n          return _defineProperty({}, instruction.pc, {\n            isDesignatedInvalid: true\n          });\n        } else {\n          //not designated invalid, filter it out\n          return {};\n        }\n      } //otherwise, we're good to go, so let's find the contract node and\n      //put it all together\n      //to get the contract node, we go up twice from the function node;\n      //the path from one to the other should have a very specific form,\n      //so this is easy\n\n\n      var contractPointer = pointer.replace(/\\/nodes\\/\\d+$/, \"\");\n      var contractNode = jsonpointer.get(ast, contractPointer);\n\n      if (contractNode.nodeType !== \"ContractDefinition\") {\n        //if it's a free function, there is no contract pointer or contract node\n        contractPointer = null;\n        contractNode = null;\n      }\n\n      return _defineProperty({}, instruction.pc, {\n        sourceIndex: sourceIndex,\n        compilationId: compilationId,\n        //note: we're assuming that functions in generated sources are never pointed to\n        pointer: pointer,\n        node: node,\n        name: node.name,\n        id: node.id,\n        mutability: Codec.Ast.Utils.mutability(node),\n        contractPointer: contractPointer,\n        contractNode: contractNode,\n        contractName: contractNode ? contractNode.name : null,\n        contractId: contractNode ? contractNode.id : null,\n        contractKind: contractNode ? contractNode.contractKind : null,\n        contractPayable: contractNode ? Codec.Ast.Utils.isContractPayable(contractNode) : null,\n        isDesignatedInvalid: false\n      });\n    }))));\n  },\n  getSourceRange: function getSourceRange() {\n    var instruction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return {\n      start: instruction.start || 0,\n      length: instruction.length || 0,\n      lines: instruction.range || {\n        start: {\n          line: 0,\n          column: 0\n        },\n        end: {\n          line: 0,\n          column: 0\n        }\n      }\n    };\n  },\n  //findOverlappingRange should be as described above\n  findRange: function findRange(findOverlappingRange, sourceStart, sourceLength) {\n    // find nodes that fully contain requested range,\n    // return one with longest pointer\n    // (note: returns { range, node, pointer }\n    var sourceEnd = sourceStart + sourceLength;\n\n    var pointerLength = function pointerLength(pointer) {\n      return (pointer.match(/\\//g) || []).length;\n    }; //counts number of slashes in ptr\n\n\n    return findOverlappingRange(sourceStart, sourceLength).filter(function (_ref5) {\n      var range = _ref5.range;\n      return sourceStart >= range[0] && sourceEnd <= range[1];\n    }).reduce(function (acc, cur) {\n      return pointerLength(cur.pointer) >= pointerLength(acc.pointer) ? cur : acc;\n    }, {\n      pointer: \"\"\n    }); //note we make sure to bias towards cur (the new value being compared) rather than acc (the old value)\n    //so that we don't actually get {pointer: \"\"} as our result\n  },\n  //makes the overlap function for an AST\n  makeOverlapFunction: function makeOverlapFunction(ast) {\n    var tree = new IntervalTree();\n    var ranges = SolidityUtils.rangeNodes(ast);\n\n    var _iterator2 = _createForOfIteratorHelper(ranges),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _step2.value,\n            range = _step2$value.range,\n            node = _step2$value.node,\n            pointer = _step2$value.pointer;\n\n        var _range = _slicedToArray(range, 2),\n            start = _range[0],\n            end = _range[1];\n\n        tree.insert(start, end, {\n          range: range,\n          node: node,\n          pointer: pointer\n        });\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return function (sourceStart, sourceLength) {\n      return tree.search(sourceStart, sourceStart + sourceLength);\n    };\n  },\n  //for use by makeOverlapFunction\n  rangeNodes: function rangeNodes(node) {\n    var pointer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n\n    if (node instanceof Array) {\n      var _ref6;\n\n      return (_ref6 = []).concat.apply(_ref6, _toConsumableArray(node.map(function (sub, i) {\n        return SolidityUtils.rangeNodes(sub, \"\".concat(pointer, \"/\").concat(i));\n      })));\n    } else if (node instanceof Object) {\n      var results = [];\n\n      if (node.src !== undefined && node.nodeType !== undefined) {\n        //don't add \"pseudo-nodes\" (i.e.: outside variable references\n        //in assembly) with no nodeType\n        results.push({\n          pointer: pointer,\n          node: node,\n          range: SolidityUtils.getRange(node)\n        });\n      }\n\n      return results.concat.apply(results, _toConsumableArray(Object.keys(node).map(function (key) {\n        return SolidityUtils.rangeNodes(node[key], \"\".concat(pointer, \"/\").concat(key));\n      })));\n    } else {\n      return [];\n    }\n  },\n  getRange: function getRange(node) {\n    // src: \"<start>:<length>:<_>\"\n    // returns [start, end]\n    var _node$src$split$slice = node.src.split(\":\").slice(0, 2).map(function (i) {\n      return parseInt(i);\n    }),\n        _node$src$split$slice2 = _slicedToArray(_node$src$split$slice, 2),\n        start = _node$src$split$slice2[0],\n        length = _node$src$split$slice2[1];\n\n    return [start, start + length];\n  }\n};\nmodule.exports = SolidityUtils;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/@truffle/solidity-utils/index.js"],"names":["debug","require","CodeUtils","Codec","jsonpointer","IntervalTree","default","SolidityUtils","getCharacterOffsetToLineAndColumnMapping","source","mapping","split","line","column","forEach","character","push","getHumanReadableSourceMap","sourceMap","instructions","processedInstruction","processedSourceMap","instruction","splitInstruction","start","parseInt","length","file","jump","modifierDepth","clonedProcessedInstruction","getProcessedInstructionsForBinary","sources","binary","numInstructions","parseCode","Array","fill","lineAndColumnMappings","map","primaryFile","index","instructionSourceMap","lineAndColumnMapping","range","end","getFunctionsByProgramCounter","asts","overlapFunctions","compilationId","Object","assign","filter","name","sourceIndex","nextInstruction","pc","isDesignatedInvalid","findOverlappingRange","ast","getSourceRange","findRange","node","pointer","nodeType","contractPointer","replace","contractNode","get","id","mutability","Ast","Utils","contractName","contractId","contractKind","contractPayable","isContractPayable","lines","sourceStart","sourceLength","sourceEnd","pointerLength","match","reduce","acc","cur","makeOverlapFunction","tree","ranges","rangeNodes","insert","search","concat","sub","i","results","src","undefined","getRange","keys","key","slice","module","exports"],"mappings":";;;;;;;;AAAA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,gBAAjB,CAAd;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AACA,IAAME,KAAK,GAAGF,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAMG,WAAW,GAAGH,OAAO,CAAC,cAAD,CAA3B;;AACA,IAAMI,YAAY,GAAGJ,OAAO,CAAC,oBAAD,CAAP,CAA8BK,OAAnD;;AAEA,IAAIC,aAAa,GAAG;AAClBC,EAAAA,wCAAwC,EAAE,kDAAUC,MAAV,EAAkB;AAC1D,QAAIC,OAAO,GAAG,EAAd;AAEAD,IAAAA,MAAM,GAAGA,MAAM,CAACE,KAAP,CAAa,EAAb,CAAT;AAEA,QAAIC,IAAI,GAAG,CAAX;AACA,QAAIC,MAAM,GAAG,CAAb;AAEAJ,IAAAA,MAAM,CAACK,OAAP,CAAe,UAAUC,SAAV,EAAqB;AAClC,UAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtBH,QAAAA,IAAI,IAAI,CAAR;AACAC,QAAAA,MAAM,GAAG,CAAC,CAAV;AAEAH,QAAAA,OAAO,CAACM,IAAR,CAAa;AACXJ,UAAAA,IAAI,EAAEA,IADK;AAEXC,UAAAA,MAAM,EAAE;AAFG,SAAb;AAID,OARD,MAQO;AACLH,QAAAA,OAAO,CAACM,IAAR,CAAa;AACXJ,UAAAA,IAAI,EAAEA,IADK;AAEXC,UAAAA,MAAM,EAAEA;AAFG,SAAb;AAID;;AAEDA,MAAAA,MAAM,IAAI,CAAV;AACD,KAjBD;AAmBA,WAAOH,OAAP;AACD,GA7BiB;AA+BlBO,EAAAA,yBAAyB,EAAE,mCAAUC,SAAV,EAAqB;AAC9C,QAAMC,YAAY,GAAGD,SAAS,CAACP,KAAV,CAAgB,GAAhB,CAArB;AAEA,QAAIS,oBAAoB,GAAG,EAA3B,CAH8C,CAGf;;AAC/B,QAAIC,kBAAkB,GAAG,EAAzB,CAJ8C,CAM9C;;AAN8C,+CAOtBF,YAPsB;AAAA;;AAAA;AAO9C,0DAAsC;AAAA,YAA7BG,WAA6B;AACpC,YAAIC,gBAAgB,GAAGD,WAAW,CAACX,KAAZ,CAAkB,GAAlB,CAAvB,CADoC,CAGpC;AACA;AACA;;AAEA,YAAIY,gBAAgB,CAAC,CAAD,CAApB,EAAyB;AACvBH,UAAAA,oBAAoB,CAACI,KAArB,GAA6BC,QAAQ,CAACF,gBAAgB,CAAC,CAAD,CAAjB,CAArC;AACD;;AAED,YAAIA,gBAAgB,CAAC,CAAD,CAApB,EAAyB;AACvBH,UAAAA,oBAAoB,CAACM,MAArB,GAA8BD,QAAQ,CAACF,gBAAgB,CAAC,CAAD,CAAjB,CAAtC;AACD;;AAED,YAAIA,gBAAgB,CAAC,CAAD,CAApB,EAAyB;AACvBH,UAAAA,oBAAoB,CAACO,IAArB,GAA4BF,QAAQ,CAACF,gBAAgB,CAAC,CAAD,CAAjB,CAApC;AACD;;AAED,YAAIA,gBAAgB,CAAC,CAAD,CAApB,EAAyB;AACvBH,UAAAA,oBAAoB,CAACQ,IAArB,GAA4BL,gBAAgB,CAAC,CAAD,CAA5C;AACD;;AAED,YAAIA,gBAAgB,CAAC,CAAD,CAApB,EAAyB;AACvBH,UAAAA,oBAAoB,CAACS,aAArB,GAAqCJ,QAAQ,CAACF,gBAAgB,CAAC,CAAD,CAAjB,CAA7C;AACD,SAzBmC,CA2BpC;AACA;AACA;;;AACA,YAAIO,0BAA0B,GAAG;AAC/BN,UAAAA,KAAK,EAAEJ,oBAAoB,CAACI,KADG;AAE/BE,UAAAA,MAAM,EAAEN,oBAAoB,CAACM,MAFE;AAG/BC,UAAAA,IAAI,EAAEP,oBAAoB,CAACO,IAHI;AAI/BC,UAAAA,IAAI,EAAER,oBAAoB,CAACQ,IAJI;AAK/BC,UAAAA,aAAa,EAAET,oBAAoB,CAACS;AALL,SAAjC;AAQAR,QAAAA,kBAAkB,CAACL,IAAnB,CAAwBc,0BAAxB;AACD;AA9C6C;AAAA;AAAA;AAAA;AAAA;;AAgD9C,WAAOT,kBAAP;AACD,GAhFiB;AAkFlB;AACA;AACA;AACA;AACAU,EAAAA,iCAAiC,EAAE,2CAAUC,OAAV,EAAmBC,MAAnB,EAA2Bf,SAA3B,EAAsC;AACvE,QAAI,CAACc,OAAD,IAAY,CAACC,MAAjB,EAAyB;AACvB,aAAO,EAAP;AACD;;AACDjC,IAAAA,KAAK,CAAC,eAAD,EAAkBkB,SAAlB,CAAL;AAEA,QAAIgB,eAAJ;;AACA,QAAIhB,SAAJ,EAAe;AACbgB,MAAAA,eAAe,GAAGhB,SAAS,CAACQ,MAA5B;AACD,KATsE,CAWvE;AACA;;;AACA,QAAIP,YAAY,GAAGjB,SAAS,CAACiC,SAAV,CAAoBF,MAApB,EAA4BC,eAA5B,CAAnB;;AAEA,QAAI,CAAChB,SAAL,EAAgB;AACd;AACA;AACA;AACA;AACA;AACAA,MAAAA,SAAS,GAAG,IAAIkB,KAAJ,CAAUjB,YAAY,CAACO,MAAvB,CAAZ;AACAR,MAAAA,SAAS,CAACmB,IAAV,CAAe;AACbb,QAAAA,KAAK,EAAE,CADM;AAEbE,QAAAA,MAAM,EAAE,CAFK;AAGbC,QAAAA,IAAI,EAAE,CAAC,CAHM;AAIbC,QAAAA,IAAI,EAAE,GAJO;AAKbC,QAAAA,aAAa,EAAE;AALF,OAAf;AAOD;;AAED,QAAMS,qBAAqB,GAAGN,OAAO,CAACO,GAAR,CAAY,UAAA9B,MAAM;AAAA,aAC9CF,aAAa,CAACC,wCAAd,CAAuDC,MAAM,IAAI,EAAjE,CAD8C;AAAA,KAAlB,CAA9B;AAIA,QAAI+B,WAAJ;;AACA,QAAItB,SAAS,CAAC,CAAD,CAAb,EAAkB;AAChBsB,MAAAA,WAAW,GAAGtB,SAAS,CAAC,CAAD,CAAT,CAAaS,IAA3B;AACD;;AACD3B,IAAAA,KAAK,CAAC,gBAAD,EAAmBwC,WAAnB,CAAL;AAEA,WAAOrB,YAAY,CAChBoB,GADI,CACA,UAACjB,WAAD,EAAcmB,KAAd,EAAwB;AAC3B;AACA;AACA;AAEA,UAAMC,oBAAoB,GAAGxB,SAAS,CAACuB,KAAD,CAAT,IAAoB,EAAjD;AAEAnB,MAAAA,WAAW,CAACmB,KAAZ,GAAoBA,KAApB,CAP2B,CAOA;;AAE3B,aAAO;AACLnB,QAAAA,WAAW,EAAXA,WADK;AAELoB,QAAAA,oBAAoB,EAApBA;AAFK,OAAP;AAID,KAdI,EAeJH,GAfI,CAeA,gBAA2C;AAAA,UAAxCjB,WAAwC,QAAxCA,WAAwC;AAAA,UAA3BoB,oBAA2B,QAA3BA,oBAA2B;AAKtCpB,MAAAA,WAAW,CAACM,IAL0B,GAU1Cc,oBAV0C,CAK5Cd,IAL4C;AAAA,kCAU1Cc,oBAV0C,CAM5ClB,KAN4C;AAMrCF,MAAAA,WAAW,CAACE,KANyB,sCAMjB,CANiB;AAAA,mCAU1CkB,oBAV0C,CAO5ChB,MAP4C;AAOpCJ,MAAAA,WAAW,CAACI,MAPwB,uCAOf,CAPe;AAAA,mCAU1CgB,oBAV0C,CAQ5Cf,IAR4C;AAQtCL,MAAAA,WAAW,CAACK,IAR0B,uCAQnBa,WARmB;AAAA,mCAU1CE,oBAV0C,CAS5Cb,aAT4C;AAS7BP,MAAAA,WAAW,CAACO,aATiB,uCASD,CATC;;AAW9C,UAAIP,WAAW,CAACE,KAAZ,KAAsB,CAAC,CAAvB,IAA4BF,WAAW,CAACI,MAAZ,KAAuB,CAAC,CAAxD,EAA2D;AACzDJ,QAAAA,WAAW,CAACE,KAAZ,GAAoB,CAApB;AACAF,QAAAA,WAAW,CAACI,MAAZ,GAAqB,CAArB;AACD;;AACD,UAAMiB,oBAAoB,GACxBL,qBAAqB,CAAChB,WAAW,CAACK,IAAb,CAArB,IAA2C,EAD7C;AAEAL,MAAAA,WAAW,CAACsB,KAAZ,GAAoB;AAClBpB,QAAAA,KAAK,EAAEmB,oBAAoB,CAACrB,WAAW,CAACE,KAAb,CAApB,IAA2C;AAChDZ,UAAAA,IAAI,EAAE,IAD0C;AAEhDC,UAAAA,MAAM,EAAE;AAFwC,SADhC;AAKlBgC,QAAAA,GAAG,EAAEF,oBAAoB,CAACrB,WAAW,CAACE,KAAZ,GAAoBF,WAAW,CAACI,MAAjC,CAApB,IAAgE;AACnEd,UAAAA,IAAI,EAAE,IAD6D;AAEnEC,UAAAA,MAAM,EAAE;AAF2D;AALnD,OAApB;AAWA,aAAOS,WAAP;AACD,KA5CI,CAAP;AA6CD,GA5KiB;AA8KlB;AACA;AACA;AACA;AACA;AACA;AACA;AACAwB,EAAAA,4BAA4B,EAAE,sCAC5B3B,YAD4B,EAE5B4B,IAF4B,EAG5BC,gBAH4B,EAI5BC,aAJ4B,EAK5B;AACA,WAAOC,MAAM,CAACC,MAAP,OAAAD,MAAM,GACX,EADW,4BAER/B,YAAY,CACZiC,MADA,CACO,UAAA9B,WAAW;AAAA,aAAIA,WAAW,CAAC+B,IAAZ,KAAqB,UAAzB;AAAA,KADlB,EAEAd,GAFA,CAEI,UAAAjB,WAAW,EAAI;AAClBtB,MAAAA,KAAK,CAAC,gBAAD,EAAmBsB,WAAnB,CAAL;AACA,UAAIgC,WAAW,GAAGhC,WAAW,CAACK,IAA9B,CAFkB,CAGlB;AACA;AACA;;AACA,UAAI2B,WAAW,KAAK,CAAC,CAArB,EAAwB;AACtB;AACA,YAAIC,eAAe,GAAGpC,YAAY,CAACG,WAAW,CAACmB,KAAZ,GAAoB,CAArB,CAAZ,IAAuC,EAA7D;;AACA,YAAIc,eAAe,CAACF,IAAhB,KAAyB,SAA7B,EAAwC;AACtC;AACA,qCACG/B,WAAW,CAACkC,EADf,EACoB;AAChBC,YAAAA,mBAAmB,EAAE;AADL,WADpB;AAKD,SAPD,MAOO;AACL;AACA,iBAAO,EAAP;AACD;AACF,OApBiB,CAqBlB;;;AACA,UAAIC,oBAAoB,GAAGV,gBAAgB,CAACM,WAAD,CAA3C;AACA,UAAIK,GAAG,GAAGZ,IAAI,CAACO,WAAD,CAAd;;AACA,UAAI,CAACK,GAAL,EAAU;AACR;AACA,eAAO,EAAP;AACD;;AACD,UAAIf,KAAK,GAAGrC,aAAa,CAACqD,cAAd,CAA6BtC,WAA7B,CAAZ;;AA5BkB,kCA6BMf,aAAa,CAACsD,SAAd,CACtBH,oBADsB,EAEtBd,KAAK,CAACpB,KAFgB,EAGtBoB,KAAK,CAAClB,MAHgB,CA7BN;AAAA,UA6BZoC,IA7BY,yBA6BZA,IA7BY;AAAA,UA6BNC,OA7BM,yBA6BNA,OA7BM;;AAkClB,UAAI,CAACA,OAAL,EAAc;AACZD,QAAAA,IAAI,GAAGH,GAAP;AACD;;AACD,UAAI,CAACG,IAAD,IAASA,IAAI,CAACE,QAAL,KAAkB,oBAA/B,EAAqD;AACnD;AACA;AACA,YAAIT,gBAAe,GAAGpC,YAAY,CAACG,WAAW,CAACmB,KAAZ,GAAoB,CAArB,CAAZ,IAAuC,EAA7D;;AACA,YAAIc,gBAAe,CAACF,IAAhB,KAAyB,SAA7B,EAAwC;AACtC;AACA,qCACG/B,WAAW,CAACkC,EADf,EACoB;AAChBC,YAAAA,mBAAmB,EAAE;AADL,WADpB;AAKD,SAPD,MAOO;AACL;AACA,iBAAO,EAAP;AACD;AACF,OApDiB,CAqDlB;AACA;AACA;AACA;AACA;;;AACA,UAAIQ,eAAe,GAAGF,OAAO,CAACG,OAAR,CAAgB,eAAhB,EAAiC,EAAjC,CAAtB;AACA,UAAIC,YAAY,GAAG/D,WAAW,CAACgE,GAAZ,CAAgBT,GAAhB,EAAqBM,eAArB,CAAnB;;AACA,UAAIE,YAAY,CAACH,QAAb,KAA0B,oBAA9B,EAAoD;AAClD;AACAC,QAAAA,eAAe,GAAG,IAAlB;AACAE,QAAAA,YAAY,GAAG,IAAf;AACD;;AACD,iCACG7C,WAAW,CAACkC,EADf,EACoB;AAChBF,QAAAA,WAAW,EAAXA,WADgB;AAEhBL,QAAAA,aAAa,EAAbA,aAFgB;AAGhB;AACAc,QAAAA,OAAO,EAAPA,OAJgB;AAKhBD,QAAAA,IAAI,EAAJA,IALgB;AAMhBT,QAAAA,IAAI,EAAES,IAAI,CAACT,IANK;AAOhBgB,QAAAA,EAAE,EAAEP,IAAI,CAACO,EAPO;AAQhBC,QAAAA,UAAU,EAAEnE,KAAK,CAACoE,GAAN,CAAUC,KAAV,CAAgBF,UAAhB,CAA2BR,IAA3B,CARI;AAShBG,QAAAA,eAAe,EAAfA,eATgB;AAUhBE,QAAAA,YAAY,EAAZA,YAVgB;AAWhBM,QAAAA,YAAY,EAAEN,YAAY,GAAGA,YAAY,CAACd,IAAhB,GAAuB,IAXjC;AAYhBqB,QAAAA,UAAU,EAAEP,YAAY,GAAGA,YAAY,CAACE,EAAhB,GAAqB,IAZ7B;AAahBM,QAAAA,YAAY,EAAER,YAAY,GAAGA,YAAY,CAACQ,YAAhB,GAA+B,IAbzC;AAchBC,QAAAA,eAAe,EAAET,YAAY,GACzBhE,KAAK,CAACoE,GAAN,CAAUC,KAAV,CAAgBK,iBAAhB,CAAkCV,YAAlC,CADyB,GAEzB,IAhBY;AAiBhBV,QAAAA,mBAAmB,EAAE;AAjBL,OADpB;AAqBD,KAxFA,CAFQ,GAAb;AA4FD,GAvRiB;AAyRlBG,EAAAA,cAAc,EAAE,0BAA4B;AAAA,QAAlBtC,WAAkB,uEAAJ,EAAI;AAC1C,WAAO;AACLE,MAAAA,KAAK,EAAEF,WAAW,CAACE,KAAZ,IAAqB,CADvB;AAELE,MAAAA,MAAM,EAAEJ,WAAW,CAACI,MAAZ,IAAsB,CAFzB;AAGLoD,MAAAA,KAAK,EAAExD,WAAW,CAACsB,KAAZ,IAAqB;AAC1BpB,QAAAA,KAAK,EAAE;AACLZ,UAAAA,IAAI,EAAE,CADD;AAELC,UAAAA,MAAM,EAAE;AAFH,SADmB;AAK1BgC,QAAAA,GAAG,EAAE;AACHjC,UAAAA,IAAI,EAAE,CADH;AAEHC,UAAAA,MAAM,EAAE;AAFL;AALqB;AAHvB,KAAP;AAcD,GAxSiB;AA0SlB;AACAgD,EAAAA,SAAS,EAAE,mBAAUH,oBAAV,EAAgCqB,WAAhC,EAA6CC,YAA7C,EAA2D;AACpE;AACA;AACA;AACA,QAAIC,SAAS,GAAGF,WAAW,GAAGC,YAA9B;;AACA,QAAIE,aAAa,GAAG,SAAhBA,aAAgB,CAAAnB,OAAO;AAAA,aAAI,CAACA,OAAO,CAACoB,KAAR,CAAc,KAAd,KAAwB,EAAzB,EAA6BzD,MAAjC;AAAA,KAA3B,CALoE,CAKA;;;AACpE,WAAOgC,oBAAoB,CAACqB,WAAD,EAAcC,YAAd,CAApB,CACJ5B,MADI,CACG;AAAA,UAAGR,KAAH,SAAGA,KAAH;AAAA,aAAemC,WAAW,IAAInC,KAAK,CAAC,CAAD,CAApB,IAA2BqC,SAAS,IAAIrC,KAAK,CAAC,CAAD,CAA5D;AAAA,KADH,EAEJwC,MAFI,CAGH,UAACC,GAAD,EAAMC,GAAN;AAAA,aACEJ,aAAa,CAACI,GAAG,CAACvB,OAAL,CAAb,IAA8BmB,aAAa,CAACG,GAAG,CAACtB,OAAL,CAA3C,GAA2DuB,GAA3D,GAAiED,GADnE;AAAA,KAHG,EAKH;AAAEtB,MAAAA,OAAO,EAAE;AAAX,KALG,CAAP,CANoE,CAapE;AACA;AACD,GA1TiB;AA4TlB;AACAwB,EAAAA,mBAAmB,EAAE,6BAAU5B,GAAV,EAAe;AAClC,QAAI6B,IAAI,GAAG,IAAInF,YAAJ,EAAX;AACA,QAAIoF,MAAM,GAAGlF,aAAa,CAACmF,UAAd,CAAyB/B,GAAzB,CAAb;;AAFkC,gDAGG8B,MAHH;AAAA;;AAAA;AAGlC,6DAA6C;AAAA;AAAA,YAAlC7C,KAAkC,gBAAlCA,KAAkC;AAAA,YAA3BkB,IAA2B,gBAA3BA,IAA2B;AAAA,YAArBC,OAAqB,gBAArBA,OAAqB;;AAAA,oCACxBnB,KADwB;AAAA,YACtCpB,KADsC;AAAA,YAC/BqB,GAD+B;;AAE3C2C,QAAAA,IAAI,CAACG,MAAL,CAAYnE,KAAZ,EAAmBqB,GAAnB,EAAwB;AAAED,UAAAA,KAAK,EAALA,KAAF;AAASkB,UAAAA,IAAI,EAAJA,IAAT;AAAeC,UAAAA,OAAO,EAAPA;AAAf,SAAxB;AACD;AANiC;AAAA;AAAA;AAAA;AAAA;;AAOlC,WAAO,UAACgB,WAAD,EAAcC,YAAd;AAAA,aACLQ,IAAI,CAACI,MAAL,CAAYb,WAAZ,EAAyBA,WAAW,GAAGC,YAAvC,CADK;AAAA,KAAP;AAED,GAtUiB;AAwUlB;AACAU,EAAAA,UAAU,EAAE,oBAAU5B,IAAV,EAA8B;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AACxC,QAAID,IAAI,YAAY1B,KAApB,EAA2B;AAAA;;AACzB,aAAO,aAAGyD,MAAH,iCACF/B,IAAI,CAACvB,GAAL,CAAS,UAACuD,GAAD,EAAMC,CAAN;AAAA,eACVxF,aAAa,CAACmF,UAAd,CAAyBI,GAAzB,YAAiC/B,OAAjC,cAA4CgC,CAA5C,EADU;AAAA,OAAT,CADE,EAAP;AAKD,KAND,MAMO,IAAIjC,IAAI,YAAYZ,MAApB,EAA4B;AACjC,UAAI8C,OAAO,GAAG,EAAd;;AAEA,UAAIlC,IAAI,CAACmC,GAAL,KAAaC,SAAb,IAA0BpC,IAAI,CAACE,QAAL,KAAkBkC,SAAhD,EAA2D;AACzD;AACA;AACAF,QAAAA,OAAO,CAAChF,IAAR,CAAa;AAAE+C,UAAAA,OAAO,EAAPA,OAAF;AAAWD,UAAAA,IAAI,EAAJA,IAAX;AAAiBlB,UAAAA,KAAK,EAAErC,aAAa,CAAC4F,QAAd,CAAuBrC,IAAvB;AAAxB,SAAb;AACD;;AAED,aAAOkC,OAAO,CAACH,MAAR,OAAAG,OAAO,qBACT9C,MAAM,CAACkD,IAAP,CAAYtC,IAAZ,EAAkBvB,GAAlB,CAAsB,UAAA8D,GAAG;AAAA,eAC1B9F,aAAa,CAACmF,UAAd,CAAyB5B,IAAI,CAACuC,GAAD,CAA7B,YAAuCtC,OAAvC,cAAkDsC,GAAlD,EAD0B;AAAA,OAAzB,CADS,EAAd;AAKD,KAdM,MAcA;AACL,aAAO,EAAP;AACD;AACF,GAjWiB;AAmWlBF,EAAAA,QAAQ,EAAE,kBAAUrC,IAAV,EAAgB;AACxB;AACA;AAFwB,gCAGFA,IAAI,CAACmC,GAAL,CACnBtF,KADmB,CACb,GADa,EAEnB2F,KAFmB,CAEb,CAFa,EAEV,CAFU,EAGnB/D,GAHmB,CAGf,UAAAwD,CAAC;AAAA,aAAItE,QAAQ,CAACsE,CAAD,CAAZ;AAAA,KAHc,CAHE;AAAA;AAAA,QAGnBvE,KAHmB;AAAA,QAGZE,MAHY;;AAQxB,WAAO,CAACF,KAAD,EAAQA,KAAK,GAAGE,MAAhB,CAAP;AACD;AA5WiB,CAApB;AA+WA6E,MAAM,CAACC,OAAP,GAAiBjG,aAAjB","sourcesContent":["const debug = require(\"debug\")(\"solidity-utils\");\nconst CodeUtils = require(\"@truffle/code-utils\");\nconst Codec = require(\"@truffle/codec\");\nconst jsonpointer = require(\"json-pointer\");\nconst IntervalTree = require(\"node-interval-tree\").default;\n\nvar SolidityUtils = {\n  getCharacterOffsetToLineAndColumnMapping: function (source) {\n    var mapping = [];\n\n    source = source.split(\"\");\n\n    var line = 0;\n    var column = 0;\n\n    source.forEach(function (character) {\n      if (character === \"\\n\") {\n        line += 1;\n        column = -1;\n\n        mapping.push({\n          line: line,\n          column: 0\n        });\n      } else {\n        mapping.push({\n          line: line,\n          column: column\n        });\n      }\n\n      column += 1;\n    });\n\n    return mapping;\n  },\n\n  getHumanReadableSourceMap: function (sourceMap) {\n    const instructions = sourceMap.split(\";\");\n\n    let processedInstruction = {}; //persists across instructions for when info doesn't change\n    let processedSourceMap = [];\n\n    //JS doesn't have scan, so we'll do this scan manually\n    for (let instruction of instructions) {\n      let splitInstruction = instruction.split(\":\");\n\n      //note: if(splitInstruction[i]) checks both that there are\n      //at least that many fields, and that that particular field\n      //is nonempty\n\n      if (splitInstruction[0]) {\n        processedInstruction.start = parseInt(splitInstruction[0]);\n      }\n\n      if (splitInstruction[1]) {\n        processedInstruction.length = parseInt(splitInstruction[1]);\n      }\n\n      if (splitInstruction[2]) {\n        processedInstruction.file = parseInt(splitInstruction[2]);\n      }\n\n      if (splitInstruction[3]) {\n        processedInstruction.jump = splitInstruction[3];\n      }\n\n      if (splitInstruction[4]) {\n        processedInstruction.modifierDepth = parseInt(splitInstruction[4]);\n      }\n\n      //we need to clone before pushing so that the array won't contain a\n      //bunch of copies of the same thing.  unfortunately, we don't have\n      //babel here, so we need to clone a bit manually.\n      let clonedProcessedInstruction = {\n        start: processedInstruction.start,\n        length: processedInstruction.length,\n        file: processedInstruction.file,\n        jump: processedInstruction.jump,\n        modifierDepth: processedInstruction.modifierDepth\n      };\n\n      processedSourceMap.push(clonedProcessedInstruction);\n    }\n\n    return processedSourceMap;\n  },\n\n  //sources: array of text sources (must be in order!)\n  //binary: raw binary to process.  should not have unresolved links.\n  //sourceMap: a processed source map as output by getHumanReadableSourceMap above\n  //we... attempt to muddle through.\n  getProcessedInstructionsForBinary: function (sources, binary, sourceMap) {\n    if (!sources || !binary) {\n      return [];\n    }\n    debug(\"sourceMap: %O\", sourceMap);\n\n    let numInstructions;\n    if (sourceMap) {\n      numInstructions = sourceMap.length;\n    }\n\n    //because we might be dealing with a constructor with arguments, we do\n    //*not* remove metadata manually\n    let instructions = CodeUtils.parseCode(binary, numInstructions);\n\n    if (!sourceMap) {\n      // HACK\n      // Let's create a source map to use since none exists. This source\n      // map maps just as many ranges as there are instructions (or\n      // possibly more), and marks them all as being Solidity-internal and\n      // not jumps.\n      sourceMap = new Array(instructions.length);\n      sourceMap.fill({\n        start: 0,\n        length: 0,\n        file: -1,\n        jump: \"-\",\n        modifierDepth: \"0\"\n      });\n    }\n\n    const lineAndColumnMappings = sources.map(source =>\n      SolidityUtils.getCharacterOffsetToLineAndColumnMapping(source || \"\")\n    );\n\n    let primaryFile;\n    if (sourceMap[0]) {\n      primaryFile = sourceMap[0].file;\n    }\n    debug(\"primaryFile %o\", primaryFile);\n\n    return instructions\n      .map((instruction, index) => {\n        // lookup source map by index and add `index` property to\n        // instruction\n        //\n\n        const instructionSourceMap = sourceMap[index] || {};\n\n        instruction.index = index; //should be fine to modify this\n\n        return {\n          instruction,\n          instructionSourceMap\n        };\n      })\n      .map(({ instruction, instructionSourceMap }) => {\n        // add source map information to instruction, or defaults\n\n        //I think it is also OK to modify instruction here\n        ({\n          jump: instruction.jump,\n          start: instruction.start = 0,\n          length: instruction.length = 0,\n          file: instruction.file = primaryFile,\n          modifierDepth: instruction.modifierDepth = 0\n        } = instructionSourceMap);\n        if (instruction.start === -1 && instruction.length === -1) {\n          instruction.start = 0;\n          instruction.length = 0;\n        }\n        const lineAndColumnMapping =\n          lineAndColumnMappings[instruction.file] || {};\n        instruction.range = {\n          start: lineAndColumnMapping[instruction.start] || {\n            line: null,\n            column: null\n          },\n          end: lineAndColumnMapping[instruction.start + instruction.length] || {\n            line: null,\n            column: null\n          }\n        };\n\n        return instruction;\n      });\n  },\n\n  //instructions: as output by the function above\n  //asts: array of abstract syntax trees for the sources. must be in order!\n  //overlapFunctions: an array of functions -- each one corresponding to the AST of the same index --\n  //that, given a start index and a length, will search for all nodes in that AST overlapping the\n  //given range, and will return an array of objects with fields node and pointer; node should\n  //be the corresponding node, and pointer a jsonpointer to it (from the AST root)\n  //compilationId: what it says.  the function will work fine without it.\n  getFunctionsByProgramCounter: function (\n    instructions,\n    asts,\n    overlapFunctions,\n    compilationId\n  ) {\n    return Object.assign(\n      {},\n      ...instructions\n        .filter(instruction => instruction.name === \"JUMPDEST\")\n        .map(instruction => {\n          debug(\"instruction %O\", instruction);\n          let sourceIndex = instruction.file;\n          //first off, a special case: if the file is -1, check for designated\n          //invalid and if it's not that give up\n          //(designated invalid gets file -1 in some Solidity versions)\n          if (sourceIndex === -1) {\n            //yeah, this is copypasted from below\n            let nextInstruction = instructions[instruction.index + 1] || {};\n            if (nextInstruction.name === \"INVALID\") {\n              //designated invalid, include it\n              return {\n                [instruction.pc]: {\n                  isDesignatedInvalid: true\n                }\n              };\n            } else {\n              //not designated invalid, filter it out\n              return {};\n            }\n          }\n          //now we proceed with the normal case\n          let findOverlappingRange = overlapFunctions[sourceIndex];\n          let ast = asts[sourceIndex];\n          if (!ast) {\n            //if we can't get the ast... filter it out I guess\n            return {};\n          }\n          let range = SolidityUtils.getSourceRange(instruction);\n          let { node, pointer } = SolidityUtils.findRange(\n            findOverlappingRange,\n            range.start,\n            range.length\n          );\n          if (!pointer) {\n            node = ast;\n          }\n          if (!node || node.nodeType !== \"FunctionDefinition\") {\n            //filter out JUMPDESTs that aren't function definitions...\n            //except for the designated invalid function\n            let nextInstruction = instructions[instruction.index + 1] || {};\n            if (nextInstruction.name === \"INVALID\") {\n              //designated invalid, include it\n              return {\n                [instruction.pc]: {\n                  isDesignatedInvalid: true\n                }\n              };\n            } else {\n              //not designated invalid, filter it out\n              return {};\n            }\n          }\n          //otherwise, we're good to go, so let's find the contract node and\n          //put it all together\n          //to get the contract node, we go up twice from the function node;\n          //the path from one to the other should have a very specific form,\n          //so this is easy\n          let contractPointer = pointer.replace(/\\/nodes\\/\\d+$/, \"\");\n          let contractNode = jsonpointer.get(ast, contractPointer);\n          if (contractNode.nodeType !== \"ContractDefinition\") {\n            //if it's a free function, there is no contract pointer or contract node\n            contractPointer = null;\n            contractNode = null;\n          }\n          return {\n            [instruction.pc]: {\n              sourceIndex,\n              compilationId,\n              //note: we're assuming that functions in generated sources are never pointed to\n              pointer,\n              node,\n              name: node.name,\n              id: node.id,\n              mutability: Codec.Ast.Utils.mutability(node),\n              contractPointer,\n              contractNode,\n              contractName: contractNode ? contractNode.name : null,\n              contractId: contractNode ? contractNode.id : null,\n              contractKind: contractNode ? contractNode.contractKind : null,\n              contractPayable: contractNode\n                ? Codec.Ast.Utils.isContractPayable(contractNode)\n                : null,\n              isDesignatedInvalid: false\n            }\n          };\n        })\n    );\n  },\n\n  getSourceRange: function (instruction = {}) {\n    return {\n      start: instruction.start || 0,\n      length: instruction.length || 0,\n      lines: instruction.range || {\n        start: {\n          line: 0,\n          column: 0\n        },\n        end: {\n          line: 0,\n          column: 0\n        }\n      }\n    };\n  },\n\n  //findOverlappingRange should be as described above\n  findRange: function (findOverlappingRange, sourceStart, sourceLength) {\n    // find nodes that fully contain requested range,\n    // return one with longest pointer\n    // (note: returns { range, node, pointer }\n    let sourceEnd = sourceStart + sourceLength;\n    let pointerLength = pointer => (pointer.match(/\\//g) || []).length; //counts number of slashes in ptr\n    return findOverlappingRange(sourceStart, sourceLength)\n      .filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1])\n      .reduce(\n        (acc, cur) =>\n          pointerLength(cur.pointer) >= pointerLength(acc.pointer) ? cur : acc,\n        { pointer: \"\" }\n      );\n    //note we make sure to bias towards cur (the new value being compared) rather than acc (the old value)\n    //so that we don't actually get {pointer: \"\"} as our result\n  },\n\n  //makes the overlap function for an AST\n  makeOverlapFunction: function (ast) {\n    let tree = new IntervalTree();\n    let ranges = SolidityUtils.rangeNodes(ast);\n    for (let { range, node, pointer } of ranges) {\n      let [start, end] = range;\n      tree.insert(start, end, { range, node, pointer });\n    }\n    return (sourceStart, sourceLength) =>\n      tree.search(sourceStart, sourceStart + sourceLength);\n  },\n\n  //for use by makeOverlapFunction\n  rangeNodes: function (node, pointer = \"\") {\n    if (node instanceof Array) {\n      return [].concat(\n        ...node.map((sub, i) =>\n          SolidityUtils.rangeNodes(sub, `${pointer}/${i}`)\n        )\n      );\n    } else if (node instanceof Object) {\n      let results = [];\n\n      if (node.src !== undefined && node.nodeType !== undefined) {\n        //don't add \"pseudo-nodes\" (i.e.: outside variable references\n        //in assembly) with no nodeType\n        results.push({ pointer, node, range: SolidityUtils.getRange(node) });\n      }\n\n      return results.concat(\n        ...Object.keys(node).map(key =>\n          SolidityUtils.rangeNodes(node[key], `${pointer}/${key}`)\n        )\n      );\n    } else {\n      return [];\n    }\n  },\n\n  getRange: function (node) {\n    // src: \"<start>:<length>:<_>\"\n    // returns [start, end]\n    let [start, length] = node.src\n      .split(\":\")\n      .slice(0, 2)\n      .map(i => parseInt(i));\n\n    return [start, start + length];\n  }\n};\n\nmodule.exports = SolidityUtils;\n"]},"metadata":{},"sourceType":"script"}