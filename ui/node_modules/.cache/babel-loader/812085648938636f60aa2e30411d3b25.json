{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilations = void 0;\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = debug_1.default(\"codec:compilations:utils\");\n\nfunction shimCompilations(inputCompilations) {\n  var shimmedCompilationIdPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  var externalSolidity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return inputCompilations.map(function (_ref, compilationIndex) {\n    var contracts = _ref.contracts,\n        sourceIndexes = _ref.sourceIndexes;\n    return shimContracts(contracts, sourceIndexes, \"\".concat(shimmedCompilationIdPrefix, \"Number(\").concat(compilationIndex, \")\"), externalSolidity);\n  });\n}\n\nexports.shimCompilations = shimCompilations;\n/**\n * wrapper around shimArtifactsToCompilation that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\n\nfunction shimArtifacts(artifacts, files) {\n  var shimmedCompilationId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"shimmedcompilation\";\n  var externalSolidity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return [shimContracts(artifacts, files, shimmedCompilationId, externalSolidity)];\n}\n\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above two functions.\n */\n\nfunction shimContracts(artifacts, files) {\n  var shimmedCompilationId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"shimmedcompilation\";\n  var externalSolidity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var contracts = [];\n  var sources = [];\n  var unreliableSourceOrder = false;\n\n  var _iterator = _createForOfIteratorHelper(artifacts),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var artifact = _step.value;\n      var contractName = artifact.contractName,\n          bytecode = artifact.bytecode,\n          sourceMap = artifact.sourceMap,\n          deployedBytecode = artifact.deployedBytecode,\n          deployedSourceMap = artifact.deployedSourceMap,\n          immutableReferences = artifact.immutableReferences,\n          sourcePath = artifact.sourcePath,\n          source = artifact.source,\n          ast = artifact.ast,\n          abi = artifact.abi,\n          _compiler = artifact.compiler,\n          generatedSources = artifact.generatedSources,\n          deployedGeneratedSources = artifact.deployedGeneratedSources;\n\n      if (artifact.contract_name) {\n        //just in case\n        contractName = artifact.contract_name; //dunno what's up w/ the type of contract_name, but it needs coercing\n      }\n\n      debug(\"contractName: %s\", contractName);\n      var sourceObject = {\n        sourcePath: sourcePath,\n        source: source,\n        ast: ast,\n        compiler: _compiler\n      }; //ast needs to be coerced because schema doesn't quite match our types here...\n\n      var contractObject = {\n        contractName: contractName,\n        bytecode: bytecode,\n        sourceMap: sourceMap,\n        deployedBytecode: deployedBytecode,\n        deployedSourceMap: deployedSourceMap,\n        immutableReferences: immutableReferences,\n        abi: abi,\n        compiler: _compiler\n      }; //if files was passed, trust that to determine the source index\n\n      if (files) {\n        var index = files.indexOf(sourcePath);\n        debug(\"sourcePath: %s\", sourceObject.sourcePath);\n        debug(\"given index: %d\", index);\n        debug(\"sources: %o\", sources.map(function (source) {\n          return source.sourcePath;\n        }));\n        sources[index] = sourceObject;\n        sourceObject.id = index.toString(); //HACK\n\n        contractObject.primarySourceId = index.toString(); //note: we never set the unreliableSourceOrder flag in this branch;\n        //we just trust files.  If files is bad, then, uh, too bad.\n      } else {\n        //if files *wasn't* passed, attempt to determine it from the ast\n        var _index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n\n\n        var _getIndexToAddAt = getIndexToAddAt(sourceObject, _index, sources, unreliableSourceOrder);\n\n        _index = _getIndexToAddAt.index;\n        unreliableSourceOrder = _getIndexToAddAt.unreliableSourceOrder;\n\n        if (_index !== null) {\n          sources[_index] = Object.assign(Object.assign({}, sourceObject), {\n            id: _index.toString()\n          });\n          contractObject.primarySourceId = _index.toString();\n        }\n      } //now: add internal sources\n\n\n      for (var _i = 0, _arr = [].concat(_toConsumableArray(generatedSources || []), _toConsumableArray(deployedGeneratedSources || [])); _i < _arr.length; _i++) {\n        var _arr$_i = _arr[_i],\n            _ast = _arr$_i.ast,\n            contents = _arr$_i.contents,\n            _index2 = _arr$_i.id,\n            name = _arr$_i.name;\n        var generatedSourceObject = {\n          sourcePath: name,\n          source: contents,\n          ast: _ast,\n          compiler: _compiler,\n          internal: true\n        };\n\n        var _getIndexToAddAt2 = getIndexToAddAt(generatedSourceObject, _index2, sources, unreliableSourceOrder);\n\n        _index2 = _getIndexToAddAt2.index;\n        unreliableSourceOrder = _getIndexToAddAt2.unreliableSourceOrder;\n\n        if (_index2 !== null) {\n          sources[_index2] = Object.assign(Object.assign({}, generatedSourceObject), {\n            id: _index2.toString()\n          });\n        }\n      }\n\n      contracts.push(contractObject);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var compiler;\n\n  if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    compiler = contracts[0].compiler;\n  }\n\n  return {\n    id: shimmedCompilationId,\n    unreliableSourceOrder: unreliableSourceOrder,\n    sources: sources,\n    contracts: contracts,\n    compiler: compiler,\n    externalSolidity: externalSolidity\n  };\n}\n\nexports.shimContracts = shimContracts;\n\nfunction sourceIndexForAst(ast) {\n  if (!ast) {\n    return undefined;\n  }\n\n  return parseInt(ast.src.split(\":\")[2]); //src is given as start:length:file.\n  //we want just the file.\n}\n\nfunction getContractNode(contract, compilation) {\n  var contractName = contract.contractName,\n      sourceMap = contract.sourceMap,\n      deployedSourceMap = contract.deployedSourceMap,\n      primarySourceId = contract.primarySourceId;\n  var unreliableSourceOrder = compilation.unreliableSourceOrder,\n      sources = compilation.sources;\n  var sourcesToCheck; //we will attempt to locate the primary source;\n  //if we can't find it, we'll just check every source in this\n  //compilation.\n\n  if (primarySourceId !== undefined) {\n    sourcesToCheck = [sources.find(function (source) {\n      return source && source.id === primarySourceId;\n    })];\n  } else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n    var sourceId = extractPrimarySource(deployedSourceMap || sourceMap);\n    sourcesToCheck = [sources[sourceId]];\n  } else {\n    //WARNING: if we end up in this case, we could get the wrong contract!\n    //(but we shouldn't end up here)\n    sourcesToCheck = sources;\n  }\n\n  return sourcesToCheck.reduce(function (foundNode, source) {\n    if (foundNode || !source) {\n      return foundNode;\n    }\n\n    if (!source.ast || source.ast.nodeType !== \"SourceUnit\") {\n      //don't search Yul sources!\n      return undefined;\n    }\n\n    return source.ast.nodes.find(function (node) {\n      return node.nodeType === \"ContractDefinition\" && node.name === contractName;\n    });\n  }, undefined);\n}\n\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n * (this is something of a HACK)\n * NOTE: duplicated from debugger, sorry\n */\n\nfunction extractPrimarySource(sourceMap) {\n  return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);\n}\n\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n  //first: is this already there? only add it if it's not.\n  //(we determine this by sourcePath if present, and the actual source\n  //contents if not)\n  debug(\"sourcePath: %s\", sourceObject.sourcePath);\n  debug(\"given index: %d\", index);\n  debug(\"sources: %o\", sources.map(function (source) {\n    return source.sourcePath;\n  }));\n\n  if (sources.every(function (existingSource) {\n    return existingSource.sourcePath !== sourceObject.sourcePath || (!sourceObject.sourcePath || sourceObject.internal) && (!existingSource.sourcePath || existingSource.internal) && existingSource.source !== sourceObject.source;\n  })) {\n    if (unreliableSourceOrder || index === undefined || index in sources) {\n      //if we can't add it at the correct spot, set the\n      //unreliable source order flag\n      debug(\"collision!\");\n      unreliableSourceOrder = true;\n    } //otherwise, just leave things alone\n\n\n    if (unreliableSourceOrder) {\n      //in case of unreliable source order, we'll ignore what indices\n      //things are *supposed* to have and just append things to the end\n      index = sources.length;\n    }\n\n    return {\n      index: index,\n      unreliableSourceOrder: unreliableSourceOrder\n    };\n  } else {\n    //return index: null indicates don't add this because it's\n    //already present\n    debug(\"already present, not adding\");\n    return {\n      index: null,\n      unreliableSourceOrder: unreliableSourceOrder\n    };\n  }\n}","map":{"version":3,"sources":["../../../lib/compilations/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilations = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:compilations:utils\");\nfunction shimCompilations(inputCompilations, shimmedCompilationIdPrefix = \"shimmedcompilation\", externalSolidity = false) {\n    return inputCompilations.map(({ contracts, sourceIndexes }, compilationIndex) => shimContracts(contracts, sourceIndexes, `${shimmedCompilationIdPrefix}Number(${compilationIndex})`, externalSolidity));\n}\nexports.shimCompilations = shimCompilations;\n/**\n * wrapper around shimArtifactsToCompilation that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\nfunction shimArtifacts(artifacts, files, shimmedCompilationId = \"shimmedcompilation\", externalSolidity = false) {\n    return [\n        shimContracts(artifacts, files, shimmedCompilationId, externalSolidity)\n    ];\n}\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above two functions.\n */\nfunction shimContracts(artifacts, files, shimmedCompilationId = \"shimmedcompilation\", externalSolidity = false) {\n    let contracts = [];\n    let sources = [];\n    let unreliableSourceOrder = false;\n    for (let artifact of artifacts) {\n        let { contractName, bytecode, sourceMap, deployedBytecode, deployedSourceMap, immutableReferences, sourcePath, source, ast, abi, compiler, generatedSources, deployedGeneratedSources } = artifact;\n        if (artifact.contract_name) {\n            //just in case\n            contractName = artifact.contract_name;\n            //dunno what's up w/ the type of contract_name, but it needs coercing\n        }\n        debug(\"contractName: %s\", contractName);\n        let sourceObject = {\n            sourcePath,\n            source,\n            ast: ast,\n            compiler\n        };\n        //ast needs to be coerced because schema doesn't quite match our types here...\n        let contractObject = {\n            contractName,\n            bytecode,\n            sourceMap,\n            deployedBytecode,\n            deployedSourceMap,\n            immutableReferences,\n            abi,\n            compiler\n        };\n        //if files was passed, trust that to determine the source index\n        if (files) {\n            const index = files.indexOf(sourcePath);\n            debug(\"sourcePath: %s\", sourceObject.sourcePath);\n            debug(\"given index: %d\", index);\n            debug(\"sources: %o\", sources.map(source => source.sourcePath));\n            sources[index] = sourceObject;\n            sourceObject.id = index.toString(); //HACK\n            contractObject.primarySourceId = index.toString();\n            //note: we never set the unreliableSourceOrder flag in this branch;\n            //we just trust files.  If files is bad, then, uh, too bad.\n        }\n        else {\n            //if files *wasn't* passed, attempt to determine it from the ast\n            let index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n            ({ index, unreliableSourceOrder } = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder));\n            if (index !== null) {\n                sources[index] = Object.assign(Object.assign({}, sourceObject), { id: index.toString() });\n                contractObject.primarySourceId = index.toString();\n            }\n        }\n        //now: add internal sources\n        for (let { ast, contents, id: index, name } of [\n            ...(generatedSources || []),\n            ...(deployedGeneratedSources || [])\n        ]) {\n            const generatedSourceObject = {\n                sourcePath: name,\n                source: contents,\n                ast: ast,\n                compiler,\n                internal: true\n            };\n            ({ index, unreliableSourceOrder } = getIndexToAddAt(generatedSourceObject, index, sources, unreliableSourceOrder));\n            if (index !== null) {\n                sources[index] = Object.assign(Object.assign({}, generatedSourceObject), { id: index.toString() });\n            }\n        }\n        contracts.push(contractObject);\n    }\n    let compiler;\n    if (!unreliableSourceOrder && contracts.length > 0) {\n        //if things were actually compiled together, we should just be able\n        //to pick an arbitrary one\n        compiler = contracts[0].compiler;\n    }\n    return {\n        id: shimmedCompilationId,\n        unreliableSourceOrder,\n        sources,\n        contracts,\n        compiler,\n        externalSolidity\n    };\n}\nexports.shimContracts = shimContracts;\nfunction sourceIndexForAst(ast) {\n    if (!ast) {\n        return undefined;\n    }\n    return parseInt(ast.src.split(\":\")[2]);\n    //src is given as start:length:file.\n    //we want just the file.\n}\nfunction getContractNode(contract, compilation) {\n    const { contractName, sourceMap, deployedSourceMap, primarySourceId } = contract;\n    const { unreliableSourceOrder, sources } = compilation;\n    let sourcesToCheck;\n    //we will attempt to locate the primary source;\n    //if we can't find it, we'll just check every source in this\n    //compilation.\n    if (primarySourceId !== undefined) {\n        sourcesToCheck = [\n            sources.find(source => source && source.id === primarySourceId)\n        ];\n    }\n    else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n        let sourceId = extractPrimarySource(deployedSourceMap || sourceMap);\n        sourcesToCheck = [sources[sourceId]];\n    }\n    else {\n        //WARNING: if we end up in this case, we could get the wrong contract!\n        //(but we shouldn't end up here)\n        sourcesToCheck = sources;\n    }\n    return sourcesToCheck.reduce((foundNode, source) => {\n        if (foundNode || !source) {\n            return foundNode;\n        }\n        if (!source.ast || source.ast.nodeType !== \"SourceUnit\") {\n            //don't search Yul sources!\n            return undefined;\n        }\n        return source.ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === contractName);\n    }, undefined);\n}\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n * (this is something of a HACK)\n * NOTE: duplicated from debugger, sorry\n */\nfunction extractPrimarySource(sourceMap) {\n    return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);\n}\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n    //first: is this already there? only add it if it's not.\n    //(we determine this by sourcePath if present, and the actual source\n    //contents if not)\n    debug(\"sourcePath: %s\", sourceObject.sourcePath);\n    debug(\"given index: %d\", index);\n    debug(\"sources: %o\", sources.map(source => source.sourcePath));\n    if (sources.every(existingSource => existingSource.sourcePath !== sourceObject.sourcePath ||\n        ((!sourceObject.sourcePath || sourceObject.internal) &&\n            (!existingSource.sourcePath || existingSource.internal) &&\n            existingSource.source !== sourceObject.source))) {\n        if (unreliableSourceOrder || index === undefined || index in sources) {\n            //if we can't add it at the correct spot, set the\n            //unreliable source order flag\n            debug(\"collision!\");\n            unreliableSourceOrder = true;\n        }\n        //otherwise, just leave things alone\n        if (unreliableSourceOrder) {\n            //in case of unreliable source order, we'll ignore what indices\n            //things are *supposed* to have and just append things to the end\n            index = sources.length;\n        }\n        return {\n            index,\n            unreliableSourceOrder\n        };\n    }\n    else {\n        //return index: null indicates don't add this because it's\n        //already present\n        debug(\"already present, not adding\");\n        return {\n            index: null,\n            unreliableSourceOrder\n        };\n    }\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}