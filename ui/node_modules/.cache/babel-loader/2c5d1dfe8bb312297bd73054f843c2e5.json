{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar stream = require('stream');\n\nvar util = require('util');\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source</caption>\n * const n = new NoFilter('Zm9v', 'base64');\n * n.pipe(process.stdout);\n *\n * @example <caption>sink</caption>\n * const n = new Nofilter();\n * // NOTE: 'finish' fires when the input is done writing\n * n.on('finish', function() { console.log(n.toString('base64')); });\n * process.stdin.pipe(n);\n */\n\n\nvar NoFilter = /*#__PURE__*/function (_stream$Transform) {\n  _inherits(NoFilter, _stream$Transform);\n\n  var _super = _createSuper(NoFilter);\n\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer} [input] - Source data\n   * @param {string} [inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {Object} [options={}] - Other options\n   * @param {string|Buffer} [options.input=null] - Input source data\n   * @param {string} [options.inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes\n   *   to store in the internal buffer before ceasing to read from the\n   *   underlying resource. Default=16kb, or 16 for objectMode streams\n   * @param {string} [options.encoding=null] - If specified, then buffers will\n   *   be decoded to strings using the specified encoding\n   * @param {boolean} [options.objectMode=false] - Whether this stream should\n   *   behave as a stream of objects. Meaning that stream.read(n) returns a\n   *   single value instead of a Buffer of size n\n   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode\n   *   strings into Buffers before passing them to _write()\n   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'\n   *   events, setting this stream's objectMode based on the objectMode of the\n   *   input stream\n   * @param {boolean} [options.readError=false] - If true, when a read()\n   *   underflows, throw an error.\n   */\n  function NoFilter(input, inputEncoding, options) {\n    var _this;\n\n    _classCallCheck(this, NoFilter);\n\n    if (options == null) {\n      options = {};\n    }\n\n    var inp;\n    var inpE;\n\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input;\n\n          if (inputEncoding != null && typeof inputEncoding === 'object') {\n            options = inputEncoding;\n          }\n        } else {\n          options = input;\n        }\n\n        break;\n\n      case 'string':\n        inp = input;\n\n        if (inputEncoding != null && typeof inputEncoding === 'object') {\n          options = inputEncoding;\n        } else {\n          inpE = inputEncoding;\n        }\n\n        break;\n    }\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (inp == null) {\n      inp = options.input;\n    }\n\n    if (inpE == null) {\n      inpE = options.inputEncoding;\n    }\n\n    delete options.input;\n    delete options.inputEncoding;\n    var watchPipe = options.watchPipe != null ? options.watchPipe : true;\n    delete options.watchPipe;\n    var readError = !!options.readError;\n    delete options.readError;\n    _this = _super.call(this, options);\n    _this.readError = readError;\n\n    if (watchPipe) {\n      _this.on('pipe', function (readable) {\n        var om = readable._readableState.objectMode;\n\n        if (_this.length > 0 && om !== _this._readableState.objectMode) {\n          throw new Error('Do not switch objectMode in the middle of the stream');\n        }\n\n        _this._readableState.objectMode = om;\n        return _this._writableState.objectMode = om;\n      });\n    }\n\n    if (inp != null) {\n      _this.end(inp, inpE);\n    }\n\n    return _this;\n  }\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {Object} obj The object to test.\n   * @returns {boolean} true if obj is a NoFilter\n   */\n\n\n  _createClass(NoFilter, [{\n    key: \"_transform\",\n    value:\n    /**\n     * @private\n     */\n    function _transform(chunk, encoding, callback) {\n      if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      this.push(chunk);\n      callback();\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_bufArray\",\n    value: function _bufArray() {\n      var bufs = this._readableState.buffer; // HACK: replace with something else one day.  This is what I get for\n      // relying on internals.\n\n      if (!Array.isArray(bufs)) {\n        var b = bufs.head;\n        bufs = [];\n\n        while (b != null) {\n          bufs.push(b.data);\n          b = b.next;\n        }\n      }\n\n      return bufs;\n    }\n    /**\n     * Pulls some data out of the internal buffer and returns it.\n     * If there is no data available, then it will return null.\n     *\n     * If you pass in a size argument, then it will return that many bytes. If\n     * size bytes are not available, then it will return null, unless we've\n     * ended, in which case it will return the data remaining in the buffer.\n     *\n     * If you do not specify a size argument, then it will return all the data in\n     * the internal buffer.\n     *\n     * @param {number} [size=null] - Number of bytes to read.\n     * @returns {string|Buffer|null} If no data or not enough data, null.  If\n     *   decoding output a string, otherwise a Buffer\n     * @throws Error - if readError is true and there was underflow\n     * @fires NoFilter#read\n     */\n\n  }, {\n    key: \"read\",\n    value: function read(size) {\n      var buf = _get(_getPrototypeOf(NoFilter.prototype), \"read\", this).call(this, size);\n\n      if (buf != null) {\n        /*\n         * Read event. Fired whenever anything is read from the stream.\n         *\n         * @event NoFilter#read\n         * @type {Buffer|string|Object}\n         *\n         */\n        this.emit('read', buf);\n\n        if (this.readError && buf.length < size) {\n          throw new Error(\"Read \".concat(buf.length, \", wanted \").concat(size));\n        }\n      } else if (this.readError) {\n        throw new Error(\"No data available, wanted \".concat(size));\n      }\n\n      return buf;\n    }\n    /**\n     * Return a promise fulfilled with the full contents, after the 'finish'\n     * event fires.  Errors on the stream cause the promise to be rejected.\n     *\n     * @param {function} [cb=null] - finished/error callback used in *addition*\n     *   to the promise\n     * @returns {Promise<Buffer|String>} fulfilled when complete\n     */\n\n  }, {\n    key: \"promise\",\n    value: function promise(cb) {\n      var _this2 = this;\n\n      var done = false;\n      return new Promise(function (resolve, reject) {\n        _this2.on('finish', function () {\n          var data = _this2.read();\n\n          if (cb != null && !done) {\n            done = true;\n            cb(null, data);\n          }\n\n          resolve(data);\n        });\n\n        _this2.on('error', function (er) {\n          if (cb != null && !done) {\n            done = true;\n            cb(er);\n          }\n\n          reject(er);\n        });\n      });\n    }\n    /**\n     * Returns a number indicating whether this comes before or after or is the\n     * same as the other NoFilter in sort order.\n     *\n     * @param {NoFilter} other - The other object to compare\n     * @returns {Number} -1, 0, 1 for less, equal, greater\n     */\n\n  }, {\n    key: \"compare\",\n    value: function compare(other) {\n      if (!(other instanceof NoFilter)) {\n        throw new TypeError('Arguments must be NoFilters');\n      }\n\n      if (this === other) {\n        return 0;\n      } else {\n        var buf1 = this.slice();\n        var buf2 = other.slice(); // these will both be buffers because of the check above.\n\n        if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n          return buf1.compare(buf2);\n        }\n\n        throw new Error('Cannot compare streams in object mode');\n      }\n    }\n    /**\n     * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n     * in object mode.\n     *\n     * @param {NoFilter} other\n     * @returns {boolean} Equal?\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.compare(other) === 0;\n    }\n    /**\n     * Read bytes or objects without consuming them.  Useful for diagnostics.\n     * Note: as a side-effect, concatenates multiple writes together into what\n     * looks like a single write, so that this concat doesn't have to happen\n     * multiple times when you're futzing with the same NoFilter.\n     *\n     * @param {Number} [start=0] - beginning offset\n     * @param {Number} [end=length] - ending offset\n     * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,\n     *   concatenated array of contents.\n     */\n\n  }, {\n    key: \"slice\",\n    value: function slice(start, end) {\n      if (this._readableState.objectMode) {\n        return this._bufArray().slice(start, end);\n      }\n\n      var bufs = this._bufArray();\n\n      switch (bufs.length) {\n        case 0:\n          return Buffer.alloc(0);\n\n        case 1:\n          return bufs[0].slice(start, end);\n\n        default:\n          var b = Buffer.concat(bufs); // TODO: store the concatented bufs back\n          // @_readableState.buffer = [b]\n\n          return b.slice(start, end);\n      }\n    }\n    /**\n      * Get a byte by offset.  I didn't want to get into metaprogramming\n      * to give you the `NoFilter[0]` syntax.\n      *\n      * @param {Number} index - The byte to retrieve\n      * @returns {Number} 0-255\n      */\n\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return this.slice()[index];\n    }\n    /**\n     * Return an object compatible with Buffer's toJSON implementation, so\n     * that round-tripping will produce a Buffer.\n     *\n     * @returns {Object}\n     *\n     * @example output for 'foo'\n     *   { type: 'Buffer', data: [ 102, 111, 111 ] }\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var b = this.slice();\n\n      if (Buffer.isBuffer(b)) {\n        return b.toJSON();\n      } else {\n        return b;\n      }\n    }\n    /**\n     * Decodes and returns a string from buffer data encoded using the specified\n     * character set encoding. If encoding is undefined or null, then encoding\n     * defaults to 'utf8'. The start and end parameters default to 0 and\n     * NoFilter.length when undefined.\n     *\n     * @param {String} [encoding='utf8'] - Which to use for decoding?\n     * @param {Number} [start=0] - Start offset\n     * @param {Number} [end=length] - End offset\n     * @returns {String}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(encoding, start, end) {\n      var buf = this.slice(start, end);\n\n      if (!Buffer.isBuffer(buf)) {\n        return JSON.stringify(buf);\n      }\n\n      if ((!encoding || encoding === 'utf8') && util.TextDecoder) {\n        var td = new util.TextDecoder('utf8', {\n          fatal: true,\n          ignoreBOM: true\n        });\n        return td.decode(buf);\n      }\n\n      return buf.toString(encoding, start, end);\n    }\n    /**\n     * @private\n     * @deprecated\n     */\n\n  }, {\n    key: \"inspect\",\n    value: function inspect(depth, options) {\n      return this[util.inspect.custom](depth, options);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: util.inspect.custom,\n    value: function value(depth, options) {\n      var bufs = this._bufArray();\n\n      var hex = bufs.map(function (b) {\n        if (Buffer.isBuffer(b)) {\n          if (options != null ? options.stylize : undefined) {\n            return options.stylize(b.toString('hex'), 'string');\n          } else {\n            return b.toString('hex');\n          }\n        } else {\n          return util.inspect(b, options);\n        }\n      }).join(', ');\n      return \"\".concat(this.constructor.name, \" [\").concat(hex, \"]\");\n    }\n    /**\n     * Current readable length, in bytes.\n     *\n     * @member {number}\n     * @readonly\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._readableState.length;\n    }\n    /**\n     * Write a JavaScript BigInt to the stream.  Negative numbers will be\n     * written as their 2's complement version.\n     *\n     * @param {bigint} val - The value to write\n     * @returns {boolean} true on success\n     */\n\n  }, {\n    key: \"writeBigInt\",\n    value: function writeBigInt(val) {\n      var str = val.toString(16);\n\n      if (val < 0) {\n        // two's complement\n        // Note: str always starts with '-' here.\n        var sz = BigInt(Math.floor(str.length / 2));\n        var mask = BigInt(1) << sz * BigInt(8);\n        val = mask + val;\n        str = val.toString(16);\n      }\n\n      if (str.length % 2) {\n        str = '0' + str;\n      }\n\n      return this.push(Buffer.from(str, 'hex'));\n    }\n    /**\n     * Read a variable-sized JavaScript unsigned BigInt from the stream.\n     *\n     * @param {number}  [len=null] - number of bytes to read or all remaining\n     *   if null\n     * @returns {bigint}\n     */\n\n  }, {\n    key: \"readUBigInt\",\n    value: function readUBigInt(len) {\n      var b = this.read(len);\n\n      if (!Buffer.isBuffer(b)) {\n        return null;\n      }\n\n      return BigInt('0x' + b.toString('hex'));\n    }\n    /**\n     * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n     * complement format.\n     *\n     * @param {number} [len=null] - number of bytes to read or all remaining\n     *   if null\n     * @returns {bigint}\n     */\n\n  }, {\n    key: \"readBigInt\",\n    value: function readBigInt(len) {\n      var b = this.read(len);\n\n      if (!Buffer.isBuffer(b)) {\n        return null;\n      }\n\n      var ret = BigInt('0x' + b.toString('hex')); // negative?\n\n      if (b[0] & 0x80) {\n        // two's complement\n        var mask = BigInt(1) << BigInt(b.length) * BigInt(8);\n        ret = ret - mask;\n      }\n\n      return ret;\n    }\n  }], [{\n    key: \"isNoFilter\",\n    value: function isNoFilter(obj) {\n      return obj instanceof this;\n    }\n    /**\n     * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n     *\n     * @param {NoFilter} nf1 - The first object to compare\n     * @param {NoFilter} nf2 - The second object to compare\n     * @returns {number} -1, 0, 1 for less, equal, greater\n     *\n     * @example\n     * const arr = [new NoFilter('1234'), new NoFilter('0123')];\n     * arr.sort(NoFilter.compare);\n     */\n\n  }, {\n    key: \"compare\",\n    value: function compare(nf1, nf2) {\n      if (!(nf1 instanceof this)) {\n        throw new TypeError('Arguments must be NoFilters');\n      }\n\n      if (nf1 === nf2) {\n        return 0;\n      } else {\n        return nf1.compare(nf2);\n      }\n    }\n    /**\n     * Returns a buffer which is the result of concatenating all the\n     * NoFilters in the list together. If the list has no items, or if\n     * the totalLength is 0, then it returns a zero-length buffer.\n     *\n     * If length is not provided, it is read from the buffers in the\n     * list. However, this adds an additional loop to the function, so\n     * it is faster to provide the length explicitly if you already know it.\n     *\n     * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n     *   mode, or all not in object mode.\n     * @param {number} [length=null] Number of bytes or objects to read\n     * @returns {Buffer|Array} The concatenated values as an array if in object\n     *   mode, otherwise a Buffer\n     */\n\n  }, {\n    key: \"concat\",\n    value: function concat(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('list argument must be an Array of NoFilters');\n      }\n\n      if (list.length === 0 || length === 0) {\n        return Buffer.alloc(0);\n      }\n\n      if (length == null) {\n        length = list.reduce(function (tot, nf) {\n          if (!(nf instanceof NoFilter)) {\n            throw new TypeError('list argument must be an Array of NoFilters');\n          }\n\n          return tot + nf.length;\n        }, 0);\n      }\n\n      var allBufs = true;\n      var allObjs = true;\n      var bufs = list.map(function (nf) {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters');\n        }\n\n        var buf = nf.slice();\n\n        if (Buffer.isBuffer(buf)) {\n          allObjs = false;\n        } else {\n          allBufs = false;\n        }\n\n        return buf;\n      });\n\n      if (allBufs) {\n        return Buffer.concat(bufs, length);\n      }\n\n      if (allObjs) {\n        var _ref;\n\n        return (_ref = []).concat.apply(_ref, _toConsumableArray(bufs)).slice(0, length);\n      } // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n      // counting objects?  I can't imagine why that would be useful.\n\n\n      throw new Error('Concatenating mixed object and byte streams not supported');\n    }\n  }]);\n\n  return NoFilter;\n}(stream.Transform);\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\n\n\nfunction _read_gen(meth, len) {\n  return function (val) {\n    var b = this.read(len);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b[meth].call(b, 0, true);\n  };\n}\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\n\n\nfunction _write_gen(meth, len) {\n  return function (val) {\n    var b = Buffer.alloc(len);\n    b[meth].call(b, val, 0, true);\n    return this.push(b);\n  };\n}\n\nObject.assign(NoFilter.prototype, {\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @function writeUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value - 0-255\n   * @returns {boolean} true on success\n   */\n  writeUInt8: _write_gen('writeUInt8', 1),\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16LE: _write_gen('writeUInt16LE', 2),\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16BE: _write_gen('writeUInt16BE', 2),\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32LE: _write_gen('writeUInt32LE', 4),\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32BE: _write_gen('writeUInt32BE', 4),\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @function writeInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt8: _write_gen('writeInt8', 1),\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16LE: _write_gen('writeInt16LE', 2),\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16BE: _write_gen('writeInt16BE', 2),\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32LE: _write_gen('writeInt32LE', 4),\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32BE: _write_gen('writeInt32BE', 4),\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatLE: _write_gen('writeFloatLE', 4),\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatBE: _write_gen('writeFloatBE', 4),\n\n  /**\n   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleLE: _write_gen('writeDoubleLE', 8),\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleBE: _write_gen('writeDoubleBE', 8),\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @function readUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt8: _read_gen('readUInt8', 1),\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16LE: _read_gen('readUInt16LE', 2),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16BE: _read_gen('readUInt16BE', 2),\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32LE: _read_gen('readUInt32LE', 4),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32BE: _read_gen('readUInt32BE', 4),\n\n  /**\n   * Read a signed 8-bit integer from the stream.\n   * Consumes 1 byte.\n   *\n   * @function readInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt8: _read_gen('readInt8', 1),\n\n  /**\n   * Read a signed 16-bit little-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16LE: _read_gen('readInt16LE', 2),\n\n  /**\n   * Read a signed 16-bit big-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16BE: _read_gen('readInt16BE', 2),\n\n  /**\n   * Read a signed 32-bit little-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32LE: _read_gen('readInt32LE', 4),\n\n  /**\n   * Read a signed 32-bit big-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32BE: _read_gen('readInt32BE', 4),\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatLE: _read_gen('readFloatLE', 4),\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatBE: _read_gen('readFloatBE', 4),\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleLE: _read_gen('readDoubleLE', 8),\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleBE: _read_gen('readDoubleBE', 8)\n});\nmodule.exports = NoFilter;","map":{"version":3,"sources":["/home/warren/environment/consensus bootcamp/truffle-testNft/node_modules/truffle-plugin-debugger/ui/node_modules/nofilter/lib/index.js"],"names":["stream","require","util","NoFilter","input","inputEncoding","options","inp","inpE","Buffer","isBuffer","watchPipe","readError","on","readable","om","_readableState","objectMode","length","Error","_writableState","end","chunk","encoding","callback","from","push","bufs","buffer","Array","isArray","b","head","data","next","size","buf","emit","cb","done","Promise","resolve","reject","read","er","other","TypeError","buf1","slice","buf2","compare","start","_bufArray","alloc","concat","index","toJSON","JSON","stringify","TextDecoder","td","fatal","ignoreBOM","decode","toString","depth","inspect","custom","hex","map","stylize","undefined","join","constructor","name","val","str","sz","BigInt","Math","floor","mask","len","ret","obj","nf1","nf2","list","reduce","tot","nf","allBufs","allObjs","Transform","_read_gen","meth","call","_write_gen","Object","assign","prototype","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","readUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source</caption>\n * const n = new NoFilter('Zm9v', 'base64');\n * n.pipe(process.stdout);\n *\n * @example <caption>sink</caption>\n * const n = new Nofilter();\n * // NOTE: 'finish' fires when the input is done writing\n * n.on('finish', function() { console.log(n.toString('base64')); });\n * process.stdin.pipe(n);\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer} [input] - Source data\n   * @param {string} [inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {Object} [options={}] - Other options\n   * @param {string|Buffer} [options.input=null] - Input source data\n   * @param {string} [options.inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes\n   *   to store in the internal buffer before ceasing to read from the\n   *   underlying resource. Default=16kb, or 16 for objectMode streams\n   * @param {string} [options.encoding=null] - If specified, then buffers will\n   *   be decoded to strings using the specified encoding\n   * @param {boolean} [options.objectMode=false] - Whether this stream should\n   *   behave as a stream of objects. Meaning that stream.read(n) returns a\n   *   single value instead of a Buffer of size n\n   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode\n   *   strings into Buffers before passing them to _write()\n   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'\n   *   events, setting this stream's objectMode based on the objectMode of the\n   *   input stream\n   * @param {boolean} [options.readError=false] - If true, when a read()\n   *   underflows, throw an error.\n   */\n  constructor(input, inputEncoding, options) {\n    if (options == null) {\n      options = {}\n    }\n    let inp\n    let inpE\n    switch (typeof(input)) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input\n          if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {\n            options = inputEncoding\n          }\n        } else {\n          options = input\n        }\n        break\n      case 'string':\n        inp = input\n        if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {\n          options = inputEncoding\n        } else {\n          inpE = inputEncoding\n        }\n        break\n    }\n\n    if ((options == null)) {\n      options = {}\n    }\n    if (inp == null) {\n      inp = options.input\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding\n    }\n    delete options.input\n    delete options.inputEncoding\n    const watchPipe = options.watchPipe != null ? options.watchPipe : true\n    delete options.watchPipe\n    const readError = !! options.readError\n    delete options.readError\n    super(options)\n\n    this.readError = readError\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        const om = readable._readableState.objectMode\n        if ((this.length > 0) && (om !== this._readableState.objectMode)) {\n          throw new Error(\n            'Do not switch objectMode in the middle of the stream')\n        }\n\n        this._readableState.objectMode = om\n        return this._writableState.objectMode = om\n      })\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE)\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {Object} obj The object to test.\n   * @returns {boolean} true if obj is a NoFilter\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 - The first object to compare\n   * @param {NoFilter} nf2 - The second object to compare\n   * @returns {number} -1, 0, 1 for less, equal, greater\n   *\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')];\n   * arr.sort(NoFilter.compare);\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (nf1 === nf2) {\n      return 0\n    } else {\n      return nf1.compare(nf2)\n    }\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters')\n    }\n    if ((list.length === 0) || (length === 0)) {\n      return Buffer.alloc(0)\n    }\n    if ((length == null)) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters')\n        }\n        return tot + nf.length\n      }, 0)\n    }\n    let allBufs = true\n    let allObjs = true\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters')\n      }\n      const buf = nf.slice()\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false\n      } else {\n        allBufs = false\n      }\n      return buf\n    })\n    if (allBufs) {\n      return Buffer.concat(bufs, length)\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length)\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported')\n  }\n\n  /**\n   * @private\n   */\n  _transform(chunk, encoding, callback) {\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    this.push(chunk)\n    callback()\n  }\n\n  /**\n   * @private\n   */\n  _bufArray() {\n    let bufs = this._readableState.buffer\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head\n      bufs = []\n      while (b != null) {\n        bufs.push(b.data)\n        b = b.next\n      }\n    }\n    return bufs\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] - Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer\n   * @throws Error - if readError is true and there was underflow\n   * @fires NoFilter#read\n   */\n  read(size) {\n    const buf = super.read(size)\n    if (buf != null) {\n      /*\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @type {Buffer|string|Object}\n       *\n       */\n      this.emit('read', buf)\n      if (this.readError && (buf.length < size)) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`)\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`)\n    }\n    return buf\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {function} [cb=null] - finished/error callback used in *addition*\n   *   to the promise\n   * @returns {Promise<Buffer|String>} fulfilled when complete\n   */\n  promise(cb) {\n    let done = false\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read()\n        if ((cb != null) && !done) {\n          done = true\n          cb(null, data)\n        }\n        resolve(data)\n      })\n      this.on('error', (er) => {\n        if ((cb != null) && !done) {\n          done = true\n          cb(er)\n        }\n        reject(er)\n      })\n    })\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other - The other object to compare\n   * @returns {Number} -1, 0, 1 for less, equal, greater\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (this === other) {\n      return 0\n    } else {\n      const buf1 = this.slice()\n      const buf2 = other.slice()\n      // these will both be buffers because of the check above.\n      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n        return buf1.compare(buf2)\n      }\n      throw new Error('Cannot compare streams in object mode')\n    }\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {Number} [start=0] - beginning offset\n   * @param {Number} [end=length] - ending offset\n   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end)\n    }\n    const bufs = this._bufArray()\n    switch (bufs.length) {\n      case 0: return Buffer.alloc(0)\n      case 1: return bufs[0].slice(start, end)\n      default:\n        const b = Buffer.concat(bufs)\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end)\n    }\n  }\n\n  /**\n    * Get a byte by offset.  I didn't want to get into metaprogramming\n    * to give you the `NoFilter[0]` syntax.\n    *\n    * @param {Number} index - The byte to retrieve\n    * @returns {Number} 0-255\n    */\n  get(index) {\n    return this.slice()[index]\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so\n   * that round-tripping will produce a Buffer.\n   *\n   * @returns {Object}\n   *\n   * @example output for 'foo'\n   *   { type: 'Buffer', data: [ 102, 111, 111 ] }\n   */\n  toJSON() {\n    const b = this.slice()\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON()\n    } else {\n      return b\n    }\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {String} [encoding='utf8'] - Which to use for decoding?\n   * @param {Number} [start=0] - Start offset\n   * @param {Number} [end=length] - End offset\n   * @returns {String}\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end)\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf)\n    }\n    if ((!encoding || (encoding === 'utf8')) && util.TextDecoder) {\n      const td = new util.TextDecoder('utf8', {\n        fatal: true,\n        ignoreBOM: true\n      })\n      return td.decode(buf)\n    }\n    return buf.toString(encoding, start, end)\n  }\n\n  /**\n   * @private\n   * @deprecated\n   */\n  inspect(depth, options) {\n    return this[util.inspect.custom](depth, options)\n  }\n\n  /**\n   * @private\n   */\n  [util.inspect.custom](depth, options) {\n    const bufs = this._bufArray()\n    const hex = bufs.map((b) => {\n      if (Buffer.isBuffer(b)) {\n        if ((options != null ? options.stylize : undefined)) {\n          return options.stylize(b.toString('hex'), 'string')\n        } else {\n          return b.toString('hex')\n        }\n      } else {\n        return util.inspect(b, options)\n      }\n    }).join(', ')\n    return `${this.constructor.name} [${hex}]`\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @member {number}\n   * @readonly\n   */\n  get length() {\n    return this._readableState.length\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val - The value to write\n   * @returns {boolean} true on success\n   */\n  writeBigInt(val) {\n    let str = val.toString(16)\n    if (val < 0) {\n      // two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2))\n      const mask = BigInt(1) << (sz * BigInt(8))\n      val = mask + val\n      str = val.toString(16)\n    }\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    return this.push(Buffer.from(str, 'hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number}  [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n  readUBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return BigInt('0x' + b.toString('hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n  readBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    let ret = BigInt('0x' + b.toString('hex'))\n    // negative?\n    if (b[0] & 0x80) {\n      // two's complement\n      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))\n      ret = ret - mask\n    }\n    return ret\n  }\n}\n\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\nfunction _read_gen(meth, len) {\n  return function(val) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b[meth].call(b, 0, true)\n  }\n}\n\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\nfunction _write_gen(meth, len) {\n  return function(val) {\n    const b = Buffer.alloc(len)\n    b[meth].call(b, val, 0, true)\n    return this.push(b)\n  }\n}\n\nObject.assign(NoFilter.prototype, {\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @function writeUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value - 0-255\n   * @returns {boolean} true on success\n   */\n  writeUInt8: _write_gen('writeUInt8', 1),\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16LE: _write_gen('writeUInt16LE', 2),\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16BE: _write_gen('writeUInt16BE', 2),\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32LE: _write_gen('writeUInt32LE', 4),\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32BE: _write_gen('writeUInt32BE', 4),\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @function writeInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt8: _write_gen('writeInt8', 1),\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16LE: _write_gen('writeInt16LE', 2),\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16BE: _write_gen('writeInt16BE', 2),\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32LE: _write_gen('writeInt32LE', 4),\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32BE: _write_gen('writeInt32BE', 4),\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatLE: _write_gen('writeFloatLE', 4),\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatBE: _write_gen('writeFloatBE', 4),\n\n  /**\n   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleLE: _write_gen('writeDoubleLE', 8),\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleBE: _write_gen('writeDoubleBE', 8),\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @function readUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt8: _read_gen('readUInt8', 1),\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16LE: _read_gen('readUInt16LE', 2),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16BE: _read_gen('readUInt16BE', 2),\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32LE: _read_gen('readUInt32LE', 4),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32BE: _read_gen('readUInt32BE', 4),\n\n  /**\n   * Read a signed 8-bit integer from the stream.\n   * Consumes 1 byte.\n   *\n   * @function readInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt8: _read_gen('readInt8', 1),\n\n  /**\n   * Read a signed 16-bit little-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16LE: _read_gen('readInt16LE', 2),\n\n  /**\n   * Read a signed 16-bit big-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16BE: _read_gen('readInt16BE', 2),\n\n  /**\n   * Read a signed 32-bit little-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32LE: _read_gen('readInt32LE', 4),\n\n  /**\n   * Read a signed 32-bit big-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32BE: _read_gen('readInt32BE', 4),\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatLE: _read_gen('readFloatLE', 4),\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatBE: _read_gen('readFloatBE', 4),\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleLE: _read_gen('readDoubleLE', 8),\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleBE: _read_gen('readDoubleBE', 8)\n})\n\nmodule.exports = NoFilter\n"]},"metadata":{},"sourceType":"script"}