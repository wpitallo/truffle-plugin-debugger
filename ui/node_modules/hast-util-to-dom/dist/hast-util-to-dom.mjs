import ns from 'web-namespaces';
import find from 'property-information/find';
import html from 'property-information/html';
import svg from 'property-information/svg';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function transform(node, options) {
  switch (node.type) {
    case 'root':
      return root(node, options);

    case 'text':
      return text(node, options);

    case 'element':
      return element(node, options);

    case 'doctype':
      return doctype(node, options);

    case 'comment':
      return comment(node, options);

    default:
      return element(node, options);
  }
} // Create a document.


function root(node, options) {
  var doc = options.doc,
      fragment = options.fragment,
      optionsNamespace = options.namespace;
  var _node$children = node.children,
      children = _node$children === void 0 ? [] : _node$children;
  var childrenLength = children.length;
  var namespace = optionsNamespace;
  var rootIsDocument = childrenLength === 0;

  for (var i = 0; i < childrenLength; i += 1) {
    var _children$i = children[i],
        tagName = _children$i.tagName,
        _children$i$propertie = _children$i.properties,
        properties = _children$i$propertie === void 0 ? {} : _children$i$propertie;

    if (tagName === 'html') {
      // If we have a root HTML node, we donâ€™t need to render as a fragment.
      rootIsDocument = true; // Take namespace of the first child.

      if (typeof optionsNamespace === 'undefined') {
        namespace = properties.xmlns || ns.html;
      }
    }
  } // The root node will be a Document, DocumentFragment, or HTMLElement.


  var el;

  if (rootIsDocument) {
    el = doc.implementation.createDocument(namespace, '', null);
  } else if (fragment) {
    el = doc.createDocumentFragment();
  } else {
    el = doc.createElement('html');
  }

  return appendAll(el, children, _objectSpread2(_objectSpread2({}, options), {}, {
    fragment: fragment,
    namespace: namespace,
    impliedNamespace: namespace
  }));
} // Create a `doctype`.


function doctype(node, _ref) {
  var doc = _ref.doc;
  return doc.implementation.createDocumentType(node.name || 'html', node["public"] || '', node.system || '');
} // Create a `text`.


function text(node, _ref2) {
  var doc = _ref2.doc;
  return doc.createTextNode(node.value);
} // Create a `comment`.


function comment(node, _ref3) {
  var doc = _ref3.doc;
  return doc.createComment(node.value);
} // Create an `element`.


function element(node, options) {
  var namespace = options.namespace,
      doc = options.doc;
  var impliedNamespace = options.impliedNamespace || namespace;
  var _node$tagName = node.tagName,
      tagName = _node$tagName === void 0 ? impliedNamespace === ns.svg ? 'g' : 'div' : _node$tagName,
      _node$properties = node.properties,
      properties = _node$properties === void 0 ? {} : _node$properties,
      _node$children2 = node.children,
      children = _node$children2 === void 0 ? [] : _node$children2;

  if ((impliedNamespace === null || impliedNamespace === undefined || impliedNamespace === ns.html) && tagName === 'svg') {
    impliedNamespace = ns.svg;
  }

  var schema = impliedNamespace === ns.svg ? svg : html;
  var el = impliedNamespace === null || impliedNamespace === undefined ? doc.createElement(tagName) : doc.createElementNS(impliedNamespace, tagName); // Add HTML attributes.

  var props = Object.keys(properties);
  var length = props.length;

  for (var i = 0; i < length; i += 1) {
    var key = props[i];

    var _find = find(schema, key),
        attribute = _find.attribute,
        property = _find.property,
        mustUseProperty = _find.mustUseProperty,
        _boolean = _find["boolean"],
        booleanish = _find.booleanish,
        overloadedBoolean = _find.overloadedBoolean,
        commaSeparated = _find.commaSeparated;

    var value = properties[key];

    if (Array.isArray(value)) {
      value = value.join(commaSeparated ? ', ' : ' ');
    }

    if (mustUseProperty) {
      el[property] = value;
    }

    if (_boolean || overloadedBoolean && typeof value === 'boolean') {
      if (value) {
        el.setAttribute(attribute, '');
      } else {
        el.removeAttribute(attribute);
      }
    } else if (booleanish) {
      el.setAttribute(attribute, value);
    } else if (value === true) {
      el.setAttribute(attribute, '');
    } else if (value || value === 0 || value === '') {
      el.setAttribute(attribute, value);
    }
  }

  return appendAll(el, children, _objectSpread2(_objectSpread2({}, options), {}, {
    impliedNamespace: impliedNamespace
  }));
} // Add all children.


function appendAll(node, children, options) {
  var childrenLength = children.length;

  for (var i = 0; i < childrenLength; i += 1) {
    node.appendChild(transform(children[i], options));
  }

  return node;
}

function toDOM(hast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return transform(hast, _objectSpread2(_objectSpread2({}, options), {}, {
    doc: options.document || document
  }));
}

export default toDOM;
